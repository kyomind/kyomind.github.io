<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-10-07T06:56:50.214Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django Ninja 教學 25：分頁（下）自定義分頁類別</title>
    <link href="https://blog.kyomind.tw/django-ninja-25/"/>
    <id>https://blog.kyomind.tw/django-ninja-25/</id>
    <published>2024-10-07T02:44:36.000Z</published>
    <updated>2024-10-07T06:56:50.214Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇我們介紹了 Django Ninja 的內建分頁器，並用它實作了簡單的分頁功能。</p><p>雖然內建的<code>PageNumberPagination</code>確實方便，但在很多時候，我們仍需要一些<strong>客製化</strong>功能。</p><p>為了實現這個目的，你需要<strong>自定義一個分頁類別</strong>。</p><p>不過別擔心，這種自定義，<strong>並非從零開始</strong>。而是繼承 Django Ninja 所提供的基礎分頁類別，再進行自己的「<strong>加工</strong>」。</p><p>這篇文章就要來教你怎麼做。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/16">這個 PR</a>。</p><hr><h2 id="客製化需求"><a href="#客製化需求" class="headerlink" title="客製化需求"></a>客製化需求</h2><p>除了基本的分頁，我們還希望能夠：</p><ul><li><strong>允許客戶端選擇</strong>每頁顯示的資料數量，<strong>可選範圍</strong>限定在 1 至 100 之間。</li><li>在回應中<strong>新增兩個欄位</strong>，顯示當前的<strong>分頁資訊</strong>：<ul><li>當前頁數（<code>page</code>）。</li><li>每頁顯示數量（<code>per_page</code>）。</li></ul></li></ul><p>這無疑是很常見的需求。我們將透過自定義分頁類別，來實現這些功能。</p><p>話不多說，直接開始！</p><span id="more"></span><h2 id="實作：自定義分頁類別"><a href="#實作：自定義分頁類別" class="headerlink" title="實作：自定義分頁類別"></a>實作：自定義分頁類別</h2><p>分頁器（分頁類別）通常是是<strong>供全專案使用</strong>，所以不適合放在 Django app 目錄中。但也不能像 exception handlers 一樣，放在專案的<code>api.py</code>，因為會引發<strong>循環引用</strong>。</p><p>所以，我在專案目錄 NinjaForum 建立一個新的 Python 模組——<code>pagination.py</code>。</p><p>在這個新模組中，直接撰寫一個名為<code>CustomPagination</code>的分頁類別，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models.query <span class="keyword">import</span> QuerySet</span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Field, Schema</span><br><span class="line"><span class="keyword">from</span> ninja.pagination <span class="keyword">import</span> PaginationBase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomPagination</span>(<span class="title class_ inherited__">PaginationBase</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line">        per_page: <span class="built_in">int</span> = Field(<span class="number">10</span>, ge=<span class="number">1</span>, le=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Output</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        items: <span class="built_in">list</span></span><br><span class="line">        page: <span class="built_in">int</span> = Field(examples=[<span class="number">1</span>])</span><br><span class="line">        per_page: <span class="built_in">int</span> = Field(examples=[<span class="number">10</span>])</span><br><span class="line">        total: <span class="built_in">int</span> = Field(examples=[<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paginate_queryset</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        queryset: QuerySet,</span></span><br><span class="line"><span class="params">        pagination: Input,</span></span><br><span class="line"><span class="params">        **params: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        start = (pagination.page - <span class="number">1</span>) * pagination.per_page</span><br><span class="line">        end = start + pagination.per_page</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;items&#x27;</span>: queryset[start:end],</span><br><span class="line">            <span class="string">&#x27;page&#x27;</span>: pagination.page,</span><br><span class="line">            <span class="string">&#x27;per_page&#x27;</span>: pagination.per_page,</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: queryset.count(),</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>這個分頁類別<strong>允許我們透過查詢參數</strong>——<code>page</code>和<code>per_page</code>——來決定分頁的大小與頁數，而且回應中<strong>還多了兩個同名的新欄位</strong>，作為額外的分頁資訊。</p><hr><h2 id="自定義分頁類別解說"><a href="#自定義分頁類別解說" class="headerlink" title="自定義分頁類別解說"></a>自定義分頁類別解說</h2><p>雖然程式碼看起來細節繁多，但仔細閱讀後，你會發現它其實不難理解。</p><p>限於篇幅，我們只挑一些重點來講。</p><h3 id="重點一：整體結構來自繼承的類別——PaginationBase"><a href="#重點一：整體結構來自繼承的類別——PaginationBase" class="headerlink" title="重點一：整體結構來自繼承的類別——PaginationBase"></a>重點一：整體結構來自繼承的類別——<code>PaginationBase</code></h3><p>第一個疑惑應該是：「啊我<strong>怎麼會知道</strong>分頁類別要這樣寫？」</p><p>沒錯，我們<strong>當然不知道</strong>，所以要看<a href="https://django-ninja.dev/guides/response/pagination/#creating-custom-pagination-class">官方文件</a>，還有<a href="https://github.com/vitalik/django-ninja/blob/master/ninja/pagination.py">原始碼</a>。</p><p>從官方文件我們可以得知，要繼承一個叫<code>PaginationBase</code>的類別。但文件中對該類別的描寫還是有點簡略，所以需要看原始碼來了解更多的具體資訊。</p><p>然後模仿並覆寫類別中的一些屬性、方法——差不多就是如此。</p><h3 id="重點二：Input-Schema"><a href="#重點二：Input-Schema" class="headerlink" title="重點二：Input Schema"></a>重點二：Input Schema</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line">    per_page: <span class="built_in">int</span> = Field(<span class="number">10</span>, ge=<span class="number">1</span>, le=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>你一定能看出來，這個 Schema 就是拿來<strong>定義和驗證</strong>與分頁有關的 <strong>URL 查詢參數</strong>。</p><p>此外，<code>Input</code>類別會作為<strong>引數</strong>傳入<code>paginate_queryset</code>方法中，作為實現分頁邏輯的一部分。</p><p><code>Input</code>中的每一個屬性，就<strong>代表一個查詢參數</strong>（限分頁相關）——而且一樣可以使用<code>Field</code>來設定細節！</p><p>這裡的<code>Field</code>是 Pydantic 的<code>Field</code>，我們在第 18 篇詳細介紹過。它允許我們為每個參數設定<strong>預設值</strong>、<strong>文件範例</strong>和<strong>基本的驗證規則</strong>。</p><p>本例中，<code>page</code>的預設值是 1，且必須大於等於 1；<code>per_page</code>的預設值是 10，且必須在 1 到 100 之間。這樣可以確保我們的分頁參數<strong>始終在合理的範圍內</strong>。</p><p>同樣的道理也適用於<code>Output</code>，它決定了 HTTP 回應「<strong>應該要有</strong>」的格式，相當於分頁回應的 Schema。</p><h3 id="重點三：paginate-queryset-方法"><a href="#重點三：paginate-queryset-方法" class="headerlink" title="重點三：paginate_queryset 方法"></a>重點三：paginate_queryset 方法</h3><p>這個方法是所有分頁類別的<strong>核心</strong>，它實現了<strong>具體的分頁邏輯</strong>。</p><p>它的第一參數是<code>self</code>，可見它是一個「<strong>實例方法</strong>」。</p><p><strong>最值得注意</strong>的是<strong>第二參數</strong>——<code>queryset</code>，它實際上就是 view 函式的 return 值，而且類型<strong>必須是</strong> <a href="https://docs.djangoproject.com/en/5.1/ref/models/querysets/">QuerySet</a>。</p><p><code>paginate_queryset</code>會利用我們熟悉的「<a href="https://vocus.cc/article/649392c3fd8978000166bbc5">切片與索引</a>」，對傳入的 QuerySet 進行「切割」。這是 Django 為 QuerySet 自行實作的功能，行為上類似 Python 的<code>list</code>、<code>tuple</code>等容器。</p><p>當它回應給客戶端時，我們就得到了<strong>切片後的 QuerySet</strong> 和<strong>自定義的回應格式</strong>。</p><hr><h2 id="測試自定義分頁"><a href="#測試自定義分頁" class="headerlink" title="測試自定義分頁"></a>測試自定義分頁</h2><p>寫完上述的自定義類別，view 函式只要多一行<code>@paginate(CustomPagination)</code>即可，這裡就省略程式碼。</p><p>直接看結果吧！我使用了<code>/?page=2&amp;per_page=5</code>（第 2 頁、每頁 5 筆）查詢參數：</p><p><img src="https://i.imgur.com/GuYj6Bk.png"></p><p>十分理想！</p><p>那如果每頁數量設定為<strong>超過 100</strong> 會怎樣呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;detail&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;less_than_equal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;loc&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;query&quot;</span>,</span><br><span class="line">                <span class="string">&quot;per_page&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Input should be less than or equal to 100&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ctx&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;le&quot;</span>: <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是 422 回應。</p><hr><h2 id="分頁功能總結"><a href="#分頁功能總結" class="headerlink" title="分頁功能總結"></a>分頁功能總結</h2><p>透過這兩篇文章，我們展示了如何在 DjangoNinja 中實作分頁，從簡單的內建方法，到複雜的自定義分頁類別。</p><p>根據專案需求，你可以選擇<strong>適合自己的分頁策略</strong>，讓每一個回應，都能以最適合的方式呈現給使用者。</p><hr><h2 id="為什麼「多重狀態碼回應」不實用？"><a href="#為什麼「多重狀態碼回應」不實用？" class="headerlink" title="為什麼「多重狀態碼回應」不實用？"></a>為什麼「多重狀態碼回應」不實用？</h2><p>還記得我們在第 13 篇、第 21 篇留下的<strong>伏筆</strong>嗎？</p><p>在〈卷 13：回應（一）Django Ninja 處理 HTTP 回應概論〉中我提到：</p><blockquote><p>但我覺得這個「多重狀態碼回應」設定在實務上<strong>沒有很實用</strong>，為何？我們後續再談。</p></blockquote><p>幫你複習一下，「多重狀態碼回應」指的是這個用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.post(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    ...,</span></span></span><br><span class="line"><span class="params"><span class="meta">    response=&#123;<span class="number">200</span>: Token, <span class="number">401</span>: Message, <span class="number">402</span>: Message&#125;  <span class="comment"># 這裡</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br></pre></td></tr></table></figure><p>然後在 view 函式中，依照不同情況，給出不同的 return。</p><p>我在〈卷 21：錯誤處理（上）HttpError 與自定義 HTTP 回應〉又說了：</p><blockquote><p>這樣看起來確實不錯，也很符合直覺，我以前寫 Django REST framework，都是這樣寫的。</p></blockquote><blockquote><p>可是，這個寫法在 Django Ninja 中，使用「分頁裝飾器」時，就會<strong>踢到鐵板</strong>了。</p></blockquote><blockquote><p>目前<strong>時機未到</strong>，在後續的〈卷 25：分頁（下）自定義分頁類別〉中，我們再把這件說清楚。</p></blockquote><p><strong>這不就來了嗎！</strong></p><p>理由很簡單，關鍵就在於本文「重點三：paginate_queryset 方法」中的那句：</p><blockquote><p>最值得注意的是第二參數——<code>queryset</code>，它實際上就是 view 函式的 return 值，而且類型<strong>必須是 QuerySet</strong>。</p></blockquote><p>因為<code>paginate_queryset</code>方法中，第二參數的類型<strong>必須是 QuerySet！</strong></p><p>在<code>paginate_queryset</code>內部，我們將這個參數視為 QuerySet 使用、操作。若傳入的<strong>不是</strong> QuerySet，分頁邏輯就會<strong>出錯</strong>。</p><h3 id="「多重狀態碼回應」與-paginate-queryset-方法的衝突"><a href="#「多重狀態碼回應」與-paginate-queryset-方法的衝突" class="headerlink" title="「多重狀態碼回應」與 paginate_queryset 方法的衝突"></a>「多重狀態碼回應」與 paginate_queryset 方法的衝突</h3><p>然而，多重狀態碼的回應，return 型別<strong>未必</strong>是 QuerySet——很可能是<code>tuple</code>。</p><p>我舉一個簡單的例子你就懂，我們把「取得文章列表」API 改成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.get(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    path=<span class="string">&quot;/posts&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    response=&#123;<span class="number">200</span>: <span class="built_in">list</span>[PostResponse], <span class="number">404</span>: ErrorMessage&#125;</span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">CustomPagination</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post] | <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]：</span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> posts.exists()：</span><br><span class="line">        <span class="keyword">return</span> <span class="number">404</span>， &#123;<span class="string">&quot;message&quot;</span>： <span class="string">&quot;沒有找到符合條件的文章&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這個例子清楚地顯示了「多重狀態碼回應」與分頁器之間的<strong>衝突</strong>：</p><ul><li>當查詢結果<strong>正常</strong>時，view 函式 return 一個 <strong>QuerySet</strong>（即<code>posts</code>），丟給分頁器進行分頁，一切運作良好。</li><li>當<strong>沒有找到文章</strong>時，view 函式試圖回傳一個<code>tuple</code>（因為 Django Ninja 非 200 回應必須有狀態碼，所以是<code>tuple</code>），而<strong>不是</strong> QuerySet。</li></ul><p>這將導致<code>paginate_queryset</code>方法出錯，因為它預期接收一個 QuerySet，後續的內部操作也是以此為前提。</p><hr><p>如果專案中所有的 API <strong>都沒有分頁</strong>，使用「多重狀態碼回應」來處理「非 200」回應是<strong>完全可行</strong>的。</p><p>但<strong>只要有一個</strong> API 需要分頁，這個有分頁的 API，為了避免上述衝突，就要改用一樣是第 21 篇提到的方式——<code>raise HttpError</code>。</p><p>考慮到<strong>專案整體的一致性</strong>，其餘的 API，也應該採用<code>raise HttpError</code>這個方式。</p><p>有鑑於分頁需求是<strong>如此的常見</strong>，所以「多重狀態碼回應」也就成為了<strong>雞肋</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇我們介紹了 Django Ninja 的內建分頁器，並用它實作了簡單的分頁功能。&lt;/p&gt;
&lt;p&gt;雖然內建的&lt;code&gt;PageNumberPagination&lt;/code&gt;確實方便，但在很多時候，我們仍需要一些&lt;strong&gt;客製化&lt;/strong&gt;功能。&lt;/p&gt;
&lt;p&gt;為了實現這個目的，你需要&lt;strong&gt;自定義一個分頁類別&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過別擔心，這種自定義，&lt;strong&gt;並非從零開始&lt;/strong&gt;。而是繼承 Django Ninja 所提供的基礎分頁類別，再進行自己的「&lt;strong&gt;加工&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;這篇文章就要來教你怎麼做。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/16&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;客製化需求&quot;&gt;&lt;a href=&quot;#客製化需求&quot; class=&quot;headerlink&quot; title=&quot;客製化需求&quot;&gt;&lt;/a&gt;客製化需求&lt;/h2&gt;&lt;p&gt;除了基本的分頁，我們還希望能夠：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;允許客戶端選擇&lt;/strong&gt;每頁顯示的資料數量，&lt;strong&gt;可選範圍&lt;/strong&gt;限定在 1 至 100 之間。&lt;/li&gt;
&lt;li&gt;在回應中&lt;strong&gt;新增兩個欄位&lt;/strong&gt;，顯示當前的&lt;strong&gt;分頁資訊&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;當前頁數（&lt;code&gt;page&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;每頁顯示數量（&lt;code&gt;per_page&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這無疑是很常見的需求。我們將透過自定義分頁類別，來實現這些功能。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 24：分頁（上）Django Ninja 的內建分頁器</title>
    <link href="https://blog.kyomind.tw/django-ninja-24/"/>
    <id>https://blog.kyomind.tw/django-ninja-24/</id>
    <published>2024-10-06T04:11:19.000Z</published>
    <updated>2024-10-07T05:52:25.603Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>分頁（<a href="https://django-ninja.dev/guides/response/pagination/">pagination</a>）功能，就算在資料量較少的小型專案，也具有相當的重要性。</p><p>沒分頁，API 照樣能運作——只是效能會受到影響，特別是在資料量大的情況下。</p><p>當 API 一次回傳大量資料時，不僅會增加伺服器負擔，還可能導致客戶端處理緩慢，甚至出現<strong>超時</strong>或<strong>記憶體不足</strong>等問題。</p><p>透過分頁，我們可以避免一次性傳輸大量資料，提高 API 的效能，同時提升使用者的體驗。</p><p>這個主題將分為<strong>上、下兩篇</strong>，介紹如何在 Django Ninja 中實作分頁功能——從<strong>內建的分頁器</strong>到<strong>自定義分頁類別</strong>，以滿足不同需求。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/15">這個 PR</a>。</p><hr><h2 id="分頁的重要性"><a href="#分頁的重要性" class="headerlink" title="分頁的重要性"></a>分頁的重要性</h2><p>分頁的<strong>核心作用</strong>是<strong>將大量資料拆分成小部分傳輸，每次只給一些</strong>，從而避免效能問題。</p><p>具體而言，分頁能夠幫助我們：</p><ol><li><strong>減少伺服器壓力</strong>：不必一次回傳全部資料，只需處理<strong>單個頁面</strong>的資料。</li><li><strong>提升網路傳輸速度</strong>：傳輸太大量的資料會增加網路延遲和資料丟失的風險，通過分頁，能<strong>有效降低傳輸需求</strong>。</li><li><strong>提升使用者體驗</strong>：客戶端可以快速獲取並顯示初步資料，無需等待所有資料傳輸完成。同時，分頁還能<strong>減少客戶端處理大量資料的壓力</strong>。</li></ol><p>因此，無論專案規模大小，實作<strong>高效的分頁策略</strong>，對 API 的擴充性與使用者體驗，都有<strong>明顯幫助</strong>。</p><p>了解了分頁的重要性後，我們來開始實作吧！</p><span id="more"></span><hr><p>這次的範例 API 是——「<strong>取得文章列表</strong>」。</p><p>因為專案的資料庫中已經有<strong>超過 60 筆文章資料</strong>，非常適合演示。</p><p>什麼？你說你沒有？歡迎參考〈<a href="/django-ninja-12/#%E4%B8%AD%E5%A0%B4%E4%BC%91%E6%81%AF%E8%88%87%E6%BA%96%E5%82%99">卷 12：請求（四）Request Body 與 Schema 介紹</a>〉結尾的「<a href="/django-ninja-12/#%E4%B8%AD%E5%A0%B4%E4%BC%91%E6%81%AF%E8%88%87%E6%BA%96%E5%82%99">中場休息與準備</a>」段落。</p><p>本篇我們將使用 Django Ninja 內建的<code>PageNumberPagination</code>分頁器，來實作簡單、有效的分頁功能。自定義部分，則留在下一篇。</p><h2 id="Django-Ninja-內建的分頁器"><a href="#Django-Ninja-內建的分頁器" class="headerlink" title="Django Ninja 內建的分頁器"></a>Django Ninja 內建的分頁器</h2><p>在 Django Ninja 中，分頁功能可以透過內建的<code>paginate</code>裝飾器加上<strong>分頁器</strong>（即<strong>分頁類別</strong>）實現。</p><p>Django Ninja 提供了兩個內建分頁器，為方便你理解，以下是它們的<strong>白話文介紹</strong>：</p><ol><li><code>LimitOffsetPagination</code>：根據「<strong>從哪一筆資料開始</strong>」和「<strong>要抓多少筆資料</strong>」來進行分頁，適合資料量很大時使用。例如：「從第 20 筆開始，抓 10 筆資料」。</li><li><code>PageNumberPagination</code>：透過<strong>頁碼</strong>進行分頁，用戶只需要<strong>指定想要的頁數</strong>，例如「抓第 2 頁的資料」。每頁的<strong>資料數量</strong>可以由開發者自行設定。</li></ol><p>我個人偏好使用<code>PageNumberPagination</code>，或自定義一個類似的版本（也就是下一篇的內容）。</p><p>但<strong>預設</strong>的分頁器是<code>LimitOffsetPagination</code>，所以在使用<code>paginate</code>裝飾器時，需要你<strong>主動聲明</strong>第一參數。等一下你就知道了。</p><p>在那之前，我們先來回顧「取得文章列表」的 API 現狀。</p><h2 id="API-現狀"><a href="#API-現狀" class="headerlink" title="API 現狀"></a>API 現狀</h2><p>如下所示，由於尚未實作分頁功能，它會<strong>一次性回傳所有文章資料</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&#x27;/posts/&#x27;</span>, response=<span class="built_in">list</span>[PostListResponse], ...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    title: <span class="literal">None</span> | <span class="built_in">str</span> = Query(<span class="params"><span class="literal">None</span>, min_length=<span class="number">2</span>, max_length=<span class="number">10</span></span>),</span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> title:</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">            title__icontains=title).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這在文章少的時候可以運作如常，但隨著資料量增加，效能將會<strong>受到影響</strong>。</p><p>接下來，我們要透過 Django Ninja 內建的分頁器來<strong>改善</strong>這個問題。</p><hr><h2 id="PageNumberPagination-實作分頁"><a href="#PageNumberPagination-實作分頁" class="headerlink" title="PageNumberPagination 實作分頁"></a>PageNumberPagination 實作分頁</h2><p>使用內建的<code>PageNumberPagination</code>，我們可以輕鬆為 API 加上分頁功能。</p><p>只要在 view 函式上使用<code>@paginate</code>裝飾器並加入參數，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja.pagination <span class="keyword">import</span> PageNumberPagination, paginate</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">PageNumberPagination, page_size=<span class="number">10</span></span>)  </span><span class="comment"># 分頁實作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我省略了大部分內容，這裡只需要關注分頁的實作。</p><p>如前所述，第一參數<code>PageNumberPagination</code>必須由你主動聲明——如果是用<code>LimitOffsetPagination</code>則不必。</p><p>實作的效果是，每頁改為顯示 10 筆文章，這數量可以透過<code>page_size</code>參數控制。</p><p>咦，那<strong>換頁</strong>怎麼辦？我們看一下<code>PageNumberPagination</code>的原始碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageNumberPagination</span>(<span class="title class_ inherited__">AsyncPaginationBase</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>Input</code>代表請求的<strong>查詢參數</strong>（下一篇會細論），換句話說，你可以在 URL 的<strong>查詢參數</strong>（query parameters）中使用參數<code>page</code>來指定「頁碼」，以達到換頁效果。</p><h3 id="測試分頁效果"><a href="#測試分頁效果" class="headerlink" title="測試分頁效果"></a>測試分頁效果</h3><p>呼叫 API，並使用<code>?page=2</code>作為查詢參數，看看效果如何：</p><p><img src="https://i.imgur.com/3H3ej9J.png"></p><p>符合預期！</p><p>回應中顯示的確實是第 2 頁內容——文章 id 從 11 開始，總共 10 筆。</p><hr><h2 id="使用內建分頁器的優點與局限"><a href="#使用內建分頁器的優點與局限" class="headerlink" title="使用內建分頁器的優點與局限"></a>使用內建分頁器的優點與局限</h2><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a><strong>優點</strong></h3><ul><li>只用簡單的<strong>分頁裝飾器 + 內建分頁器</strong>即可實現分頁，而且可以控制每頁的數量，非常方便且實用。</li><li>適合不需要複雜自定義的情況。</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a><strong>局限</strong></h3><ul><li>缺乏靈活性，例如我們<strong>無法讓使用者指定</strong>每頁顯示多少筆資料。</li><li>回應的欄位與格式是<strong>固定</strong>的——而且有點簡略。</li></ul><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過 Django Ninja 內建的分頁器，我們能夠迅速為 API 加入分頁功能，立即實現簡單的分頁需求。</p><p>然而，內建分頁器在<strong>控制靈活性</strong>上有所不足，也無法建立客製化回應。當分頁需求變得複雜時，就顯得有點捉襟見肘。</p><p>此時，<strong>自定義分頁器</strong>會是一個更好的解決方案。</p><p>下一篇，我們將探討如何在 Django Ninja 中自定義分頁類別，以滿足這些進階需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;分頁（&lt;a href=&quot;https://django-ninja.dev/guides/response/pagination/&quot;&gt;pagination&lt;/a&gt;）功能，就算在資料量較少的小型專案，也具有相當的重要性。&lt;/p&gt;
&lt;p&gt;沒分頁，API 照樣能運作——只是效能會受到影響，特別是在資料量大的情況下。&lt;/p&gt;
&lt;p&gt;當 API 一次回傳大量資料時，不僅會增加伺服器負擔，還可能導致客戶端處理緩慢，甚至出現&lt;strong&gt;超時&lt;/strong&gt;或&lt;strong&gt;記憶體不足&lt;/strong&gt;等問題。&lt;/p&gt;
&lt;p&gt;透過分頁，我們可以避免一次性傳輸大量資料，提高 API 的效能，同時提升使用者的體驗。&lt;/p&gt;
&lt;p&gt;這個主題將分為&lt;strong&gt;上、下兩篇&lt;/strong&gt;，介紹如何在 Django Ninja 中實作分頁功能——從&lt;strong&gt;內建的分頁器&lt;/strong&gt;到&lt;strong&gt;自定義分頁類別&lt;/strong&gt;，以滿足不同需求。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/15&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;分頁的重要性&quot;&gt;&lt;a href=&quot;#分頁的重要性&quot; class=&quot;headerlink&quot; title=&quot;分頁的重要性&quot;&gt;&lt;/a&gt;分頁的重要性&lt;/h2&gt;&lt;p&gt;分頁的&lt;strong&gt;核心作用&lt;/strong&gt;是&lt;strong&gt;將大量資料拆分成小部分傳輸，每次只給一些&lt;/strong&gt;，從而避免效能問題。&lt;/p&gt;
&lt;p&gt;具體而言，分頁能夠幫助我們：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;減少伺服器壓力&lt;/strong&gt;：不必一次回傳全部資料，只需處理&lt;strong&gt;單個頁面&lt;/strong&gt;的資料。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提升網路傳輸速度&lt;/strong&gt;：傳輸太大量的資料會增加網路延遲和資料丟失的風險，通過分頁，能&lt;strong&gt;有效降低傳輸需求&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提升使用者體驗&lt;/strong&gt;：客戶端可以快速獲取並顯示初步資料，無需等待所有資料傳輸完成。同時，分頁還能&lt;strong&gt;減少客戶端處理大量資料的壓力&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，無論專案規模大小，實作&lt;strong&gt;高效的分頁策略&lt;/strong&gt;，對 API 的擴充性與使用者體驗，都有&lt;strong&gt;明顯幫助&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;了解了分頁的重要性後，我們來開始實作吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 23：檔案上傳——Django UploadedFile 介紹</title>
    <link href="https://blog.kyomind.tw/django-ninja-23/"/>
    <id>https://blog.kyomind.tw/django-ninja-23/</id>
    <published>2024-10-05T08:33:59.000Z</published>
    <updated>2024-10-07T05:52:25.603Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>現代 Web 服務中，<strong>檔案上傳</strong>是一個常見的情境。</p><p>無論是使用者上傳照片、夾帶附件，檔案上傳都是不可或缺的功能。</p><p>本文介紹如何在 Django Ninja 中實現<strong>圖片上傳</strong>功能，以使用者「上傳大頭貼」（以下都稱為 avatar，因為大頭貼感覺太可愛🥹）API 為例，帶你一步步了解這個過程。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/14">這個 PR</a>。</p><hr><p>不過，在此之前，我們要先了解，本章有哪些主題。</p><h2 id="第六章「API-進階功能」簡介"><a href="#第六章「API-進階功能」簡介" class="headerlink" title="第六章「API 進階功能」簡介"></a>第六章「API 進階功能」簡介</h2><p>對 API 專案而言，<strong>進階功能</strong>能幫助我們應對<strong>複雜場景</strong>與<strong>大型專案</strong>的挑戰。</p><p>雖然這是一個入門指南，但我們仍會涵蓋一些常見的進階功能，這些功能不僅提升 API 的靈活性，還能增強了系統效能與使用者體驗。</p><p>本章將介紹 3 個重要的進階功能：</p><ul><li>卷 23：檔案上傳——Django UploadedFile 介紹</li><li>卷 24：分頁（上）Django Ninja 的內建分頁器</li><li>卷 25：分頁（下）自定義分頁類別</li><li>卷 26：資料查詢與過濾（上）FilterSchema 介紹</li><li>卷 27：資料查詢與過濾（下）FilterSchema 多欄位查詢</li></ul><p>這些技術不僅對大型專案至關重要，也讓你能在 API 開發中，有效應對多變的需求。</p><span id="more"></span><hr><p>了解了本章重點後，我們開始講述第一個功能——檔案上傳。</p><h2 id="檔案上傳的主角——UploadedFile"><a href="#檔案上傳的主角——UploadedFile" class="headerlink" title="檔案上傳的主角——UploadedFile"></a>檔案上傳的主角——UploadedFile</h2><p>在 Django Ninja 中，我們可以使用<code>UploadedFile</code>來接收上傳的檔案，它是 Django <code>UploadedFile</code>的<strong>重新封裝</strong>，兩者基本上大同小異。</p><h3 id="UploadedFile-概述"><a href="#UploadedFile-概述" class="headerlink" title="UploadedFile 概述"></a>UploadedFile 概述</h3><p><a href="https://docs.djangoproject.com/en/5.1/ref/files/uploads/">UploadedFile</a> 是 Django 處理檔案上傳的核心物件。當使用者上傳檔案時，Django 會自動將檔案封裝成<code>UploadedFile</code>實例，方便我們進行<strong>後續的檔案處理和儲存</strong>。</p><p><code>UploadedFile</code>物件有很多屬性，其中比較常用的有：</p><ul><li><code>name</code>：上傳檔案的名稱。這可以用來存取檔案的<strong>原始檔名</strong>。</li><li><code>size</code>：檔案的大小（以<strong>位元組</strong>計算）。我們可以用來進行檔案大小的驗證。</li><li><code>content_type</code>：檔案的 <a href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 類型。這對於驗證上傳檔案的<strong>格式</strong>非常有用，比如確保檔案是圖片格式。我們後面會用到！</li><li><code>read()</code>：用來<strong>讀取檔案的內容</strong>。當需要進行自訂檔案處理時，我們可以使用這個方法來取得檔案的二進位資料。</li><li><code>chunks()</code>：當檔案非常大時，使用這個方法可以<strong>分塊讀取檔案</strong>，避免過多的記憶體佔用。</li></ul><p>這些特性使得<code>UploadedFile</code>非常靈活，能夠應對各種上傳需求，從簡單的圖片上傳到大型檔案的處理。</p><p>OK，關於檔案上傳，了解<code>UploadedFile</code>這個核心元件就足夠了。</p><p>開始實作「上傳 avatar」API 的程式碼之前，我們要先進行一些「<strong>前置作業</strong>」。</p><hr><p>檔案上傳，有很多部分其實<strong>和 Django 比較有關</strong>，而非 Django Ninja 範疇，所以我會重點帶過。</p><h2 id="Django-專案相關設定"><a href="#Django-專案相關設定" class="headerlink" title="Django 專案相關設定"></a>Django 專案相關設定</h2><p>在實作檔案上傳功能之前，我們需要先告訴 Django：<strong>如何處理上傳的檔案</strong>。這涉及到<code>MEDIA_URL</code>和<code>MEDIA_ROOT</code>的設定。</p><h3 id="MEDIA-URL和MEDIA-ROOT設定"><a href="#MEDIA-URL和MEDIA-ROOT設定" class="headerlink" title="MEDIA_URL和MEDIA_ROOT設定"></a><code>MEDIA_URL</code>和<code>MEDIA_ROOT</code>設定</h3><ul><li><code>MEDIA_URL</code>：這是檔案的 URL 前綴，所有上傳的檔案會透過這個 URL 來存取。</li><li><code>MEDIA_ROOT</code>：這是 Django 伺服器內部，實際儲存上傳檔案的路徑。</li></ul><p>在專案的<code>settings.py</code>新增程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/settings.py</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span></span><br><span class="line">MEDIA_ROOT = BASE_DIR / <span class="string">&#x27;media&#x27;</span></span><br></pre></td></tr></table></figure><p>如此一來，上傳的檔案會儲存在專案根目錄的<code>media</code>資料夾中，並通過<code>/media/</code>路徑來存取。</p><h3 id="開發環境下的檔案存取"><a href="#開發環境下的檔案存取" class="headerlink" title="開發環境下的檔案存取"></a>開發環境下的檔案存取</h3><p>我們需要 Django 提供的<code>static</code>方法，來讓<strong>開發環境</strong>能夠直接存取這些檔案。</p><p>在專案的<code>urls.py</code>加上這行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, api.urls),</span><br><span class="line">    <span class="comment"># 讓開發環境可以存取上傳的檔案，僅供開發環境使用</span></span><br><span class="line">] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure><p>這段程式碼允許 Django 在開發環境下提供靜態檔案的存取。</p><h3 id="建立ImageField欄位"><a href="#建立ImageField欄位" class="headerlink" title="建立ImageField欄位"></a>建立<code>ImageField</code>欄位</h3><p><code>ImageField</code>是 Django 專門用來存放圖片的欄位，它實際上是存儲圖片的<strong>檔案路徑</strong>。類似的欄位還有<code>FileField</code>。</p><p>程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/models.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">AbstractUser</span>):</span><br><span class="line">    ...</span><br><span class="line">    avatar = models.ImageField(upload_to=<span class="string">&#x27;avatars/&#x27;</span>, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>搭配之前的<code>settings.py</code>設定，<code>avatar</code>欄位會將上傳的圖片存在<code>media/avatars/</code>資料夾中——這個路徑由<code>MEDIA_ROOT</code>與欄位<code>upload_to</code>共同決定。</p><p>移至本分支後，專案中已經有新的遷移檔，記得要<strong>資料庫遷移</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">make migrate</span><br></pre></td></tr></table></figure><p>附帶一提，<code>ImageField</code>依賴第三方套件——<a href="https://pypi.org/project/pillow/">Pillow</a>。這個套件為欄位提供了處理圖片功能，要先安裝欄位才能正常運作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add pillow</span><br></pre></td></tr></table></figure><p>使用 Poetry 的讀者，直接在合併後的分支<code>poetry install</code>即可。</p><hr><h2 id="實作：上傳-avatar"><a href="#實作：上傳-avatar" class="headerlink" title="實作：上傳 avatar"></a>實作：上傳 avatar</h2><p>前置作業結束，我們終於可以進入重頭戲。</p><p>以下是完整的「上傳 avatar」功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> File, Router, UploadedFile</span><br><span class="line"><span class="keyword">from</span> ninja.errors <span class="keyword">import</span> HttpError</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/&#123;int:user_id&#125;/avatar/&#x27;</span>,summary=<span class="string">&#x27;上傳 avatar&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_avatar</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    user_id: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    avatar_file: UploadedFile = File(<span class="params"></span>)</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上傳 avatar</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 檢查檔案類型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> avatar_file.content_type.startswith(<span class="string">&#x27;image/&#x27;</span>):</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">400</span>, <span class="string">&#x27;檔案必須是圖片格式&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    user = User.objects.get(<span class="built_in">id</span>=user_id)</span><br><span class="line">    user.avatar = avatar_file</span><br><span class="line">    user.save()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;圖片上傳成功&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>以下是對這段程式碼的重點解析。</p><h3 id="一、UploadedFile參數定義"><a href="#一、UploadedFile參數定義" class="headerlink" title="一、UploadedFile參數定義"></a>一、<code>UploadedFile</code>參數定義</h3><p>在 view 函式的簽名中，<code>UploadedFile</code>作為 type hint 使用，而<code>avatar_file</code>參數則代表上傳的檔案。</p><p>你可以<strong>任意命名</strong><code>avatar_file</code>這個參數，比如<a href="https://django-ninja.dev/guides/input/file-params/">文件範例</a>中是叫<code>file</code>。我特地取不同名字，就是要強調它的名字是<strong>完全可自訂</strong>的。</p><p>但是！無論你取什麼名稱，在發請求時，<strong>body 中的 key</strong> 也要使用<strong>相同的名稱</strong>。</p><p>此時的 body 可能長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /users/<span class="number">1</span>/avatar/</span><br><span class="line">Content-<span class="type">Type</span>: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;avatar_file&quot;</span>; filename=<span class="string">&quot;example.jpg&quot;</span></span><br><span class="line">Content-<span class="type">Type</span>: image/jpeg</span><br><span class="line"></span><br><span class="line">(binary image data here)</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure><p>Header 中的<code>Content-Type</code>為<code>multipart/form-data</code>，而且每個 key-value 對都是以<code>Content-Disposition: form-data;</code>開頭。這種格式允許<strong>在一個請求中同時傳送多個不同類型的資料</strong>，包括文字和二進位檔案。</p><p>其中的細節，可以參考這篇〈<a href="https://blog.errorbaker.tw/posts/cwc329/multipart-form-data/">multipart&#x2F;form-data 初探</a>〉。</p><h3 id="二、File函式"><a href="#二、File函式" class="headerlink" title="二、File函式"></a>二、<code>File</code>函式</h3><p>定義<code>=File()</code>的<strong>目的</strong>是在告訴 Django Ninja，這個參數<strong>應該從 HTTP 請求中的「上傳檔案」部分獲取</strong>。類似做法還有我們第 11 篇提到的<code>Query</code>。</p><p>如果沒有這個標記，框架可能無法正確識別並處理上傳的內容。</p><h3 id="三、檢查檔案類型"><a href="#三、檢查檔案類型" class="headerlink" title="三、檢查檔案類型"></a>三、檢查檔案類型</h3><p>我們使用了<code>UploadedFile</code>的<code>content_type</code>屬性，獲得這個 body 內容的檔案類型，確認它是圖片，然後才發行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢查檔案類型</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> avatar_file.content_type.startswith(<span class="string">&#x27;image/&#x27;</span>):</span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">400</span>, <span class="string">&#x27;檔案必須是圖片格式&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這個方法雖然粗糙，但對於簡單的圖片上傳功能來說已經足夠。</p><p>在生產環境中，你需要<strong>更嚴格的檢查</strong>，例如使用專門的圖片處理套件來驗證檔案內容。</p><h3 id="四、儲存圖片"><a href="#四、儲存圖片" class="headerlink" title="四、儲存圖片"></a>四、儲存圖片</h3><p>最後，我們將圖片賦值給<code>User</code>的<code>avatar</code>欄位，並呼叫<code>save()</code>方法。</p><p>Django 會自動處理檔案的儲存，如果<strong>名稱重複</strong>，它還會<strong>自動產生唯一的檔名</strong>，然後把檔案放到我們之前指定的位置。</p><p>透過 API 上傳了兩次一模一樣的 avatar 後，我們在專案根目錄使用<code>tree</code>指令看一下結果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ tree media</span><br><span class="line">media</span><br><span class="line">└── avatars</span><br><span class="line">    ├── my-avatar.png</span><br><span class="line">    └── my-avatar_gVwgCiG.png  <span class="comment"># 相同檔名第二次上傳，自動更名</span></span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure><p>可以看到，第二次上傳的圖片被「<strong>自動更名</strong>」了。這<strong>保證</strong>了檔名的<strong>唯一性</strong>。</p><p>在生產環境中，最好自行定義檔案的統一命名格式，以確保更好的管理和安全性。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>本文介紹了如何在 Django Ninja 中實作檔案上傳功能，從前置設定到 API 實作，詳述了<code>UploadedFile</code>的使用方式。</p><p>接下來，我們將介紹另一項進階功能——分頁（Pagination），它能幫助你在回應大量資料時，有效提升效能與使用者體驗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;現代 Web 服務中，&lt;strong&gt;檔案上傳&lt;/strong&gt;是一個常見的情境。&lt;/p&gt;
&lt;p&gt;無論是使用者上傳照片、夾帶附件，檔案上傳都是不可或缺的功能。&lt;/p&gt;
&lt;p&gt;本文介紹如何在 Django Ninja 中實現&lt;strong&gt;圖片上傳&lt;/strong&gt;功能，以使用者「上傳大頭貼」（以下都稱為 avatar，因為大頭貼感覺太可愛🥹）API 為例，帶你一步步了解這個過程。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/14&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不過，在此之前，我們要先了解，本章有哪些主題。&lt;/p&gt;
&lt;h2 id=&quot;第六章「API-進階功能」簡介&quot;&gt;&lt;a href=&quot;#第六章「API-進階功能」簡介&quot; class=&quot;headerlink&quot; title=&quot;第六章「API 進階功能」簡介&quot;&gt;&lt;/a&gt;第六章「API 進階功能」簡介&lt;/h2&gt;&lt;p&gt;對 API 專案而言，&lt;strong&gt;進階功能&lt;/strong&gt;能幫助我們應對&lt;strong&gt;複雜場景&lt;/strong&gt;與&lt;strong&gt;大型專案&lt;/strong&gt;的挑戰。&lt;/p&gt;
&lt;p&gt;雖然這是一個入門指南，但我們仍會涵蓋一些常見的進階功能，這些功能不僅提升 API 的靈活性，還能增強了系統效能與使用者體驗。&lt;/p&gt;
&lt;p&gt;本章將介紹 3 個重要的進階功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷 23：檔案上傳——Django UploadedFile 介紹&lt;/li&gt;
&lt;li&gt;卷 24：分頁（上）Django Ninja 的內建分頁器&lt;/li&gt;
&lt;li&gt;卷 25：分頁（下）自定義分頁類別&lt;/li&gt;
&lt;li&gt;卷 26：資料查詢與過濾（上）FilterSchema 介紹&lt;/li&gt;
&lt;li&gt;卷 27：資料查詢與過濾（下）FilterSchema 多欄位查詢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些技術不僅對大型專案至關重要，也讓你能在 API 開發中，有效應對多變的需求。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 22：錯誤處理（下）全域錯誤處理——深入解析 Exception Handlers</title>
    <link href="https://blog.kyomind.tw/django-ninja-22/"/>
    <id>https://blog.kyomind.tw/django-ninja-22/</id>
    <published>2024-10-04T03:03:51.000Z</published>
    <updated>2024-10-07T05:52:25.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇文章，我們學習了如何操作<code>HttpError</code>，並建議你<strong>只在</strong> view 函式中使用它。</p><p>但光是這樣，專案 API 的錯誤處理，還遠遠<strong>不夠完善</strong>，至少有 3 個常見問題待解：</p><ol><li>Schema 中的驗證方法 ，如果不要<code>raise HttpError</code>，那要怎麼做才好？</li><li>我們應該如何處理<strong>其他類型的錯誤</strong>，例如資料庫操作錯誤？</li><li>如何確保不同 API 錯誤的<strong>回應格式一致</strong>？</li></ol><p>這些問題都指向了一個<strong>更大的需求</strong>：我們需要一個<strong>全面的錯誤處理機制</strong>。</p><p>這篇文章，就要來回答這些問題。所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/13">這個 PR</a>。</p><span id="more"></span><hr><h2 id="改用-Django-ValidationError"><a href="#改用-Django-ValidationError" class="headerlink" title="改用 Django ValidationError"></a>改用 Django ValidationError</h2><p>還記得驗證方法中，最原始的版本是拋出<code>ValueError</code>嗎？</p><p><code>ValueError</code>會被 Django Ninja 自動捕捉並給出 422 回應，這是好事，但不符合我們的<strong>自定義需求</strong>。</p><p>所以後來我們改採了<code>HttpError</code>，它雖然也會被捕捉，但回應的格式與內容比較簡潔——而且除了錯誤訊息，還能<strong>自訂狀態碼</strong>。</p><p>然而，如上一篇所述，這樣做雖然簡單，卻並不合適。</p><blockquote><p><strong>那究竟要拋出什麼錯誤？</strong></p></blockquote><h3 id="避免使用-Pydantic-或-Django-Ninja-提供的錯誤"><a href="#避免使用-Pydantic-或-Django-Ninja-提供的錯誤" class="headerlink" title="避免使用 Pydantic 或 Django Ninja 提供的錯誤"></a>避免使用 Pydantic 或 Django Ninja 提供的錯誤</h3><p>上一篇還提到，無論 Pydantic 或 Django Ninja，都有自己內建的<code>ValidationError</code>。</p><p>但它們更多是<strong>供框架內部使用</strong>，而且回傳的錯誤格式過於詳細，<strong>初始化方式也很龜毛</strong>。比如 Django Ninja 的驗證錯誤，需要這樣初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValidationError(</span><br><span class="line">    [&#123;<span class="string">&#x27;loc&#x27;</span>: (<span class="string">&#x27;confirm_password&#x27;</span>,),</span><br><span class="line">      <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;密碼和確認密碼必須相同&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;value_error&#x27;</span>&#125;])</span><br></pre></td></tr></table></figure><p>這不是我們熟悉的「塞一個錯誤訊息字串」就好了。</p><p>因此，我<strong>並不推薦</strong>在驗證邏輯中<strong>直接使用</strong>這些錯誤類型。</p><h3 id="請愛用-Django-ValidationError"><a href="#請愛用-Django-ValidationError" class="headerlink" title="請愛用 Django ValidationError"></a>請愛用 Django ValidationError</h3><p>在 Schema 驗證邏輯中，我們更應該使用 Django 內建的<code>ValidationError</code>。</p><p>它的設計已經<strong>完整考慮到了開發者的需求</strong>，初始化方式<strong>可簡單</strong>（使用單一字串）<strong>可複雜</strong>（使用<code>list</code>或<code>dict</code>），適合絕大多數場景。</p><p>這裡我們用<strong>字串</strong>來初始化即可，程式碼修正如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    confirm_password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @model_validator(<span class="params">mode=<span class="string">&#x27;after&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_passwords_match</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.password != self.confirm_password:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;密碼和確認密碼必須相同&#x27;</span>)</span><br></pre></td></tr></table></figure><p>將原本的<code>HttpError</code>改為了 Django 的<code>ValidationError</code>。</p><p>並以「錯誤訊息字串」作為初始化方式，少了原本的第一參數「狀態碼」。</p><hr><h2 id="Django-Ninja-不會自動處理這些錯誤"><a href="#Django-Ninja-不會自動處理這些錯誤" class="headerlink" title="Django Ninja 不會自動處理這些錯誤"></a>Django Ninja 不會自動處理這些錯誤</h2><p>將拋出的錯誤類型改為 Django 的<code>ValidationError</code> 後，你可能會注意到一個問題：Django Ninja <strong>並不會</strong>自動捕捉這些錯誤！</p><p>也就是說，當我們拋出<code>ValidationError</code>時，Django Ninja 不會像處理<code>HttpError</code>一樣，自動格式化並返回 422 錯誤回應——而是<strong>直接 500</strong>。</p><p>這部分我們在〈<a href="/django-ninja-20/">卷 20：資料驗證（下）Pydantic model_validator 實現「跨欄位」驗證</a>〉的結尾處提過。</p><p>現在，則要介紹<strong>具體的解決之道</strong>——<code>exception_handler</code>。</p><p>我們需要<strong>自行處理</strong>這些拋出的錯誤，這正是<code>exception_handler</code>發揮作用的地方。</p><hr><h2 id="全域錯誤處理器——Exception-Handlers"><a href="#全域錯誤處理器——Exception-Handlers" class="headerlink" title="全域錯誤處理器——Exception Handlers"></a>全域錯誤處理器——Exception Handlers</h2><p>為了<strong>統一處理</strong>這些<strong>不同來源</strong>（不限於 Schema 驗證方法）的<strong>同類型</strong>錯誤，我們可以使用 Django Ninja 提供的<code>@api.exception_handler</code>裝飾器。</p><p>這個裝飾器允許我們<strong>針對「特定類型的錯誤」定義專屬的回應邏輯</strong>，並套用到<strong>整個 API 範圍</strong>內。</p><h3 id="定義exception-handler"><a href="#定義exception-handler" class="headerlink" title="定義exception_handler"></a>定義<code>exception_handler</code></h3><p>我們可以為 Django 的<code>ValidationError</code>定義一個全域錯誤處理器，確保當任何地方<strong>拋出</strong>這個錯誤時，handler 都會<strong>加以捕捉</strong>，讓 API 返回我們<strong>自定義的回應格式</strong>。</p><p>在專案<code>api.py</code>中，加入下列程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpRequest, HttpResponse</span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI(...)</span><br><span class="line"></span><br><span class="line">api.add_router(...)</span><br><span class="line">api.add_router(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增的 exception handler</span></span><br><span class="line"><span class="meta">@api.exception_handler(<span class="params">exc_class=ValidationError</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">django_validation_error_handler</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest, exception: ValidationError</span></span><br><span class="line"><span class="params"></span>) -&gt; HttpResponse:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    處理 Django ValidationError 例外</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> api.create_response(</span><br><span class="line">        request, &#123;<span class="string">&#x27;detail&#x27;</span>: exception.message&#125;, status=<span class="number">400</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>我們定義了一個 exception handler 函式，當遇到 Django 的<code>ValidationError</code>時，會回傳 HTTP 400 回應，包含<strong>自定義錯誤訊息</strong>，這樣可以保持<strong>回應的格式一致性</strong>。</p><p>程式碼很簡單，但其中的重點不少，讓我們逐一解析。</p><hr><h2 id="Exception-Handlers-重點解析"><a href="#Exception-Handlers-重點解析" class="headerlink" title="Exception Handlers 重點解析"></a>Exception Handlers 重點解析</h2><p>我們從「專案組織」這個議題講起。</p><h3 id="一、Exception-Handlers-函式放哪好？"><a href="#一、Exception-Handlers-函式放哪好？" class="headerlink" title="一、Exception Handlers 函式放哪好？"></a>一、Exception Handlers 函式放哪好？</h3><p>如前所述，這個錯誤處理器的影響範圍是<strong>全域</strong>的，所以可以把它放在專案的<strong>任何地方</strong>。</p><p>不過，還是建議將它放在<strong>最適合的位置</strong>。我認為主要有<strong>兩個選擇</strong>：</p><ol><li>如果你的錯誤處理函式不多，可以直接放在<strong>專案的</strong><code>api.py</code><strong>中</strong>——我們的例子就是這麼做的。這符合專案<code>api.py</code>的<strong>全域管理</strong>屬性。</li><li>如果錯誤處理比較多，建議獨立出一個 Python 模組來管理。</li></ol><h3 id="二、函式與參數命名"><a href="#二、函式與參數命名" class="headerlink" title="二、函式與參數命名"></a>二、函式與參數命名</h3><p>又到了我喜聞樂見的「<strong>命名</strong>」部分☺️</p><p>Exception handler 是一個（被裝飾的）函式，理論上應該要遵循「<strong>動詞開頭</strong>」的<strong>函式命名慣例</strong>。</p><p>但我卻使用了<code>django_validation_error_handler</code>這樣偏「<strong>名詞</strong>」的命名。</p><p>因為它的本質更接近於一個<strong>處理裝置</strong>或<strong>機制</strong>，而非傳統意義上的函式。</p><p>當然，這取決於你<strong>從什麼角度看</strong>！你也可以說它就是有「處理的行為」，所以還是得用動詞開頭來命名。我完全同意。</p><p>接著是<code>exception</code>參數，Django Ninja <a href="https://django-ninja.dev/guides/errors/">文件</a>都會命名為<code>exc</code>，我個人很不喜歡，因為我覺得<code>exc</code><strong>一點也不直觀</strong>，屬於<strong>完全沒必要的縮寫</strong>。</p><p>退一步來說，我寧可使用單字母<code>e</code>——類似 Pydantic 驗證方法中的<code>v</code>。</p><h3 id="三、函式邏輯解析"><a href="#三、函式邏輯解析" class="headerlink" title="三、函式邏輯解析"></a>三、函式邏輯解析</h3><p>Exception handler 的函式邏輯，可長可短、可簡單可複雜，但<strong>不外乎做這兩件事</strong>：</p><ol><li><strong>接收特定錯誤類型</strong>。</li><li><strong>返回特定 HTTP 回應</strong>。</li></ol><p>本例中，我們接收 Django 的<code>ValidationError</code>，並返回「400 Bad Request」回應，而且錯誤訊息的內容<strong>來自於拋出的錯誤</strong>——由我們自行定義。</p><p>這樣的<strong>錯誤處理靈活性</strong>已經算不錯。如果你的<code>ValidationError</code>採用<code>list</code>或<code>dict</code>初始化，那這個處理函式就需要寫得更複雜一些。</p><hr><h2 id="牛刀小試：以處理-404-回應為例"><a href="#牛刀小試：以處理-404-回應為例" class="headerlink" title="牛刀小試：以處理 404 回應為例"></a>牛刀小試：以處理 404 回應為例</h2><p>我們再來實作另一個 exception handler，處理常見的 404。</p><p>以「取得單一文章資訊」API 為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params">request: HttpRequest, post_id: <span class="built_in">int</span></span>) -&gt; Post:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得單一文章資訊</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    post = Post.objects.get(<span class="built_in">id</span>=post_id)</span><br><span class="line">    <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure><p>目前，如果前端輸入的文章 id 不存在，伺服器將直接 500：</p><blockquote><p>raise self.model.DoesNotExist(<br>post.models.Post.DoesNotExist: <strong>Post matching query does not exist.</strong></p></blockquote><p>而且還曝露內部訊息——這實在太瞎了！🤣</p><p>因為 Django ORM 中 QuerySet 的<code>get</code>方法，在<strong>查詢不到結果</strong>或<strong>查到複數結果</strong>時，都會<strong>拋出錯誤</strong>。而我們並沒有捕捉或處理這些錯誤，所以伺服器直接 500 了。</p><p>兩種錯誤並不相同——錯訊訊息也要不同。這裡先處理<strong>第一種</strong>情況就好。</p><h3 id="查無結果時，返回-404-回應"><a href="#查無結果時，返回-404-回應" class="headerlink" title="查無結果時，返回 404 回應"></a>查無結果時，返回 404 回應</h3><p>經過這兩篇的介紹，你有<strong>兩種方式</strong>來回應 404。</p><p>第一，直接使用<code>HttpError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    post = Post.objects.get(<span class="built_in">id</span>=post_id)</span><br><span class="line"><span class="keyword">except</span> Post.DoesNotExist:</span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">404</span>, <span class="string">&#x27;文章不存在&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這是我們前一篇的做法，<strong>也相當推薦</strong>。</p><p>第二，使用 exception handler：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.exception_handler(<span class="params">exc_class=ObjectDoesNotExist</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">object_does_not_exist_handler</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest, exception: ObjectDoesNotExist</span></span><br><span class="line"><span class="params"></span>) -&gt; HttpResponse:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    處理 Django ObjectDoesNotExist 例外</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> api.create_response(</span><br><span class="line">        request, &#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;查無資料&#x27;</span>&#125;, status=<span class="number">404</span>)</span><br></pre></td></tr></table></figure><p>這個做法相比於第一種，有其優點和缺點：</p><ul><li>優點：<strong>不必變更</strong> view 函式的內容（<strong>寫法更簡潔</strong>），而且可以捕捉<strong>所有 API</strong> 拋出的<code>ObjectDoesNotExist</code>錯誤。（它是<code>Post.DoesNotExist</code>的父類別）</li><li>缺點：無法自定義「<strong>詳細</strong>」的錯誤訊息——因為我們不知道<code>ObjectDoesNotExist</code>是發生在查詢什麼模型物件。<ul><li>當然，如果你願意為<strong>不同錯誤</strong>定義各自的 exception handler，就能夠實現！——比如只捕捉<code>Post.DoesNotExist</code>，錯誤訊息就可以寫「文章不存在」。</li><li>但就要定義很多個 exception handlers，有點麻煩啦！</li></ul></li></ul><p>選擇第一種還是第二種做法，需要你<strong>視情況而定</strong>。</p><hr><h2 id="第五章總結"><a href="#第五章總結" class="headerlink" title="第五章總結"></a>第五章總結</h2><p>第五章說真的，資訊量頗大，這 4 篇文章我寫了很久，而且還「<strong>重構</strong>」過！——本來只有 2 篇而已。</p><p>我們先討論了如何自定義單一欄位驗證，以及跨欄位驗證。然後再循序漸進地學習如何處理 API 拋出的錯誤——<strong>愈來愈優雅、愈來愈全面</strong>。</p><p>如果你是從第 1 篇看到這裡，真的，完全可以為自己感到驕傲。</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>接下來，比較輕鬆了嗎？——並沒有。</p><p>我們要介紹 API 的<strong>常見進階功能</strong>。</p><p>這些功能相比於處理請求、回應，可以說「<strong>不一定</strong>」要有，但對許多 API 專案來說仍相當重要。</p><p>下一章，我們將逐一探討這些進階功能，並學習如何在 Django Ninja 中實現它們。讓我們繼續深入 API 開發的世界吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章，我們學習了如何操作&lt;code&gt;HttpError&lt;/code&gt;，並建議你&lt;strong&gt;只在&lt;/strong&gt; view 函式中使用它。&lt;/p&gt;
&lt;p&gt;但光是這樣，專案 API 的錯誤處理，還遠遠&lt;strong&gt;不夠完善&lt;/strong&gt;，至少有 3 個常見問題待解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Schema 中的驗證方法 ，如果不要&lt;code&gt;raise HttpError&lt;/code&gt;，那要怎麼做才好？&lt;/li&gt;
&lt;li&gt;我們應該如何處理&lt;strong&gt;其他類型的錯誤&lt;/strong&gt;，例如資料庫操作錯誤？&lt;/li&gt;
&lt;li&gt;如何確保不同 API 錯誤的&lt;strong&gt;回應格式一致&lt;/strong&gt;？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這些問題都指向了一個&lt;strong&gt;更大的需求&lt;/strong&gt;：我們需要一個&lt;strong&gt;全面的錯誤處理機制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這篇文章，就要來回答這些問題。所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/13&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 21：錯誤處理（上）HttpError 與自定義 HTTP 回應</title>
    <link href="https://blog.kyomind.tw/django-ninja-21/"/>
    <id>https://blog.kyomind.tw/django-ninja-21/</id>
    <published>2024-10-03T02:46:01.000Z</published>
    <updated>2024-10-07T05:52:25.603Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>在軟體開發中，<strong>錯誤處理</strong>是一個不容忽視——但<strong>常常被忽視</strong>——的環節。</p><p>不誇張地說，錯誤處理是一個「<strong>做得好沒人誇，做不好系統就慘兮兮</strong>」的議題。</p><p>沒關係，我們還是<strong>盡可能把自己做好</strong>。</p><p>Django Ninja 使用 Pydantic 進行資料驗證，失敗時，預設回應「422 Unprocessable Entity」。</p><p>然而，我們有時候需要回應「400 Bad Request」或別的狀態碼，以符合<strong>現實業務需求</strong>或<strong>團隊開發習慣</strong>。</p><p>總之，無論出於何種原因，我們想<strong>自訂錯誤訊息、格式，以及回應的狀態碼</strong>，而<strong>不使用</strong> Django Ninja 預設的 422 回應——不得不說，這個制式回應的資訊有點多、結構有點複雜，因為它要兼容各種情況。</p><p>本文將介紹如何<strong>自定義錯誤處理與回應</strong>——使用 Django Ninja 內建的<code>HttpError</code>。</p><p>所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/12">這個 PR</a>。</p><hr><h2 id="Django-Ninja-的自動錯誤處理"><a href="#Django-Ninja-的自動錯誤處理" class="headerlink" title="Django Ninja 的自動錯誤處理"></a>Django Ninja 的自動錯誤處理</h2><p>上一篇我們提到，如果你在 Schema 的驗證方法中，拋出<code>ValueError</code>錯誤，Django Ninja 將會<strong>自動捕捉並回應</strong>。</p><p>事實上，不止<code>ValueError</code>，Django Ninja 還會替你處理以下這幾種錯誤：</p><ul><li><code>pydantic.ValidationError</code>，來自 Pydantic 的驗證錯誤，這是<strong>為何</strong>當 Schema 欄位有問題時，我們會直接收到 422 回應。</li><li>此外，Django Ninja 還內建了一個 <code>ninja.errors.ValidationError</code>，這些錯誤同樣會返回 422。</li><li><code>ninja.errors.HttpError</code>：這是本文的重點，下面會介紹。</li></ul><p>這些都是 Django Ninja 會自動捕捉的錯誤，但不是每一種都給出制式的 422 回應——第三種就不是。</p><span id="more"></span><hr><h2 id="新需求：驗證失敗時，改用-400-回應"><a href="#新需求：驗證失敗時，改用-400-回應" class="headerlink" title="新需求：驗證失敗時，改用 400 回應"></a>新需求：驗證失敗時，改用 400 回應</h2><p>如果我們希望 Schema 驗證失敗時，要返回「400 Bad Request」而不是 422，怎麼做最簡單？</p><p>答：使用 Django Ninja 的<code>HttpError</code>。</p><p>以下是 Schema 的程式碼改動，只改了兩行！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> ninja.errors <span class="keyword">import</span> HttpError  <span class="comment"># 第一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @model_validator(<span class="params">mode=<span class="string">&#x27;after&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_passwords_match</span>(<span class="params">self</span>) -&gt; Self:</span><br><span class="line">        <span class="keyword">if</span> self.password != self.confirm_password:</span><br><span class="line">            <span class="keyword">raise</span> HttpError(<span class="number">400</span>, <span class="string">&#x27;密碼和確認密碼必須相同&#x27;</span>)  <span class="comment"># 第二行</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>沒錯，就這麼簡單！</p><p>只是把驗證方法拋出的錯誤，從<code>ValueError</code>替換為<code>HttpError</code>即可。</p><p>值得留意的是，<code>HttpError</code>實例的<strong>初始化</strong>，需要<strong>兩個參數</strong>，第一個是 HTTP 狀態碼，第二個才是錯誤訊息。</p><h3 id="回應內容"><a href="#回應內容" class="headerlink" title="回應內容"></a>回應內容</h3><p>看看同樣的驗證失敗，回應有何不同：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 400 Bad Request</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;密碼和確認密碼必須相同&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>變成我們熟悉的格式——只有錯誤訊息。</p><hr><h2 id="在驗證方法中使用-HttpError-的不妥之處"><a href="#在驗證方法中使用-HttpError-的不妥之處" class="headerlink" title="在驗證方法中使用 HttpError 的不妥之處"></a>在驗證方法中使用 HttpError 的不妥之處</h2><p>直接在 Schema 的驗證方法中拋出<code>HttpError</code>，是一種便捷的方式，因為它能夠<strong>簡化回應處理</strong>。</p><p>我們<strong>無需</strong>額外捕捉錯誤或手動指定回應格式。驗證失敗時，API 會<strong>直接回應</strong>我們定義的狀態碼和錯誤訊息，既簡單又方便。</p><p>然而，這麼做其實<strong>並不妥當</strong>，主要有幾個問題，比如降低可測試性、限制回應的靈活性等等。但其中<strong>最關鍵</strong>的，還是是我們上一篇提到的——「<strong>關注點分離</strong>」。</p><h3 id="違反「關注點分離」"><a href="#違反「關注點分離」" class="headerlink" title="違反「關注點分離」"></a>違反「關注點分離」</h3><p><strong>這個做法違反了「關注點分離」原則。</strong></p><p>驗證邏輯的職責是檢查資料的正確性，而<strong>回應</strong>應該由 view 函式負責。</p><p>將回應邏輯混入驗證過程中，會讓驗證和回應這兩個<strong>本應獨立</strong>的部分<strong>耦合在一起</strong>，導致<strong>職責混亂</strong>，不利於程式碼維護。</p><p>因此，雖然在驗證方法內使用<code>HttpError</code>，看似能夠方便地實現需求，但從<strong>架構設計</strong>的角度考慮，將<strong>回應處理</strong>放在 view 函式中，才是一個更合理的選擇。</p><p>別擔心，下一篇我們會換個做法，但本文的主角還是<code>HttpError</code>。</p><hr><h2 id="HttpError-的典型情境：在-view-函式中使用"><a href="#HttpError-的典型情境：在-view-函式中使用" class="headerlink" title="HttpError 的典型情境：在 view 函式中使用"></a>HttpError 的典型情境：在 view 函式中使用</h2><p>相比於在 Schema 中使用<code>HttpError</code>，把它放在 view 函式裡執行，方為正道。</p><p>以下就是一個經典場景。</p><p>儘管資料驗證邏輯應盡可能放在 Schema 中，<strong>但也不是所有的驗證都適合丟給 Schema 做</strong>。</p><p>比如，使用者的 email 欄位具有「<strong>唯一性</strong>」——不能重複。所以我們希望先確認使用者輸入的 email <strong>是否和 db 中的資料重複</strong>，是的話，直接回應<code>409 Conflict</code>。</p><p>這無疑也是一種<strong>驗證</strong>，但它涉及了「<strong>資料庫查詢</strong>」。</p><p>這種涉及資料庫查詢的驗證，更適合在 view 函式中進行，而不是在 Schema 裡。因為資料庫查詢屬於<strong>比較重的動態操作</strong>，與 Schema 的<strong>靜態資料檢查</strong>有著<strong>本質的不同</strong>。</p><p>因此，我們更常在 view 函式中使用<code>HttpError</code>處理這類需求。</p><p>新增程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_user</span>(<span class="params">..., payload: CreateUserRequest</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> User.objects.<span class="built_in">filter</span>(email=payload.email).exists():</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">409</span>, <span class="string">&#x27;使用者 email 已存在&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上面是「預先查詢」，和下面這個寫法，在結果上是類似的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    user.save()</span><br><span class="line"><span class="keyword">except</span> IntegrityError:  <span class="comment"># Django ORM 唯一性錯誤</span></span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">409</span>, <span class="string">&#x27;使用者 email 已存在&#x27;</span>)</span><br></pre></td></tr></table></figure><p>只不過一個是<strong>事前驗證並拋出錯誤</strong>，一個是<strong>事後捕捉錯誤</strong>（然後再拋出）。</p><p>驗證失敗的回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 409 Conflict</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用者 email 已存在&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>確實還不錯！</p><hr><h2 id="為什麼不直接-return-409-回應就好？"><a href="#為什麼不直接-return-409-回應就好？" class="headerlink" title="為什麼不直接 return 409 回應就好？"></a>為什麼不直接 return 409 回應就好？</h2><p>聰明的你可能會想到：</p><blockquote><p>咦，那我<strong>何不直接 return</strong> 一個帶有錯誤訊息的 Python 字典就好了？為什麼非得在 view 函式中<code>raise HttpError</code>？</p></blockquote><p>這個想法，大概的程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/&#x27;</span>, response=&#123;<span class="number">201</span>: <span class="built_in">dict</span>, <span class="number">409</span>: <span class="built_in">dict</span>&#125;, ...</span>)</span></span><br><span class="line"><span class="keyword">def</span> (...) -&gt; <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> User.objects.<span class="built_in">filter</span>(email=payload.email).exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="number">409</span>, &#123;<span class="string">&quot;detail&quot;</span>: <span class="string">&quot;使用者 email 已存在&quot;</span>&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>這樣不是<strong>更加直觀</strong>嗎？</p><p>這是一個<strong>好問題</strong>。</p><h3 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h3><p>我們還是先來看一下，這段程式碼中有哪些重點：</p><ul><li><code>response=&#123;201: dict, 409: dict&#125;</code>：第 13 篇提過的「<strong>多重狀態碼回應</strong>」，這不就派上用場了！</li><li>用<code>return</code>取代<code>raise</code>。</li><li>如果想驗證錯誤訊息格式，可以定義一個 Schema。這個例子只是簡化版。</li></ul><p>看起來確實不錯，也很符合直覺，其實我以前寫 Django REST framework，<strong>都是</strong>這樣寫的。</p><p><strong>可是</strong>，這個寫法在 Django Ninja 中，使用「分頁裝飾器」時，就會<strong>踢到鐵板</strong>了。</p><p>目前時機未到，在後續的〈卷 25：分頁（下）自定義分頁類別〉中，我們再把這件事說清楚。</p><p>總之，現階段我們只要知道，類似情況還是<code>raise HttpError</code>會比較妥當。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在這篇文章中，我們學習了如何使用 Django Ninja 內建的<code>HttpError</code>來自定義錯誤回應，以避免預設的 422。</p><p>並解釋了為何<code>HttpError</code>不適合用在 Schema 中（雖然我們暫時這麼做了😅），而是應該放到 view 函式裡。</p><p>下一篇，我們將改善 Schema 拋出的錯誤、探討全域錯誤處理機制，並且使用 Django Ninja 所提供的<code>exception_handler</code>裝飾器，進一步提升 API 的錯誤處理能力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;在軟體開發中，&lt;strong&gt;錯誤處理&lt;/strong&gt;是一個不容忽視——但&lt;strong&gt;常常被忽視&lt;/strong&gt;——的環節。&lt;/p&gt;
&lt;p&gt;不誇張地說，錯誤處理是一個「&lt;strong&gt;做得好沒人誇，做不好系統就慘兮兮&lt;/strong&gt;」的議題。&lt;/p&gt;
&lt;p&gt;沒關係，我們還是&lt;strong&gt;盡可能把自己做好&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Django Ninja 使用 Pydantic 進行資料驗證，失敗時，預設回應「422 Unprocessable Entity」。&lt;/p&gt;
&lt;p&gt;然而，我們有時候需要回應「400 Bad Request」或別的狀態碼，以符合&lt;strong&gt;現實業務需求&lt;/strong&gt;或&lt;strong&gt;團隊開發習慣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;總之，無論出於何種原因，我們想&lt;strong&gt;自訂錯誤訊息、格式，以及回應的狀態碼&lt;/strong&gt;，而&lt;strong&gt;不使用&lt;/strong&gt; Django Ninja 預設的 422 回應——不得不說，這個制式回應的資訊有點多、結構有點複雜，因為它要兼容各種情況。&lt;/p&gt;
&lt;p&gt;本文將介紹如何&lt;strong&gt;自定義錯誤處理與回應&lt;/strong&gt;——使用 Django Ninja 內建的&lt;code&gt;HttpError&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/12&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Django-Ninja-的自動錯誤處理&quot;&gt;&lt;a href=&quot;#Django-Ninja-的自動錯誤處理&quot; class=&quot;headerlink&quot; title=&quot;Django Ninja 的自動錯誤處理&quot;&gt;&lt;/a&gt;Django Ninja 的自動錯誤處理&lt;/h2&gt;&lt;p&gt;上一篇我們提到，如果你在 Schema 的驗證方法中，拋出&lt;code&gt;ValueError&lt;/code&gt;錯誤，Django Ninja 將會&lt;strong&gt;自動捕捉並回應&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;事實上，不止&lt;code&gt;ValueError&lt;/code&gt;，Django Ninja 還會替你處理以下這幾種錯誤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pydantic.ValidationError&lt;/code&gt;，來自 Pydantic 的驗證錯誤，這是&lt;strong&gt;為何&lt;/strong&gt;當 Schema 欄位有問題時，我們會直接收到 422 回應。&lt;/li&gt;
&lt;li&gt;此外，Django Ninja 還內建了一個 &lt;code&gt;ninja.errors.ValidationError&lt;/code&gt;，這些錯誤同樣會返回 422。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ninja.errors.HttpError&lt;/code&gt;：這是本文的重點，下面會介紹。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些都是 Django Ninja 會自動捕捉的錯誤，但不是每一種都給出制式的 422 回應——第三種就不是。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 20：資料驗證（下）Pydantic model_validator 實現「跨欄位」驗證</title>
    <link href="https://blog.kyomind.tw/django-ninja-20/"/>
    <id>https://blog.kyomind.tw/django-ninja-20/</id>
    <published>2024-10-02T03:31:23.000Z</published>
    <updated>2024-10-07T05:52:25.628Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇我們講完了單一欄位的自定義驗證，這篇則要來討論<strong>跨欄位</strong>之間的驗證。</p><p>跨欄位驗證同樣是 API 開發中十分常見的需求，例如註冊帳號時，要保證「密碼」與「確認密碼」兩個欄位內容相同；選擇<strong>日期期間</strong>時，開始日期不能晚於結束日期等。</p><p>這些驗證場景<strong>無法</strong>透過單一欄位驗證實現，因為它們需要同時檢查<strong>多個欄位之間的邏輯關聯</strong>，來確保整體資料的<strong>一致性和正確性</strong>。</p><p>本文將介紹如何透過 Pydantic 來實現跨欄位驗證需求——以「確認密碼」為例，展示這個功能的實際應用。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/11">這個 PR</a>。</p><hr><h2 id="跨欄位驗證與關注點分離"><a href="#跨欄位驗證與關注點分離" class="headerlink" title="跨欄位驗證與關注點分離"></a>跨欄位驗證與關注點分離</h2><p>其實，無論是單一欄位還是跨欄位的自定義驗證，都<strong>不一定</strong>要藉由 Pydantic 來完成。</p><p>理論上，資料驗證可以<strong>直接</strong>在 view 函式中進行，例如取出輸入的欄位值，手動驗證它的合法性。跨欄位驗證也是如此。</p><p>然而，這是一種方便但「<strong>粗糙</strong>」的做法——只適合用在驗證邏輯非常單純的情況。</p><p>透過 Pydantic 進行資料驗證，則能夠帶來一個明顯的好處：<strong>關注點分離</strong>。</p><span id="more"></span><h3 id="關注點分離"><a href="#關注點分離" class="headerlink" title="關注點分離"></a>關注點分離</h3><p><a href="https://zh.wikipedia.org/zh-tw/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">關注點分離</a>（Separation of Concerns）是一種<strong>設計原則</strong>。主張將程式中不同功能的職責劃分到<strong>獨立</strong>的模組或層次中。</p><p>每個模組主要<strong>專注於一個具體的方向或目標</strong>，從而<strong>避免把多個不同的功能耦合</strong>在一起。這樣的劃分可以讓程式更易於測試、維護和擴充。</p><p>依照關注點分離，<strong>資料驗證</strong>的邏輯應該集中在 Schema，而不是在 view 函式中進行。</p><p>如此一來，view 可以<strong>專注於處理核心業務邏輯</strong>，而將資料驗證交由專門的元件負責。</p><p>透過 Pydantic 的驗證機制，我們可以實現關注點分離，讓資料驗證與業務邏輯分開，這不僅提升了程式碼的結構，也讓開發流程更加清楚、穩定。</p><hr><h2 id="新需求：確認密碼"><a href="#新需求：確認密碼" class="headerlink" title="新需求：確認密碼"></a>新需求：確認密碼</h2><p>我們要實作一個非常簡單，但足以<strong>充分說明</strong>跨欄位驗證價值的功能：<strong>確認密碼</strong>。</p><p>先回顧上一篇結束時，「新增使用者」API 的請求 Schema 內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    username: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line">    email: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;alice@example.com&#x27;</span>])</span><br><span class="line">    password: <span class="built_in">str</span> = Field(min_length=<span class="number">8</span>, examples=[<span class="string">&#x27;password123&#x27;</span>])</span><br><span class="line">    bio: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">        default=<span class="literal">None</span>, examples=[<span class="string">&#x27;Hello, I am Alice.&#x27;</span>])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>這個 Schema 的設計，顯然<strong>有所不足</strong>。</p><p>因為用戶註冊時，密碼通常需要<strong>輸入兩次</strong>，第二次的作用是「<strong>確認</strong>」——重要的事情說兩次嘛！</p><p>所以，我們要新增一個<code>confirm_password</code>欄位，和<code>password</code>進行<strong>跨欄位驗證：確認兩者內容相同</strong>。</p><p>儘管其中的驗證邏輯非常簡單，但這正是跨欄位驗證的<strong>絕佳舞台</strong>。</p><hr><h2 id="實作跨欄位驗證：使用-model-validator"><a href="#實作跨欄位驗證：使用-model-validator" class="headerlink" title="實作跨欄位驗證：使用 model_validator"></a>實作跨欄位驗證：使用 model_validator</h2><p>Pydantic v2 引入了<code>@model_validator</code>裝飾器來處理跨欄位驗證，這是對 Pydantic v1 中<code>@root_validator</code>的改進和替代。</p><p>這裡的 model，指的是 Pydantic 的 <a href="https://docs.pydantic.dev/latest/api/base_model/">BaseModel</a>——也就是我們的 Schema，而不是 Django 的 <a href="https://docs.djangoproject.com/en/5.1/topics/db/models/">Models</a>。</p><p>我們透過<code>@model_validator</code>來強化「新增使用者」API，加上「確認密碼」功能。</p><p>直接看修改後的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    password: <span class="built_in">str</span> = Field(min_length=<span class="number">8</span>, examples=[<span class="string">&#x27;password123&#x27;</span>])</span><br><span class="line">    confirm_password: <span class="built_in">str</span> = Field(</span><br><span class="line">        min_length=<span class="number">8</span>, examples=[<span class="string">&#x27;password123&#x27;</span>])</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @model_validator(<span class="params">mode=<span class="string">&#x27;after&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_passwords_match</span>(<span class="params">self</span>) -&gt; Self:</span><br><span class="line">        <span class="keyword">if</span> self.password != self.confirm_password:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;密碼和確認密碼必須相同&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><h3 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h3><ul><li>新增了一個<code>confirm_password</code>欄位。</li><li>使用<code>@model_validator(mode=&#39;after&#39;)</code>裝飾器來定義跨欄位的驗證方法。<ul><li><code>mode</code>總共有三種：before、after 和 wrap。其中的細節頗多，限於篇幅，本文無法展開（可能等番外篇再行補充）。</li><li>你只要知道，<strong>大部分時候是用 after 模式</strong>，此時的驗證方法是一個「<strong>實例方法</strong>」，<code>self</code>參數代表 Schema 實例本身（從 input 資料初始化而來）。</li></ul></li><li>驗證方法<code>check_passwords_match</code>比較<code>password</code>和<code>confirm_password</code>欄位，如果欄位內容不相同，則拋出<code>ValueError</code>。<ul><li>如前所述，儘管邏輯非常簡單，但它確實現了<strong>兩個欄位之間</strong>的驗證。</li></ul></li><li>跨欄位驗證在<strong>所有單一欄位驗證完成後</strong>才會執行。</li></ul><h3 id="關注點分離的實際應用"><a href="#關注點分離的實際應用" class="headerlink" title="關注點分離的實際應用"></a>關注點分離的實際應用</h3><p>你會發現，在這次新增「確認密碼」的功能實作中，view 函式<strong>完全沒有變動</strong>！——這正是關注點分離原則的體現。</p><p>相較於直接在 view 函式中實作驗證邏輯（需要同時修改 view 和 Schema），這樣的實作方式無疑更加乾淨、解耦。</p><hr><h2 id="驗證失敗時的-HTTP-回應"><a href="#驗證失敗時的-HTTP-回應" class="headerlink" title="驗證失敗時的 HTTP 回應"></a>驗證失敗時的 HTTP 回應</h2><p>最後，讓我們來看看，當資料驗證失敗時，會得到什麼樣的 HTTP 回應。</p><h3 id="違反密碼長度限制"><a href="#違反密碼長度限制" class="headerlink" title="違反密碼長度限制"></a>違反密碼長度限制</h3><p>回應結果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string_too_short&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;body&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;payload&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;password&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String should have at least 8 characters&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ctx&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;min_length&quot;</span><span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>這是 Django Ninja 捕捉 Pydantic 驗證錯誤所給出的「系統級」回應，狀態碼為 422。</p><h3 id="違反「必須包含數字」規則、確認密碼不一致"><a href="#違反「必須包含數字」規則、確認密碼不一致" class="headerlink" title="違反「必須包含數字」規則、確認密碼不一致"></a>違反「必須包含數字」規則、確認密碼不一致</h3><p>輸入的密碼中沒有數字，回應結果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value_error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;body&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;payload&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;password&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Value error, 密碼必須包含至少一個數字&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ctx&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;密碼必須包含至少一個數字&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>好像<strong>差不多</strong>耶？沒錯，因為這也是 Django Ninja 的<strong>自動回應格式</strong>——除了錯誤訊息中<strong>包含</strong>我們自定義的內容。</p><p>但事實上，這是因為我們在驗證方法中拋出的是<code>ValueError</code>，所以 Django Ninja 會自動幫你處理。</p><p>類似的回應也發生在<strong>確認密碼不一致</strong>時：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;detail&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;value_error&quot;</span>,</span><br><span class="line">            <span class="string">&quot;loc&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;body&quot;</span>,</span><br><span class="line">                <span class="string">&quot;payload&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Value error, 密碼和確認密碼必須相同&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ctx&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: <span class="string">&quot;密碼和確認密碼必須相同&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果拋出的<strong>別種錯誤</strong>，比如 Django 的<code>ValidationError</code>，甚至是我們<strong>自己定義的錯誤</strong>，Django Ninja 還會自動處理嗎？</p><p>答案是：<strong>不會</strong>。</p><p>你會得到「<strong>500 Internal Server Error</strong>」——這將是我們下下篇的重點。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>本文中，我們介紹了如何透過<code>@model_validator</code>來實現跨欄位驗證的需求，同時落實關注點分離原則。</p><p>學習完這兩篇以後，你對 <strong>Django Ninja 資料驗證</strong>的了解，已經超越大部分人。</p><p>接下來，我們將深入探討，當資料驗證失敗時，要如何優雅地處理錯誤——並回應，以提升 API 的使用體驗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇我們講完了單一欄位的自定義驗證，這篇則要來討論&lt;strong&gt;跨欄位&lt;/strong&gt;之間的驗證。&lt;/p&gt;
&lt;p&gt;跨欄位驗證同樣是 API 開發中十分常見的需求，例如註冊帳號時，要保證「密碼」與「確認密碼」兩個欄位內容相同；選擇&lt;strong&gt;日期期間&lt;/strong&gt;時，開始日期不能晚於結束日期等。&lt;/p&gt;
&lt;p&gt;這些驗證場景&lt;strong&gt;無法&lt;/strong&gt;透過單一欄位驗證實現，因為它們需要同時檢查&lt;strong&gt;多個欄位之間的邏輯關聯&lt;/strong&gt;，來確保整體資料的&lt;strong&gt;一致性和正確性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文將介紹如何透過 Pydantic 來實現跨欄位驗證需求——以「確認密碼」為例，展示這個功能的實際應用。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/11&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;跨欄位驗證與關注點分離&quot;&gt;&lt;a href=&quot;#跨欄位驗證與關注點分離&quot; class=&quot;headerlink&quot; title=&quot;跨欄位驗證與關注點分離&quot;&gt;&lt;/a&gt;跨欄位驗證與關注點分離&lt;/h2&gt;&lt;p&gt;其實，無論是單一欄位還是跨欄位的自定義驗證，都&lt;strong&gt;不一定&lt;/strong&gt;要藉由 Pydantic 來完成。&lt;/p&gt;
&lt;p&gt;理論上，資料驗證可以&lt;strong&gt;直接&lt;/strong&gt;在 view 函式中進行，例如取出輸入的欄位值，手動驗證它的合法性。跨欄位驗證也是如此。&lt;/p&gt;
&lt;p&gt;然而，這是一種方便但「&lt;strong&gt;粗糙&lt;/strong&gt;」的做法——只適合用在驗證邏輯非常單純的情況。&lt;/p&gt;
&lt;p&gt;透過 Pydantic 進行資料驗證，則能夠帶來一個明顯的好處：&lt;strong&gt;關注點分離&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Pydantic" scheme="https://blog.kyomind.tw/tags/Pydantic/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 19：資料驗證（上）單一欄位驗證——使用 Pydantic field_validator</title>
    <link href="https://blog.kyomind.tw/django-ninja-19/"/>
    <id>https://blog.kyomind.tw/django-ninja-19/</id>
    <published>2024-10-01T02:31:53.000Z</published>
    <updated>2024-10-07T05:52:25.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p><strong>資料驗證</strong>是 API 開發中的關鍵需求之一，它負責確保從客戶端提交的資料是<strong>符合預期</strong>的，從而避免潛在的錯誤和安全問題。</p><p>有效的資料驗證可以在 API 接收到錯誤資料時，給出<strong>即時且友善</strong>的回應，提升系統的穩定性和<strong>使用者體驗</strong>。</p><p>Django Ninja 中，資料驗證的核心工具是 <strong>Pydantic</strong>。它提供了強大的驗證功能，不僅能對資料型別進行檢查，還能輕鬆實現<strong>自定義驗證</strong>。</p><p>本文將介紹如何在 Django Ninja 中使用 Pydantic 實作<strong>單一欄位的自定義驗證</strong>；下一篇則講述<strong>跨欄位的自定義驗證</strong>。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/10">這個 PR</a>。</p><hr><h2 id="第五章總論"><a href="#第五章總論" class="headerlink" title="第五章總論"></a>第五章總論</h2><p>資料驗證很重要，而驗證失敗時，程式往往會拋出<strong>驗證錯誤</strong>。如何有效處理這些錯誤，則是「<strong>錯誤處理</strong>」要討論的範疇。</p><p>本章將探討這兩個<strong>密切相關</strong>的主題，共計 4 篇文章：</p><ul><li>卷 19：資料驗證（上）單一欄位驗證——使用 Pydantic field_validator（本文）</li><li>卷 20：資料驗證（下）Pydantic model_validator 實現「跨欄位」驗證</li><li>卷 21：錯誤處理（上）HttpError 與自定義 HTTP 回應</li><li>卷 22：錯誤處理（下）全域錯誤處理——深入解析 Exception Handlers</li></ul><p>前兩篇，我們會學習如何實現靈活的資料驗證，以確保輸入資料符合預期，並在必要時拋出錯誤。</p><p>後兩篇，我們將討論如何處理 API 流程中可能出現的各種錯誤（不限於驗證錯誤），以提供更好的使用者體驗。</p><p>Django Ninja 的資料驗證與錯誤處理機制，相較 Django REST framework <strong>更加複雜</strong>，因此我們得用<strong>完整的篇幅</strong>來介紹，幫助你清楚地理解它們。</p><span id="more"></span><hr><h2 id="API-修正"><a href="#API-修正" class="headerlink" title="API 修正"></a>API 修正</h2><p>我們會以上一篇文章中新建立的 API——<strong>新增使用者</strong>——為例。</p><p>繼續改善它，加上自定義驗證，讓客戶端傳來的資料更可靠。</p><p>不過我要先做一些<strong>錯誤修正</strong>，修正後的程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/&#x27;</span>, summary=<span class="string">&#x27;新增使用者&#x27;</span>, response=&#123;<span class="number">201</span>: <span class="built_in">dict</span>&#125;</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_user</span>(<span class="params">...</span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    user = User(</span><br><span class="line">        username=payload.username,</span><br><span class="line">        email=payload.email,</span><br><span class="line">        bio=payload.bio,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 使用 set_password 方法加密密碼</span></span><br><span class="line">    user.set_password(raw_password=payload.password)</span><br><span class="line">    user.save()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">201</span>, &#123;<span class="string">&#x27;id&#x27;</span>: user.<span class="built_in">id</span>, <span class="string">&#x27;username&#x27;</span>: user.username&#125;</span><br></pre></td></tr></table></figure><p>主要改正了這兩處：</p><ol><li>在<code>router</code>裝飾器<strong>新增</strong>了<code>response=&#123;201: dict&#125;</code>參數。本來沒有定義，實際使用這個 API 時會出現錯誤。因為<strong>預設只有 200 回應</strong>，想要 200 以外的回應，要透過<code>response</code>參數聲明才行。</li><li>使用<code>set_password</code>方法對用戶輸入的密碼進行<strong>加密</strong>。這是 Django 內建的功能，防止密碼直接儲存在 db 中。密碼不能明文存儲，無疑是現代開發的 ABC。</li></ol><hr><p>修正結束，我們正式進入主題。</p><h2 id="不同「層次」的驗證"><a href="#不同「層次」的驗證" class="headerlink" title="不同「層次」的驗證"></a>不同「層次」的驗證</h2><p>既然是驗證，主要當然是跟來自客戶端的<strong>請求</strong>有關——<strong>驗證請求內容。</strong></p><p>Django Ninja 中，每個 API 可以透過定義 Schema，來<strong>描述 API 所接收的資料結構</strong>。這些 Schema 基於 Pydantic，能自動對請求中的資料進行驗證。</p><p>Schema 中的 type hints 可以驗證資料<strong>型別</strong>，這是最基本的驗證。</p><p>前一篇提到的 Pydantic Field，則可以對資料的長度、範圍等特性進行驗證。這部分在後面會示範。</p><p>這些都是偏「形式上」的驗證，而本文將聚焦於更複雜的「<strong>自定義驗證</strong>」——基於一定的<strong>規則</strong>。</p><h3 id="範例-API-的-Schema-現狀"><a href="#範例-API-的-Schema-現狀" class="headerlink" title="範例 API 的 Schema 現狀"></a>範例 API 的 Schema 現狀</h3><p>以「新增使用者」為例，request body 接收<code>username</code>、<code>email</code>、<code>password</code>和<code>bio</code>等欄位。透過我們定義的 Schema，能完成最基本的<strong>資料型別驗證</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: <span class="built_in">str</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    bio: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>如上一篇所述，只有<code>bio</code>欄位是可選的，其餘則為必填——缺少就會得到 422 回應。所以 Schema 同時也驗證了資料的「<strong>存在性</strong>」。</p><p>目前看起來還不錯！但我們並不就此滿足。</p><hr><h2 id="新需求：密碼規則"><a href="#新需求：密碼規則" class="headerlink" title="新需求：密碼規則"></a>新需求：密碼規則</h2><p>我們要求使用者在設定密碼時，遵守以下兩個規則：</p><ol><li>密碼長度至少 8 個字元。</li><li>必須包含至少一個數字。</li></ol><p>這些規則有助於提高帳號的安全性，防止用戶設定過於簡單的密碼。</p><p>考慮到<strong>教學目的</strong>，我沒有讓規則過於複雜。這兩條規則都有其<strong>特定的教學意義</strong>：</p><ol><li>最小長度限制可以<strong>直接透過 Pydantic Field 實現</strong>，不必自行實作。</li><li>第二個規則是重頭戲，我們會使用 Pydantic 的<code>@field_validator</code>裝飾器，自行定義欄位的驗證規則。</li></ol><hr><h2 id="實作密碼規則驗證：使用-field-validator"><a href="#實作密碼規則驗證：使用-field-validator" class="headerlink" title="實作密碼規則驗證：使用 field_validator"></a>實作密碼規則驗證：使用 field_validator</h2><p>根據需求，我們可以先利用 Pydantic 的<code>Field</code>來設定<strong>最小長度限制</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password: <span class="built_in">str</span> = Field(min_length=<span class="number">8</span>, examples=[<span class="string">&#x27;password123&#x27;</span>])</span><br></pre></td></tr></table></figure><p>如上，我們只需要新增一個<code>min_length=8</code>參數即可。</p><p>至於「必須包含數字」的驗證，則要用<code>@field_validator</code>裝飾器來實作。</p><h3 id="field-validator-裝飾器"><a href="#field-validator-裝飾器" class="headerlink" title="field_validator 裝飾器"></a>field_validator 裝飾器</h3><p>在 Pydantic v1 中，這個裝飾器的名稱是<code>validator</code>，v2 才改為<code>field_validator</code>。</p><p>Pydantic 從 v1 到 v2，有<strong>許多</strong> <a href="https://en.wiktionary.org/wiki/breaking_change">breaking change</a>，比如之前提過的<code>example</code>參數變成<code>examples</code>，即是一例。這部分值得留意。</p><p>以下是修改後的 Schema，我們只關注<code>field_validator</code>部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @field_validator(<span class="params"><span class="string">&#x27;password&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate_password_contains_number</span>(<span class="params">cls, v: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        驗證密碼至少包含一個數字</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.search(<span class="string">r&#x27;\d&#x27;</span>, v):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;密碼必須包含至少一個數字&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><h3 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h3><ol><li><code>field_validator</code>裝飾器<strong>必須使用參數</strong>，合法值是<strong>欄位名稱</strong>，如<code>password</code>。</li><li>雖然範例中沒有演示，但它可以套用在<strong>多個欄位</strong>。<ol><li>寫法為<code>@field_validator(&#39;欄位1&#39;, &#39;欄位2&#39;, ...)</code>，你甚至可以直接寫成<code>@field_validator(&#39;*&#39;)</code>——套用到<strong>全部</strong>欄位。</li><li>但請注意，這些欄位會執行<strong>同一個驗證邏輯</strong>，所以它們理論上是<strong>邏輯類似</strong>的欄位。</li></ol></li><li><strong>驗證方法的名稱</strong>可以自訂，你想怎麼命名都行，只要自己好懂即可。<ol><li>因為 Pydantic 主要是看裝飾器上的欄位名稱。</li><li>這和 Django REST framework 的驗證方法是採用<code>validate_&lt;欄位名&gt;</code>的命名模式，有<strong>很大的不同</strong>。</li></ol></li><li>Pydantic 驗證方法的參數名稱命名慣例是<code>v</code>，而 Django REST framework 則是<code>value</code>。</li><li>慣例二：驗證方法在<strong>成功時會原封不動 return 輸入值</strong>；失敗時則會拋出錯誤。</li><li>Pydantic 的驗證方法是一個「<strong>類別方法</strong>」，所以第一個參數是<code>cls</code>。特別的是，你<strong>可以省略</strong><code>@classmethod</code>裝飾器，因為 Pydantic 已經在內部處理了。<ol><li>不過<a href="https://docs.pydantic.dev/latest/concepts/validators/#field-validators">官方文件</a>仍建議你使用<code>@classmethod</code>，我們從善如流。</li><li>如果有聲明<code>@classmethod</code>裝飾器，它的位置必須<strong>最靠近</strong>驗證方法。</li></ol></li></ol><p>想不到吧？短短幾行，竟然有這麼多<strong>看點</strong>！</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這一篇，我們學習了如何透過 Pydantic，對單一欄位進行資料驗證，實作了密碼強度檢查規則。</p><p>下一篇，我們要繼續這個主題，實現更複雜的<strong>跨欄位驗證</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;資料驗證&lt;/strong&gt;是 API 開發中的關鍵需求之一，它負責確保從客戶端提交的資料是&lt;strong&gt;符合預期&lt;/strong&gt;的，從而避免潛在的錯誤和安全問題。&lt;/p&gt;
&lt;p&gt;有效的資料驗證可以在 API 接收到錯誤資料時，給出&lt;strong&gt;即時且友善&lt;/strong&gt;的回應，提升系統的穩定性和&lt;strong&gt;使用者體驗&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Django Ninja 中，資料驗證的核心工具是 &lt;strong&gt;Pydantic&lt;/strong&gt;。它提供了強大的驗證功能，不僅能對資料型別進行檢查，還能輕鬆實現&lt;strong&gt;自定義驗證&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文將介紹如何在 Django Ninja 中使用 Pydantic 實作&lt;strong&gt;單一欄位的自定義驗證&lt;/strong&gt;；下一篇則講述&lt;strong&gt;跨欄位的自定義驗證&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/10&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第五章總論&quot;&gt;&lt;a href=&quot;#第五章總論&quot; class=&quot;headerlink&quot; title=&quot;第五章總論&quot;&gt;&lt;/a&gt;第五章總論&lt;/h2&gt;&lt;p&gt;資料驗證很重要，而驗證失敗時，程式往往會拋出&lt;strong&gt;驗證錯誤&lt;/strong&gt;。如何有效處理這些錯誤，則是「&lt;strong&gt;錯誤處理&lt;/strong&gt;」要討論的範疇。&lt;/p&gt;
&lt;p&gt;本章將探討這兩個&lt;strong&gt;密切相關&lt;/strong&gt;的主題，共計 4 篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷 19：資料驗證（上）單一欄位驗證——使用 Pydantic field_validator（本文）&lt;/li&gt;
&lt;li&gt;卷 20：資料驗證（下）Pydantic model_validator 實現「跨欄位」驗證&lt;/li&gt;
&lt;li&gt;卷 21：錯誤處理（上）HttpError 與自定義 HTTP 回應&lt;/li&gt;
&lt;li&gt;卷 22：錯誤處理（下）全域錯誤處理——深入解析 Exception Handlers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前兩篇，我們會學習如何實現靈活的資料驗證，以確保輸入資料符合預期，並在必要時拋出錯誤。&lt;/p&gt;
&lt;p&gt;後兩篇，我們將討論如何處理 API 流程中可能出現的各種錯誤（不限於驗證錯誤），以提供更好的使用者體驗。&lt;/p&gt;
&lt;p&gt;Django Ninja 的資料驗證與錯誤處理機制，相較 Django REST framework &lt;strong&gt;更加複雜&lt;/strong&gt;，因此我們得用&lt;strong&gt;完整的篇幅&lt;/strong&gt;來介紹，幫助你清楚地理解它們。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Pydantic" scheme="https://blog.kyomind.tw/tags/Pydantic/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 18：API 文件（下）用 Pydantic Field 設定範例與預設值</title>
    <link href="https://blog.kyomind.tw/django-ninja-18/"/>
    <id>https://blog.kyomind.tw/django-ninja-18/</id>
    <published>2024-09-30T01:42:11.000Z</published>
    <updated>2024-10-07T05:52:25.616Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇文章中，我們探討了 Django Ninja 影響 API 文件<strong>呈現</strong>的一些重要設定。它們是<strong>自動化 API 文件</strong>的基本功，不容忽視。</p><p>但這樣<strong>還不夠</strong>！我們想要讓這份文件更加<strong>生動</strong>，讀起來清晰易懂。</p><p>其中的關鍵在於 API 文件上的<strong>資料範例</strong>。好的範例讓人一讀就懂，能有效縮短理解和思考的時間。</p><p>本文將介紹如何運用 Pydantic 的<code>Field</code>設定，全方位提升 API 文件的清晰與可讀性。我們會探討如何為自動生成的文件加上<strong>栩栩如生的範例</strong>，讓文件<strong>更貼近真實</strong>。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/9">這個 PR</a>。</p><hr><h2 id="Pydantic-在-Django-Ninja-中的角色"><a href="#Pydantic-在-Django-Ninja-中的角色" class="headerlink" title="Pydantic 在 Django Ninja 中的角色"></a>Pydantic 在 Django Ninja 中的角色</h2><p>Pydantic 是一個實現<strong>資料驗證、序列化</strong>的套件，廣泛應用於 FastAPI 和 Django Ninja 等框架。</p><p>在 Django Ninja 中，Pydantic 被用來定義 Schema，這些 Schema 決定了 API 如何處理 HTTP 請求和回應中的資料，並自動轉換成<strong>符合 OpenAPI 標準的文件</strong>。</p><p>Pydantic 的強大之處在於，它不僅能驗證資料，還可以通過<code>Field</code>設定，為文件欄位<strong>提供額外的說明、範例和預設值</strong>。</p><p>這些細節設定會<strong>自動反映</strong>在轉換後的 API 文件中，幫助開發者更好地理解 API 的行為與內涵。</p><span id="more"></span><h2 id="Pydantic-Field"><a href="#Pydantic-Field" class="headerlink" title="Pydantic Field"></a>Pydantic Field</h2><p>Pydantic 的<code>Field</code>是一個強大的工具，可以用來為每個資料欄位提供更多細節資訊，如標題、描述、範例和預設值等。</p><p>這些設定不僅有助於數據驗證，也大大提升了 API 文件的可讀性。以下是一些常見的<code>Field</code>參數：</p><ul><li><code>title</code>：為欄位設定標題，幫助開發者快速理解該欄位的作用。</li><li><code>description</code>：提供欄位描述，讓人更清楚地了解這個欄位的用途與限制。</li><li><code>examples</code>：設定<strong>範例值</strong>，幫助開發者直觀理解 API 的輸入、輸出格式。</li><li><code>default</code>：<strong>第一位置參數</strong>，提供欄位的<strong>預設值</strong>。Input 未提供該欄位值時，將<strong>自動使用預設值</strong>。</li></ul><p>善用這些參數，可以產生高品質的 API 文件。</p><h2 id="程式與文件的平衡點"><a href="#程式與文件的平衡點" class="headerlink" title="程式與文件的平衡點"></a>程式與文件的平衡點</h2><p>不過！我們還是要稍稍向「現實」靠攏，如果每一個 API 都要你寫這麼多內容，可能會讓開發者感到<strong>負擔過重</strong>。</p><p>而且，使用大量參數，文件確實變好看了，但產生文件的程式碼不免會<strong>落落長</strong>！</p><p>我們要找到一個<strong>平衡點</strong>，既能提供足夠資訊，又不會讓程式變得過於冗長。</p><p>從這個角度考慮，我覺得其中<strong>最重要的兩個參數</strong>，是<code>default</code>和<code>examples</code>——尤其是<strong>後者</strong>！</p><p>所以本文會<strong>專注介紹這兩者</strong>，這樣不僅學習上更聚焦，也符合我的開發日常。</p><hr><h2 id="官方文件與原始碼"><a href="#官方文件與原始碼" class="headerlink" title="官方文件與原始碼"></a>官方文件與原始碼</h2><p>如果你想多了解 Pydantic Field 的參數與用法，那就要看 Pydantic 的<a href="https://docs.pydantic.dev/latest/concepts/fields/">官方文件</a>——而不是 Django Ninja。</p><p>Django Ninja 的文件中，並沒有專門的章節介紹<code>Field</code>的使用。這是因為<code>Field</code>實際上是 Pydantic 的功能，而不是 Django Ninja 特有的。</p><p>不過如果你真的去看這份文件，可能會發現，它對<code>Field</code>全部參數的解說，也不算是非常詳盡。</p><p>想要知道<strong>所有可用的參數</strong>，我覺得看<a href="https://github.com/pydantic/pydantic/blob/main/pydantic/fields.py">原始碼</a>是最快的。然後從<strong>函式簽名</strong>（對，<code>Field</code>是一個函式）的 type hints 去揣摩它的用法，也不失為一個好的方式。</p><hr><p>以下，我們開始講述如何使用 Pydantic Field 的<code>examples</code>和<code>default</code>參數，讓 API 文件更加生動且嚴謹。</p><h2 id="為-API-文件加入「範例」"><a href="#為-API-文件加入「範例」" class="headerlink" title="為 API 文件加入「範例」"></a>為 API 文件加入「範例」</h2><p>上一篇我們提到目前 API 文件的<strong>不足</strong>，其中「<strong>缺乏真實範例</strong>」這個問題還未解決：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-22T08:58:55.960Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-22T08:58:55.960Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>無論<code>0</code>或<code>&quot;string&quot;</code>，都稱不上是好的文件範例——它們都<strong>不夠真實</strong>。</p><p>現在，我們要為「取得單一文章資訊」的回應 Schema <strong>加上範例</strong>，程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_AuthorInfo</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> = Field(examples=[<span class="number">1</span>])</span><br><span class="line">    username: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line">    email: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;alice@exapmple.com&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> = Field(examples=[<span class="number">1</span>])</span><br><span class="line">    title: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;Ninja is awesome!&#x27;</span>])</span><br><span class="line">    content: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;This is my first post.&#x27;</span>])</span><br><span class="line">    author: _AuthorInfo</span><br><span class="line">    created_at: datetime = Field(examples=[<span class="string">&#x27;2021-01-01T00:00:00Z&#x27;</span>])</span><br><span class="line">    updated_at: datetime = Field(examples=[<span class="string">&#x27;2021-01-01T00:00:00Z&#x27;</span>])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>這裡有<strong>兩個重點</strong>。</p><h3 id="重點一：examples-參數"><a href="#重點一：examples-參數" class="headerlink" title="重點一：examples 參數"></a>重點一：examples 參數</h3><p>我只有使用<code>examples</code>參數，這樣最簡單，而且<strong>範例</strong>確實是文件中<strong>相當重要的一環</strong>。</p><p>此外，這個<code>examples</code>其實<strong>大有文章</strong>，如果你寫成<code>example</code>，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> = Field(example=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>實際上<strong>也能正常運作</strong>，但 Mypy 卻會提醒你：</p><blockquote><p>Unexpected keyword argument “example” for “Field”; did you mean “examples”?</p></blockquote><p>沒錯，因為現在的 Pydantic v2，<code>Field</code><strong>只有</strong><code>examples</code>這個參數。<code>example</code>應該是 Pydantic v1 的做法，而 Django Ninja 還<strong>保持了對二者的相容</strong>。</p><p>考慮到未來，建議還是使用<code>examples</code>，不僅可以避免 Mypy 的警告，而且與最新版本的 Pydantic 保持一致。</p><h3 id="重點二：巢狀-Schema-的範例"><a href="#重點二：巢狀-Schema-的範例" class="headerlink" title="重點二：巢狀 Schema 的範例"></a>重點二：巢狀 Schema 的範例</h3><p>巢狀 Schema 的範例，只要在<strong>底層</strong> Schema 加上<code>Field</code>即可。引用層不必聲明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_AuthorInfo</span>(<span class="title class_ inherited__">Schema</span>):  <span class="comment"># 這是巢狀底層，要寫 Field</span></span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> = Field(examples=[<span class="number">1</span>])</span><br><span class="line">    username: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line">    email: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;alice@exapmple.com&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    author: _AuthorInfo  <span class="comment"># 無須再寫 Field</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="實際效果"><a href="#實際效果" class="headerlink" title="實際效果"></a>實際效果</h3><p>看一下實際的 API 文件回應，我直接截取頁面中的 JSON 值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ninja is awesome!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is my first post.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@exapmple.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-01-01T00:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-01-01T00:00:00Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>是不是比之前更生動、好讀呢？</p><hr><h2 id="default-參數的正確使用時機"><a href="#default-參數的正確使用時機" class="headerlink" title="default 參數的正確使用時機"></a>default 參數的正確使用時機</h2><p>在我看來，大部分的時候，我們<strong>並不需要</strong>定義預設值。</p><p>我建議你也<strong>不要</strong>這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>雖然文件上一樣也會顯示範例值為 1，但其實這個寫法與下面這個寫法<strong>等價</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> = Field(default=<span class="number">1</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>這實際上是在定義預設值</strong>。如前所述，如果 Schema 用在 HTTP 請求，且客戶端未提供該欄位的值時，Django Ninja 將<strong>自動使用</strong>預設值。</p><p>這很可能會造成<strong>出乎意料</strong>的結果。</p><p>正確的流程是：前端沒有提供值的時候，Django Ninja 應該要給出 422 回應。</p><p>所以你根本不需要（也不應該）定義預設值——<strong>除了下列情況</strong>。</p><h2 id="在可選欄位使用預設值-None"><a href="#在可選欄位使用預設值-None" class="headerlink" title="在可選欄位使用預設值 None"></a>在可選欄位使用預設值 None</h2><p>我個人推薦，只在請求欄位為「<strong>可選（optional）</strong>」時，使用<code>default</code>參數。</p><p>而且此時的預設值<strong>應為</strong><code>None</code>。</p><p>為了示範，我們建立一個<strong>新 API</strong>——「<strong>新增使用者</strong>」（也就是<strong>用戶註冊</strong>）。這個 API 在後續教學中，還會被反覆提及與改進。</p><p>還記得我們的<code>User</code>模型中，<code>bio</code>欄位是可選的嗎？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">AbstractUser</span>):</span><br><span class="line">    email = models.EmailField(unique=<span class="literal">True</span>)  <span class="comment"># 強制唯一的 email</span></span><br><span class="line">    bio = models.TextField(null=<span class="literal">True</span>)  <span class="comment"># 個人簡介欄位（可選）</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>所以，我們的 API 請求 Schema 如下——直接看<code>bio</code>欄位設定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    bio: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        examples=[<span class="string">&#x27;Hello, I am Alice.&#x27;</span>]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>Field 中的<code>default=None</code>設定讓你在客戶端沒有填入值時，API 也不會出錯。</p><p>另外留意<code>bio: str | None</code>這個 type hint，千萬不要少了<code>None</code>，會影響文件的渲染結果：（這是有<code>None</code>的結果）</p><p><img src="https://i.imgur.com/PMIJ05r.png"></p><p>有<code>None</code>，API 文件才會顯示欄位值為<strong>可選（string | null）。</strong></p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>經過本章的學習與改進，我們的 API 文件已經達到 <strong>80 分水準</strong>！在大多數開發專案中，這樣的文件品質可以說相當出色了。</p><p>接下來我們要進入<strong>第五章</strong>——<strong>資料驗證</strong>與<strong>錯誤處理</strong>。</p><p>這個章節將涵蓋如何在 Django Ninja 中實現有效的資料驗證，以及如何優雅地處理和回應各種可能的錯誤情況。</p><p>通過這些技巧，我們將能夠建立更穩健、可靠的 API。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章中，我們探討了 Django Ninja 影響 API 文件&lt;strong&gt;呈現&lt;/strong&gt;的一些重要設定。它們是&lt;strong&gt;自動化 API 文件&lt;/strong&gt;的基本功，不容忽視。&lt;/p&gt;
&lt;p&gt;但這樣&lt;strong&gt;還不夠&lt;/strong&gt;！我們想要讓這份文件更加&lt;strong&gt;生動&lt;/strong&gt;，讀起來清晰易懂。&lt;/p&gt;
&lt;p&gt;其中的關鍵在於 API 文件上的&lt;strong&gt;資料範例&lt;/strong&gt;。好的範例讓人一讀就懂，能有效縮短理解和思考的時間。&lt;/p&gt;
&lt;p&gt;本文將介紹如何運用 Pydantic 的&lt;code&gt;Field&lt;/code&gt;設定，全方位提升 API 文件的清晰與可讀性。我們會探討如何為自動生成的文件加上&lt;strong&gt;栩栩如生的範例&lt;/strong&gt;，讓文件&lt;strong&gt;更貼近真實&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/9&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Pydantic-在-Django-Ninja-中的角色&quot;&gt;&lt;a href=&quot;#Pydantic-在-Django-Ninja-中的角色&quot; class=&quot;headerlink&quot; title=&quot;Pydantic 在 Django Ninja 中的角色&quot;&gt;&lt;/a&gt;Pydantic 在 Django Ninja 中的角色&lt;/h2&gt;&lt;p&gt;Pydantic 是一個實現&lt;strong&gt;資料驗證、序列化&lt;/strong&gt;的套件，廣泛應用於 FastAPI 和 Django Ninja 等框架。&lt;/p&gt;
&lt;p&gt;在 Django Ninja 中，Pydantic 被用來定義 Schema，這些 Schema 決定了 API 如何處理 HTTP 請求和回應中的資料，並自動轉換成&lt;strong&gt;符合 OpenAPI 標準的文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Pydantic 的強大之處在於，它不僅能驗證資料，還可以通過&lt;code&gt;Field&lt;/code&gt;設定，為文件欄位&lt;strong&gt;提供額外的說明、範例和預設值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這些細節設定會&lt;strong&gt;自動反映&lt;/strong&gt;在轉換後的 API 文件中，幫助開發者更好地理解 API 的行為與內涵。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Pydantic" scheme="https://blog.kyomind.tw/tags/Pydantic/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 17：API 文件（上）Django Ninja 文件實踐指南</title>
    <link href="https://blog.kyomind.tw/django-ninja-17/"/>
    <id>https://blog.kyomind.tw/django-ninja-17/</id>
    <published>2024-09-29T06:19:38.000Z</published>
    <updated>2024-10-07T05:52:25.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>「<strong>依程式碼自動產生 API 文件</strong>」是 Django Ninja 的一大賣點。</p><p>事實上，<strong>API 文件的自動化</strong>，正是我在工作上的專案從 Django REST framework 轉向 Django Ninja 的<strong>首要考量</strong>——也是我開始學習 Django Ninja 的契機。</p><p>Django Ninja 省去了大量<strong>人工撰寫</strong>（我們用 <a href="https://apiblueprint.org/">API Blueprint</a>）API 文件的時間，特別是在 API 規格變動時，<strong>不需要再同步修改文件</strong>，大大減少了維護文件的心力。</p><p>可見這個特性有多麼重要。</p><h3 id="教學順序的考量"><a href="#教學順序的考量" class="headerlink" title="教學順序的考量"></a>教學順序的考量</h3><p>那麼，為何我到了系列的第 17 篇文章——也就是本篇，才開始介紹 Django Ninja 的 API 文件功能呢？</p><p>原因在於，要產生優秀的 API 文件，<strong>需要你對 Schema 的使用有一定的了解</strong>。所以我不得不放在第三章之後。</p><p>現在，我們要開始探討如何使用 Django Ninja 產出高品質的 API 文件。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/8">這個 PR</a>。</p><span id="more"></span><hr><h2 id="Documentation-as-Code"><a href="#Documentation-as-Code" class="headerlink" title="Documentation as Code"></a>Documentation as Code</h2><p>現代軟體開發中，「<a href="https://swimm.io/learn/code-documentation/documentation-as-code-why-you-need-it-and-how-to-get-started">Documentation as Code</a>」（DoC） 是一個逐漸被認可的理念。</p><p>DoC 是指<strong>將文件與程式碼緊密結合</strong>，開發人員<strong>使用「與軟體程式碼開發相同的流程和工具」來建立和維護文件</strong>。</p><p>文件<strong>隨著程式碼的變更而自動更新</strong>，兩者<strong>無時無刻都保持著一致性</strong>。</p><p>這不僅提升了開發效率，還減少了<strong>因文件過時而導致的溝通不順暢或誤解</strong>。</p><p>Django Ninja 的自動化產生文件功能無疑是「Documentation as Code」精神的實踐。</p><p>我們可以透過撰寫 API 路由、view 函式、Schema 等<strong>程式碼</strong>，自動產生符合 <a href="https://www.openapis.org/">OpenAPI</a> 標準的文件，當程式碼變更時，這些文件<strong>也會自動反映變更結果</strong>，無需手動維護。</p><h3 id="Django-Ninja-自動化-API-文件的兩大重點"><a href="#Django-Ninja-自動化-API-文件的兩大重點" class="headerlink" title="Django Ninja 自動化 API 文件的兩大重點"></a>Django Ninja 自動化 API 文件的兩大重點</h3><p>在 Django Ninja 中，要產生高品質的 API 文件，主要涉及<strong>兩個重點</strong>：</p><ol><li><strong>Django Ninja 設定</strong>：Django Ninja 內建了好一些控制 API 文件細節的設定，這是本文的重點。</li><li><strong>Pydantic 設定</strong>：這是下一篇要探討的內容，講述如何有效定義 Schema，讓各種細節自動呈現在 API 文件中。</li></ol><p>看到這裡，是不是有點小期待呢？☺️</p><hr><h2 id="專案-API-文件現況"><a href="#專案-API-文件現況" class="headerlink" title="專案 API 文件現況"></a>專案 API 文件現況</h2><p>在開始大刀闊斧地加強文件品質之前，我們先來看看目前 API 文件有多麼「陽春」。</p><p>啟動 Django 伺服器後，造訪下列網址可以查看當前 API 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000/docs</span><br></pre></td></tr></table></figure><p>目前的文件內容如下：</p><p><img src="https://i.imgur.com/jMSkDMj.png"></p><p>我們從「<strong>對開發人員是否有用、好讀</strong>」的角度進行簡要分析。</p><h3 id="問題解析"><a href="#問題解析" class="headerlink" title="問題解析"></a>問題解析</h3><p>首先，它<strong>沒有分組</strong>！</p><p>Django user app 和 post app 的 API 都<strong>混在一起</strong>了，當 API 愈來愈多，就會顯得十分雜亂。這是<strong>最優先要解決</strong>的問題。</p><p>其次，API 的說明如「Get Users」、「Create Post」等，顯然都是從 view 函式名稱自動轉換而來。資訊有限，且不夠口語、不夠詳細，簡單講就是不夠「<strong>讀者友善</strong>」。</p><p>我們點進唯一的 POST API 看一下內容：</p><p><img src="https://i.imgur.com/NCitdKc.png"></p><p>內頁的說明有「新增文章」，這其實是<strong>從 view 函式的 docstring 獲取</strong>的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_post</span>(<span class="params">...</span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增文章</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>再看一下 HTTP 請求 body 的範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;user_id&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能說<strong>不盡理想</strong>，像<code>&quot;string&quot;</code>這樣的例子，只有表現出「型別」，沒有模擬<strong>真實世界</strong>的文章標題或內容。</p><hr><p>上述問題正是我們需要改善 API 文件的重點。</p><p>其中，請求 body 範例與 Schema 設定有關，是下一篇的重心。</p><p>本文先聚焦於 <strong>Django Ninja 設定</strong>——讓我們一一介紹。</p><h2 id="一、使用-Tags-為-API-分組"><a href="#一、使用-Tags-為-API-分組" class="headerlink" title="一、使用 Tags 為 API 分組"></a>一、使用 Tags 為 API 分組</h2><p>我們第一個要解決的是 API 的<strong>分組</strong>（分類）問題。</p><p>為了讓文件結構更清晰，Django Ninja 支援使用 <a href="https://django-ninja.dev/guides/routers/#router-tags">Tags</a> 來對 API 進行分組。不僅有助於組織文件，還能讓開發者或使用者更快地找到所需的 API。</p><p>Tags 分組可以在<strong>兩個地方</strong>進行設定。</p><h3 id="一級路由分組"><a href="#一級路由分組" class="headerlink" title="一級路由分組"></a>一級路由分組</h3><p>最常見的做法，是在<strong>一級路由</strong>進行設定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/арі.py</span></span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;&#x27;</span>, router=<span class="string">&#x27;user.api.router&#x27;</span>, tags=[<span class="string">&#x27;User&#x27;</span>])</span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;&#x27;</span>, router=<span class="string">&#x27;post.api.router&#x27;</span>, tags=[<span class="string">&#x27;Post&#x27;</span>])</span><br></pre></td></tr></table></figure><p>因為同一個 Django app 的 API，通常就是在同一組。</p><h3 id="路由裝飾器分組"><a href="#路由裝飾器分組" class="headerlink" title="路由裝飾器分組"></a>路由裝飾器分組</h3><p>也可以在<strong>路由裝飾器</strong>設定分組，但我認為這屬於相對「<strong>例外</strong>」的情況，主要用於：</p><ol><li>全專案只有一個 Django app。</li><li>同一個 Django app 需要不同的分組。</li></ol><p>比如下面範例中，沒有區分 Django app，但仍有分組需求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;User&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_users</span>(<span class="params">request</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.post(<span class="params"><span class="string">&quot;/posts/&quot;</span>, tags=[<span class="string">&quot;Post&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_post</span>(<span class="params">request, title: <span class="built_in">str</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>大部分情況，我推薦在一級路由進行分組就好。</p><p>不然像上面的例子那樣，一個一個標記，實踐起來有點繁瑣。</p><hr><h2 id="二、路由裝飾器的文件設定"><a href="#二、路由裝飾器的文件設定" class="headerlink" title="二、路由裝飾器的文件設定"></a>二、路由裝飾器的文件設定</h2><p>Django Ninja 的<strong>路由裝飾器</strong>不僅可以設定基本的 API 路徑，還允許你加上 <strong>API 的描述文字</strong>，這些內容會直接反映在生成的 API 文件中。</p><p>透過這些設定，你可以為 API 的參數、回應、甚至意圖加上說明，讓文件更全面。</p><p>透過<code>description</code>和<code>summary</code>參數，能為各 API 路由提供說明。不過<code>description</code>會取代上述「docstring 轉 API 說明」的效果，所以我平常都只寫<code>summary</code>。</p><p><strong>畢竟我們寫 Python，docstring 可是必須的！</strong></p><p>程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">..., summary=<span class="string">&#x27;取得文章列表&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>到目前為止的實際改善效果：（分組、API 說明）</p><p><img src="https://i.imgur.com/WRv4MGd.png"></p><p>非常不錯唷！</p><hr><h2 id="三、NinjaAPI-設定"><a href="#三、NinjaAPI-設定" class="headerlink" title="三、NinjaAPI 設定"></a>三、NinjaAPI 設定</h2><p>你可以通過<code>NinjaAPI</code>類別的<strong>初始化</strong>設定，來客製一些<strong>全域</strong>的 API 文件細節。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/арі.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI(</span><br><span class="line">    title=<span class="string">&quot;忍者論壇 API&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;這是忍者論壇的 API 文件，供讀者參考&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>對應的實際效果：</p><p><img src="https://i.imgur.com/oLgmQkM.png"></p><p><code>NinjaAPI</code>的初始化設定<strong>非常多樣</strong>——有些可能是你需要的。</p><p>這裡只是簡單例示，更多設定細節，可查看<a href="https://django-ninja.dev/reference/api/">文件</a>。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>本文探討了 Django Ninja 自動生成 API 文件的常見設定，讓「Documentation as Code」精神得以實現——程式碼與文件能輕鬆保持一致，減少了手動維護的麻煩。</p><p>然而，API 文件的品質，還取決於我們如何定義 Schema 中的細節。</p><p>接下來，我們將深入探討這個議題，說明如何透過 Pydantic 的<code>Field</code>參數設定，提供<strong>高品質的文件範例</strong>，進一步提升 API 文件的可讀性和清晰度。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;依程式碼自動產生 API 文件&lt;/strong&gt;」是 Django Ninja 的一大賣點。&lt;/p&gt;
&lt;p&gt;事實上，&lt;strong&gt;API 文件的自動化&lt;/strong&gt;，正是我在工作上的專案從 Django REST framework 轉向 Django Ninja 的&lt;strong&gt;首要考量&lt;/strong&gt;——也是我開始學習 Django Ninja 的契機。&lt;/p&gt;
&lt;p&gt;Django Ninja 省去了大量&lt;strong&gt;人工撰寫&lt;/strong&gt;（我們用 &lt;a href=&quot;https://apiblueprint.org/&quot;&gt;API Blueprint&lt;/a&gt;）API 文件的時間，特別是在 API 規格變動時，&lt;strong&gt;不需要再同步修改文件&lt;/strong&gt;，大大減少了維護文件的心力。&lt;/p&gt;
&lt;p&gt;可見這個特性有多麼重要。&lt;/p&gt;
&lt;h3 id=&quot;教學順序的考量&quot;&gt;&lt;a href=&quot;#教學順序的考量&quot; class=&quot;headerlink&quot; title=&quot;教學順序的考量&quot;&gt;&lt;/a&gt;教學順序的考量&lt;/h3&gt;&lt;p&gt;那麼，為何我到了系列的第 17 篇文章——也就是本篇，才開始介紹 Django Ninja 的 API 文件功能呢？&lt;/p&gt;
&lt;p&gt;原因在於，要產生優秀的 API 文件，&lt;strong&gt;需要你對 Schema 的使用有一定的了解&lt;/strong&gt;。所以我不得不放在第三章之後。&lt;/p&gt;
&lt;p&gt;現在，我們要開始探討如何使用 Django Ninja 產出高品質的 API 文件。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/8&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 16：回應（四）Resolver 方法——欄位資料格式化</title>
    <link href="https://blog.kyomind.tw/django-ninja-16/"/>
    <id>https://blog.kyomind.tw/django-ninja-16/</id>
    <published>2024-09-28T03:53:48.000Z</published>
    <updated>2024-10-07T05:52:25.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇提到，API 回應常常是對 Django Model 物件內容的篩選與加工——然後 JSON 序列化。</p><p>其中「<strong>加工</strong>」部分，用更專業的說法，大概是「<strong>資料格式化</strong>」——依照一定的規則，對輸出資料進行<strong>某種轉換或重新組織</strong>，以符合<strong>特定的輸出格式</strong>。</p><p>資料格式化的種類很多，例如：</p><ol><li><strong>時間格式轉換</strong>：將資料庫中的時間戳（timestamp），轉換為更易讀的格式。</li><li><strong>數值轉換</strong>：將數字轉換為貨幣格式，或將小數點位數進行四捨五入。</li><li><strong>字串處理</strong>：截斷過長的文字、加上統一的前綴等。</li></ol><p>不論原因為何，絕大部分時候都是為了資料的「<strong>可讀性</strong>」，或符合特定業務規則。</p><p>可想而知，像資料格式化這樣的需求，不僅實務上重要，在 API 開發中也十分常見，值得我們用一整篇文章，細細探討。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/7">這個 PR</a>。</p><hr><h2 id="場景與需求"><a href="#場景與需求" class="headerlink" title="場景與需求"></a>場景與需求</h2><p>再次回到「取得單一文章資訊」API，這是目前的回傳格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8000/posts/2/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1 content&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我們決定<strong>簡化</strong>回應的時間字串，改採「<code>&quot;2024-09-12T02:28:16Z&quot;</code>」格式。</p><p>和舊版相比，只是少了「<code>.801</code>」這個小數部分而已，且依舊符合 <a href="https://zh.wikipedia.org/zh-tw/ISO_8601">ISO 8601</a> 標準。</p><p>總之，回應中<code>created_at</code>和<code>updated_at</code>兩個欄位的內容，需要進行<strong>格式上的轉換</strong>。即上述提到的「<strong>資料格式化</strong>」。</p><span id="more"></span><hr><h2 id="Django-REST-framework-做法"><a href="#Django-REST-framework-做法" class="headerlink" title="Django REST framework 做法"></a>Django REST framework 做法</h2><p>首先，我們還是不免俗地先介紹 Django REST framework（<strong>以下簡稱 DRF</strong>）的做法，方便你<strong>對比兩者的差異</strong>——你會發現<strong>其實大同小異</strong>。</p><p>在 DRF 中，我們可以透過<code>SerializerMethodField</code>實現時間格式的轉換。以下是透過 DRF 實現的範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">...</span><br><span class="line">    created_at = serializers.SerializerMethodField()</span><br><span class="line">    updated_at = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_created_at</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> obj.created_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_updated_at</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> obj.updated_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中的重點有三：</p><ol><li>要格式化的欄位，值必須是<code>SerializerMethodField</code>。</li><li>在序列化器類別中，定義相同欄位名稱的<strong>實例方法</strong>（有第一位置參數<code>self</code>），且命名時要加上<code>get_</code>前綴，比如<code>get_created_at</code>。</li><li><code>obj</code>參數指的是<strong>當前被序列化的物件</strong>。本例中，我們<strong>預期</strong>引數是一個<code>Post</code>模型實例。這個方法<strong>將在序列化過程中會被自動調用</strong>，將原始的 datetime 物件轉換為指定的字串格式。</li></ol><p>附帶一提，在 DRF 序列化器的各種實例方法中，<code>obj</code>這個參數名稱可以稱得上是一個<strong>命名慣例</strong>。</p><hr><h2 id="Django-Ninja-的欄位資料格式化"><a href="#Django-Ninja-的欄位資料格式化" class="headerlink" title="Django Ninja 的欄位資料格式化"></a>Django Ninja 的欄位資料格式化</h2><p>看完 DRF，我們來看看 Django Ninja 怎麼做。</p><p>透過 Django Ninja 的 <a href="https://django-ninja.dev/guides/response/#resolvers">Resolver</a> 方法，我們也能輕鬆處理這類需求。</p><h3 id="Django-Ninja-的-Resolver-方法"><a href="#Django-Ninja-的-Resolver-方法" class="headerlink" title="Django Ninja 的 Resolver 方法"></a>Django Ninja 的 Resolver 方法</h3><p>在 Django Ninja 中，我們用 <strong>Resolver 方法</strong>來實現同樣的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    created_at: datetime</span><br><span class="line">    updated_at: datetime</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_created_at</span>(<span class="params">obj: Post</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> obj.created_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_updated_at</span>(<span class="params">self, obj: Post</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> obj.updated_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>方法的命名</strong>，相較於 DRF 用的是<code>get_</code>前綴，Django Ninja 則是採<code>resolve_</code>前綴。</p><p>此外，你沒有看錯，這裡使用了<strong>兩種寫法</strong>：</p><ul><li><code>resolve_created_at</code> 是一個「<strong>靜態方法</strong>（static method）」，需要使用<code>@staticmethod</code>裝飾器，且沒有<code>self</code>參數。</li><li><code>resolve_updated_at</code> 是一個典型的<strong>實例方法</strong>，有<code>self</code>參數。</li></ul><p>因為文件的範例中，確實存在這兩種寫法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskSchema</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    owner: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    lower_title: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_owner</span>(<span class="params">obj</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj.owner:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;obj.owner.first_name&#125;</span> <span class="subst">&#123;obj.owner.last_name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_lower_title</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> self.title.lower()</span><br></pre></td></tr></table></figure><h3 id="實例方法版本未實裝"><a href="#實例方法版本未實裝" class="headerlink" title="實例方法版本未實裝"></a>實例方法版本未實裝</h3><p>但是！現階段，你只要知道「靜態方法」版本即可。</p><p>因為採第二種寫法，你將會得到下列<strong>錯誤訊息</strong>：</p><blockquote><p>Error extracting attribute: NotImplementedError: <strong>Non static resolves are not supported yet</strong> [type&#x3D;get_attribute_error, input_value&#x3D;&lt;DjangoGetter: &lt;Post: Ali…’s Django Ninja Post 1&gt;&gt;, input_type&#x3D;DjangoGetter]</p></blockquote><p>什麼？還沒有實作！</p><p>我只好乖乖都改成靜態方法。</p><h3 id="回傳結果"><a href="#回傳結果" class="headerlink" title="回傳結果"></a>回傳結果</h3><p>最後看一下效果如何：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8000/posts/2/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1 content&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>非常好！</p><hr><h2 id="使用-Alias-攤平欄位資訊"><a href="#使用-Alias-攤平欄位資訊" class="headerlink" title="使用 Alias 攤平欄位資訊"></a>使用 Alias 攤平欄位資訊</h2><p>另一個常見的格式化需求，是我們之前提過的「<strong>攤平</strong>」（flatten）複雜資料結構。</p><p>這是一種對資料的「<strong>重組</strong>」，而<strong>結構重組</strong>同樣屬於本文所探討的<strong>資料格式化</strong>範疇。</p><p>還記得在第 14 篇，我們透過<code>@property</code>產生「取得文章列表」回應中<code>author_name</code>欄位內容嗎？——這是對<code>User</code>模型的攤平，直接獲取其<code>username</code>欄位資訊。</p><p>這裡我們換一個<strong>更優雅</strong>的做法——<a href="https://django-ninja.dev/guides/response/#aliases">alias</a>。</p><h3 id="使用-Alias"><a href="#使用-Alias" class="headerlink" title="使用 Alias"></a>使用 Alias</h3><p>Django Ninja（幾乎是從 Pydantic 照搬來的）提供了<code>Field</code>與<code>alias</code>參數來實現這一功能。</p><p>有關<code>Field</code>，在〈卷 18：用 Pydantic Field 設定範例與預設值〉將會有更多著墨。</p><p>我們先來看看如何使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostListResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    created_at: datetime</span><br><span class="line">    author_name: <span class="built_in">str</span> = Field(alias=<span class="string">&#x27;author.username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意，原先<code>Post</code>模型的<code>@property</code>方法要拿掉，或至少<strong>不能</strong>和<code>author_name</code><strong>撞名</strong>，否則會出錯唷！</p><p>我選擇了移除<code>@property</code>方法，直接改用這個新做法。</p><h3 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h3><p>透過<code>alias=author.username</code>取得<code>Post</code>的<strong>關聯模型</strong>——<code>User</code>的<code>username</code>屬性值。實現了<strong>巢狀資料的攤平</strong>。</p><p>這種設計，顯然是向 DRF 的<strong>優秀借鑑</strong>，相當於 DRF 中的 <code>source=author.username</code>寫法。</p><p>雖然<strong>有點抽象</strong>，卻非常優雅。</p><p><code>alias</code>的用途不限於資料攤平（這反而是比較進階的用法），其它細節，如欄位名稱替換等，可直接參考 <a href="https://docs.pydantic.dev/latest/concepts/alias/">Pydantic 文件</a>。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Django Ninja 的 Resolver 方法允許我們對 API 回應中的欄位資料進行<strong>動態處理</strong>，滿足各種格式轉換與自定義需求。</p><p>在處理像<code>created_at</code>和<code>updated_at</code>這樣的時間欄位時，Resolver 方法不僅簡單易用，還能保證程式碼的結構清晰。</p><p><code>Field</code>與<code>alias</code>參數則更優雅地實現了另一種常見的資料格式化——「攤平」。不僅簡化了 API 回應，且無需修改背後的 Django 模型。</p><p>透過這些方式，我們能更靈活地控制 API 的輸出，以符合客戶端需求。</p><h2 id="下一章預告"><a href="#下一章預告" class="headerlink" title="下一章預告"></a>下一章預告</h2><p>完成了對「<strong>Django Ninja 處理 HTTP 回應</strong>」共 4 篇的學習，第三章也正式告一段落。接下來，我們要將目光轉向 API 開發中的<strong>另一個重要主題——文件</strong>！</p><p>隨著專案規模的增長，<strong>清晰的 API 文件</strong>對於任何需要使用 API 的人員都<strong>至關重要</strong>——包括後端開發者<strong>自己</strong>！</p><p>一份好的 API 文件能夠<strong>大幅降低溝通成本，提高開發效率、減少錯誤</strong>。它不僅是一種技術文書，更是<strong>團隊協作的重要樞紐</strong>。</p><p>第四章，我們會探討如何有效地透過 Django Ninja 程式碼，產生高品質的 API 文件，從而提升整體的開發體驗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇提到，API 回應常常是對 Django Model 物件內容的篩選與加工——然後 JSON 序列化。&lt;/p&gt;
&lt;p&gt;其中「&lt;strong&gt;加工&lt;/strong&gt;」部分，用更專業的說法，大概是「&lt;strong&gt;資料格式化&lt;/strong&gt;」——依照一定的規則，對輸出資料進行&lt;strong&gt;某種轉換或重新組織&lt;/strong&gt;，以符合&lt;strong&gt;特定的輸出格式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;資料格式化的種類很多，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;時間格式轉換&lt;/strong&gt;：將資料庫中的時間戳（timestamp），轉換為更易讀的格式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;數值轉換&lt;/strong&gt;：將數字轉換為貨幣格式，或將小數點位數進行四捨五入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字串處理&lt;/strong&gt;：截斷過長的文字、加上統一的前綴等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不論原因為何，絕大部分時候都是為了資料的「&lt;strong&gt;可讀性&lt;/strong&gt;」，或符合特定業務規則。&lt;/p&gt;
&lt;p&gt;可想而知，像資料格式化這樣的需求，不僅實務上重要，在 API 開發中也十分常見，值得我們用一整篇文章，細細探討。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/7&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;場景與需求&quot;&gt;&lt;a href=&quot;#場景與需求&quot; class=&quot;headerlink&quot; title=&quot;場景與需求&quot;&gt;&lt;/a&gt;場景與需求&lt;/h2&gt;&lt;p&gt;再次回到「取得單一文章資訊」API，這是目前的回傳格式：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// http://127.0.0.1:8000/posts/2/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Alice&amp;#x27;s Django Ninja Post 1&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Alice&amp;#x27;s Django Ninja Post 1 content&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;punctuation&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Alice&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&amp;quot;email&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;alice@example.com&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;created_at&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;2024-09-12T02:28:16.801Z&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;updated_at&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;2024-09-12T02:28:16.801Z&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我們決定&lt;strong&gt;簡化&lt;/strong&gt;回應的時間字串，改採「&lt;code&gt;&amp;quot;2024-09-12T02:28:16Z&amp;quot;&lt;/code&gt;」格式。&lt;/p&gt;
&lt;p&gt;和舊版相比，只是少了「&lt;code&gt;.801&lt;/code&gt;」這個小數部分而已，且依舊符合 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; 標準。&lt;/p&gt;
&lt;p&gt;總之，回應中&lt;code&gt;created_at&lt;/code&gt;和&lt;code&gt;updated_at&lt;/code&gt;兩個欄位的內容，需要進行&lt;strong&gt;格式上的轉換&lt;/strong&gt;。即上述提到的「&lt;strong&gt;資料格式化&lt;/strong&gt;」。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
</feed>
