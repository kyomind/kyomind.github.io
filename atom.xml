<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/favicon-32x32.png</icon>
  <subtitle>Kyo 的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-12-24T07:04:15.339Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的 LeetCode 筆記：記錄刷題的簡單做法</title>
    <link href="https://blog.kyomind.tw/leetcode-notes-method/"/>
    <id>https://blog.kyomind.tw/leetcode-notes-method/</id>
    <published>2024-12-24T06:19:26.000Z</published>
    <updated>2024-12-24T07:04:15.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/g9WO9S7.jpeg"></p><p>系列的前兩篇中，我們首先介紹了準備工作、學習資源和基本的刷題原則，這些內容<strong>特別適合初學者或希望減少刷題壓力的讀者</strong>。畢竟我也不喜歡刷題😂</p><p>接著，在第二篇裡，我們討論了如何使用 AI 工具（我設計的 <a href="https://chatgpt.com/g/g-6731960a3a2081909fe1975e05c034c4-li-li-kou-kou">GPTs</a>）來提高刷題效率（或說提高「意願」），以及使用 AI 輔助刷題時的一些重點與注意事項。</p><p>如果你還沒看過前兩篇，建議可以先看看，會對整個學習脈絡有更清楚的理解。</p><h3 id="系列：我的-LeetCode-刷題之道"><a href="#系列：我的-LeetCode-刷題之道" class="headerlink" title="系列：我的 LeetCode 刷題之道"></a>系列：我的 LeetCode 刷題之道</h3><ul><li><a href="https://blog.kyomind.tw/series/#%E6%88%91%E7%9A%84-LeetCode-%E5%88%B7%E9%A1%8C%E4%B9%8B%E9%81%93">文章清單（連載中）</a></li></ul><p>本文將聚焦於刷題過程中的<strong>筆記</strong>環節，採取簡單、實用的筆記方式，讓你的學習過程更有條理，並在複習時更加輕鬆。</p><p>話不多說，讓我們開始。</p><span id="more"></span><hr><h2 id="為什麼做筆記？"><a href="#為什麼做筆記？" class="headerlink" title="為什麼做筆記？"></a>為什麼做筆記？</h2><p>學習是否一定要做筆記？不同的人有不同看法。我也遇過很厲害但不太做筆記的人。</p><p><a href="https://www.facebook.com/will.fans/">保哥</a>在其臉書發文中提過：</p><p><img src="https://i.imgur.com/lvzlAud.png"></p><p>這段內容<strong>讓我最有感觸</strong>的是「<strong>只有不到 1% 會重看一次</strong>」，你也有類似經驗嗎？</p><p>我學習時幾乎都會做筆記。不過，不得不承認，「做了卻沒複習」這件事也很常發生。</p><p>而且我覺得，筆記如果沒有被複習，<strong>那其實和沒做差不多</strong>——都是船過水無痕。</p><p>所以，筆記建議不要寫太多、太長，組織上也不要太複雜，夠用就好。</p><blockquote><p>延伸閱讀：<a href="/less-is-more/">為什麼你「不需要」所謂的人生管理系統</a></p></blockquote><p>我的 LeetCode 筆記法相對簡單，沒有使用任何專門的筆記軟體，只是將程式碼和筆記緊密結合在一起，放在 Git repo（repository）中。</p><p>接下來，我將分享具體的做法、思路與注意事項。</p><hr><h2 id="Git-Repo-介紹"><a href="#Git-Repo-介紹" class="headerlink" title="Git Repo 介紹"></a>Git Repo 介紹</h2><p>把刷題筆記放在一個 repo 中，是「簡單筆記」的第一步——可能是最重要的一步。</p><p>我將所有寫過的 LeetCode 題目與筆記放在一個 Git repo 裡，並同步到 GitHub，名為「<a href="https://github.com/kyomind/Grind-75">Grind-75</a>」。</p><p>這個名稱顯然是「致敬」第一篇提到的刷題清單「<a href="https://www.techinterviewhandbook.org/grind75/">Grind 75</a>」，同時也是期許自己刷個 75 題就好。</p><p>Repo 的結構非常簡單，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── pyproject.toml</span><br><span class="line">└── solutions</span><br><span class="line">    ├── 1. Two Sum.md</span><br><span class="line">    ├── 1. Two Sum.py</span><br><span class="line">    ├── 102. Binary Tree Level Order Traversal.md</span><br><span class="line">    ├── 102. Binary Tree Level Order Traversal.py</span><br><span class="line">    ├── ...(中略)</span><br><span class="line">    ├── 973. K Closest Points to Origin.md</span><br><span class="line">    ├── 973. K Closest Points to Origin.py</span><br><span class="line">    └── 98. Validate Binary Search Tree.py</span><br></pre></td></tr></table></figure><p>每道題目都會有一個同名的 Python 檔案。（我用 Python 刷題）</p><p>此外，複習時會再建立一個同名的 Markdown 筆記，補充更多內容。兩者的搭配構成了我的筆記總合。</p><p>這樣的組織方式有幾個好處：</p><ol><li><strong>檔名與題目名稱一致</strong>：能快速定位到需要查看的題目。</li><li><strong>版本管理（版控）</strong>：版控的重要性在開發時自不待言，寫筆記倒是還好。主要的好處應該是：要刪內容時可以「大方」一點，反正有 Git！</li><li><strong>相互對照</strong>：放在同一個地方，筆記和程式碼方便快速對照。</li></ol><p>Git repo 也方便上傳到 GitHub 分享、供他人參考。雖然除了自己應該沒人會想看🤣，但至少是個足跡！</p><hr><h2 id="筆記方法與流程"><a href="#筆記方法與流程" class="headerlink" title="筆記方法與流程"></a>筆記方法與流程</h2><p>刷題時，我分兩個階段建立筆記。</p><p>這些做法目前都還在<strong>實驗階段</strong>，可作為參考。</p><p>如果後續有更新或不同想法，我會再回來修正、補充。</p><h2 id="第一次刷題：記錄在-Python-檔中"><a href="#第一次刷題：記錄在-Python-檔中" class="headerlink" title="第一次刷題：記錄在 Python 檔中"></a>第一次刷題：記錄在 Python 檔中</h2><p>在第一次刷題時，我的重心在於「理解」。此時大部分時候都不是我獨立完成答案，而是與 AI 協作。</p><p>在這階段，我會將筆記以「程式碼註解」形式寫在 Python 檔裡，格式有兩種：</p><ol><li><strong>使用「單行註解」記錄重點</strong>：說明解題意圖、做法，或需要特別注意的細節。</li><li><strong>使用「多行字串」記錄長筆記</strong>：例如思路分析或 AI 提供的重要觀念。</li></ol><p>範例如下，來自「<a href="https://github.com/kyomind/Grind-75/blob/main/solutions/102.%20Binary%20Tree%20Level%20Order%20Traversal.py">102. Binary Tree Level Order Traversal.py</a>」：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 BFS 進行層序遍歷 + queue</span></span><br><span class="line"><span class="comment"># 這過程和爬蟲一個網站非常像</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root</span>):</span><br><span class="line">        levels = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> levels</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化佇列，將根節點加入佇列</span></span><br><span class="line">        <span class="comment"># XXX 這裡使用 list 來模擬 queue，在移除第一個元素時，效率較低</span></span><br><span class="line">        <span class="comment"># 可以使用 collections.deque 來實現，移除時則使用 popleft() 方法</span></span><br><span class="line">        <span class="comment"># queue = deque([root])</span></span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 開始 BFS</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>我會適時使用「<code>XXX</code>」這類 Code Tags 來標註特別重要的部分。如上述第 10 行。</p><h2 id="第一次複習：建立-Markdown-筆記"><a href="#第一次複習：建立-Markdown-筆記" class="headerlink" title="第一次複習：建立 Markdown 筆記"></a>第一次複習：建立 Markdown 筆記</h2><p>當我第二次接觸這道題目（第一次複習）時，會再新增一個 Markdown 檔案，<strong>進一步補充</strong>筆記內容。</p><p>這些 Markdown 筆記通常包括：</p><ul><li>和 AI 的<strong>關鍵環節問答</strong>。</li><li>具體的<strong>易錯點</strong>分析。</li><li>自己對解題的<strong>額外補充或心得</strong>。</li></ul><p>範例如下，取自「<a href="https://github.com/kyomind/Grind-75/blob/main/solutions/567.%20Permutation%20in%20String.md">567. Permutation in String.md</a>」：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2024-12-13</span></span><br><span class="line"><span class="section">## 我反對使用 range() 來滑動視窗</span></span><br><span class="line">在LeetCode官方的題目tag中，給的是「Hash Table Two Pointers String Sliding Window」</span><br><span class="line">如果用range，其實就沒有突顯Two Pointers的實作，要用while才有</span><br><span class="line">我覺得range方法雖然「簡潔」，但理解負擔也很大——更加抽象，而且更加「不通用」(無法離開Python)</span><br><span class="line"></span><br><span class="line"><span class="section">##  ChatGPT</span></span><br><span class="line">你說得非常有道理！在 <span class="strong">**LeetCode 官方標籤**</span> 中，明確提到 <span class="strong">**Two Pointers**</span>，但如果我們使用 <span class="code">`range`</span> 搭配索引來寫，雖然程式碼簡潔，但這種寫法：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> <span class="strong">**沒有突顯 Two Pointers**</span> 的概念：雙指標本質上是維護兩個獨立的索引來滑動視窗，而非透過單個索引來完成。</span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**抽象度較高**</span>：對於初學者來說，<span class="code">`range(len(s1), len(s2))`</span> 的邏輯並不直觀，理解它為什麼能模擬視窗移動較為困難。</span><br><span class="line"><span class="bullet">3.</span> <span class="strong">**不通用**</span>：這種寫法過於依賴 Python 語言特性，無法直接轉換到其他語言（如 C++、Java）。</span><br><span class="line"></span><br><span class="line">...(下略)</span><br></pre></td></tr></table></figure><p>Markdown 的內容通常會比較長，而且會標註日期——即複習日。</p><p>這份 Markdown，就是傳統意義上的筆記，和程式碼放在一起。</p><hr><h2 id="筆記的價值與兩難"><a href="#筆記的價值與兩難" class="headerlink" title="筆記的價值與兩難"></a>筆記的價值與兩難</h2><p>話說回來，這些筆記，我日後真的都會回去看嗎？</p><p>就像前面引用保哥的那段話，說真的，我自己也不敢肯定。</p><p>但可以確定的是，當我要複習時，這些筆記能讓我<strong>快速回復記憶、重新建立大腦的答題情境</strong>。</p><p>考慮到「<strong>筆記愈長，複習意願愈低</strong>」的人性，我們應盡可能只記錄關鍵部分，避免未來回顧時需要費力過濾內容。</p><p>隨著刷題的進展與對一些概念的熟悉，不需要的筆記也要<strong>狠心將其刪除</strong>。</p><p>這正是為何要在 Git repo 中寫筆記——你可以大膽刪內容！</p><hr><h2 id="心得與注意事項"><a href="#心得與注意事項" class="headerlink" title="心得與注意事項"></a>心得與注意事項</h2><p>以下幾個常見問題，是我在過程中反覆思考過的部分。</p><h3 id="為什麼不使用筆記軟體？"><a href="#為什麼不使用筆記軟體？" class="headerlink" title="為什麼不使用筆記軟體？"></a>為什麼不使用筆記軟體？</h3><p>雖然我是筆記與筆記軟體的重度用戶，但我認為在刷題情境下，筆記最好直接和程式碼緊密結合即可。</p><p>如果把筆記放在 Notion、Logseq 等工具中，<strong>程式碼、筆記間的對照會變得麻煩，直接影響複習意願。</strong></p><h3 id="為什麼要分成兩種筆記？"><a href="#為什麼要分成兩種筆記？" class="headerlink" title="為什麼要分成兩種筆記？"></a>為什麼要分成兩種筆記？</h3><p>因為程式碼註解主要用於記錄細節和立即的想法，而 Markdown 則整理較完整的思路與學習心得。</p><p>兩者各有擅長與不擅長之處：</p><table><thead><tr><th></th><th>程式碼註解</th><th>Markdown 筆記</th></tr></thead><tbody><tr><td>優點一</td><td>適合記錄即時的技術細節</td><td>適合整理較完整的思路和心得</td></tr><tr><td>優點二</td><td>位置顯眼，易得性高，直接與程式碼結合</td><td>方便編輯與完整的格式</td></tr><tr><td>缺點一</td><td>不適合稍長或需要換行的內容</td><td>必須和程式碼兩兩對照</td></tr><tr><td>缺點二</td><td>太多註解會影響程式碼閱讀</td><td>容易長篇大論、失焦</td></tr></tbody></table><p>這種分工讓筆記更有條理，也更容易維護。</p><h3 id="還能更簡單嗎？"><a href="#還能更簡單嗎？" class="headerlink" title="還能更簡單嗎？"></a>還能更簡單嗎？</h3><blockquote><p>Markdown 筆記能不能併入程式碼？比如用多行註解取代。</p></blockquote><p>可以是可以，但我認為<strong>分開的好處大於合併</strong>。</p><p>首先，程式碼應盡量保持簡潔，過多的註解會影響閱讀；其次，Markdown 更適合整理筆記，哪怕只是排版上的「<strong>換行</strong>」，也比註解方便許多。</p><p>此外，分開管理也讓我們能更靈活地調整和刪減筆記。</p><h3 id="如何確保筆記品質？"><a href="#如何確保筆記品質？" class="headerlink" title="如何確保筆記品質？"></a>如何確保筆記品質？</h3><p>做筆記時很容易想要追求完整、多多益善，這是<strong>筆記愛好者的通病</strong>，我也不例外😷</p><p>有一個簡單暴力但有效的方法：<strong>限制 Markdown 筆記的行數上限！</strong></p><p>我目前的想法是：</p><ol><li>Easy：上限 100行。</li><li>Medium：上限 200 行。</li><li>Hard：上限 300 行。（實際上我沒有打算寫 Hard 題😅）</li></ol><p>超過上限就要刪減內容！（這裡留有一個餘地：你可以一行寫長一點XD）</p><p>這些數字是否適合，要實驗一段時間後才知道。但可以確信的是：<strong>有上限絕對比沒上限好得多</strong>。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>本文分享了我在刷題時的筆記方法。這套方法雖然簡單，卻能幫助我們梳理學習思路，同時避免筆記變得過於冗長。</p><p>本系列一直將刷題視為一種<strong>學習方式</strong>，而不僅是通過面試的手段。</p><p>至於怎麼樣的方式適合自己，需要一定的嘗試與調整。這也是我寫這個系列的初衷——希望能讓刷題變得有趣、有多元價值。</p><p>但願我們都能在這個過程中，找到一點屬於自己的成就感。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>系列的下一篇，我會分享我如何複習這些筆記——畢竟筆記就是拿來複習的。</p><p>這部分都還在持續實踐與構思中，敬請期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/g9WO9S7.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;系列的前兩篇中，我們首先介紹了準備工作、學習資源和基本的刷題原則，這些內容&lt;strong&gt;特別適合初學者或希望減少刷題壓力的讀者&lt;/strong&gt;。畢竟我也不喜歡刷題😂&lt;/p&gt;
&lt;p&gt;接著，在第二篇裡，我們討論了如何使用 AI 工具（我設計的 &lt;a href=&quot;https://chatgpt.com/g/g-6731960a3a2081909fe1975e05c034c4-li-li-kou-kou&quot;&gt;GPTs&lt;/a&gt;）來提高刷題效率（或說提高「意願」），以及使用 AI 輔助刷題時的一些重點與注意事項。&lt;/p&gt;
&lt;p&gt;如果你還沒看過前兩篇，建議可以先看看，會對整個學習脈絡有更清楚的理解。&lt;/p&gt;
&lt;h3 id=&quot;系列：我的-LeetCode-刷題之道&quot;&gt;&lt;a href=&quot;#系列：我的-LeetCode-刷題之道&quot; class=&quot;headerlink&quot; title=&quot;系列：我的 LeetCode 刷題之道&quot;&gt;&lt;/a&gt;系列：我的 LeetCode 刷題之道&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/series/#%E6%88%91%E7%9A%84-LeetCode-%E5%88%B7%E9%A1%8C%E4%B9%8B%E9%81%93&quot;&gt;文章清單（連載中）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文將聚焦於刷題過程中的&lt;strong&gt;筆記&lt;/strong&gt;環節，採取簡單、實用的筆記方式，讓你的學習過程更有條理，並在複習時更加輕鬆。&lt;/p&gt;
&lt;p&gt;話不多說，讓我們開始。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/g9WO9S7.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="LeetCode" scheme="https://blog.kyomind.tw/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>《給網站工程師的網路課》心得：Web 開發者的網路學習指南</title>
    <link href="https://blog.kyomind.tw/network-101-course/"/>
    <id>https://blog.kyomind.tw/network-101-course/</id>
    <published>2024-12-21T02:30:00.000Z</published>
    <updated>2024-12-21T02:49:26.678Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sl3ouFQ.jpeg"></p><p>上星期日，我參加了<a href="https://azole.medium.com/">小賴</a>的《給網站工程師的網路課》，獲益良多，有必要寫一篇文章分享。</p><p>但<strong>本文並不是上課筆記</strong>，而是想談談我作為一個轉職軟體工程師，學習網路知識的<strong>不同階段歷程</strong>，以及這堂課<strong>如何彌補了過去的不足</strong>。</p><p>如果你對這堂課感興趣，但不知道自己適不適合，推薦參考下面兩篇文章：</p><ul><li><a href="https://azole.medium.com/%E7%B5%A6%E7%B6%B2%E7%AB%99%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E7%B6%B2%E8%B7%AF%E8%AA%B2-21157b1d47d1">給網站工程師的網路課</a>：講者小賴對課程內容的專文介紹。</li><li><a href="https://anna-su.com/tech/internet-course-for-web-developers">給網站工程師的網路課 - 上課心得筆記</a>：實際參與學員的上課心得與筆記。</li></ul><p>看完之後，能一定程度了解這堂課的內容、定位與輪廓。</p><p>這是一堂實體課，時長為一個下午（約 4 小時），但資訊量明顯超過 4 小時能講完的內容，可說是非常充實。</p><p>如果你也是 Web 開發者，卻仍對網路感到一知半解，相信本文能帶給你一些方向。</p><span id="more"></span><hr><p>讓我們直接開始吧！</p><h2 id="Web-開發者需要了解網路嗎？"><a href="#Web-開發者需要了解網路嗎？" class="headerlink" title="Web 開發者需要了解網路嗎？"></a>Web 開發者需要了解網路嗎？</h2><p>答案自然是「Yes」——不然我就不會寫這篇文章了😂，但也<strong>沒那麼簡單</strong>。</p><p>無論前端、後端，還是全端工程師，我們的主要工作都圍繞著 Web 展開，且大部分的產出都必須透過 HTTP 來運作。</p><p>而 HTTP 建立在 TCP&#x2F;IP 協議之上，因此網路知識的重要性不言而喻。</p><p>但我們也得承認，對大多數 Web 開發者而言，<strong>網路往往不是工作中的主角。</strong></p><p>日常的功能開發，往往是以「<strong>框架</strong>」為主角，無論是前端的 Vue、React，或是我熟悉的 Django。網路常常是作為「<strong>配角</strong>」，在背後默默運作。</p><h3 id="重要的「配角」"><a href="#重要的「配角」" class="headerlink" title="重要的「配角」"></a>重要的「配角」</h3><p>但有些時候，網路問題「確實」會直接影響到你的開發效率，甚至讓你感到<strong>無力</strong>。</p><p>舉個例子，網站部署後出現發現<strong>網頁載入緩慢</strong>，這究竟是前端請求問題、伺服器端設定問題，還是網路出了問題？</p><p>又或者，你的 API 平時運作良好，但<strong>偶爾會出現 Timeout</strong>，究竟<strong>該從哪裡開始排查</strong>？</p><p>這類問題雖與功能無關，但<strong>直接影響了功能的實現</strong>，不得不處理。在缺乏基礎網路知識的情況下，往往只能靠「<strong>試誤、碰運氣</strong>」來排查問題，甚至可能因此卡關好幾天。</p><p>所以，網路雖然不屬於核心技能範疇，但同時也是避不開、需要好好了解的一部分。</p><hr><h2 id="我的網路學習三階段"><a href="#我的網路學習三階段" class="headerlink" title="我的網路學習三階段"></a>我的網路學習三階段</h2><p>說是這麼說，我對網路的學習也稱不上多認真啦🤣</p><p>在介紹這三個階段之前，還是不免俗地強調：每個人的學習路徑不盡相同，以下僅是我個人的經驗。</p><h2 id="第一階段：從-HTTP-開始"><a href="#第一階段：從-HTTP-開始" class="headerlink" title="第一階段：從 HTTP 開始"></a>第一階段：從 HTTP 開始</h2><p>幾年前，我曾在<a href="https://time.geekbang.org/">極客時間</a>購買了一堂課，叫《<a href="https://time.geekbang.org/column/intro/100029001">透視 HTTP 協議</a>》。（有興趣的話，也可透過我的<a href="https://time.geekbang.org/column/intro/100029001?code=q-hHhk4l1RmUbh/YwVDnxx78GI0QO2uJ7UJ1JqX2S8Q=">分享連結</a>購買，我會得到一點點佣金，感謝支持！）</p><p>這堂課對我了解 HTTP 知識有很大的幫助，像是請求方法、body、狀態碼、header 的作用等。深入淺出，學起來很踏實。</p><p>雖然這些知識在網路上可能都找得到，但這堂課幫你整理得更有體系，我不必自己尋尋覓覓，就能循序漸進地掌握 HTTP 中各個重要概念。</p><p>總之，我覺得這是前期對我很有幫助的教材。但它對於 HTTP 以外的內容（TCP&#x2F;IP、DNS），則著墨較少，所以只適合作為一個開端。</p><hr><h2 id="第二階段：用-ChatGPT-補一補"><a href="#第二階段：用-ChatGPT-補一補" class="headerlink" title="第二階段：用 ChatGPT 補一補"></a>第二階段：用 ChatGPT 補一補</h2><p>隨著 ChatGPT 等 AI 工具的出現，基礎知識的學習變得更方便了！</p><p>你或許聽過 <a href="https://github.com/JushBJJ/Mr.-Ranedeer-AI-Tutor">Mr. Ranedeer</a> 這個設計精巧的 <a href="https://chatgpt.com/g/g-9PKhaweyb-mr-ranedeer">GPTs</a>，號稱可以讓你自學任何主題。</p><p>雖然不一定有那麼神（而且很多知識也不是以文字呈現的），但拿來學一些<strong>軟體開發的通用知識</strong>確實挺不錯。</p><p>比如給它這樣的提示詞（prompt）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/plan 關於「從瀏覽器輸入網址到取得回應，中間發生了什麼事？」這個主題的開發者必知知識</span><br></pre></td></tr></table></figure><p>它會列出下列的學習清單（回答我有多次調整過，但格式不變，截圖僅為部分）：</p><p><img src="https://i.imgur.com/IsbOjTW.png" alt="Mr. Ranedeer"><span class="cap">Mr. Ranedeer</span></p><p>這種學習方式有幾個好處：</p><ol><li>可以<strong>快速獲得該主題的輪廓與流程。</strong></li><li>可以針對不懂的細節<strong>反覆詢問</strong>，逐步加深理解。就像我的「<a href="https://blog.kyomind.tw/gpts-for-leetcode/#%E4%B8%80%E3%80%81%E3%80%8C%E5%93%A9%E5%93%A9%E6%89%A3%E6%89%A3%E3%80%8DGPTs-%E4%BB%8B%E7%B4%B9">哩哩扣扣</a>」一樣。</li></ol><h3 id="靠-AI-自學的缺點"><a href="#靠-AI-自學的缺點" class="headerlink" title="靠 AI 自學的缺點"></a>靠 AI 自學的缺點</h3><p><strong>但缺點也很明顯：AI 不知道你「不知道什麼」。</strong></p><p>網路知識龐雜，初學者不易分辨哪些概念屬於基礎，哪些則是進階——其實自己看書也有類似困境，所以我幾乎不太想直接去啃那些大部頭的網路書籍。</p><p>更困難的是，作為初學者，我們往往不知道哪些知識<strong>對現階段的自己最重要！</strong>（這情況在學習新技術時經常發生）</p><p>AI 確實能提供答案，但它不一定知道你的<strong>學習困境</strong>所在（而我們自己也不清楚），更無法取代經驗豐富老師的引導。</p><p>總之，AI 在原來的基礎上，幫我補足了第一階段課程中的缺憾，但仍缺少一個完整的框架與指引。只能算是聊勝於無。</p><hr><h2 id="第三階段：上小賴的《給網站工程師的網路課》"><a href="#第三階段：上小賴的《給網站工程師的網路課》" class="headerlink" title="第三階段：上小賴的《給網站工程師的網路課》"></a>第三階段：上小賴的《給網站工程師的網路課》</h2><p>這次參加小賴的課程，讓我真正體會到什麼叫做「<strong>把零散的知識串聯起來</strong>」。</p><p>就像<a href="https://www.threads.net/@kyomind.tw/post/DDqc75PSu_2">我在 Threads 上說的</a>：「這是<strong>知識與快樂的螺旋</strong>！」</p><p>之前的學習，我本以為已經算是「相對有體系」了，但上完這堂課後，才知道自己還是太天真了😅——這很正常啦！畢竟網路世界博大精深。</p><h3 id="課程亮點"><a href="#課程亮點" class="headerlink" title="課程亮點"></a>課程亮點</h3><p>這堂課從「輸入網址、按完 Enter」後的 DNS 查詢開始，一路講到 TCP、IP 協議，並串聯起路徑上的各個環節。</p><p>用淺顯易懂的方式解釋網路運作，並輔以具體的例子、圖片；操作 <a href="https://www.wireshark.org/">Wireshark</a> 讓我對網路封包有了更多視覺上的理解。（比如看到 TCP 中的 port number 值）</p><p>光 DNS 部分，就讓我有一種打通任督二脈的感覺——雖然有學過，但發現自己的了解仍稍嫌片面。</p><p>和單純的記憶知識相比，我想其中的關鍵差別在於「<strong>經驗</strong>」。這堂課有很多小賴的實戰經驗，<strong>它們讓知識變得更加真實、栩栩如生。</strong></p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>總的來說，這是一堂讓我獲益良多的課程。</p><p>我之前所學的 HTTP 與 AI 提供的網路知識，相較之下仍像是散落的拼圖，而這次課程把這些拼圖組合起來，讓我看到<strong>一幅更清晰的全景</strong>。</p><p>這堂課是針對 <strong>Web 開發者</strong>設計，難度拿捏得宜，不會過於深奧，也不流於表面，適合想補足網路知識的工程師。</p><p>如果你是 Web 開發者，正在摸索網路相關的學習路徑，這堂課也許就是你的下一站。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sl3ouFQ.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上星期日，我參加了&lt;a href=&quot;https://azole.medium.com/&quot;&gt;小賴&lt;/a&gt;的《給網站工程師的網路課》，獲益良多，有必要寫一篇文章分享。&lt;/p&gt;
&lt;p&gt;但&lt;strong&gt;本文並不是上課筆記&lt;/strong&gt;，而是想談談我作為一個轉職軟體工程師，學習網路知識的&lt;strong&gt;不同階段歷程&lt;/strong&gt;，以及這堂課&lt;strong&gt;如何彌補了過去的不足&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你對這堂課感興趣，但不知道自己適不適合，推薦參考下面兩篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://azole.medium.com/%E7%B5%A6%E7%B6%B2%E7%AB%99%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E7%B6%B2%E8%B7%AF%E8%AA%B2-21157b1d47d1&quot;&gt;給網站工程師的網路課&lt;/a&gt;：講者小賴對課程內容的專文介紹。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://anna-su.com/tech/internet-course-for-web-developers&quot;&gt;給網站工程師的網路課 - 上課心得筆記&lt;/a&gt;：實際參與學員的上課心得與筆記。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看完之後，能一定程度了解這堂課的內容、定位與輪廓。&lt;/p&gt;
&lt;p&gt;這是一堂實體課，時長為一個下午（約 4 小時），但資訊量明顯超過 4 小時能講完的內容，可說是非常充實。&lt;/p&gt;
&lt;p&gt;如果你也是 Web 開發者，卻仍對網路感到一知半解，相信本文能帶給你一些方向。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/sl3ouFQ.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="HTTP" scheme="https://blog.kyomind.tw/tags/HTTP/"/>
    
    <category term="課程心得" scheme="https://blog.kyomind.tw/tags/%E8%AA%B2%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>GPTs 介紹：AI 刷題助手與使用方式</title>
    <link href="https://blog.kyomind.tw/gpts-for-leetcode/"/>
    <id>https://blog.kyomind.tw/gpts-for-leetcode/</id>
    <published>2024-11-30T15:06:21.000Z</published>
    <updated>2024-12-18T07:02:16.897Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/g9WO9S7.jpeg"></p><blockquote><p>本來只打算寫兩篇，現在變成 4 篇了，大綱可參考「<a href="/grind-leetcode-with-ai-preparation/#%E7%B3%BB%E5%88%97%E6%A6%82%E8%BF%B0%E8%88%87%E5%B0%8E%E8%AE%80">系列概述與導讀</a>」。</p></blockquote><p>上一篇，我們介紹了 LeetCode 刷題的準備與基本原則，本篇則要介紹我刷題時搭配的 AI 工具——自定義的 <a href="https://openai.com/index/introducing-gpts/">GPTs</a>。</p><p>不過有一點需要提醒：你得先訂閱 <a href="https://openai.com/index/chatgpt-plus/">ChatGPT Plus</a>，才能直接使用他人建立的 GPTs。</p><p>話不多說，直接開始正文。</p><h3 id="系列：我的-LeetCode-刷題之道"><a href="#系列：我的-LeetCode-刷題之道" class="headerlink" title="系列：我的 LeetCode 刷題之道"></a>系列：我的 LeetCode 刷題之道</h3><ul><li><a href="/series/#%E6%88%91%E7%9A%84-LeetCode-%E5%88%B7%E9%A1%8C%E4%B9%8B%E9%81%93">文章清單（連載中）</a></li></ul><span id="more"></span><hr><h2 id="一、「哩哩扣扣」GPTs-介紹"><a href="#一、「哩哩扣扣」GPTs-介紹" class="headerlink" title="一、「哩哩扣扣」GPTs 介紹"></a>一、「哩哩扣扣」GPTs 介紹</h2><p>隆眾介紹你的 AI 刷題助手——<a href="https://chatgpt.com/g/g-6731960a3a2081909fe1975e05c034c4-li-li-kou-kou">哩哩扣扣</a>。</p><p><img src="https://i.imgur.com/I1EGApi.png" alt="哩哩扣扣"><span class="cap">哩哩扣扣</span></p><p>我們都知道，任何一個 AI 都能夠回答你關於 LeetCode 的問題與解析，因為這類資料對於大語言模型來說，<strong>可說是再熟悉不過了。</strong></p><p>這個 GPTs 是專為「<strong>深入了解 LeetCode 題目</strong>」打造的，回答模式偏向<strong>學習取向</strong>，而非單純提供答案。</p><p>輸入題目時，推薦使用完整截圖方式，這樣 AI 更能知曉題目的條件限制等細節。</p><p>我個人都是用<strong>長截圖</strong>一氣呵成，但分段多次截圖也無妨。</p><p>當然，如果你只想了解題目大概或掌握重點解法，那麼提供題號和標題就足夠了。</p><hr><h2 id="二、學習取向的回答模式"><a href="#二、學習取向的回答模式" class="headerlink" title="二、學習取向的回答模式"></a>二、學習取向的回答模式</h2><p>這個 GPTs 的最大特色，就是它的「第一次回答」。</p><p>共分成五大部分：</p><ol><li>題目解析</li><li>核心演算法與資料結構</li><li>解題思路與方法比較</li><li>相關題目與延伸概念</li><li>常見錯誤與陷阱</li></ol><p>這樣的回答，可以說是把該題的重點，<strong>完整地為你梳理一遍</strong>，讓你在首次接觸時，就能有一個<strong>相對完整的輪廓</strong>。</p><h3 id="題目解析"><a href="#題目解析" class="headerlink" title="題目解析"></a>題目解析</h3><p>先以第一部分「<strong>題目解析</strong>」為例，以下是回答的截圖：（<a href="https://leetcode.com/problems/two-sum/description/">1. Two Sum</a>）</p><p><img src="https://i.imgur.com/fVdelfK.png" alt="哩哩扣扣"><span class="cap">哩哩扣扣</span></p><p>第一部分又分成三個小節。首先是<strong>規則講解</strong>，將題目要求用中文說明，幫助非英語母語者快速抓住重點，或確認自己沒有理解錯誤，非常實用。</p><p>接著是<strong>核心概念</strong>，指出這題與哪些演算法重點相關。</p><p>最後，GPTs 還會對題目進行<strong>重要性評估</strong>，幫助你快速判斷該題<strong>對面試和學習的價值</strong>。</p><h3 id="解題思路與方法比較"><a href="#解題思路與方法比較" class="headerlink" title="解題思路與方法比較"></a>解題思路與方法比較</h3><p>回答的第三部分，是「<strong>解題思路與方法比較</strong>」，這是我覺得最有價值的地方。</p><p>例示如下：（<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a>）</p><p><img src="https://i.imgur.com/tOJNLlz.png" alt="哩哩扣扣"><span class="cap">哩哩扣扣</span></p><p>如你所見，它會幫你整理本題的常用解法，大致說明解題的思路——包括<strong>直接但不效率的暴力解法</strong>。畢竟作為學習者，知曉什麼是「不佳的做法」也是學習的一部分。</p><p>最後會用表格呈現<strong>各種解法的優缺點</strong>，讓你一目瞭然。</p><hr><p>大致了解 GPTs 的特色後，再來講述一下我實際上是怎麼用它刷題的。</p><h2 id="三、我的使用方式與刷題流程"><a href="#三、我的使用方式與刷題流程" class="headerlink" title="三、我的使用方式與刷題流程"></a><strong>三、我的使用方式與刷題流程</strong></h2><p>我練習<strong>新題目</strong>的流程大致如下：</p><ol><li>看刷題清單，做到哪裡了，選定今天要刷的題目。</li><li>看 LeetCode 網站上的題目內容，了解題目規則，思考 5-10 分鐘。</li><li>如果有想法，可以先試著在 VS Code 作答。如果沒有，直接看 AI 對本題的介紹。尤其是前述的「<strong>解題思路與方法比較</strong>」部分。</li><li>基於 AI 的回答，看看是否知道怎麼解了，嘗試作答。如果還是不明白，請 AI 給出「詳細的解法流程」。</li><li>從 AI 第一次回答開始，只要有疑問，<strong>直接繼續提問</strong>，不一定要急著作答。</li></ol><p>以上就是我使用 AI 工具輔助刷題的流程。</p><p>光這樣講可能還有點籠統，以下是其中兩個重點環節的說明。</p><h3 id="理解題目後，要思考多久？"><a href="#理解題目後，要思考多久？" class="headerlink" title="理解題目後，要思考多久？"></a>理解題目後，要思考多久？</h3><p>一開始我對此也有一些困惑，但做了大概十幾二十題後，我有一個心得，那就是——真的不用思考太久。</p><p>Easy 類的題目，還在入門階段，可以思考稍微久一點，10 分鐘到 15 分鐘是可以的。</p><p>Medium 以上的題目，<strong>套路成分會更重</strong>，第一次接觸時，你要靠自己想出解法的難度很高，所以這個時候我覺得思考 5 到 10 分鐘就足夠了。</p><p>總之，我們的重點是要掌握這些題目的<strong>上手方式和正確的寫法</strong>，至於第一次做題能不能靠自己想出來，其實不是很重要。</p><h3 id="第一次學習時的重點"><a href="#第一次學習時的重點" class="headerlink" title="第一次學習時的重點"></a>第一次學習時的重點</h3><p>第一次學習時，我會花比較多的時間跟 AI 討論，了解一些<strong>重要基本元素</strong>，比如<strong>雙指針（左右、快慢指針）</strong>、<strong>二分搜尋的開閉問題</strong>（雙閉區間、左閉右開）等等主題。</p><p>這些都不是題目裡面會直接告訴你的，但它們卻是<strong>題目的重要組成部分</strong>。</p><p>當你不太懂時，可以直接跟 AI 討論。</p><p>AI 可以回答關於刷題的任何問題，所以這個時候多花一點時間是值得的，因為這正是<strong>理解與鞏固基礎</strong>的時機。</p><hr><h2 id="四、注意事項"><a href="#四、注意事項" class="headerlink" title="四、注意事項"></a><strong>四、注意事項</strong></h2><p>使用 AI 輔助刷題，其實為了幫助我們<strong>更輕鬆地「思考」</strong>——而不是獲得答案。</p><p>因此，程式碼答案本身其實是<strong>最不值錢</strong>的部分。理解為什麼要這樣寫，以及掌握其中的關鍵細節，才是這個強大工具能夠給你的最大幫助。</p><p>我們可以想像，以前的人要深入理解題目<strong>需要花費大量時間</strong>：要先閱讀相關書籍來學習解題模式，解完題後還要到 LeetCode 討論區研究其他人的解法和技巧。</p><p>這些都是<strong>很費功夫</strong>的過程，但現在 AI 可以完成其中絕大部分的工作，<strong>而你只需要向它認真提問即可。</strong></p><p>為了用好 AI，以下是我認為值得注意的部分：</p><ul><li><strong>避免過度依賴</strong>：直接複製 AI 給出的程式碼不是太大的問題，只要你詳細和它討論過，而且<strong>理解每一步的邏輯</strong>。（我會在複習階段才自己全手工寫一遍）</li><li><strong>不宜讓對話過長</strong>：我會有意地<strong>避免問一些無關緊要的問題</strong>，以免對話因過長而失焦。日後要複習時，<strong>不至於讓自己看得眼花撩亂</strong>。這是個人偏好，僅供參考。</li><li><strong>不止提問，更要思考</strong>：思考 AI 的回答是否<strong>合理</strong>，也是學習中的重要一環，不止是一直提問——最好還能夠反駁它！</li><li><strong>保持獨立思考</strong>：AI 的回答具有一定的<strong>隨機性</strong>，雖然刷題這件事，它做得<strong>非常好</strong>，但仍可能因為你<strong>提問方式的不同</strong>而給出不同的回答方向，這點必須留意。</li></ul><hr><h2 id="五、總結與下一步"><a href="#五、總結與下一步" class="headerlink" title="五、總結與下一步"></a><strong>五、總結與下一步</strong></h2><p>AI 是刷題的強大助手，但要真正發揮其價值，需要你以合適的方式使用它。</p><p>這篇文章與第一篇相隔超過一個月，遠比預期的晚，原因有二：</p><ol><li>我在使用中<strong>不斷改善 AI 的回答架構</strong>，讓它對學習更有幫助。</li><li>其次，我也需要時間，<strong>慢慢摸索與它互動的最佳方式</strong>。</li></ol><p>它的用法還不止我說的這些，需要讀者自行想像、發揮。</p><p>下一篇會介紹，在刷題過程中，我如何<strong>做筆記</strong>，讓學習效果更好、記憶更深刻。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/g9WO9S7.jpeg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本來只打算寫兩篇，現在變成 4 篇了，大綱可參考「&lt;a href=&quot;/grind-leetcode-with-ai-preparation/#%E7%B3%BB%E5%88%97%E6%A6%82%E8%BF%B0%E8%88%87%E5%B0%8E%E8%AE%80&quot;&gt;系列概述與導讀&lt;/a&gt;」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇，我們介紹了 LeetCode 刷題的準備與基本原則，本篇則要介紹我刷題時搭配的 AI 工具——自定義的 &lt;a href=&quot;https://openai.com/index/introducing-gpts/&quot;&gt;GPTs&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不過有一點需要提醒：你得先訂閱 &lt;a href=&quot;https://openai.com/index/chatgpt-plus/&quot;&gt;ChatGPT Plus&lt;/a&gt;，才能直接使用他人建立的 GPTs。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始正文。&lt;/p&gt;
&lt;h3 id=&quot;系列：我的-LeetCode-刷題之道&quot;&gt;&lt;a href=&quot;#系列：我的-LeetCode-刷題之道&quot; class=&quot;headerlink&quot; title=&quot;系列：我的 LeetCode 刷題之道&quot;&gt;&lt;/a&gt;系列：我的 LeetCode 刷題之道&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/series/#%E6%88%91%E7%9A%84-LeetCode-%E5%88%B7%E9%A1%8C%E4%B9%8B%E9%81%93&quot;&gt;文章清單（連載中）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    <content src="https://i.imgur.com/g9WO9S7.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="LeetCode" scheme="https://blog.kyomind.tw/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>去了兩個月健身房之後——我的「有氧運動」進化史</title>
    <link href="https://blog.kyomind.tw/cardio-evolution-2-months/"/>
    <id>https://blog.kyomind.tw/cardio-evolution-2-months/</id>
    <published>2024-11-14T09:21:31.000Z</published>
    <updated>2024-11-16T02:32:03.766Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>兩個多月前，我發表了〈<a href="/weekly-review-37/">37，加入健身房，專注 Zone 2</a>〉，宣誓著我投入有氧運動的決心！</p><p>75 天過去，我仍持續嗎？還是已經半途而廢？</p><p>本文就來整理一下，這兩個月多的變化，以及我獲得的體驗與感悟。</p><blockquote><p>延伸閱讀：<a href="/weekly-review-28/">28，去了 2 個月圖書館之後</a></p></blockquote><hr><h2 id="以減脂為起點"><a href="#以減脂為起點" class="headerlink" title="以減脂為起點"></a>以減脂為起點</h2><p>8 月底，我為了「減脂」（嚴格來說是降低體脂率）而報名健身房。</p><p>當時的計畫很簡單：不涉及重訓（另有教練），把這個健身房當成「<strong>有氧專區</strong>」，全力投入有氧運動來達成減脂的目標。</p><p>加入健身房的第一個月，<strong>跑步機是我的首選</strong>。使用方式也很簡單——以 Zone 2 的中低強度運動為主。<strong>我不跑步</strong>，而是設定坡度，採用走路的方式訓練。</p><p>那時我的期望是慢慢來，讓身體自然適應。</p><p>這兩個月來，經歷了幾個階段的改變（當然少不了和 AI 討論😎），訓練模式和目標也逐漸調整。</p><p>可說是一段「有氧運動進化史」，是不是真的愈來愈好，我敢不說。但顯然更符合我的期待。以下分三個階段講述——<strong>純個人經驗，僅供參考</strong>。</p><span id="more"></span><hr><h2 id="第一階段：跑步機上坡走路"><a href="#第一階段：跑步機上坡走路" class="headerlink" title="第一階段：跑步機上坡走路"></a>第一階段：跑步機上坡走路</h2><p>剛開始的前兩週，重點放在上坡走路。</p><p>因為右膝比較沒那麼穩定，讓我對跑步有所遲疑，但為了達成一定心率，光快走也不足以進入 <a href="https://www.google.com/search?q=Zone%202">Zone 2</a>（最大心率 60-70% 左右，對我而言相當於 115-133）。</p><p>具體做法是，跑步機設定坡度 10，時速 4 公里，行走約 45 分鐘。</p><p>結束後再用 15 分鐘橢圓機，作為強度上的補充，達成所謂的「80&#x2F;20」黃金比例——這裡指的是<strong>中低強度運動佔 80%，高強度佔 20%。</strong></p><p>這種平穩且強度不大的運動方式，很快身體就習慣了。<strong>這帶來了一個問題：感覺真的很無聊！</strong>而且時間又得要長才行——中低強度就是靠時間取勝。</p><p>隨著身體的適應，我意識到需要調整訓練方式才能打破僵局。</p><hr><h2 id="第二階段：跑步機、橢圓機-1-1"><a href="#第二階段：跑步機、橢圓機-1-1" class="headerlink" title="第二階段：跑步機、橢圓機 1 : 1"></a>第二階段：跑步機、橢圓機 1 : 1</h2><p>為避免中低強度訓練帶來的<strong>無趣與厭煩感</strong>，進入第三週後，我開始調整兩種器械的使用比例：<strong>改為跑步機和橢圓機各 25 分鐘。</strong></p><p>這樣的「1 : 1」分配讓運動的變化更多，主要是提高了整體強度，但仍繼續保有一定的 Zone 2 比例。</p><p>在此簡介一下我對橢圓機的用法，基本上<strong>以 5 分鐘為一個週期</strong>，前 3 分鐘是低強度，RPM（每分鐘轉速）約 80-100，阻力 8（上限 20）。</p><p>後 2 分鐘則是高度強，RPM 提高到 120 左右。</p><p>如此交錯，效果不錯！比單純高強度要來得持久——不然我 10 分鐘就想下來了。這樣的交錯也符合「間歇訓練」的精神。</p><p>在 RPM 120 的高強度階段，心率可以來到 140 甚至 150。</p><p>維持了 3 週，感覺不錯，但如你所料，身體又又又開始適應了。</p><p>到了本階段後期，120 RPM 已經連心率 140 都難以企及，而且身體也不那麼喘了，是時候繼續向前邁進了。</p><hr><h2 id="第三階段：徹底擁抱橢圓機，轉為-Zone-3-的心肺訓練"><a href="#第三階段：徹底擁抱橢圓機，轉為-Zone-3-的心肺訓練" class="headerlink" title="第三階段：徹底擁抱橢圓機，轉為 Zone 3 的心肺訓練"></a>第三階段：徹底擁抱橢圓機，轉為 Zone 3 的心肺訓練</h2><p>10 月中起，我將跑步機「<strong>邊緣化</strong>」，只用來進行<strong>短暫的熱身</strong>（約 5-7 分鐘），橢圓機正式成為我的有氧主力，每次使用約 35 分鐘。</p><p>此時我已經不滿足於 Zone 2 減脂，而更想要鍛鍊心肺——這需要一定的強度。</p><p>橢圓機一樣以 5 分鐘為週期，但做法調整為，第 2 和 4、5 分鐘為高強度時間，RPM 140-160，剩下兩分鐘則是低強度，RPM 100 左右。</p><p>隨著運動強度的提升，帶來的感受也有所不同，<strong>運動後的愉悅感變得更強</strong>，心肺耐力和體能也都有明顯的進步——主要是不太容易喘。</p><p>這樣的訓練強度也改變了我對有氧運動的看法。之前單純為了減脂而動，現在則是為了進步與挑戰（在合理的範圍內），有氧運動逐漸成為我生活中的小小重心。</p><h2 id="表格整理"><a href="#表格整理" class="headerlink" title="表格整理"></a>表格整理</h2><p>我們稍微整理一下這三個階段的<strong>運動內容、強度和心率</strong>，如下表所示：</p><table><thead><tr><th>階段</th><th>訓練內容</th><th>心率範圍</th><th>備註</th></tr></thead><tbody><tr><td><strong>第一階段</strong></td><td>跑步機上坡走路，坡度 10，時速 4 公里，45 分鐘 + 橢圓機 15 分鐘</td><td>115-135 BPM</td><td>主要以 Zone 2 減脂為主</td></tr><tr><td><strong>第二階段</strong></td><td>跑步機 25 分鐘 + 橢圓機 25 分鐘（間歇訓練）</td><td>120-150 BPM</td><td>提升強度，加入高低交替</td></tr><tr><td><strong>第三階段</strong></td><td>橢圓機 35 分鐘，週期性高強度（RPM 140-160）</td><td>130-155 BPM</td><td>以 Zone 3 心肺訓練為主</td></tr></tbody></table><p>總的來說，最有滿足感的還是第三階段。</p><p><img src="https://i.imgur.com/EgvLoGo.jpeg" alt="階段三：心率"><span class="cap">階段三：心率</span></p><p>不僅是因為強度的提升，更因為<strong>運動後的愉悅感</strong>。</p><hr><p>除了階段性的變化，我還有<strong>兩個有趣的發現</strong>，如下。</p><h2 id="頻率與現實"><a href="#頻率與現實" class="headerlink" title="頻率與現實"></a>頻率與現實</h2><p>一開始，給自己設定了一個十分積極的頻率——每週去五次健身房。</p><p>對此，我只有兩個字評論：作夢😆</p><p>這個頻率很快被證明根本<strong>不切實際</strong>：每次運動加上通勤、暖身，至少需要 1 小時。5 次就 5 小時了。</p><p>還有強度要求，心理上很容易<strong>產生抗拒</strong>——這是為何我堅持橢圓機只用 35 分鐘，不能再多了。</p><p>最後的定論是：每週二到三次，保持適度的頻率。這樣的節奏既能持續進行，又不會讓訓練變成生活中的壓力。</p><h2 id="意外收穫：文思泉湧的創作狀態"><a href="#意外收穫：文思泉湧的創作狀態" class="headerlink" title="意外收穫：文思泉湧的創作狀態"></a>意外收穫：文思泉湧的創作狀態</h2><p>值得一提的是，在橢圓機上進行高強度訓練時，我發現大腦進入了一種「<strong>文思泉湧</strong>」的狀態，很容易產生新的靈感——尤其是寫作的靈感！</p><p><strong>短短 35 分鐘，腦海裡不斷浮現出有趣的想法。</strong></p><p>想要進入這個狀態，首先要清空一下大腦，然後專注於運動，不要讓其他事情干擾。這樣，大腦就會自然而然地開始運作。但請注意，這<strong>可能不適合跑步等需要專注的運動</strong>。</p><p>毫不誇張地說，在這個狀態下，<strong>我感覺新思緒的產生速度大概是靜態時的 3-5 倍</strong>。</p><p>我<strong>特別珍惜</strong>這樣的時刻，不過也不會立刻拿起手機就開始記錄，這多少有點危險。只能等運動結束後，或間歇中的低強度期間，趕緊記錄下來，作為日後的寫作素材。</p><p>事實上，本文的標題就是在橢圓機上想到的。</p><hr><h2 id="總結與未來展望"><a href="#總結與未來展望" class="headerlink" title="總結與未來展望"></a>總結與未來展望</h2><p>展望——其實沒什麼展望XD</p><p>我覺得能夠維持現在這個狀態與頻率，就<strong>已經相當不錯</strong>了！</p><p>畢竟，現實往往是：好的習慣不易養成，要中斷卻非常簡單。</p><p>我希望繼續保持這個平衡，試著讓運動成為生活中一部分，而不是一種負擔。</p><p>這段時間的經歷讓我再次體會到，<strong>持續的小進步比短期的大爆發更有價值</strong>——而且總是如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;兩個多月前，我發表了〈&lt;a href=&quot;/weekly-review-37/&quot;&gt;37，加入健身房，專注 Zone 2&lt;/a&gt;〉，宣誓著我投入有氧運動的決心！&lt;/p&gt;
&lt;p&gt;75 天過去，我仍持續嗎？還是已經半途而廢？&lt;/p&gt;
&lt;p&gt;本文就來整理一下，這兩個月多的變化，以及我獲得的體驗與感悟。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;延伸閱讀：&lt;a href=&quot;/weekly-review-28/&quot;&gt;28，去了 2 個月圖書館之後&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;以減脂為起點&quot;&gt;&lt;a href=&quot;#以減脂為起點&quot; class=&quot;headerlink&quot; title=&quot;以減脂為起點&quot;&gt;&lt;/a&gt;以減脂為起點&lt;/h2&gt;&lt;p&gt;8 月底，我為了「減脂」（嚴格來說是降低體脂率）而報名健身房。&lt;/p&gt;
&lt;p&gt;當時的計畫很簡單：不涉及重訓（另有教練），把這個健身房當成「&lt;strong&gt;有氧專區&lt;/strong&gt;」，全力投入有氧運動來達成減脂的目標。&lt;/p&gt;
&lt;p&gt;加入健身房的第一個月，&lt;strong&gt;跑步機是我的首選&lt;/strong&gt;。使用方式也很簡單——以 Zone 2 的中低強度運動為主。&lt;strong&gt;我不跑步&lt;/strong&gt;，而是設定坡度，採用走路的方式訓練。&lt;/p&gt;
&lt;p&gt;那時我的期望是慢慢來，讓身體自然適應。&lt;/p&gt;
&lt;p&gt;這兩個月來，經歷了幾個階段的改變（當然少不了和 AI 討論😎），訓練模式和目標也逐漸調整。&lt;/p&gt;
&lt;p&gt;可說是一段「有氧運動進化史」，是不是真的愈來愈好，我敢不說。但顯然更符合我的期待。以下分三個階段講述——&lt;strong&gt;純個人經驗，僅供參考&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
    <category term="生活" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>iThome 鐵人賽寫作攻略——新手必看指南</title>
    <link href="https://blog.kyomind.tw/ithome-ironman-tips/"/>
    <id>https://blog.kyomind.tw/ithome-ironman-tips/</id>
    <published>2024-11-13T04:07:49.000Z</published>
    <updated>2024-11-14T09:22:18.069Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/8kDoWyy.jpeg"></p><p>除了「加碼」組別，<a href="https://ithelp.ithome.com.tw/2024ironman/">2024 iThome 鐵人賽</a>已圓滿落幕，而我也順利完賽。</p><p>在讀完〈<a href="https://kucw.io/blog/ithome-sharing/">iThome 鐵人賽 - 得《優選》獎項的寫作心法</a>〉和〈<a href="https://ithelp.ithome.com.tw/articles/10358571">【Day 31】- 忙碌上班族如何在鐵人賽中堅持30天寫作？從靈感到策略：9個關鍵步驟</a>〉這兩篇大作後，我不禁見獵心喜、心癢難耐🤩</p><p>也想好好寫一篇攻略，獻給還在觀望中、猶豫明年是否要參賽的你。</p><p>雖說是「寫作」攻略，但其實更適合稱為「<strong>參賽與完賽</strong>」攻略。</p><p>本文不會介紹任何寫作技巧，而是聚焦於<strong>如何成功跑完這場「寫作馬拉松」</strong>——最好再拿個獎！</p><p>接下來，我將分享我的鐵人賽參賽經驗，以及一些實際的做法。</p><span id="more"></span><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文的最大目標，就是<strong>試圖鼓吹你在明年參賽</strong>——畢竟今年已經來不及了🤣</p><p>如果閱讀後你依舊沒有這樣的衝動，那麼這篇文章就算是失敗了。</p><p>因此，我們無須講太多「細節」，而是從「更高的層級」與「可行性角度」來討論這個議題。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文主要寫給下列這三種人：</p><ol><li>平常沒有寫作習慣，但想藉由參賽來磨練寫作能力的軟體工程師。</li><li>已經有在寫作，希望獲得更多文章曝光度、聲望的工程師。</li><li>別說了！我就是要得獎、出書。</li></ol><p>本文對三者都有幫助，但話說回來，我們還是會更加著重在「<strong>新手鐵人</strong>」，以降低你的行動（報名參賽）門檻。</p><p>此外，我之前已有兩篇文章討論過鐵人賽，所以本文可以視為對兩者的（大量）補充：</p><ul><li><a href="/weekly-review-35/">35，開始備戰 2024 iThome 鐵人賽</a></li><li><a href="/2024-ironman-event/">2024 iThome 鐵人賽參賽思路：主題選擇、命名與標題策略</a></li></ul><p>了解完上述前提後，我們正式開始。</p><hr><h2 id="一、心態區別：是否以「得獎」為目標"><a href="#一、心態區別：是否以「得獎」為目標" class="headerlink" title="一、心態區別：是否以「得獎」為目標"></a>一、心態區別：是否以「得獎」為目標</h2><p>參賽不一定非得為了得獎。</p><p>不過，在參賽之前，我們可以先問自己：「我是否要以得獎為目標？」</p><p><strong>因為兩者的道路可能會有很大的不同</strong>。</p><p><strong>不以得獎為目標，有時更利於學習</strong>。但代價就是——沒有獎😂</p><p>以我自己為例，我在〈<a href="/weekly-review-35/">35，開始備戰 2024 iThome 鐵人賽</a>〉就提到目標是<a href="/weekly-review-35/#%E5%80%8B%E4%BA%BA%E6%9C%9F%E5%BE%85">為了得獎</a>。什麼獎都可以，但就是要得獎！</p><h3 id="得獎的取捨"><a href="#得獎的取捨" class="headerlink" title="得獎的取捨"></a>得獎的取捨</h3><p>一旦想得獎，就不得不研究一下，哪些是<strong>重點</strong>。</p><p>不可否認，這樣的創作多少是「<strong>不自由</strong>」的，但也有它自己的價值。</p><p>我認為，先想清楚這個問題，<strong>會讓自己更享受參賽的過程</strong>。</p><p>如果明年繼續參賽，我應該就<strong>不會</strong>以獲獎為目標了，而是更多放在學習與嘗試——然後順便寫個文章。</p><p>很多時候，兩者無法兼得，選擇往往是必要的。</p><hr><h2 id="二、了解評審標準"><a href="#二、了解評審標準" class="headerlink" title="二、了解評審標準"></a>二、了解評審標準</h2><p>我們假設你是以「得獎」為目標參賽，因為這樣才能發揮本文的<strong>最大價值</strong>。</p><p>以此為前提，了解評審時的重點顯然相當必要。<a href="https://s.itho.me/vendor/2024/iThome/iThome%E9%90%B5%E4%BA%BA%E8%B3%BD%E6%B4%BB%E5%8B%95%E7%B0%A1%E7%AB%A0-20240614.pdf">報名簡章</a>是這樣寫的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">陸、主題競賽評審要點：</span><br><span class="line">- 主題：主題規劃符合該組別的立意，並能充份切合所選參賽主題下，參賽者所訂定之議題</span><br><span class="line">- 結構：30 篇文章組織良好、其所規劃結構足以引導讀者理解參賽者訂定之議題</span><br><span class="line">- 內容：文章內容的技術或經驗具備專業性、豐富性、深入性</span><br><span class="line">- 表達：透過適當文字、圖片、程式碼或影片等方式，讓人更容易理解</span><br></pre></td></tr></table></figure><p>這 4 項要全都做到滿分，我想很難。</p><h3 id="讀者意識"><a href="#讀者意識" class="headerlink" title="讀者意識"></a>讀者意識</h3><p>但它們都指向了一個<strong>共同的上位概念</strong>——「<strong>請務必讓讀者好了解！</strong>」</p><p>這不正是所謂的「<strong>讀者意識</strong>」？要求你了解讀者的需求與可能有的疑惑，並以此來調整內容的深度和表達方式。</p><p>這種意識能幫助你在保持專業的同時，讓文章<strong>更容易被理解和接受</strong>。</p><p>覺得自己寫得很棒，還不算數。<strong>讀者們也這麼認為，那才算數</strong>！</p><h3 id="我的著眼點"><a href="#我的著眼點" class="headerlink" title="我的著眼點"></a>我的著眼點</h3><p>所以，我對這段要點的解讀，會更加著重在「<strong>結構</strong>」與「<strong>表達</strong>」這兩部分。</p><p>結構務必清晰（這並不容易，後面會再討論），而文字表達則要「<strong>善解人意</strong>」。最忌諱的就是簡單介紹一下，然後丟一大段程式碼讓讀者自行理解——這樣不太體貼唷！</p><p>能做好這兩點，就已經相當不錯了。</p><hr><h2 id="三、提前開始準備"><a href="#三、提前開始準備" class="headerlink" title="三、提前開始準備"></a>三、提前開始準備</h2><p>既然想要拿獎，提前準備就是必要的——非常必要。</p><p>即使像我這樣在參賽期間已經離職、不必工作的人，也<strong>不可能</strong>在開賽日當天才開始動筆，同時還妄想能確保寫作品質——我對寫作很完美主義☺️</p><p>具體而言，我在 9&#x2F;13 開賽日之前，已寫完系列的前 13 篇文章。</p><p>假設「正常」參賽者必須一邊工作一邊創作，那我認為「最好」能在參賽前，<strong>預先完成 10-15 篇</strong>。</p><h3 id="囤稿以緩衝"><a href="#囤稿以緩衝" class="headerlink" title="囤稿以緩衝"></a>囤稿以緩衝</h3><p>這樣的準備量可能看起來有點多，但它能夠<strong>大大減輕你在比賽期間的壓力</strong>。想像一下，當其他參賽者正在為每天的截稿時間而焦急時，你已經有了足夠的「緩衝」。</p><p>這不僅能讓你<strong>更加從容</strong>地面對每天的寫作任務，<strong>還能賦予你額外的時間，去重新編輯和完善你的文章</strong>——非常適合我這種完美主義者😇</p><p>事實證明，這很重要。</p><p>系列後半段的文章，儘管我早早就列出了大綱、定完標題。但實際創作時，<strong>發現要改動的幅度極大</strong>，涉及了文章主題和系列架構的調整。</p><p>如果沒有之前 13 篇囤稿作為緩衝，那不是累死自己，就是虎頭蛇尾。</p><p>兩者都不是我想要的！</p><hr><h2 id="四、選擇熟悉的主題"><a href="#四、選擇熟悉的主題" class="headerlink" title="四、選擇熟悉的主題"></a>四、選擇熟悉的主題</h2><p>關於參賽主題的選擇，我在開賽前就討論過，那時主要強調「<a href="/weekly-review-35/#%E4%B8%80%E3%80%81%E9%81%BF%E9%96%8B%E5%A4%AA%E5%B8%B8%E8%A6%8B%E7%9A%84%E4%B8%BB%E9%A1%8C">避開太常見的主題</a>」。</p><p>現在完賽了，我還想補充一點：「如果是以<strong>獲獎</strong>為目標，那麼勢必得選擇<strong>自己熟悉的主題</strong>」。</p><p>即使這個主題是常見的，也比嘗試創作一個自己不熟悉的技術主題要來得好。</p><p>其中的道理不難理解：<strong>熟悉的主題，你可以更好地掌握內容，更好地表達</strong>。</p><p>如果真的很想寫自己不熟悉的主題怎麼辦？很簡單，先放下得獎的念頭，好好享受學習與分享的過程😘</p><h3 id="熟悉不等於好寫"><a href="#熟悉不等於好寫" class="headerlink" title="熟悉不等於好寫"></a>熟悉不等於好寫</h3><p>更別說，<strong>熟悉並不意味著好寫</strong>。畢竟，<strong>自己會</strong>和<strong>教別人做</strong>往往是兩回事。所以寫完之後你很可能會發現——「自己<strong>好像沒有</strong>原先以為的那麼懂！」</p><p>就像我在〈<a href="/django-ninja-30/">卷 30：系列回顧與完賽心得</a>〉中說的：</p><blockquote><p>在我看來，寫作的滿足感在於「提供價值、發揮影響力」。這份價值不僅是對讀者，也包括對作者自己——<strong>透過這 30 篇文章創作，我對 Django Ninja 的理解又增進許多</strong>。</p></blockquote><p>恭喜你！又進步了。</p><hr><h2 id="五、結構、結構，還是結構"><a href="#五、結構、結構，還是結構" class="headerlink" title="五、結構、結構，還是結構"></a>五、結構、結構，還是結構</h2><p>前面提到，「結構」與「表達」是我認為在 4 項評分標準中特別重要的部分。</p><p>其實就算不是參加比賽，<strong>任何一篇文章都需要良好的結構和友善的表達</strong>——這是寫作的基本，同時也是<strong>最難的部分</strong>。</p><p>在鐵人賽這樣以 30 篇作為一個完整系列的「<strong>連載型創作</strong>」中，我認為結構的重要性，可以說<strong>再強調也不為過</strong>。</p><p>好的結構和壞的結構，或者說沒有結構，寫出來的作品可能是<strong>天壤之別</strong>。（注意，這裡的「作品」不是指單篇文章，而是一整個系列）</p><p>就像蓋一層樓的矮房，結構影響不大；但要蓋 30 層大樓，結構就<strong>至關重要</strong>了。</p><h3 id="具體做法"><a href="#具體做法" class="headerlink" title="具體做法"></a>具體做法</h3><p>講完了結構的重要性，那具體要怎麼做呢？</p><p>我自己的做法是先跟 AI 好好討論，把 30 篇標題都先定下來。不過這有點強人所難，尤其在最開始的時候。</p><p>為了降低壓力與兼顧彈性，我們可以採取<strong>折衷方案</strong>：先確定<strong>前 10 篇的標題</strong>，後 20 篇僅擬定大綱——也就是章節名稱。</p><p>在寫完前面的部分後，後面你就會有靈感了！</p><p>但無論如何，<strong>絕對不要沒有先草擬系列的架構就開始寫</strong>！很容易虎頭蛇尾。</p><hr><h2 id="六、別讓「字數」成為壓力"><a href="#六、別讓「字數」成為壓力" class="headerlink" title="六、別讓「字數」成為壓力"></a>六、別讓「字數」成為壓力</h2><p>關於字數，我有很多話想說。不過篇幅所限，我們可以總結為 3 點。</p><h3 id="一、保持各篇字數的相對均衡"><a href="#一、保持各篇字數的相對均衡" class="headerlink" title="一、保持各篇字數的相對均衡"></a>一、保持各篇字數的相對均衡</h3><p>這一點很少人提及，但我個人還蠻重視的。因為<strong>字數的均勻</strong>表示你在系列的編排上<strong>的確有經過深思熟慮</strong>。</p><p><strong>這是另一種用心的展現。</strong></p><p>想像一下，如果這一篇為 800 字，而下一篇卻有 2500 字，作為讀者，你可能會感到<strong>思緒有些混亂</strong>。至少我個人<strong>不那麼喜歡閱讀</strong>字數起伏太大的系列文章。</p><p>當然，字數均勻並不是說每一篇都要一樣多——這恐怕也不切實際。只要<strong>差距別太大</strong>，讓讀者感到舒適即可。</p><p>下圖是我 30 篇文章的字數分布，除了第 29 篇有點「失手」外，其餘文章的字數均落在「<a href="https://zh.wikipedia.org/zh-tw/68%E2%80%9395%E2%80%9399.7%E6%B3%95%E5%89%87">兩個標準差</a>」以內。</p><p><img src="https://i.imgur.com/qoUSere.png"></p><p>可見我不是說說而已——還身體力行🐥</p><h3 id="二、字數不是多多益善"><a href="#二、字數不是多多益善" class="headerlink" title="二、字數不是多多益善"></a>二、字數不是多多益善</h3><p>說真的，這是一個不易突破的「<strong>心魔</strong>」！</p><p>連我自己都不容易說服自己：<strong>真的不需要寫太多字。</strong></p><p>但我們得承認：<strong>現代讀者的注意力是很有限的</strong>。就算是寫給有心學習的讀者，適度控制篇幅也是一種「<strong>保護閱讀注意力</strong>」的體貼表現。</p><p>所以，我認為網路文章的最佳字數確實存在一個<strong>相對理想的區間</strong>。</p><p>如果你問我，我會說這個區間是 1000 到 2000 中文字。</p><p>而我正是以每篇 1500 字作為單篇的字數目標——雖然後半段開始有點守不住XD</p><h3 id="三、字數偏少會不會不容易得獎？"><a href="#三、字數偏少會不會不容易得獎？" class="headerlink" title="三、字數偏少會不會不容易得獎？"></a>三、字數偏少會不會不容易得獎？</h3><p>我可以告訴你——我不知道XD</p><p>但是！確實是有字數不算多，但獲得<strong>優選</strong>的唷！（冠軍可能有點難）</p><p>比如去年 <strong>Vue.js 組優選</strong>——《<a href="https://ithelp.ithome.com.tw/users/20130500/ironman/6236">Nuxt.js 3.x 筆記－打造 SSR 專案</a>》。言簡意賅，搭配精心製作的解說圖片，讀起來非常舒服。</p><p>我就是看完這個系列，才有了足夠的勇氣，下定決心好好控制字數——雖然從結果而言不算成功😅</p><hr><h2 id="七、參考前人的作品"><a href="#七、參考前人的作品" class="headerlink" title="七、參考前人的作品"></a>七、參考前人的作品</h2><p>參考他人是一個很好的學習方法，尤其是那些獲獎或頗受好評的系列。畢竟所有的學習都是<strong>從模仿開始</strong>。</p><p>透過閱讀這些作品，你可以學習到他們的寫作風格、內容組織方式，以及<strong>如何維持整個系列的連貫性</strong>——這是新手鐵人<strong>最需要學習的</strong>，包括我自己。</p><p>以下是我在開賽前就已大致拜讀過的系列：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20130500/ironman/6236">Nuxt.js 3.x 筆記－打造 SSR 專案</a></li><li><a href="https://ithelp.ithome.com.tw/users/20162175/ironman/6445">時光之鏡：透視過去、現在與未來的 Observability</a></li><li><a href="https://ithelp.ithome.com.tw/users/20151036/ironman/6130">Spring Boot 零基礎入門</a></li><li><a href="https://ithelp.ithome.com.tw/users/20152669/ironman/6306">FastAPI 入門30天</a></li></ul><p>我用一份專屬的 Notion 筆記，記錄下我認為值得參考的部分，並在寫作時隨時翻閱。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>連續寫作 30 天，真的別具滋味。</p><p>這段旅程所帶來的收穫與學習，遠比創作單篇或數篇文章要來得多。更令人驚喜的是，你會發現自己的潛力比想像中大。</p><p>希望這篇攻略能對你有所助益，讓你在明年的鐵人賽中，大展身手。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/8kDoWyy.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了「加碼」組別，&lt;a href=&quot;https://ithelp.ithome.com.tw/2024ironman/&quot;&gt;2024 iThome 鐵人賽&lt;/a&gt;已圓滿落幕，而我也順利完賽。&lt;/p&gt;
&lt;p&gt;在讀完〈&lt;a href=&quot;https://kucw.io/blog/ithome-sharing/&quot;&gt;iThome 鐵人賽 - 得《優選》獎項的寫作心法&lt;/a&gt;〉和〈&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10358571&quot;&gt;【Day 31】- 忙碌上班族如何在鐵人賽中堅持30天寫作？從靈感到策略：9個關鍵步驟&lt;/a&gt;〉這兩篇大作後，我不禁見獵心喜、心癢難耐🤩&lt;/p&gt;
&lt;p&gt;也想好好寫一篇攻略，獻給還在觀望中、猶豫明年是否要參賽的你。&lt;/p&gt;
&lt;p&gt;雖說是「寫作」攻略，但其實更適合稱為「&lt;strong&gt;參賽與完賽&lt;/strong&gt;」攻略。&lt;/p&gt;
&lt;p&gt;本文不會介紹任何寫作技巧，而是聚焦於&lt;strong&gt;如何成功跑完這場「寫作馬拉松」&lt;/strong&gt;——最好再拿個獎！&lt;/p&gt;
&lt;p&gt;接下來，我將分享我的鐵人賽參賽經驗，以及一些實際的做法。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/8kDoWyy.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>39，10 月回顧——鐵人賽、演算法與 AI</title>
    <link href="https://blog.kyomind.tw/weekly-review-39/"/>
    <id>https://blog.kyomind.tw/weekly-review-39/</id>
    <published>2024-11-01T13:06:08.000Z</published>
    <updated>2024-11-30T16:11:24.146Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>好些日子沒寫 Weekly Review 了！</p><p>十月剛過，正是個不錯的時間點。</p><p>本篇就來整理一下「<strong>待業的第 2 個月</strong>」我都做了什麼。</p><span id="more"></span><hr><h2 id="iThome-鐵人賽"><a href="#iThome-鐵人賽" class="headerlink" title="iThome 鐵人賽"></a>iThome 鐵人賽</h2><p>雙十連假 4 天我幾乎都在寫作，連假落幕時，也是我的參賽劃下句點之時。</p><p>不過，正如〈<a href="https://blog.kyomind.tw/django-ninja-30/">Django Ninja 30：系列回顧與完賽心得</a>〉文中說的，這系列還沒有完全結束。我預計還會再新增 3 到 4 篇相關內容，其中心得與花絮就佔兩篇。</p><p>但請原諒我，並不是鐵人賽結束後就閒著了，所以剩下的內容只能一篇篇慢慢生出來。</p><p>在「<a href="https://kyomind.notion.site/40b324f98ca94827921a6831b0d7a38f">訂戶限定</a>」中提過，比賽結束後，我去了一趟「福隆 - 石城」徒步之旅。造訪<a href="https://newtaipei.travel/zh-tw/attractions/detail/110829">舊草嶺隧道</a>與<a href="https://www.yilan.travel/">頭城五漁鐵</a>。</p><p><img src="https://i.imgur.com/UcjquRE.jpeg" alt="舊草嶺隧道"><span class="cap">舊草嶺隧道</span></p><p>感覺很好！尤其在經歷了這一大波腦力勞動之後。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-33/">33，Tony Huang 與我的坪林之旅</a></p></blockquote><p>下星期，我打算繼續走訪<strong>苗栗海線——從白沙屯到通霄</strong>。</p><p>一邊動腦，一邊身體力行。</p><hr><h2 id="演算法與-LeetCode"><a href="#演算法與-LeetCode" class="headerlink" title="演算法與 LeetCode"></a>演算法與 LeetCode</h2><p>不知道大家是否看過這篇〈<a href="https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/">與 AI 共舞——我的 LeetCode 刷題之道（準備篇）</a>〉了，可以說是我近期的力作！</p><p>重點並不在刷題本身，而是其中蘊含的一種精神。怎麼說呢？就是<strong>遵從主流，但不完全按照主流的做法</strong>。</p><blockquote><p>這裡的「主流」是指什麼？</p></blockquote><p>指的是普遍認為刷題是找工作的必經之路，或至少是一個重要的手段。</p><p>我們很難否定這件事，但我的選擇是，將 AI 工具融入刷題過程中，<strong>用「更慢」的速度來刷題</strong>——這是反主流的。</p><p>在主流之中，選擇一條「不那麼主流」的分支。</p><p>這種方法既遵循了主流的刷題建議，又加入了<strong>個人的元素（AI、深度與反思）</strong>，更符合我的價值觀。</p><h3 id="初步感受"><a href="#初步感受" class="headerlink" title="初步感受"></a>初步感受</h3><p>從 10 月中到今天，我已經連續 15 天刷題了！</p><p>目前完成 <a href="https://www.techinterviewhandbook.org/grind75/">Grind 75</a> 中的 17 題，Easy 的題目也快被消耗完畢。（平心而論，有些 Easy 題目挺無聊的，難怪 <a href="https://neetcode.io/practice">NeetCode 150</a> 沒有選入）</p><p><img src="https://i.imgur.com/1UJOP42.png" alt="LeetCode Dashboard"><span class="cap">LeetCode Dashboard</span></p><p>只能說，這種方式<strong>很適合我</strong>，讓人想起台灣軟體圈那本你一定聽過的暢銷書——高見龍大大的《<a href="https://gitbook.tw/">為你自己學 Git</a>》。</p><p>或許可以稱作「<strong>為你自己刷 LeetCode</strong>」。</p><p>不過，人還是要<strong>適度休息</strong>。我已決定，明後兩天都不刷題！</p><p>明天要去宜蘭玩，後天則是前往新竹，參加「<a href="https://ithelp.ithome.com.tw/2024ironman/signup/team/339">AI 寶寶上學去！</a>」的團隊完賽慶功宴。真是令人期待🤩</p><hr><h2 id="再論職涯中的-gap-time"><a href="#再論職涯中的-gap-time" class="headerlink" title="再論職涯中的 gap time"></a>再論職涯中的 gap time</h2><p>在〈<a href="https://www.threads.net/@kyomind.tw/post/C-qEHRxyuIQ">Day 15：《上班，辭職，還是撐下去？》節選（一）</a>〉中引用了書裡的這段話：</p><blockquote><p>未來我們也許會工作幾年後就先「退休」幾年，去學習一段時間之後，再投入下一階段的工作生涯。</p></blockquote><p>我非常喜歡這樣的想法，和前面的「用自己的方式刷 LeetCode」類似，都是一種<strong>既不違反主流（相信人還是需要工作），又不完全按照主流價值行事的生存之道</strong>。</p><p>我想，「擁有自己的價值觀」這件事情本身，就足以讓人感到幸福。</p><h3 id="更大的舞台"><a href="#更大的舞台" class="headerlink" title="更大的舞台"></a>更大的舞台</h3><p>不過話說回來，在這個時間點，我也沒有以前那麼大的勇氣，再 gap 超過 1 年。</p><p>但，幾個月總可以吧！用我認同的方式去實現自己認為重要的事——學習演算法和系統設計。（其實這些都是在符合主流的「審美」😅）</p><p>畢竟，想成為優秀的軟體工程師，不就該如此？</p><p>可以說，離職待業這兩個月以來，我覺得自己過得很充實，最近的狀態也挺不錯。但我心裡清楚，做這些事，付出這些時間，終歸是為了尋找更好、更大的舞台。</p><p>且讓我們拭目以待。</p><hr><h2 id="AI-與我"><a href="#AI-與我" class="headerlink" title="AI 與我"></a>AI 與我</h2><blockquote><p>AI 會取代軟體工程師嗎？</p></blockquote><p>這是最近（或說一直以來）十分熱門的議題。尤其在 <a href="https://blog.kyomind.tw/cursor/">Cursor</a> 大紅之後！畢竟現在不用懂程式就可以寫出軟體服務或功能了。</p><p>先說說我個人的極簡看法：理性上覺得「沒那麼容易」，但情感上則常常在擔心這天的到來，哈哈哈！</p><p>答案究竟為何，沒人知道。</p><p>可是有一件事，對我而言是 100% 確定——<strong>我非常依賴 AI</strong>。</p><h2 id="Copilot-with-AI"><a href="#Copilot-with-AI" class="headerlink" title="Copilot with AI"></a>Copilot with AI</h2><p>今年寫了好幾篇和 AI 有關的文章：</p><ol><li><a href="https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/">與 AI 共舞——我的 LeetCode 刷題之道（準備篇）</a></li><li><a href="https://blog.kyomind.tw/myth-of-ai-writing-efficiency/">AI 讓寫作變輕鬆了？我可不這麼認為</a></li><li><a href="https://blog.kyomind.tw/my-ai-dialogue-notes/">我寫「AI 對話筆記」的方法與思考</a></li><li><a href="https://blog.kyomind.tw/not-by-ai/">為文章標註 Not By AI？ 我覺得大可不必</a></li></ol><p>訂戶限定也有兩篇：</p><ol><li>訂戶限定 07：鐵人賽尾聲 × 續論 AI 工具 × 我的滑鼠停產了！</li><li>訂戶限定 06：待業週記（二）失眠症與 AI輔助思考</li></ol><p>以後應該會更多。</p><h3 id="依賴-AI"><a href="#依賴-AI" class="headerlink" title="依賴 AI"></a>依賴 AI</h3><p>我對 AI 的「依賴」可能超過絕大多數人。</p><p>如上述這些文章所說，AI 對我來說，不僅僅是一個工具，也不僅僅是一個「懶人」的幫手。</p><p>真正讓我依賴 AI 的原因，是它已經成為我<strong>思考和生活的一部分</strong>。</p><p>無論是寫作、學習還是人生的重大難題，我總是先想到 AI，讓它扮演我的良師益友，來回討論，再決定下一步的行動。</p><p>如同我在「<a href="https://blog.kyomind.tw/about/#AI-%E6%99%82%E4%BB%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%80%85">AI 時代的工作者</a>」中所言：</p><blockquote><p>它不僅提升了產能，更挑戰我的思維模式，迫使我重新審視自己，以更深刻的方式思考問題。</p></blockquote><p>這種<strong>智識上的滿足感</strong>，以前可是很難得的，而現在不同了。</p><p>因為我們有了 AI。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;好些日子沒寫 Weekly Review 了！&lt;/p&gt;
&lt;p&gt;十月剛過，正是個不錯的時間點。&lt;/p&gt;
&lt;p&gt;本篇就來整理一下「&lt;strong&gt;待業的第 2 個月&lt;/strong&gt;」我都做了什麼。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>與 AI 共舞——我的 LeetCode 刷題之道（準備篇）</title>
    <link href="https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/"/>
    <id>https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/</id>
    <published>2024-10-24T05:12:52.000Z</published>
    <updated>2024-12-11T02:54:59.765Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/g9WO9S7.jpeg"></p><!-- ![picture 2](https://i.imgur.com/SsRLsJl.jpeg) --><blockquote><p>歡迎使用我的刷題助手 GPTs——<a href="https://chatgpt.com/g/g-6731960a3a2081909fe1975e05c034c4-li-li-kou-kou">哩哩扣扣</a> 🤖</p></blockquote><p><strong>你刷過 LeetCode 嗎？</strong></p><p>老實說，我一直很排斥刷題，因為感覺很「填鴨」，一點也不吸引人。</p><p>這可能是因為這件事和求職面試掛勾，所以讓人有壓力；又或者我還沒有真正領略資料結構與演算法之美。</p><p>總之，<strong>我很逃避！</strong></p><p>但這次不同了。</p><p>我找到了一個全新的方法，讓刷題<strong>不再那麼痛苦</strong>，還幫助我盡可能理解每一道題——這都要歸功於 AI。</p><p>我將分享如何透過 <strong>AI 輔助</strong>來提升刷 LeetCode 的學習效果。關鍵是——它讓原本枯燥的過程（對我來說）<strong>變得有趣</strong>。</p><p>當然，這樣的方法也有一些「<strong>限制</strong>」，後續會提及。</p><p>正文開始前，我必須先花一些篇幅來介紹整個系列的大綱。</p><span id="more"></span><hr><h2 id="系列概述與導讀"><a href="#系列概述與導讀" class="headerlink" title="系列概述與導讀"></a>系列概述與導讀</h2><p>我將透過一系列文章，介紹我如何使用 AI 工具（也就是我自建的 GPTs，第二篇有該 GPTs 的公開連結）來提升 LeetCode 刷題效率，並結合<strong>筆記和複習</strong>，打造一個完整的學習流程。</p><p>本系列包括 4 篇文章：</p><ol><li><strong>準備篇</strong>：讀者定位與前置準備，奠定基礎。</li><li><strong>GPTs 篇</strong>：講解 GPTs 的設計與使用方式。</li><li><strong>筆記篇</strong>：我刷題過程中的筆記策略與工具選擇。</li><li><strong>複習篇</strong>：有了筆記，該如何複習？</li></ol><p>看完這 4 篇，你能了解我是如何刷題，並可根據自己的需求，選擇或調整成適合自己的學習方式。</p><h3 id="系列：我的-LeetCode-刷題之道"><a href="#系列：我的-LeetCode-刷題之道" class="headerlink" title="系列：我的 LeetCode 刷題之道"></a>系列：我的 LeetCode 刷題之道</h3><ul><li><a href="/series/#%E6%88%91%E7%9A%84-LeetCode-%E5%88%B7%E9%A1%8C%E4%B9%8B%E9%81%93">文章清單（連載中）</a></li></ul><hr><p>本文是第一篇——準備篇，講述我在開始刷題之前的準備工作，包括自學教材的選擇、刷題清單的選定，以及基本的<strong>刷題價值觀</strong>。</p><p>接下來，介紹本文的輪廓。</p><h2 id="給-LeetCode-初學者的刷題指南"><a href="#給-LeetCode-初學者的刷題指南" class="headerlink" title="給 LeetCode 初學者的刷題指南"></a>給 LeetCode 初學者的刷題指南</h2><p>本文闡述如何運用 AI，將 LeetCode 刷題變成一種「<strong>互動式的學習之旅</strong>」。</p><p>我們的<strong>首要目標</strong>是——<strong>有效降低刷題的痛苦與排斥感</strong>！（這不止和 AI 有關，還包括了選用的教材、個人動機、心態等）</p><p>這方法不僅讓刷題變得有趣，還能幫助我們理解每道題目背後的演算法思維。換言之，你會<strong>學得更好</strong>。</p><p>如果你和我一樣，曾經對 LeetCode 感到困頓或厭倦，希望尋找一個更有效、更愉快的學習方式，這篇文章將會對你有所幫助。</p><p>雖然說是「給初學者」，講得好像我很懂——<strong>但其實我自己也是初學者</strong>😅。所以本系列更像是一篇篇「<strong>LeetCode 自學者的探索筆記</strong>」。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文<strong>特別適合</strong>下列讀者：</p><ul><li>討厭機械式刷題、希望刷題<strong>不止是為了面試</strong>的人</li><li>想了解如何利用 AI 助手提升學習效率的人</li><li><strong>不想刷太多題</strong>的人！（沒錯，你沒看錯，後面會闡述<strong>為何不多刷題</strong>）</li></ul><p>尤其要強調——本文非常適合演算法<strong>初學者</strong>，俗稱「小白」。</p><h3 id="不適合的讀者"><a href="#不適合的讀者" class="headerlink" title="不適合的讀者"></a>不適合的讀者</h3><p>有光有就影，我覺得本文可能不適合下列讀者：</p><ul><li>已有豐富刷題經驗的人</li><li>希望在短時間內刷大量題目以通過面試的人</li><li>偏好傳統學習方式，不太習慣使用 AI 輔助工具的人</li></ul><p>這類讀者通常已有自己的學習方式或目標，可能與本文的方法不太契合。</p><hr><p>我們先從刷題前的「<strong>前置準備</strong>」說起。</p><p>具體而言，有兩個前置準備：<strong>自學教材與刷題清單</strong>。</p><h2 id="前置準備一：演算法自學教材推薦"><a href="#前置準備一：演算法自學教材推薦" class="headerlink" title="前置準備一：演算法自學教材推薦"></a>前置準備一：演算法自學教材推薦</h2><p>像我這類半路轉職且演算法基礎為零的人。先讀過一些教材再開始，肯定會比較好。</p><p>但不必事先就花大量時間，可以學習教材到一定階段後，比如最常見的 array 和 linked list，就開始練習相關題目，讓理論與應用相輔相成。</p><p>關於教材選擇，我嘗試過好些書或線上課，從結果來看，只能說<strong>不盡理想</strong>。</p><p>但其中還是有些優質資源，特別適合初學者。</p><p>以下是我推薦且正在使用的教材，它們相當程度考慮了無基礎者的自學需求。</p><h3 id="一、《Hello-演算法》"><a href="#一、《Hello-演算法》" class="headerlink" title="一、《Hello 演算法》"></a>一、《Hello 演算法》</h3><p>這是一個<a href="https://www.hello-algo.com/zh-hant/chapter_hello_algo/">網站</a>（線上版的電子書），本質上是一個 <a href="https://github.com/krahets/hello-algo">GitHub 開源專案</a>。目前已有繁體中文版，同時也出版了實體書。</p><p>本書完全面向新手，還搭配了各種實用的動畫幫助理解——這是實體書辦不到的。</p><p>此外，它支援多種程式語言，能滿足不同開發者對熟悉程式碼範例的需求——這也是實體書無法擁有的優勢。</p><h3 id="二、《大話資料結構：全新彩色版》"><a href="#二、《大話資料結構：全新彩色版》" class="headerlink" title="二、《大話資料結構：全新彩色版》"></a>二、《大話資料結構：全新彩色版》</h3><p>這本《<a href="https://www.tenlong.com.tw/products/9789865501693">大話資料結構</a>》和更加知名的《<a href="https://www.tenlong.com.tw/products/9786267146804">大話設計模式</a>》是同一位作者。</p><p>書中有大量插圖幫助你理解，更重要的是，作者在自序中<strong>強調</strong>，這是一本面向「<strong>自學</strong>」的教材。</p><p>所以很多概念都會<strong>從頭講起</strong>，不會讓你有<strong>囫圇吞棗</strong>之感。</p><p>我個人已經讀完一輪，覺得確實有做到上述承諾。不過書中仍有少數比較進階的內容，我都是先跳過——建議你也如此。</p><p>附帶一提，本書的實作語言是 C，所以我閱讀時比較少看程式碼實作，而是著重於圖示和觀念的理解。</p><hr><p>教材部分，以上兩樣就足夠了！</p><p>有些人可能注意到，我並沒有推薦大多數刷題者所熟知的《<a href="https://www.tenlong.com.tw/products/9789865025526">提升程式設計師的面試力｜189道面試題目與解答</a>》，不是它不好，只是我還沒看而已😅</p><h2 id="前置準備二：刷題清單"><a href="#前置準備二：刷題清單" class="headerlink" title="前置準備二：刷題清單"></a>前置準備二：刷題清單</h2><p>有了書可以作為參考，接著就從第 1 題直接開刷了嗎？當然不是。</p><p>LeetCode 題目成百上千，題海茫茫，所以我們還需要「刷題清單」，它們能幫助我們更有效地學習。</p><p>尤其對於初學者，<strong>信心</strong>很重要！刷題的<strong>路徑</strong>也是。</p><p>這意謂著<strong>挫折感不能太多</strong>，不然容易半途而廢。</p><p>這些精心挑選的題目，涵蓋了各種基本且常見的演算法和資料結構，讓我們能夠系統性地提升自己，循序漸進。</p><p>這裡，我要介紹兩個廣受歡迎的題單：<a href="https://www.techinterviewhandbook.org/grind75/">Grind 75</a> 和 <a href="https://neetcode.io/practice">NeetCode 150</a>。</p><h3 id="Grind-75"><a href="#Grind-75" class="headerlink" title="Grind 75"></a>Grind 75</h3><blockquote><p>A modern Blind 75 you can customize, by the author of Blind 75.</p></blockquote><p>由 Blind 75——可能是史上最知名的 LeetCode 刷題清單——的作者，經過改良之後的新版。</p><p>用網站的方式呈現，而且加入更多功能！不再是固定的 75 題。而是可以讓你依照實際的準備時間，選擇更多（最多 169 題）或更少。</p><p>網站會依照<strong>你設定的條件</strong>，顯示你應該刷哪些題目，以獲得最高的刷題 CP 值。</p><p><img src="https://i.imgur.com/yy8wngp.png" alt="Grind 75"><span class="cap">Grind 75</span></p><p>這是我目前的刷題進度，我選擇了「Group by Weeks」、「Order by Difficulty」，這樣會從 Easy 題目開始一一列給你。</p><h3 id="NeetCode-150"><a href="#NeetCode-150" class="headerlink" title="NeetCode 150"></a>NeetCode 150</h3><blockquote><p>The NeetCode 150 is the Blind 75 plus 75 more problems. It’s a more beginner friendly and comprehensive list.</p></blockquote><p>和上述網站大同小異，這 150 題是以 Blind 75 為基礎加以擴充。</p><p>兩者主要的差別是，作者是個<a href="https://www.youtube.com/@NeetCode">知名 YouTuber</a>。所以這 150 題都有<strong>影片版的題解</strong>，可作為你學習上的參考。</p><p>如果只是單純想要題單，那 Grind 75 應該就足夠了。</p><hr><p>講完了前置準備，我們還有一件事要聊聊。</p><p>本文標題既然叫「<strong>刷題之『道』</strong>」，那就要展現一點<strong>獨特的價值觀</strong>，以符合「<strong>道</strong>」這個字的重量與意涵。</p><p>而我認為，這其中的道，關鍵就在於——<strong>如何與 AI 互動</strong>。</p><h2 id="AI-的兩種用法：快與慢"><a href="#AI-的兩種用法：快與慢" class="headerlink" title="AI 的兩種用法：快與慢"></a>AI 的兩種用法：快與慢</h2><p>我將 AI 的使用方式（互動模式） 分為兩種：「快速模式」和「深度模式」。</p><h3 id="快速模式"><a href="#快速模式" class="headerlink" title="快速模式"></a>快速模式</h3><p>所謂的「<strong>快速模式</strong>」，就是讓 AI 幫你做那些，人類做起來很慢、很無聊，但機器做卻非常輕鬆的活。</p><p>大概就是各式各樣<strong>需要自動化的繁瑣任務</strong>，比如整理報表、改錯字之類的。</p><p>不用說，這類的需求還挺多的。</p><p>甚至你有一個程式開發上的需求，想知道怎麼寫，直接問它，叫它給出程式碼——<strong>直接拿來用，而不管其中的原理</strong>。這也是一種「<strong>快</strong>」。</p><p>簡言之，所謂的「快」，就是讓 AI「<strong>代替</strong>」你做事——包括<strong>思考</strong>。</p><h3 id="深度模式"><a href="#深度模式" class="headerlink" title="深度模式"></a>深度模式</h3><p>AI 可以代替你做很多事——通常是那些你<strong>不喜歡做</strong>的事。</p><p>但它（就目前而言）還不能<strong>代替你學習</strong>。所以學習「本身」往往不適用於快速模式。</p><p>AI 確實已經學會了！<strong>但你還沒</strong>。</p><p>而「<strong>深度模式</strong>」則是與 AI 進行<strong>深入的對話與討論</strong>，以獲得<strong>更全面的理解</strong>。</p><p>這個模式下，我們要的<strong>不僅僅是答案</strong>，而是探索<strong>問題的本質</strong>和<strong>背後的原理</strong>。通過與 AI 進行深度交流，我們可以激發新的思考，發現自己思維中的盲點，最終達到<strong>更高的學習層次</strong>。</p><p>如同我在「<a href="/about/#AI-%E6%99%82%E4%BB%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%80%85">AI 時代的工作者</a>」中說的，這是我喜歡，也是我使用 AI 的<strong>主要方式</strong>。</p><blockquote><p>相關文章：<a href="/myth-of-ai-writing-efficiency/">AI 讓寫作變輕鬆了？我可不這麼認為</a></p></blockquote><hr><p>快速模式適用於需要<strong>立刻解決問題</strong>或<strong>取得資訊</strong>的情況，而深度模式則適合<strong>深刻的理解和學習</strong>。</p><p>在刷題過程中，我們可以靈活運用這兩種模式（但<strong>主軸</strong>仍是深度模式），以達到最佳的學習效果。</p><h2 id="我的刷題原則與價值觀"><a href="#我的刷題原則與價值觀" class="headerlink" title="我的刷題原則與價值觀"></a>我的刷題原則與價值觀</h2><p>如前所述，這一篇我們還不會講到具體的做法， 但可以先解釋一些<strong>原則與價值觀</strong>。</p><p>這是我目前刷題的基本原則：</p><ul><li>每天只刷一題。</li><li>每天只刷一小時。</li><li>每一題要盡可能深入理解、釐清細節，或嘗試不同的做法。</li></ul><p>這也是為何這個方法<strong>並不適合</strong>現在就要透過大量刷題來求職的人——它更多是為了長遠打算。</p><h3 id="多多益善？"><a href="#多多益善？" class="headerlink" title="多多益善？"></a>多多益善？</h3><p>你可能會覺得：「那我一天刷 2 小時，每小時刷 2 題，這樣一天就可以做 4 題了！」</p><p>這我不反對，但也不建議。因為太在意刷題的「<strong>數量</strong>」可能會導致淺層學習，無法真正掌握核心概念。</p><p>更重要的是，長時間、高強度的刷題，容易造成<strong>疲勞和厭煩感</strong>，反而降低學習效率——甚至<strong>放棄</strong>。</p><h3 id="少則得"><a href="#少則得" class="headerlink" title="少則得"></a>少則得</h3><p>我是這樣想的：顯然我不太熱衷於刷題，更喜歡做具體的專案。</p><p>所以<strong>這輩子</strong>可能就<strong>只會完成</strong> NeetCode 150 或 Grind 75 的最大題數（169 題）。對於「熟悉常見演算法與資料結構」這個命題，我認為這些題目已經足夠。</p><p>既然如此，求快就不是重點，數量當然也不是。</p><p>同時我們還要考慮到「<strong>複習</strong>」，畢竟好的學習肯定包含了<strong>有效的複習</strong>。做的題目不多，對複習反而是一大<strong>優勢</strong>，至少心理上不會那麼猶豫。</p><p>最後補充 Grind 75 作者在 <a href="https://www.techinterviewhandbook.org/grind75/faq">FAQ</a> 中的最後一道問答，很能表達我的想法：</p><blockquote><p>Will you add more questions in future?（問題）</p></blockquote><blockquote><p>You have time to do more than 169 questions?! <strong>The returns on doing questions beyond this list is diminishing and not very recommended.</strong> But if there’s high demand, I could add more.（回答）</p></blockquote><p>少則得，多則惑。</p><hr><h2 id="第一篇結語"><a href="#第一篇結語" class="headerlink" title="第一篇結語"></a>第一篇結語</h2><p>本文探討了刷題的準備工作、基本原則和價值觀。</p><p>我們介紹了一些有用的資源，比如《Hello 演算法》 或 Grind 75。還討論了為什麼我不打算追求刷題的數量，並解釋了背後的思維。</p><p>這些看法不免存在著個人偏好，但也有一定的普世價值。</p><p>每個人都有自己的學習風格和目標，對於希望深入理解演算法，而不僅僅是為了應付面試的人來說，本文應該會是個不錯的參考。</p><p>下一篇中，我將介紹具體的刷題策略和技巧，以及如何運用 AI 助手來最大化我們的學習成果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/g9WO9S7.jpeg&quot;&gt;&lt;/p&gt;
&lt;!-- ![picture 2](https://i.imgur.com/SsRLsJl.jpeg) --&gt;

&lt;blockquote&gt;
&lt;p&gt;歡迎使用我的刷題助手 GPTs——&lt;a href=&quot;https://chatgpt.com/g/g-6731960a3a2081909fe1975e05c034c4-li-li-kou-kou&quot;&gt;哩哩扣扣&lt;/a&gt; 🤖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;你刷過 LeetCode 嗎？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老實說，我一直很排斥刷題，因為感覺很「填鴨」，一點也不吸引人。&lt;/p&gt;
&lt;p&gt;這可能是因為這件事和求職面試掛勾，所以讓人有壓力；又或者我還沒有真正領略資料結構與演算法之美。&lt;/p&gt;
&lt;p&gt;總之，&lt;strong&gt;我很逃避！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但這次不同了。&lt;/p&gt;
&lt;p&gt;我找到了一個全新的方法，讓刷題&lt;strong&gt;不再那麼痛苦&lt;/strong&gt;，還幫助我盡可能理解每一道題——這都要歸功於 AI。&lt;/p&gt;
&lt;p&gt;我將分享如何透過 &lt;strong&gt;AI 輔助&lt;/strong&gt;來提升刷 LeetCode 的學習效果。關鍵是——它讓原本枯燥的過程（對我來說）&lt;strong&gt;變得有趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;當然，這樣的方法也有一些「&lt;strong&gt;限制&lt;/strong&gt;」，後續會提及。&lt;/p&gt;
&lt;p&gt;正文開始前，我必須先花一些篇幅來介紹整個系列的大綱。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/g9WO9S7.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="LeetCode" scheme="https://blog.kyomind.tw/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 30：系列回顧與完賽心得</title>
    <link href="https://blog.kyomind.tw/django-ninja-30/"/>
    <id>https://blog.kyomind.tw/django-ninja-30/</id>
    <published>2024-10-12T03:39:06.000Z</published>
    <updated>2024-10-25T03:49:53.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 30 篇。</p><p>系列最終章，我們的「<strong>Django Ninja 探險</strong>」將暫時告一段落。</p><p>這當然不是結束，畢竟 Django Ninja 還只是一個<strong>相對新的專案</strong>——我對它的未來充滿期待。</p><p>本文將分為兩個部分：</p><ol><li>回顧整個系列，檢視我們在各章中學到的概念與技術——盡可能只提重點。</li><li>分享我在寫作過程中的最大挑戰、對 Django Ninja 的期待，最後則是我的鐵人賽完賽心得。</li></ol><p>受限於篇幅，更多的<strong>幕後花絮、創作細節及個人心得</strong>，我將在與正賽無關的第 31、32 篇中，再行分享。</p><p>此外，我還會不定期更新「<strong>Django Ninja 番外篇</strong>」，補充正篇中未能詳述的內容。有興趣的讀者，<strong>歡迎<a href="https://ithelp.ithome.com.tw/users/20167825/ironman/7451">訂閱本系列</a>或<a href="/subscribe/">本站 email</a>。</strong></p><p>話不多說，我們直接開始。</p><hr><h2 id="一、系列目標與主要學習成果"><a href="#一、系列目標與主要學習成果" class="headerlink" title="一、系列目標與主要學習成果"></a>一、系列目標與主要學習成果</h2><p>回到第 1 篇的開頭，整個系列的目標是：</p><blockquote><p>在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的<strong>基礎實作</strong>，透過<strong>文字教學</strong>與<strong>範例專案</strong>的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。</p></blockquote><p>沒錯，而我們具體做了哪些事呢？</p><h3 id="主要學習成果"><a href="#主要學習成果" class="headerlink" title="主要學習成果"></a>主要學習成果</h3><p>透過本系列，讀者掌握了以下 Django Ninja 核心技能：</p><ol><li>設定 Django Ninja 路由。（卷 7-8）</li><li>處理各種 HTTP 請求及參數——路徑參數、查詢參數、body。（卷 9-12）</li><li>使用 Schema 設計和定義 API 回應的資料結構。（卷 13-16）</li><li>從專案程式碼自動產生 API 文件、透過 Pydantic 驗證資料、有效處理系統拋出的錯誤。（卷 17-22）</li><li>靈活運用進階功能，包括檔案上傳、分頁和資料過濾。（卷 23-27）</li></ol><p>還有最後的身分認證與單元測試。可說是一段<strong>相當完整的旅程</strong>。</p><span id="more"></span><hr><p>其中的精妙與困難，這裡不再贅述。</p><p>讓我們一起回顧，我認為學習 Django Ninja 的一些重點，以及它帶來的<strong>滿足感</strong>——這很重要！</p><h2 id="二、各章節重點回顧"><a href="#二、各章節重點回顧" class="headerlink" title="二、各章節重點回顧"></a>二、各章節重點回顧</h2><p>我們只挑各章節中<strong>特別值得一提</strong>的部分。有我<strong>個人的觀點</strong>。</p><h3 id="第二章：範例專案與環境設定"><a href="#第二章：範例專案與環境設定" class="headerlink" title="第二章：範例專案與環境設定"></a><strong>第二章：範例專案與環境設定</strong></h3><p>本章最重要的，莫過於對「Python 現代開發工具」的介紹。再次推薦「<a href="https://blog.wei-lee.me/posts/tech/2020/02/python-table-manners-series/">Python Table Manners</a>」系列。</p><p>從 Poetry 到 Mypy，我認為這些工具都是現代專案中的<strong>必備要素</strong>。它們各有替代品，你可以選擇自己偏好的工具，只要確保這些要素都已整合到開發流程中。</p><p>我相信，無論 AI 如何發展，專案的「<strong>基礎建設</strong>」總是不可少的。</p><h3 id="第三章第一節：路由"><a href="#第三章第一節：路由" class="headerlink" title="第三章第一節：路由"></a>第三章第一節：路由</h3><p>Django Ninja 的路由設定與傳統的 Django、Django REST framework 有<strong>很大的不同</strong>。</p><p>這部分，後起之秀基本上都向 Flask 首創的「<strong>路由裝飾器</strong>」看齊——優秀的設計，值得相互借鑑、學習🫡</p><p>新寫法不僅更直覺、簡單，還減少了路由設定<strong>分散</strong>在不同檔案的<strong>窘境</strong>。</p><p>不過，路由也因此成了一開始學習 Django Ninja 的<strong>小小門檻</strong>。所以我花了足足兩篇，比較兩者的差異，讓你能更清楚其中的思路與考慮。</p><h3 id="第三章第三節：HTTP-回應"><a href="#第三章第三節：HTTP-回應" class="headerlink" title="第三章第三節：HTTP 回應"></a>第三章第三節：HTTP 回應</h3><p>表面上是講 HTTP 回應，其實重點在介紹 Django Ninja Schema——也就是 Pydantic BaseModel。</p><p>說本節是「<strong>Pydantic 入門</strong>」，一點也不為過。</p><p>而且，對 Pydantic 的了解，其重要性還延伸至 API 文件、資料驗證等後續章節。可說是一切的基礎。</p><p>Django Ninja 用 Schema 來<strong>組織與序列化</strong> HTTP 回應，這與 Django REST framework 使用的<strong>序列化器</strong>，<strong>本質上並無區別</strong>。</p><p>但兩者在<strong>使用思維上的差異</strong>，卻帶給我<strong>截然不同</strong>的體驗。主要見解我已寫在〈卷 15：回應（三）為何不用 ModelSchema？——相比 DRF，我更偏愛 Django Ninja 的理由〉，值得你再三回味。</p><h3 id="第四章：API-文件"><a href="#第四章：API-文件" class="headerlink" title="第四章：API 文件"></a>第四章：API 文件</h3><p>這還有什麼好說的呢？太關鍵了！</p><p>如果沒有「依程式碼、type hints 自動產生 API 文件」這個<strong>殺手級功能</strong>，習慣 Django REST framework 的開發者如我，怎麼會有動力再學習一個<strong>定位類似</strong>的新框架？</p><p><strong>懶就是一切的動力！</strong></p><h3 id="第五章：資料驗證與錯誤處理"><a href="#第五章：資料驗證與錯誤處理" class="headerlink" title="第五章：資料驗證與錯誤處理"></a>第五章：資料驗證與錯誤處理</h3><p>這一章是我的血與淚😂</p><p>Django Ninja 的資料驗證與錯誤處理方式，和 Django REST framework <strong>很不一樣</strong>。更讓我頭痛的是，之前工作中我並非以「最正規」的方式實踐——仍受到 Django REST framework 開發習慣的影響。</p><p>那時還想說：「這也太難用了吧！」——原來是我自己誤解了。為了寫好這 4 篇，我幾乎是<strong>重新學習</strong>。不得不說，有一種<strong>豁然開朗</strong>的感覺。</p><p>因此，你在本系列看到的實作方式，應該是相當合理、道地的用法。結合經驗，那些坑我都幫你踩過了，請勿擔心。</p><hr><p>接下來是<strong>個人心得</strong>部分。</p><h2 id="三、寫作上的最大挑戰"><a href="#三、寫作上的最大挑戰" class="headerlink" title="三、寫作上的最大挑戰"></a>三、寫作上的最大挑戰</h2><p>我覺得，整個系列在創作上的<strong>最大挑戰</strong>，就是要盡可能<strong>搭配</strong> <a href="https://github.com/kyomind/Django-Ninja-Tutorial">GitHub 專案</a>中的<strong>程式碼</strong>，來為文章提供<strong>稱職且連貫的範例</strong>。</p><p>（不用說，這個專案非常歡迎「<strong>來自你的星星</strong>」唷🌟）</p><p>這比單純的舉例要<strong>麻煩許多</strong>，我必須事先規劃整個系列的內容進度，思考 API 實作如何跟每一篇的主題<strong>契合</strong>，讓人有「<strong>帶入感</strong>」。</p><p>此外，還得考慮到敘事上的<strong>連貫性</strong>——程式碼要<strong>循序漸進，從簡單到複雜</strong>，而不能反過來。這樣讀者才能夠順暢地跟著專案一起學習。</p><p>這樣的規劃不僅需要技術知識，更多的是教學思維與<strong>讀者意識</strong>——知道讀者可能會在哪裡「卡關」。</p><p>整體而言，是個<strong>極具挑戰但也非常有趣</strong>的過程。</p><hr><h2 id="四、我對-Django-Ninja-的評價與期待"><a href="#四、我對-Django-Ninja-的評價與期待" class="headerlink" title="四、我對 Django Ninja 的評價與期待"></a>四、我對 Django Ninja 的評價與期待</h2><p>Django Ninja 是烏克蘭開發者 <a href="https://github.com/vitalik">Vitaliy Kucheryaviy</a> 一人維護的開源專案，更新的頻率不高，通常無法立刻回應用戶們的期待。</p><p>但我想說：「如果可以，我真的不願再回去寫 Django REST framework 了。」</p><p>原因只有一個，就是第 15 篇提到的——「<strong>明確優於隱晦</strong>」（Explicit is better than implicit）。</p><p>Django Ninja 也許沒讓開發更「快」，但絕對更透明、更可控。</p><p>我相信，從長遠來看，這種<strong>透明與可控</strong>，能為我們省下的 debug 時間，遠不是簡單的「快」可以比擬的。</p><h3 id="未來期待"><a href="#未來期待" class="headerlink" title="未來期待"></a>未來期待</h3><p>隨著 Django 本身對<strong>非同步</strong>（async）的支援日益增加，我相信 Django Ninja 的潛力正被逐步釋放。</p><p>我期待，在不久的將來，當人們談到「<strong>用 Django 寫 API</strong>」時，不再只有想到 Django REST framework，還會提及這個<strong>強而有力的新選擇——Django Ninja</strong>。</p><hr><h2 id="五、完賽心得"><a href="#五、完賽心得" class="headerlink" title="五、完賽心得"></a>五、完賽心得</h2><p>呼！終於寫完了，這個過程比我想像的更加漫長。</p><p>從 9 月初到雙十節，整整 40 天（含開賽前的備稿），我每天早上醒來就是寫作，全心全意投入到這場盛宴當中。最終，我交出了一份自己也覺得滿意的作品。</p><p>在我看來，寫作的滿足感在於「<strong>提供價值、發揮影響力</strong>」。這份價值不僅是對讀者，也包括對作者自己——透過這 30 篇文章創作，我對 Django Ninja 的理解又增進許多。</p><p>希望這個系列能為你帶來些許價值，讓你在接下來的開發旅程中更加得心應手。</p><p>每一次的寫作都是一次學習，而每一次的學習都是一次成長。這個系列或許已經結束，但我們的軟體工程師之路，還遠遠沒有。</p><p>而且，如果可以，我希望這能成為一生的追求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 30 篇。&lt;/p&gt;
&lt;p&gt;系列最終章，我們的「&lt;strong&gt;Django Ninja 探險&lt;/strong&gt;」將暫時告一段落。&lt;/p&gt;
&lt;p&gt;這當然不是結束，畢竟 Django Ninja 還只是一個&lt;strong&gt;相對新的專案&lt;/strong&gt;——我對它的未來充滿期待。&lt;/p&gt;
&lt;p&gt;本文將分為兩個部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回顧整個系列，檢視我們在各章中學到的概念與技術——盡可能只提重點。&lt;/li&gt;
&lt;li&gt;分享我在寫作過程中的最大挑戰、對 Django Ninja 的期待，最後則是我的鐵人賽完賽心得。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;受限於篇幅，更多的&lt;strong&gt;幕後花絮、創作細節及個人心得&lt;/strong&gt;，我將在與正賽無關的第 31、32 篇中，再行分享。&lt;/p&gt;
&lt;p&gt;此外，我還會不定期更新「&lt;strong&gt;Django Ninja 番外篇&lt;/strong&gt;」，補充正篇中未能詳述的內容。有興趣的讀者，&lt;strong&gt;歡迎&lt;a href=&quot;https://ithelp.ithome.com.tw/users/20167825/ironman/7451&quot;&gt;訂閱本系列&lt;/a&gt;或&lt;a href=&quot;/subscribe/&quot;&gt;本站 email&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;話不多說，我們直接開始。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、系列目標與主要學習成果&quot;&gt;&lt;a href=&quot;#一、系列目標與主要學習成果&quot; class=&quot;headerlink&quot; title=&quot;一、系列目標與主要學習成果&quot;&gt;&lt;/a&gt;一、系列目標與主要學習成果&lt;/h2&gt;&lt;p&gt;回到第 1 篇的開頭，整個系列的目標是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的&lt;strong&gt;基礎實作&lt;/strong&gt;，透過&lt;strong&gt;文字教學&lt;/strong&gt;與&lt;strong&gt;範例專案&lt;/strong&gt;的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;沒錯，而我們具體做了哪些事呢？&lt;/p&gt;
&lt;h3 id=&quot;主要學習成果&quot;&gt;&lt;a href=&quot;#主要學習成果&quot; class=&quot;headerlink&quot; title=&quot;主要學習成果&quot;&gt;&lt;/a&gt;主要學習成果&lt;/h3&gt;&lt;p&gt;透過本系列，讀者掌握了以下 Django Ninja 核心技能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定 Django Ninja 路由。（卷 7-8）&lt;/li&gt;
&lt;li&gt;處理各種 HTTP 請求及參數——路徑參數、查詢參數、body。（卷 9-12）&lt;/li&gt;
&lt;li&gt;使用 Schema 設計和定義 API 回應的資料結構。（卷 13-16）&lt;/li&gt;
&lt;li&gt;從專案程式碼自動產生 API 文件、透過 Pydantic 驗證資料、有效處理系統拋出的錯誤。（卷 17-22）&lt;/li&gt;
&lt;li&gt;靈活運用進階功能，包括檔案上傳、分頁和資料過濾。（卷 23-27）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;還有最後的身分認證與單元測試。可說是一段&lt;strong&gt;相當完整的旅程&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Django REST framework" scheme="https://blog.kyomind.tw/tags/Django-REST-framework/"/>
    
  </entry>
  
  <entry>
    <title>單元測試——使用 Test Client 與 pytest 測試 API</title>
    <link href="https://blog.kyomind.tw/django-ninja-29/"/>
    <id>https://blog.kyomind.tw/django-ninja-29/</id>
    <published>2024-10-11T02:48:06.000Z</published>
    <updated>2024-11-22T14:32:00.439Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 29 篇。</p><p>「請問你們的專案有單元測試嗎？」</p><p>面試中如果你提出這個問題，可能會讓面試官面有難色。</p><p>測試的重要性，大部分開發者都心知肚明。只是願意認真對待的人未必很多。</p><p>但如果真心想提高程式碼品質、減少 bug，讓專案更容易維護，那單元測試依舊是<strong>不可或缺</strong>的工具。</p><p>良好的測試不僅能幫助我們<strong>及早發現問題</strong>，還能在專案<strong>重構或新增功能</strong>時，確保現有的功能不會被破壞。</p><p>雖然寫測試會增加初期的開發時間，而且維護上也需要花費心力——這本來就不是一件輕鬆的事。但長期而言，它能為專案帶來持續的健全與穩定性。</p><p>所以，我們還是好好寫測試吧！</p><hr><h2 id="本文大綱"><a href="#本文大綱" class="headerlink" title="本文大綱"></a>本文大綱</h2><p>這是整個系列中唯一一篇有全文大綱的教學。</p><p>原因是，本文<strong>要提及的事項較多</strong>，畢竟單元測試這麼大的主題，怎麼可能靠一篇 2500 字的文章說完。限於篇幅，無法一一詳談——但也不能直接省略。</p><p>所以需要有一個供讀者鳥瞰的全文輪廓，讓你更容易了解、吸收。大綱如下：</p><ol><li>單元測試的理想與現實。</li><li>Django API 測試重要概念說明。<ul><li>Test Client 的意義與用途。</li><li>pytest 和 pytest-django 簡介。</li><li>pytest fixtures 與測試函式。</li></ul></li><li>測試程式碼的實作與解說。</li><li>結語。</li></ol><p>簡單來說，本文不會講解所有的程式碼改動，而是在<strong>必要時提及</strong>。其餘部分，由我直接實作並收錄在範例專案中，讓讀者自行參考。</p><p>在有限的篇幅中，帶你了解<strong>整體概念</strong>比關注細節更重要。當你掌握了基本概念，再去看程式碼會更加得心應手。</p><p>有關單元測試的<strong>更多討論</strong>，歡迎參考這篇心得〈<a href="https://blog.kyomind.tw/python-craftsman-02/">為什麼你應該寫單元測試——《Python 工匠》筆記</a>〉。這是一本立論紮實的好書，相信你會有所收獲。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/20">這個 PR</a>。</p><span id="more"></span><hr><h2 id="一、單元測試的理想與現實"><a href="#一、單元測試的理想與現實" class="headerlink" title="一、單元測試的理想與現實"></a>一、單元測試的理想與現實</h2><p>我覺得，討論單元測試，就必須先<strong>直面現實</strong>。</p><p>在軟體測試領域，充斥著各種關於測試的狂熱與教條主義，有時反而讓人卻步。</p><h3 id="單元測試的理想"><a href="#單元測試的理想" class="headerlink" title="單元測試的理想"></a>單元測試的理想</h3><p>理論上，撰寫單元測試應該是每位開發者都要做的事（我確實是這麼想的） 。</p><p>此外，還有「<a href="https://zh.wikipedia.org/zh-tw/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">測試驅動開發</a>（TDD）」的理念，這是一種以測試為主導的開發模式，要求在撰寫功能程式碼之前，先撰寫測試。</p><p>甚至有少部分人認為，測試覆蓋率就是要 100%。因為如果不是 100%，比如 70%，那我們就可以問：「為什麼不是其它數字？」</p><h3 id="現實：大部分人不在乎那些理想"><a href="#現實：大部分人不在乎那些理想" class="headerlink" title="現實：大部分人不在乎那些理想"></a>現實：大部分人不在乎那些理想</h3><p>然而，現實中，我們很少能看到理想的測試——甚至常常沒有測試。</p><p>現實中的專案因為時間、資源等諸多限制，往往不願投入心力去撰寫測試。</p><p>一些老舊專案，由於前期沒有測試基礎，後續要再補上測試變得更加困難（畢竟都亂成一團💩了），這就是我們常說的「<strong>技術債</strong>」。</p><p>再者，過度的「測試理想主義」有時也會讓初學者<strong>望而卻步</strong>。許多新手在接觸測試時，會擔心自己無法達到 100% 的覆蓋率，因此對測試產生了<strong>抗拒</strong>或<strong>懷疑</strong>。</p><p>這樣的完美主義往往有害無利，我們需要在理想與現實之間找到一個<strong>折衷</strong>。</p><h3 id="折衷：務實的測試策略"><a href="#折衷：務實的測試策略" class="headerlink" title="折衷：務實的測試策略"></a>折衷：務實的測試策略</h3><p>在實際開發中，我們應秉持著一個<strong>實用且可行</strong>的測試策略，重點放在測試專案中最核心的功能，例如 API 的呼叫與 200 回應。</p><p>多數情況下，只要能覆蓋 <strong>60-70%</strong> 功能，就已經能<strong>明顯提高</strong>專案程式碼的品質，並為後續開發提供一定的<strong>安全感</strong>——這真的很重要。</p><p>不必追求完美的測試覆蓋率，只要<strong>願意開始行動</strong>，測試就能發揮它<strong>應有的價值</strong>。</p><hr><h2 id="二、Django-API-測試重要概念說明"><a href="#二、Django-API-測試重要概念說明" class="headerlink" title="二、Django API 測試重要概念說明"></a>二、Django API 測試重要概念說明</h2><p>回到專案本身。</p><p>雖然本文無法提及太多 API 單元測試的具體細節，但重要的概念仍不可略過。以下一一說明。</p><h3 id="Test-Client-的意義與用途"><a href="#Test-Client-的意義與用途" class="headerlink" title="Test Client 的意義與用途"></a>Test Client 的意義與用途</h3><p>Test client 對 API 的測試至關重要，因為它能模擬真實的 HTTP 請求——注意，只是模擬。</p><p>API 測試和一般的程式碼測試<strong>略有不同</strong>，一般的測試，只要寫好相關的測試函式、邏輯並執行即可。但在 API 測試中，還需要一個「<strong>假的客戶端</strong>」來模擬請求的發送。</p><p>手動測試 API，我們通常會使用 API client，比如 Postman。而自動化的單元測試，則需要把這個「假的客戶端」直接寫在測試程式碼中——即 test client。</p><p>它相當於一個「<strong>專案內部的 API client</strong>」，而且能<strong>自動執行</strong>。</p><p>Django Ninja 有提供自己的 <a href="https://github.com/vitalik/django-ninja/blob/master/ninja/testing/client.py">test client</a>，但我建議你先不要用，因為它還<strong>不夠健全</strong>。</p><p>在範例專案中，我使用的是 Django 內建的 <a href="https://docs.djangoproject.com/en/5.1/topics/testing/tools/#the-test-client">test client</a>——歷史悠久、穩定可靠。</p><h3 id="pytest-簡介"><a href="#pytest-簡介" class="headerlink" title="pytest 簡介"></a>pytest 簡介</h3><p><a href="https://docs.pytest.org/en/stable/">pytest</a>（對，它的 p 是小寫，同 <a href="https://github.com/pyenv/pyenv">pyenv</a>）是一個廣受歡迎的 Python 測試框架，擁有自己的<strong>生態系</strong>——包含大量實用的外掛。</p><p>相較於 Python 內建的<code>unittest</code>模組，pytest 的<strong>語法更直觀</strong>、使用上的靈活性更好。尤其是它的 <strong>fixtures</strong>、<strong>參數化測試</strong>等功能，讓測試的撰寫更加簡單、高效。</p><h3 id="pytest-django"><a href="#pytest-django" class="headerlink" title="pytest-django"></a>pytest-django</h3><p><a href="https://pytest-django.readthedocs.io/en/latest/">pytest-django</a> 是一個專為 Django 設計的 pytest 整合套件。它提供了豐富的 Django 整合功能，包括許多內建的 fixtures 和實用的裝飾器。</p><p>其中又以<code>@pytest.mark.django_db</code>裝飾器最常用，它能自動管理測試過程中的<strong>資料庫狀態</strong>。</p><p>它讓 pytest 在每次測試執行前自動建立一個全新的資料庫，並在測試結束後刪除。這確保每次測試的<strong>環境一致</strong>，防止<strong>資料殘留</strong>導致的測試結果不準確。</p><h3 id="pytest-Fixtures-與測試函式"><a href="#pytest-Fixtures-與測試函式" class="headerlink" title="pytest Fixtures 與測試函式"></a>pytest Fixtures 與測試函式</h3><p><a href="https://docs.pytest.org/en/stable/fixture.html">Fixtures</a> 是 pytest 提供的一種<strong>機制</strong>，用來<strong>設定</strong>測試所需的<strong>初始環境</strong>。它們本質上是<strong>函式</strong>，但用法卻不像一般的函式。只要事先定義好，即可在測試函式中<strong>作為參數引用</strong>。</p><p>Fixtures 可以定義在 Django app 的<code>tests.py</code>中，但我們通常將它們放在可供全專案共用的<code>conftest.py</code>模組。</p><p>測試 API 時，我們經常需要一些初始資料，例如使用者、產品等。這些資料可以<strong>透過 fixtures 自動產生</strong>，無需每次手動重建。</p><p>如此一來，撰寫測試的效率提高，還避免了重複的狀態設定。</p><hr><h2 id="五、測試程式碼實作與解說"><a href="#五、測試程式碼實作與解說" class="headerlink" title="五、測試程式碼實作與解說"></a>五、測試程式碼實作與解說</h2><p>本篇我實作 3 個 fixture 和 3 個測試函式，它們都與 user 有關，容我<strong>擇要</strong>解說其中的細節。</p><h3 id="強大而靈活的-pytest-Fixtures"><a href="#強大而靈活的-pytest-Fixtures" class="headerlink" title="強大而靈活的 pytest Fixtures"></a>強大而靈活的 pytest Fixtures</h3><p>這是專案的 3 個 fixture，定義在<code>conftest.py</code>中：（為減少篇幅我省略了 docstring）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> Client</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;session&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client</span>() -&gt; Client:</span><br><span class="line">    <span class="keyword">return</span> Client()</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>() -&gt; User:</span><br><span class="line">    <span class="keyword">return</span> User.objects.create_user(</span><br><span class="line">        username=<span class="string">&#x27;testuser&#x27;</span>,</span><br><span class="line">        email=<span class="string">&#x27;testuser@example.com&#x27;</span>,</span><br><span class="line">        password=<span class="string">&#x27;testpassword123&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticated_client</span>(<span class="params">client: Client, user: User</span>) -&gt; Client:</span><br><span class="line">    response = client.post(</span><br><span class="line">        <span class="string">&#x27;/users/login/&#x27;</span>,</span><br><span class="line">        &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;testuser&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;testpassword123&#x27;</span>&#125;,</span><br><span class="line">        content_type=<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">    <span class="comment"># 設定登入後的 cookies</span></span><br><span class="line">    client.cookies.update(response.cookies)</span><br><span class="line">    <span class="keyword">return</span> client</span><br></pre></td></tr></table></figure><p>在這段程式碼中：</p><ol><li><code>client</code>：提供了一個可以用來模擬發送請求的 Django test client。（未認證）</li><li><code>user</code>：自動建立一個測試用的使用者，供測試函式甚至<strong>其它 fixture</strong> 引用。</li><li><code>authenticated_client</code>：引用上述的 2 個 fixture，組合並模擬了一個<strong>登入過的 client</strong>，這樣才能測試那些有「認證保護」的 API。</li></ol><p>Fixtures 的<strong>定義、組合與使用</strong>，是 pytest 的<strong>一大特色</strong>。</p><p>不僅能簡化測試的環境設定，還能提高測試程式碼的可讀性——把<strong>測試狀態</strong>和<strong>測試邏輯</strong>分開，這也是一種「<strong>關注點分離</strong>」。</p><p>在實際的測試函式中，我們只需要將所需的 fixtures <strong>作為參數傳入</strong>，pytest 會<strong>自動處理</strong>它們的<strong>初始化和清理</strong>工作。</p><p>這種設計大大減少了重複程式碼，讓測試更加<strong>專注於</strong> API 的邏輯驗證而非環境設定。</p><h3 id="測試函式"><a href="#測試函式" class="headerlink" title="測試函式"></a>測試函式</h3><p>最後是測試函式，我們看其中的兩個就好：（我省略了參數的 type hints，讓你聚焦於 fixtures 本身）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_get_users</span>(<span class="params">authenticated_client</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    測試取得所有使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = authenticated_client.get(<span class="string">&#x27;/users/&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_login_user</span>(<span class="params">client, user</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    測試登入使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = client.post(</span><br><span class="line">        <span class="string">&#x27;/users/login/&#x27;</span>,</span><br><span class="line">        data=&#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;testuser&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;testpassword123&#x27;</span>&#125;,</span><br><span class="line">        content_type=<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure><p>選擇這兩個函式是有<strong>教學用意</strong>的：</p><ol><li><code>test_login_user</code>函式測試「使用者登入」API，該 API 是給「<strong>未登入</strong>」的用戶存取，所以引用<strong>一般的 client</strong>（未認證）即可。<ul><li>函式也引用了 user fixture，因為登入成功的前提是：該用戶已經「<strong>存在</strong>」。</li><li>而 user fixture 的作用正是在測試開始前，<strong>先建立</strong>該用戶。</li></ul></li><li><code>test_get_users</code>測試的是「<strong>有認證保護</strong>」的 API，需要登入才能存取，所以我們引用了<code>authenticated_client</code>。<ul><li>這個測試函式「<strong>只有</strong>」引用 authenticated_client，但實際的測試結果會是：清單中存在一個用戶。（程式碼不包含這部分）</li><li>因為 authenticated_client 引用了 user 和 client 這兩個 fixture。所以<strong>只要</strong>引用了authenticated_client，<strong>就相當於引用了上述二者</strong>。</li></ul></li></ol><p>該「<strong>引用</strong>」哪些 fixture，就看各函式需要什麼樣的<strong>測試狀態與條件</strong>。</p><p>Fixtures 本身可以重複使用，這樣的設計讓測試本身也非常「<strong>模組化</strong>」——這是 pytest 如此受歡迎的原因之一。</p><h3 id="執行單元測試"><a href="#執行單元測試" class="headerlink" title="執行單元測試"></a>執行單元測試</h3><p>最後，來跑一下測試！</p><p>你可以在專案的根目錄直接使用<code>pytest</code>指令，或透過 VS Code 的 Testing UI 來執行單元測試：</p><p><img src="https://i.imgur.com/OtM4FXn.png" alt="VS Code - Testing"><span class="cap">VS Code - Testing</span></p><p>Beautiful！</p><hr><h2 id="六、結語"><a href="#六、結語" class="headerlink" title="六、結語"></a>六、結語</h2><p>理想與現實總有差距，透過務實的測試策略，我們可以在不過度追求完美的前提下，為專案提供足夠的品質保證。</p><p>Test client 和 pytest 等工具，讓 API 測試變得簡單、有條理。測試覆蓋率不必是百分之百，只要能達到<strong>一定水準</strong>，就可以為開發過程帶來<strong>巨大的助力</strong>。</p><p>本系列教學<strong>已接近尾聲</strong>。我們探討了 Django Ninja 的核心功能與進階特性——從路由設計到單元測試。這是一個<strong>辛苦但充實</strong>的過程——無論對你我而言。</p><p>下一篇，也就是最後一篇。我們要簡單回顧整個系列，並分享我在本次鐵人賽的創作與完賽心得。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 29 篇。&lt;/p&gt;
&lt;p&gt;「請問你們的專案有單元測試嗎？」&lt;/p&gt;
&lt;p&gt;面試中如果你提出這個問題，可能會讓面試官面有難色。&lt;/p&gt;
&lt;p&gt;測試的重要性，大部分開發者都心知肚明。只是願意認真對待的人未必很多。&lt;/p&gt;
&lt;p&gt;但如果真心想提高程式碼品質、減少 bug，讓專案更容易維護，那單元測試依舊是&lt;strong&gt;不可或缺&lt;/strong&gt;的工具。&lt;/p&gt;
&lt;p&gt;良好的測試不僅能幫助我們&lt;strong&gt;及早發現問題&lt;/strong&gt;，還能在專案&lt;strong&gt;重構或新增功能&lt;/strong&gt;時，確保現有的功能不會被破壞。&lt;/p&gt;
&lt;p&gt;雖然寫測試會增加初期的開發時間，而且維護上也需要花費心力——這本來就不是一件輕鬆的事。但長期而言，它能為專案帶來持續的健全與穩定性。&lt;/p&gt;
&lt;p&gt;所以，我們還是好好寫測試吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文大綱&quot;&gt;&lt;a href=&quot;#本文大綱&quot; class=&quot;headerlink&quot; title=&quot;本文大綱&quot;&gt;&lt;/a&gt;本文大綱&lt;/h2&gt;&lt;p&gt;這是整個系列中唯一一篇有全文大綱的教學。&lt;/p&gt;
&lt;p&gt;原因是，本文&lt;strong&gt;要提及的事項較多&lt;/strong&gt;，畢竟單元測試這麼大的主題，怎麼可能靠一篇 2500 字的文章說完。限於篇幅，無法一一詳談——但也不能直接省略。&lt;/p&gt;
&lt;p&gt;所以需要有一個供讀者鳥瞰的全文輪廓，讓你更容易了解、吸收。大綱如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;單元測試的理想與現實。&lt;/li&gt;
&lt;li&gt;Django API 測試重要概念說明。&lt;ul&gt;
&lt;li&gt;Test Client 的意義與用途。&lt;/li&gt;
&lt;li&gt;pytest 和 pytest-django 簡介。&lt;/li&gt;
&lt;li&gt;pytest fixtures 與測試函式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;測試程式碼的實作與解說。&lt;/li&gt;
&lt;li&gt;結語。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;簡單來說，本文不會講解所有的程式碼改動，而是在&lt;strong&gt;必要時提及&lt;/strong&gt;。其餘部分，由我直接實作並收錄在範例專案中，讓讀者自行參考。&lt;/p&gt;
&lt;p&gt;在有限的篇幅中，帶你了解&lt;strong&gt;整體概念&lt;/strong&gt;比關注細節更重要。當你掌握了基本概念，再去看程式碼會更加得心應手。&lt;/p&gt;
&lt;p&gt;有關單元測試的&lt;strong&gt;更多討論&lt;/strong&gt;，歡迎參考這篇心得〈&lt;a href=&quot;https://blog.kyomind.tw/python-craftsman-02/&quot;&gt;為什麼你應該寫單元測試——《Python 工匠》筆記&lt;/a&gt;〉。這是一本立論紮實的好書，相信你會有所收獲。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/20&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="單元測試" scheme="https://blog.kyomind.tw/tags/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"/>
    
    <category term="pytest" scheme="https://blog.kyomind.tw/tags/pytest/"/>
    
  </entry>
  
  <entry>
    <title>身分認證——Session 認證與全域設定</title>
    <link href="https://blog.kyomind.tw/django-ninja-28/"/>
    <id>https://blog.kyomind.tw/django-ninja-28/</id>
    <published>2024-10-10T01:42:57.000Z</published>
    <updated>2024-10-24T10:02:55.937Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 28 篇。</p><p>歡迎來到第七章！本章總共有兩篇內容：</p><ul><li>卷 28：身分認證——Session 認證與全域設定</li><li>卷 29：單元測試——使用 Test Client 與 pytest 測試 API</li></ul><p>這些主題的核心功能，<strong>並非由 Django Ninja 實作</strong>，但框架仍提供了<strong>一定程度的整合</strong>。並且，這些功能對於任何 Django 專案來說，都至關重要。</p><p>本文介紹幾乎所有 API 專案都需要的——<strong>身分認證</strong>（<a href="https://django-ninja.dev/guides/authentication/">Authentication</a>）。</p><p>我們將探討如何在 Django Ninja 中利用 Django 內建的 session-based 認證，實現完整的登入驗證功能，並進一步說明如何設定<strong>全域認證</strong>，以減少程式碼的重複。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/19">這個 PR</a>。</p><hr><h2 id="認證的兩個層次"><a href="#認證的兩個層次" class="headerlink" title="認證的兩個層次"></a>認證的兩個層次</h2><p>進入實作前，我們要先了解，所謂的<strong>身分認證</strong>，究竟代表什麼。</p><p>以「帳號密碼 + session 認證」為例，身分認證的範圍主要涵蓋<strong>兩個階段</strong>。</p><p>首先，當使用者透過帳號密碼進行登入時，系統會檢查這些內容、確認身分<strong>合法</strong>。登入成功後，系統會將使用者資訊（比如用戶 id）儲存至 session，以<strong>維持登入狀態</strong>。</p><p>這是<strong>登入時的認證</strong>，也是我們最常說的認證。（<strong>狹義的認證</strong>）</p><p>接著，當使用者嘗試存取受「<strong>認證保護</strong>」的 API 時，系統會檢查 session 並確認身分，確保每個 API 請求都來自<strong>合法登入</strong>的使用者。</p><p>簡言之：</p><ul><li>第一階段：初次登入時的身分確認。</li><li>第二階段：後續請求時的身分確認。</li></ul><p>兩個層次相輔相成、一體兩面，確保服務能夠在使用者<strong>登入</strong>和<strong>後續操作</strong>中，提供適當的安全保障。</p><span id="more"></span><hr><h2 id="實作「使用者登入」API"><a href="#實作「使用者登入」API" class="headerlink" title="實作「使用者登入」API"></a>實作「使用者登入」API</h2><p>了解了上述兩個層次後，我們要先來實作「<strong>狹義</strong>」的認證——也就是<strong>登入驗證</strong>本身。</p><p>我們將建立一個「使用者登入」API，並直接透過 Django 的<code>authenticate</code>和<code>login</code>函式處理<strong>帳號密碼驗證</strong>和<strong>登入狀態</strong>——非常方便！</p><p><code>authenticate</code>用來<strong>驗證</strong>使用者輸入的帳號（<code>username</code>）和密碼是否正確，<code>login</code>則將使用者的登入狀態<strong>儲存</strong>至 session。</p><h3 id="程式碼實作"><a href="#程式碼實作" class="headerlink" title="程式碼實作"></a>程式碼實作</h3><p>先新增一個登入請求 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/schemas.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    username: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line">    password: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;password123&#x27;</span>])</span><br></pre></td></tr></table></figure><p>然後是 view 函式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate, login</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> user.schemas <span class="keyword">import</span> CreateUserRequest, LoginRequest</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/login/&#x27;</span>, summary=<span class="string">&#x27;登入使用者&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_user</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest, payload: LoginRequest</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    登入使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    user = authenticate(</span><br><span class="line">        request,</span><br><span class="line">        username=payload.username,</span><br><span class="line">        password=payload.password</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        login(request, user)  <span class="comment"># 將使用者登入狀態儲存至 session</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;登入成功&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">401</span>, <span class="string">&#x27;帳號或密碼錯誤&#x27;</span>)</span><br></pre></td></tr></table></figure><p>非常簡單！</p><p>附帶一提，我不太喜歡程式中有「不必要」的<code>else</code>，此時的寫法仍不盡理想——因為<code>else</code><strong>完全可以省略</strong>。</p><p>在最新的程式碼中，你可以看到我已改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = authenticate(...)</span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">401</span>, <span class="string">&#x27;帳號或密碼錯誤&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login(request, user)  <span class="comment"># 將使用者登入狀態儲存至 session</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;登入成功&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>這樣的做法即所謂的 <a href="https://zh.wikipedia.org/zh-tw/%E5%8D%AB%E8%AF%AD%E5%8F%A5">Guard Clause</a> 或 <a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/early-return-coding-skill-9f3016d4b88d">Early Return</a>（雖然這裡是 raise）。</p><h3 id="簡評與重要補充"><a href="#簡評與重要補充" class="headerlink" title="簡評與重要補充"></a>簡評與重要補充</h3><p><code>authenticate</code>和<code>login</code>的用法幾乎是固定的，很容易理解：</p><ul><li><code>authenticate</code>在驗證成功時會 return 對應的<code>User</code>物件，失敗時則返回<code>None</code>。</li><li><code>login</code>不會 return，但<code>request</code>和<code>user</code>為必要的參數。</li></ul><p>成功登入後，你會得到 200 回應，並獲得兩組 cookie：</p><p><img src="https://i.imgur.com/c6gMBDY.png"></p><p>這對於 API client（比如 Postman）使用者很重要，畢竟瀏覽器會自動幫你存，但這些工具可不會——好吧，我錯了，至少我用的 RapidAPI 會<strong>自動存儲、發送</strong>！</p><p>（我測試 API 時還覺得奇怪，怎麼認證防護都失效了🤣）</p><p>如果工具沒有幫你做，記得自己在請求的 headers 加上：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/users/2/avatar/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">...</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>csrftoken=...; sessionid=...</span><br><span class="line"><span class="attribute">X-CSRFToken</span><span class="punctuation">: </span>...</span><br></pre></td></tr></table></figure><p><code>authenticate</code>預設是以<code>AbstractUser</code>的<code>username</code>欄位和密碼作為認證基準，如果想用別的欄位，比如<code>email</code>，則要自己覆寫 Django 的認證後端。</p><hr><h2 id="為-API-加上「認證保護」"><a href="#為-API-加上「認證保護」" class="headerlink" title="為 API 加上「認證保護」"></a>為 API 加上「認證保護」</h2><p>登入功能完成後，接下來要將「需要登入才能存取」的 API，分別加上<strong>認證保護</strong>，使用 Django Ninja 提供的<code>django_auth</code>——這是專門給 Django 內建的 session 認證使用。</p><p>我們以「上傳 avatar」API 為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja.security <span class="keyword">import</span> django_auth</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    path=<span class="string">&#x27;/users/&#123;int:user_id&#125;/avatar/&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    summary=<span class="string">&#x27;上傳 avatar&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    auth=django_auth  <span class="comment"># 加上這組參數</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br></pre></td></tr></table></figure><p>這個例子中，<code>auth=django_auth</code>確保只有「已登入的使用者」才能存取此 API，否則將得到 401 或 403 回應。</p><hr><h2 id="Django-Ninja-的-request-auth"><a href="#Django-Ninja-的-request-auth" class="headerlink" title="Django Ninja 的 request.auth"></a>Django Ninja 的 request.auth</h2><p>但你可能會想到：</p><blockquote><p>光是驗證「已登入」還不夠吧？</p></blockquote><p>「上傳 avatar」應該只能幫「<strong>自己</strong>」上傳，總不能幫「<strong>別人</strong>」上傳大頭照吧！</p><p>沒錯，所以我們在 <strong>view 函式內部</strong>，還要<strong>多一層驗證</strong>。</p><h3 id="Django-的request-user"><a href="#Django-的request-user" class="headerlink" title="Django 的request.user"></a>Django 的<code>request.user</code></h3><p>傳統的 Django 專案，我們會透過函式的第一參數——<code>request</code>，用<code>request.user</code>來獲得<strong>當前使用者資訊</strong>，比如：（參考<a href="https://docs.djangoproject.com/en/5.1/topics/auth/default/#authentication-in-web-requests">文件</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.user.is_authenticated:</span><br><span class="line">    <span class="comment"># Do something for authenticated users.</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Do something for anonymous users.</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>具體來說：</p><ul><li>當使用者已登入，<code>request.user</code>會是一個<code>User</code>實例，代表<strong>當前登入的使用者</strong>。</li><li>未登入時，<code>request.user</code>則是一個<code>AnonymousUser</code>實例，代表<strong>未登入使用者</strong>。</li></ul><p>當使用者已登入，我們可以檢查<code>request.user</code>的屬性，比如<code>request.user.id</code>，來確認<strong>是否為「本人」</strong>。</p><h3 id="Django-Ninja-的request-auth"><a href="#Django-Ninja-的request-auth" class="headerlink" title="Django Ninja 的request.auth"></a>Django Ninja 的<code>request.auth</code></h3><p>但寫 Django Ninja 則需要使用它提供的<code>request.auth</code>，實作結果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_avatar</span>(<span class="params">...</span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上傳 avatar</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 檢查登入的使用者是否為「本人」</span></span><br><span class="line">    <span class="keyword">if</span> request.auth.<span class="built_in">id</span> != user_id:</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">403</span>, <span class="string">&#x27;無權限上傳其他使用者的 avatar&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>測試一下，登入後在 URL path 打別人的 id 來呼叫此 API：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 403 Forbidden</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;無權限上傳其他使用者的 avatar&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>非常好！</p><hr><h2 id="request-auth-解析"><a href="#request-auth-解析" class="headerlink" title="request.auth 解析"></a>request.auth 解析</h2><p>雖然這裡用<code>request.auth</code>來取代<code>request.user</code>，但其實兩者的內涵有<strong>很大的不同</strong>。</p><p>在 Django Ninja 中，<code>request.auth</code>代表的是<strong>認證流程 return 的結果</strong>。此外，Django Ninja 允許你<strong>自定義認證方法</strong>，所以<code>request.auth</code>的內容是<strong>不固定的</strong>。</p><p>讓我們深入了解一下。</p><h3 id="認證結果"><a href="#認證結果" class="headerlink" title="認證結果"></a>認證結果</h3><p><code>request.auth</code>包含了<strong>當前認證方法</strong>返回的值。</p><ul><li>這個值可以是<strong>任何類型</strong>，取決於你<strong>如何實現認證邏輯</strong>。</li><li>這給了開發者極大的靈活性，它可以是<code>User</code>物件、字串、Python 字典等等。</li></ul><h3 id="認證方法與常見用例"><a href="#認證方法與常見用例" class="headerlink" title="認證方法與常見用例"></a>認證方法與常見用例</h3><ul><li>使用 Django 的 session 認證時，<code>request.auth</code>是 Django 的<code>User</code>物件。</li><li>對於 API key 認證，<code>request.auth</code>可能是 API key 本身或與之相關的資訊。</li><li>在 JWT 認證中，<code>request.auth</code>可能包含解碼後的 token 資訊。</li></ul><p>總之，只要記得，想在 view 函式內進一步取得<strong>認證資訊</strong>，要透過<code>request.auth</code>。</p><hr><p>這樣就已經實作完認證了，但我們可以讓事情更「簡單」一點。</p><h2 id="全域認證的設定與例外"><a href="#全域認證的設定與例外" class="headerlink" title="全域認證的設定與例外"></a>全域認證的設定與例外</h2><p>一一對每個 API 設定認證保護，感覺有點<strong>繁瑣</strong>——尤其在 API 多的時候。</p><p>對此，Django Ninja 支援<strong>全域認證</strong>，讓所有 API <strong>預設都直接受到保護</strong>，開發者只需在特定路由中進行<strong>例外</strong>處理，<strong>排除</strong>不想套用的 API 即可。</p><p>實作上非常簡單，Django Ninja 直接提供了<code>SessionAuth</code>認證類別，用來處理全域的 session-based 認證。</p><h3 id="實作全域認證：使用SessionAuth"><a href="#實作全域認證：使用SessionAuth" class="headerlink" title="實作全域認證：使用SessionAuth"></a>實作全域認證：使用<code>SessionAuth</code></h3><p>在專案的<code>api.py</code>中加入下面內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja.security <span class="keyword">import</span> SessionAuth</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">api = NinjaAPI(</span><br><span class="line">    auth=SessionAuth(),  <span class="comment"># 設定全域認證</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如此一來，全部的 API 都<strong>預設擁有認證保護</strong>，你可以在特定 API 中排除，比如「登入使用者」：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/users/login/&#x27;</span>, summary=<span class="string">&#x27;登入使用者&#x27;</span>, auth=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure><p>在路由裝飾器中，把<code>auth</code>定義為<code>None</code>，<strong>解除</strong>認證保護。</p><hr><h2 id="測試認證保護"><a href="#測試認證保護" class="headerlink" title="測試認證保護"></a>測試認證保護</h2><p>我們來測試一下「<strong>有認證保護</strong>」的 API，你會發現在<strong>未登入</strong>的情況下，<strong>嘗試不同 HTTP 方法的 API</strong>，你將會得到不同的錯誤回應：</p><ul><li>GET：401 Unauthorized</li><li>POST：403 Forbidden</li></ul><p>所以前面才會說你會得到「401 或 403」回應。</p><h3 id="測試「取得所有使用者」API"><a href="#測試「取得所有使用者」API" class="headerlink" title="測試「取得所有使用者」API"></a>測試「取得所有使用者」API</h3><p>在我們的專案設計中，只有登入的使用者才能存取「取得所有使用者」API。</p><p>未登入的情況下，你會得到 401 回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 401 Unauthorized</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unauthorized&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="測試「新增文章」API"><a href="#測試「新增文章」API" class="headerlink" title="測試「新增文章」API"></a>測試「新增文章」API</h3><p>未登入也無法存取「新增文章」API——這顯然非常合理，否則文章不就沒作者了😅</p><p>你會得到 403 回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 403 Forbidden</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CSRF check Failed&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>你心想：「奇怪？為什麼是 CSRF check Failed？」</p><p>這是 Django 的 CSRF 保護機制，因為我們的 API 是 POST 方法，所以 Django 會自動檢查 CSRF token，但我們沒有提供 CSRF token，所以就會出現這個錯誤。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>在這篇文章中，我們探討了 Django 的 session 認證與 Django Ninja 的整合，實作了「使用者登入」API，並為其他 API 加上認證保護。最後還示範了如何實現全域認證，讓整個流程更加簡單。</p><p>這個系列的<strong>最後實踐</strong>，我們要來為專案——<strong>寫測試</strong>！</p><p>下一篇將探討，如何使用 test client 和 pytest 來為我們的 Django API 撰寫<strong>單元測試</strong>。這不僅能幫助我們驗證現有功能，還能為未來的開發和重構提供多一層的保障。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 28 篇。&lt;/p&gt;
&lt;p&gt;歡迎來到第七章！本章總共有兩篇內容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷 28：身分認證——Session 認證與全域設定&lt;/li&gt;
&lt;li&gt;卷 29：單元測試——使用 Test Client 與 pytest 測試 API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些主題的核心功能，&lt;strong&gt;並非由 Django Ninja 實作&lt;/strong&gt;，但框架仍提供了&lt;strong&gt;一定程度的整合&lt;/strong&gt;。並且，這些功能對於任何 Django 專案來說，都至關重要。&lt;/p&gt;
&lt;p&gt;本文介紹幾乎所有 API 專案都需要的——&lt;strong&gt;身分認證&lt;/strong&gt;（&lt;a href=&quot;https://django-ninja.dev/guides/authentication/&quot;&gt;Authentication&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;我們將探討如何在 Django Ninja 中利用 Django 內建的 session-based 認證，實現完整的登入驗證功能，並進一步說明如何設定&lt;strong&gt;全域認證&lt;/strong&gt;，以減少程式碼的重複。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/19&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;認證的兩個層次&quot;&gt;&lt;a href=&quot;#認證的兩個層次&quot; class=&quot;headerlink&quot; title=&quot;認證的兩個層次&quot;&gt;&lt;/a&gt;認證的兩個層次&lt;/h2&gt;&lt;p&gt;進入實作前，我們要先了解，所謂的&lt;strong&gt;身分認證&lt;/strong&gt;，究竟代表什麼。&lt;/p&gt;
&lt;p&gt;以「帳號密碼 + session 認證」為例，身分認證的範圍主要涵蓋&lt;strong&gt;兩個階段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，當使用者透過帳號密碼進行登入時，系統會檢查這些內容、確認身分&lt;strong&gt;合法&lt;/strong&gt;。登入成功後，系統會將使用者資訊（比如用戶 id）儲存至 session，以&lt;strong&gt;維持登入狀態&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是&lt;strong&gt;登入時的認證&lt;/strong&gt;，也是我們最常說的認證。（&lt;strong&gt;狹義的認證&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;接著，當使用者嘗試存取受「&lt;strong&gt;認證保護&lt;/strong&gt;」的 API 時，系統會檢查 session 並確認身分，確保每個 API 請求都來自&lt;strong&gt;合法登入&lt;/strong&gt;的使用者。&lt;/p&gt;
&lt;p&gt;簡言之：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一階段：初次登入時的身分確認。&lt;/li&gt;
&lt;li&gt;第二階段：後續請求時的身分確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兩個層次相輔相成、一體兩面，確保服務能夠在使用者&lt;strong&gt;登入&lt;/strong&gt;和&lt;strong&gt;後續操作&lt;/strong&gt;中，提供適當的安全保障。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
  </entry>
  
</feed>
