<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-09-29T07:49:55.816Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django Ninja 教學 17：API 文件（上）Django Ninja 實踐重點</title>
    <link href="https://blog.kyomind.tw/django-ninja-17/"/>
    <id>https://blog.kyomind.tw/django-ninja-17/</id>
    <published>2024-09-29T06:19:38.000Z</published>
    <updated>2024-09-29T07:49:55.816Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>「<strong>依程式碼自動產生 API 文件</strong>」是 Django Ninja 的一大賣點。</p><p>事實上，<strong>API 文件的自動化</strong>，正是我在工作上的專案從 Django REST framework 轉向 Django Ninja 的<strong>首要考量</strong>——也是我開始學習 Django Ninja 的契機。</p><p>Django Ninja 省去了大量<strong>人工撰寫</strong>（我們用 <a href="https://apiblueprint.org/">API Blueprint</a>）API 文件的時間，特別是在 API 規格變動時，<strong>不需要再同步修改文件</strong>，大大減少了維護文件的心力。</p><p>可見這個特性有多麼重要。</p><h3 id="教學順序的考量"><a href="#教學順序的考量" class="headerlink" title="教學順序的考量"></a>教學順序的考量</h3><p>那麼，為何我到了系列的第 17 篇文章——也就是本篇，才開始介紹 Django Ninja 的 API 文件功能呢？</p><p>原因在於，要產生優秀的 API 文件，<strong>需要你對 Schema 的使用有一定的了解</strong>。所以我不得不放在第三章之後。</p><p>現在，我們要開始探討如何使用 Django Ninja 產出高品質的 API 文件。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/8">這個 PR</a>。</p><span id="more"></span><hr><h2 id="Documentation-as-Code"><a href="#Documentation-as-Code" class="headerlink" title="Documentation as Code"></a>Documentation as Code</h2><p>現代軟體開發中，「<a href="https://swimm.io/learn/code-documentation/documentation-as-code-why-you-need-it-and-how-to-get-started">Documentation as Code</a>」（DoC） 是一個逐漸被認可的理念。</p><p>DoC 是指<strong>將文件與程式碼緊密結合</strong>，開發人員<strong>使用「與軟體程式碼開發相同的流程和工具」來建立和維護文件</strong>。</p><p>文件<strong>隨著程式碼的變更而自動更新</strong>，兩者<strong>無時無刻都保持著一致性</strong>。</p><p>這不僅提升了開發效率，還減少了<strong>因文件過時而導致的溝通不順暢或誤解</strong>。</p><p>Django Ninja 的自動化產生文件功能無疑是「Documentation as Code」精神的實踐。</p><p>我們可以透過撰寫 API 路由、view 函式、Schema 等<strong>程式碼</strong>，自動產生符合 <a href="https://www.openapis.org/">OpenAPI</a> 標準的文件，當程式碼變更時，這些文件<strong>也會自動反映變更結果</strong>，無需手動維護。</p><h3 id="Django-Ninja-自動化-API-文件的兩大重點"><a href="#Django-Ninja-自動化-API-文件的兩大重點" class="headerlink" title="Django Ninja 自動化 API 文件的兩大重點"></a>Django Ninja 自動化 API 文件的兩大重點</h3><p>在 Django Ninja 中，要產生高品質的 API 文件，主要涉及<strong>兩個重點</strong>：</p><ol><li><strong>Django Ninja 設定</strong>：Django Ninja 內建了好一些控制 API 文件細節的設定，這是本文的重點。</li><li><strong>Pydantic 設定</strong>：這是下一篇要探討的內容，講述如何有效定義 Schema，讓各種細節自動呈現在 API 文件中。</li></ol><p>看到這裡，是不是有點小期待呢？☺️</p><hr><h2 id="專案-API-文件現況"><a href="#專案-API-文件現況" class="headerlink" title="專案 API 文件現況"></a>專案 API 文件現況</h2><p>在開始大刀闊斧地加強文件品質之前，我們先來看看目前 API 文件有多麼「陽春」。</p><p>啟動 Django 伺服器後，造訪下列網址可以查看當前 API 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000/docs</span><br></pre></td></tr></table></figure><p>目前的文件內容如下：</p><p><img src="https://i.imgur.com/jMSkDMj.png"></p><p>我們從「<strong>對開發人員是否有用、好讀</strong>」的角度進行簡要分析。</p><h3 id="問題解析"><a href="#問題解析" class="headerlink" title="問題解析"></a>問題解析</h3><p>首先，它<strong>沒有分組</strong>！</p><p>Django user app 和 post app 的 API 都<strong>混在一起</strong>了，當 API 愈來愈多，就會顯得十分雜亂。這是<strong>最優先要解決</strong>的問題。</p><p>其次，API 的說明如「Get Users」、「Create Post」等，顯然都是從 view 函式名稱自動轉換而來。資訊有限，且不夠口語、不夠詳細，簡單講就是不夠「<strong>讀者友善</strong>」。</p><p>我們點進唯一的 POST API 看一下內容：</p><p><img src="https://i.imgur.com/NCitdKc.png"></p><p>內頁的說明有「新增文章」，這其實是<strong>從 view 函式的 docstring 獲取</strong>的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_post</span>(<span class="params">...</span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增文章</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>再看一下 HTTP 請求 body 的範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;user_id&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能說<strong>不盡理想</strong>，像<code>&quot;string&quot;</code>這樣的例子，只有表現出「型別」，沒有模擬<strong>真實世界</strong>的文章標題或內容。</p><hr><p>上述問題正是我們需要改善 API 文件的重點。</p><p>其中，請求 body 範例與 Schema 設定有關，是下一篇的重心。</p><p>本文先聚焦於 <strong>Django Ninja 設定</strong>——讓我們一一介紹。</p><h2 id="一、使用-Tags-為-API-分組"><a href="#一、使用-Tags-為-API-分組" class="headerlink" title="一、使用 Tags 為 API 分組"></a>一、使用 Tags 為 API 分組</h2><p>我們第一個要解決的是 API 的<strong>分組</strong>（分類）問題。</p><p>為了讓文件結構更清晰，Django Ninja 支援使用 <a href="https://django-ninja.dev/guides/routers/#router-tags">Tags</a> 來對 API 進行分組。不僅有助於組織文件，還能讓開發者或使用者更快地找到所需的 API。</p><p>Tags 分組可以在<strong>兩個地方</strong>進行設定。</p><h3 id="一級路由分組"><a href="#一級路由分組" class="headerlink" title="一級路由分組"></a>一級路由分組</h3><p>最常見的做法，是在<strong>一級路由</strong>進行設定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/арі.py</span></span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;&#x27;</span>, router=<span class="string">&#x27;user.api.router&#x27;</span>, tags=[<span class="string">&#x27;User&#x27;</span>])</span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;&#x27;</span>, router=<span class="string">&#x27;post.api.router&#x27;</span>, tags=[<span class="string">&#x27;Post&#x27;</span>])</span><br></pre></td></tr></table></figure><p>因為同一個 Django app 的 API，通常就是在同一組。</p><h3 id="路由裝飾器分組"><a href="#路由裝飾器分組" class="headerlink" title="路由裝飾器分組"></a>路由裝飾器分組</h3><p>也可以在<strong>路由裝飾器</strong>設定分組，但我認為這屬於相對「<strong>例外</strong>」的情況，主要用於：</p><ol><li>全專案只有一個 Django app。</li><li>同一個 Django app 需要不同的分組。</li></ol><p>比如下面範例中，沒有區分 Django app，但仍有分組需求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;User&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_users</span>(<span class="params">request</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.post(<span class="params"><span class="string">&quot;/posts/&quot;</span>, tags=[<span class="string">&quot;Post&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_post</span>(<span class="params">request, title: <span class="built_in">str</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>大部分情況，我推薦在一級路由進行分組就好。</p><p>不然像上面的例子那樣，一個一個標記，實踐起來有點繁瑣。</p><hr><h2 id="二、路由裝飾器的文件設定"><a href="#二、路由裝飾器的文件設定" class="headerlink" title="二、路由裝飾器的文件設定"></a>二、路由裝飾器的文件設定</h2><p>Django Ninja 的<strong>路由裝飾器</strong>不僅可以設定基本的 API 路徑，還允許你加上 <strong>API 的描述文字</strong>，這些內容會直接反映在生成的 API 文件中。</p><p>透過這些設定，你可以為 API 的參數、回應、甚至意圖加上說明，讓文件更全面。</p><p>透過<code>description</code>和<code>summary</code>參數，能為各 API 路由提供說明。不過<code>description</code>會取代上述「docstring 轉 API 說明」的效果，所以我平常都只寫<code>summary</code>。</p><p><strong>畢竟我們寫 Python，docstring 可是必須的！</strong></p><p>程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">..., summary=<span class="string">&#x27;取得文章列表&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>到目前為止的實際改善效果：（分組、API 說明）</p><p><img src="https://i.imgur.com/WRv4MGd.png"></p><p>非常不錯唷！</p><hr><h2 id="三、NinjaAPI-設定"><a href="#三、NinjaAPI-設定" class="headerlink" title="三、NinjaAPI 設定"></a>三、NinjaAPI 設定</h2><p>你可以通過<code>NinjaAPI</code>類別的<strong>初始化</strong>設定，來客製一些<strong>全域</strong>的 API 文件細節。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/арі.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI(</span><br><span class="line">    title=<span class="string">&quot;忍者論壇 API&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;這是忍者論壇的 API 文件，供讀者參考&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>對應的實際效果：</p><p><img src="https://i.imgur.com/oLgmQkM.png"></p><p><code>NinjaAPI</code>的初始化設定<strong>非常多樣</strong>——有些可能是你需要的。</p><p>這裡只是簡單例示，更多設定細節，可查看<a href="https://django-ninja.dev/reference/api/">文件</a>。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>本文探討了 Django Ninja 自動生成 API 文件的常見設定，讓「Documentation as Code」精神得以實現——程式碼與文件能輕鬆保持一致，減少了手動維護的麻煩。</p><p>然而，API 文件的品質，還取決於我們如何定義 Schema 中的細節。</p><p>接下來，我們將深入探討這個議題，說明如何透過 Pydantic 的<code>Field</code>參數設定，提供<strong>高品質的文件範例</strong>，進一步提升 API 文件的可讀性和清晰度。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;依程式碼自動產生 API 文件&lt;/strong&gt;」是 Django Ninja 的一大賣點。&lt;/p&gt;
&lt;p&gt;事實上，&lt;strong&gt;API 文件的自動化&lt;/strong&gt;，正是我在工作上的專案從 Django REST framework 轉向 Django Ninja 的&lt;strong&gt;首要考量&lt;/strong&gt;——也是我開始學習 Django Ninja 的契機。&lt;/p&gt;
&lt;p&gt;Django Ninja 省去了大量&lt;strong&gt;人工撰寫&lt;/strong&gt;（我們用 &lt;a href=&quot;https://apiblueprint.org/&quot;&gt;API Blueprint&lt;/a&gt;）API 文件的時間，特別是在 API 規格變動時，&lt;strong&gt;不需要再同步修改文件&lt;/strong&gt;，大大減少了維護文件的心力。&lt;/p&gt;
&lt;p&gt;可見這個特性有多麼重要。&lt;/p&gt;
&lt;h3 id=&quot;教學順序的考量&quot;&gt;&lt;a href=&quot;#教學順序的考量&quot; class=&quot;headerlink&quot; title=&quot;教學順序的考量&quot;&gt;&lt;/a&gt;教學順序的考量&lt;/h3&gt;&lt;p&gt;那麼，為何我到了系列的第 17 篇文章——也就是本篇，才開始介紹 Django Ninja 的 API 文件功能呢？&lt;/p&gt;
&lt;p&gt;原因在於，要產生優秀的 API 文件，&lt;strong&gt;需要你對 Schema 的使用有一定的了解&lt;/strong&gt;。所以我不得不放在第三章之後。&lt;/p&gt;
&lt;p&gt;現在，我們要開始探討如何使用 Django Ninja 產出高品質的 API 文件。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/8&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 16：回應（四）Resolver 方法——欄位資料格式化</title>
    <link href="https://blog.kyomind.tw/django-ninja-16/"/>
    <id>https://blog.kyomind.tw/django-ninja-16/</id>
    <published>2024-09-28T03:53:48.000Z</published>
    <updated>2024-09-28T18:41:54.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇提到，API 回應常常是對 Django Model 物件內容的篩選與加工——然後 JSON 序列化。</p><p>其中「<strong>加工</strong>」部分，用更專業的說法，大概是「<strong>資料格式化</strong>」——依照一定的規則，對輸出資料進行<strong>某種轉換或重新組織</strong>，以符合<strong>特定的輸出格式</strong>。</p><p>資料格式化的種類很多，例如：</p><ol><li><strong>時間格式轉換</strong>：將資料庫中的時間戳（timestamp），轉換為更易讀的格式。</li><li><strong>數值轉換</strong>：將數字轉換為貨幣格式，或將小數點位數進行四捨五入。</li><li><strong>字串處理</strong>：截斷過長的文字、加上統一的前綴等。</li></ol><p>不論原因為何，絕大部分時候都是為了資料的「<strong>可讀性</strong>」，或符合特定業務規則。</p><p>可想而知，像資料格式化這樣的需求，不僅實務上重要，在 API 開發中也十分常見，值得我們用一整篇文章，細細探討。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/7">這個 PR</a>。</p><hr><h2 id="場景與需求"><a href="#場景與需求" class="headerlink" title="場景與需求"></a>場景與需求</h2><p>再次回到「取得單一文章資訊」API，這是目前的回傳格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8000/posts/2/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1 content&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我們決定<strong>簡化</strong>回應的時間字串，改採「<code>&quot;2024-09-12T02:28:16Z&quot;</code>」格式。</p><p>和舊版相比，只是少了「<code>.801</code>」這個小數部分而已，且依舊符合 <a href="https://zh.wikipedia.org/zh-tw/ISO_8601">ISO 8601</a> 標準。</p><p>總之，回應中<code>created_at</code>和<code>updated_at</code>兩個欄位的內容，需要進行<strong>格式上的轉換</strong>。即上述提到的「<strong>資料格式化</strong>」。</p><span id="more"></span><hr><h2 id="Django-REST-Framework-做法"><a href="#Django-REST-Framework-做法" class="headerlink" title="Django REST Framework 做法"></a>Django REST Framework 做法</h2><p>首先，我們還是不免俗地先介紹 Django REST Framework（<strong>以下簡稱 DRF</strong>）的做法，方便你<strong>對比兩者的差異</strong>——你會發現<strong>其實大同小異</strong>。</p><p>在 DRF 中，我們可以透過<code>SerializerMethodField</code>實現時間格式的轉換。以下是透過 DRF 實現的範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">...</span><br><span class="line">    created_at = serializers.SerializerMethodField()</span><br><span class="line">    updated_at = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_created_at</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> obj.created_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_updated_at</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> obj.updated_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中的重點有三：</p><ol><li>要格式化的欄位，值必須是<code>SerializerMethodField</code>。</li><li>在序列化器類別中，定義相同欄位名稱的<strong>實例方法</strong>（有第一位置參數<code>self</code>），且命名時要加上<code>get_</code>前綴，比如<code>get_created_at</code>。</li><li><code>obj</code>參數指的是<strong>當前被序列化的物件</strong>。本例中，我們<strong>預期</strong>引數是一個<code>Post</code>模型實例。這個方法<strong>將在序列化過程中會被自動調用</strong>，將原始的 datetime 物件轉換為指定的字串格式。</li></ol><p>附帶一提，在 DRF 序列化器的各種實例方法中，<code>obj</code>這個參數名稱可以稱得上是一個<strong>命名慣例</strong>。</p><hr><h2 id="Django-Ninja-的欄位資料格式化"><a href="#Django-Ninja-的欄位資料格式化" class="headerlink" title="Django Ninja 的欄位資料格式化"></a>Django Ninja 的欄位資料格式化</h2><p>看完 DRF，我們來看看 Django Ninja 怎麼做。</p><p>透過 Django Ninja 的 <a href="https://django-ninja.dev/guides/response/#resolvers">Resolver</a> 方法，我們也能輕鬆處理這類需求。</p><h3 id="Django-Ninja-的-Resolver-方法"><a href="#Django-Ninja-的-Resolver-方法" class="headerlink" title="Django Ninja 的 Resolver 方法"></a>Django Ninja 的 Resolver 方法</h3><p>在 Django Ninja 中，我們用 <strong>Resolver 方法</strong>來實現同樣的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    created_at: datetime</span><br><span class="line">    updated_at: datetime</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_created_at</span>(<span class="params">obj: Post</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> obj.created_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_updated_at</span>(<span class="params">self, obj: Post</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> obj.updated_at.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>方法的命名</strong>，相較於 DRF 用的是<code>get_</code>前綴，Django Ninja 則是採<code>resolve_</code>前綴。</p><p>此外，你沒有看錯，這裡使用了<strong>兩種寫法</strong>：</p><ul><li><code>resolve_created_at</code> 是一個「<strong>靜態方法</strong>（static method）」，需要使用<code>@staticmethod</code>裝飾器，且沒有<code>self</code>參數。</li><li><code>resolve_updated_at</code> 是一個典型的<strong>實例方法</strong>，有<code>self</code>參數。</li></ul><p>因為文件的範例中，確實存在這兩種寫法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskSchema</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    owner: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    lower_title: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_owner</span>(<span class="params">obj</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj.owner:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;obj.owner.first_name&#125;</span> <span class="subst">&#123;obj.owner.last_name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">resolve_lower_title</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> self.title.lower()</span><br></pre></td></tr></table></figure><h3 id="實例方法版本未實裝"><a href="#實例方法版本未實裝" class="headerlink" title="實例方法版本未實裝"></a>實例方法版本未實裝</h3><p>但是！現階段，你只要知道「靜態方法」版本即可。</p><p>因為採第二種寫法，你將會得到下列<strong>錯誤訊息</strong>：</p><blockquote><p>Error extracting attribute: NotImplementedError: <strong>Non static resolves are not supported yet</strong> [type&#x3D;get_attribute_error, input_value&#x3D;&lt;DjangoGetter: &lt;Post: Ali…’s Django Ninja Post 1&gt;&gt;, input_type&#x3D;DjangoGetter]</p></blockquote><p>什麼？還沒有實作！</p><p>我只好乖乖都改成靜態方法。</p><h3 id="回傳結果"><a href="#回傳結果" class="headerlink" title="回傳結果"></a>回傳結果</h3><p>最後看一下效果如何：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8000/posts/2/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1 content&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>非常好！</p><hr><h2 id="使用-Alias-攤平欄位資訊"><a href="#使用-Alias-攤平欄位資訊" class="headerlink" title="使用 Alias 攤平欄位資訊"></a>使用 Alias 攤平欄位資訊</h2><p>另一個常見的格式化需求，是我們之前提過的「<strong>攤平</strong>」（flatten）複雜資料結構。</p><p>這是一種對資料的「<strong>重組</strong>」，而<strong>結構重組</strong>同樣屬於本文所探討的<strong>資料格式化</strong>範疇。</p><p>還記得在第 14 篇，我們透過<code>@property</code>產生「取得文章列表」回應中<code>author_name</code>欄位內容嗎？——這是對<code>User</code>模型的攤平，直接獲取其<code>username</code>欄位資訊。</p><p>這裡我們換一個<strong>更優雅</strong>的做法——<a href="https://django-ninja.dev/guides/response/#aliases">alias</a>。</p><h3 id="使用-Alias"><a href="#使用-Alias" class="headerlink" title="使用 Alias"></a>使用 Alias</h3><p>Django Ninja（幾乎是從 Pydantic 照搬來的）提供了<code>Field</code>與<code>alias</code>參數來實現這一功能。</p><p>有關<code>Field</code>，在〈卷 18：用 Pydantic Field 設定範例與預設值〉將會有更多著墨。</p><p>我們先來看看如何使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostListResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    created_at: datetime</span><br><span class="line">    author_name: <span class="built_in">str</span> = Field(alias=<span class="string">&#x27;author.username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意，原先<code>Post</code>模型的<code>@property</code>方法要拿掉，或至少<strong>不能</strong>和<code>author_name</code><strong>撞名</strong>，否則會出錯唷！</p><p>我選擇了移除<code>@property</code>方法，直接改用這個新做法。</p><h3 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h3><p>透過<code>alias=author.username</code>取得<code>Post</code>的<strong>關聯模型</strong>——<code>User</code>的<code>username</code>屬性值。實現了<strong>巢狀資料的攤平</strong>。</p><p>這種設計，顯然是向 DRF 的<strong>優秀借鑑</strong>，相當於 DRF 中的 <code>source=author.username</code>寫法。</p><p>雖然<strong>有點抽象</strong>，卻非常優雅。</p><p><code>alias</code>的用途不限於資料攤平（這反而是比較進階的用法），其它細節，如欄位名稱替換等，可直接參考 <a href="https://docs.pydantic.dev/latest/concepts/alias/">Pydantic 文件</a>。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Django Ninja 的 Resolver 方法允許我們對 API 回應中的欄位資料進行<strong>動態處理</strong>，滿足各種格式轉換與自定義需求。</p><p>在處理像<code>created_at</code>和<code>updated_at</code>這樣的時間欄位時，Resolver 方法不僅簡單易用，還能保證程式碼的結構清晰。</p><p><code>Field</code>與<code>alias</code>參數則更優雅地實現了另一種常見的資料格式化——「攤平」。不僅簡化了 API 回應，且無需修改背後的 Django 模型。</p><p>透過這些方式，我們能更靈活地控制 API 的輸出，以符合客戶端需求。</p><h2 id="下一章預告"><a href="#下一章預告" class="headerlink" title="下一章預告"></a>下一章預告</h2><p>完成了對「<strong>Django Ninja 處理 HTTP 回應</strong>」共 4 篇的學習，第三章也正式告一段落。接下來，我們要將目光轉向 API 開發中的<strong>另一個重要主題——文件</strong>！</p><p>隨著專案規模的增長，<strong>清晰的 API 文件</strong>對於任何需要使用 API 的人員都<strong>至關重要</strong>——包括後端開發者<strong>自己</strong>！</p><p>一份好的 API 文件能夠<strong>大幅降低溝通成本，提高開發效率、減少錯誤</strong>。它不僅是一種技術文書，更是<strong>團隊協作的重要樞紐</strong>。</p><p>第四章，我們會探討如何有效地透過 Django Ninja 程式碼，產生高品質的 API 文件，從而提升整體的開發體驗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇提到，API 回應常常是對 Django Model 物件內容的篩選與加工——然後 JSON 序列化。&lt;/p&gt;
&lt;p&gt;其中「&lt;strong&gt;加工&lt;/strong&gt;」部分，用更專業的說法，大概是「&lt;strong&gt;資料格式化&lt;/strong&gt;」——依照一定的規則，對輸出資料進行&lt;strong&gt;某種轉換或重新組織&lt;/strong&gt;，以符合&lt;strong&gt;特定的輸出格式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;資料格式化的種類很多，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;時間格式轉換&lt;/strong&gt;：將資料庫中的時間戳（timestamp），轉換為更易讀的格式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;數值轉換&lt;/strong&gt;：將數字轉換為貨幣格式，或將小數點位數進行四捨五入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字串處理&lt;/strong&gt;：截斷過長的文字、加上統一的前綴等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不論原因為何，絕大部分時候都是為了資料的「&lt;strong&gt;可讀性&lt;/strong&gt;」，或符合特定業務規則。&lt;/p&gt;
&lt;p&gt;可想而知，像資料格式化這樣的需求，不僅實務上重要，在 API 開發中也十分常見，值得我們用一整篇文章，細細探討。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/7&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;場景與需求&quot;&gt;&lt;a href=&quot;#場景與需求&quot; class=&quot;headerlink&quot; title=&quot;場景與需求&quot;&gt;&lt;/a&gt;場景與需求&lt;/h2&gt;&lt;p&gt;再次回到「取得單一文章資訊」API，這是目前的回傳格式：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// http://127.0.0.1:8000/posts/2/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Alice&amp;#x27;s Django Ninja Post 1&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Alice&amp;#x27;s Django Ninja Post 1 content&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;punctuation&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Alice&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&amp;quot;email&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;alice@example.com&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;created_at&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;2024-09-12T02:28:16.801Z&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;updated_at&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;2024-09-12T02:28:16.801Z&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我們決定&lt;strong&gt;簡化&lt;/strong&gt;回應的時間字串，改採「&lt;code&gt;&amp;quot;2024-09-12T02:28:16Z&amp;quot;&lt;/code&gt;」格式。&lt;/p&gt;
&lt;p&gt;和舊版相比，只是少了「&lt;code&gt;.801&lt;/code&gt;」這個小數部分而已，且依舊符合 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; 標準。&lt;/p&gt;
&lt;p&gt;總之，回應中&lt;code&gt;created_at&lt;/code&gt;和&lt;code&gt;updated_at&lt;/code&gt;兩個欄位的內容，需要進行&lt;strong&gt;格式上的轉換&lt;/strong&gt;。即上述提到的「&lt;strong&gt;資料格式化&lt;/strong&gt;」。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 15：回應（三）為何不用 ModelSchema？——相比 DRF，我更偏愛 Django Ninja 的理由</title>
    <link href="https://blog.kyomind.tw/django-ninja-15/"/>
    <id>https://blog.kyomind.tw/django-ninja-15/</id>
    <published>2024-09-27T03:37:59.000Z</published>
    <updated>2024-09-29T02:12:20.322Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>Django API 回應，常常是對 Model 物件（即 db 資料）內容進行一定的<strong>篩選與加工</strong>。</p><p>比如「取得單一文章資訊」API，實際上就是從<code>Post</code>物件挑選欄位，再進行序列化。</p><p>這個過程中，我們需要考慮如何將<strong>模型物件</strong>轉換為 API 的回應結構，同時保持程式碼的可維護性與靈活。</p><p>對此，Django REST Framework（<strong>以下簡稱 DRF</strong>）提供了<strong>非常實用的「特製」序列化器</strong>——<code>ModelSerializer</code>，可說是 DRF 開發者必學的核心功能。</p><p>Django Ninja 雖然也有類似的實踐——<code>ModelSchema</code>，對我而言卻是雞肋般的存在，<strong>我幾乎不曾使用</strong>。</p><p>這樣的差異，無疑是兩者的核心設計理念不同所導致。</p><p>我們曾在第 3 篇中討論過，兩者在功能上的主要區別。本文將透過「<strong>Django 模型物件的序列化</strong>」這個頗具代表性的議題，說明「<strong>為何相比於 DRF，我更喜歡寫 Django Ninja</strong>」。</p><span id="more"></span><hr><h2 id="ModelSerializer-的亮點"><a href="#ModelSerializer-的亮點" class="headerlink" title="ModelSerializer 的亮點"></a>ModelSerializer 的亮點</h2><p>DRF 中的<code>ModelSerializer</code>是個非常強大的工具，它能夠自動將 Django 模型轉換為 API 需要的資料結構——序列化器，大大簡化了「<strong>為序列化器定義欄位</strong>」的過程。</p><p>附帶一提，DRF <a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器</a>，相當於 Django Ninja 所使用的 Schema，兩者的概念大同小異，都是用於<strong>資料的驗證與序列化</strong>。</p><p>如果我們把「取得單一文章資訊」API 回應用<code>ModelSerializer</code>改寫，它將長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author 序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthorSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = User</span><br><span class="line">        fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;email&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Post 序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    author = AuthorSerializer()  <span class="comment"># 嵌套的 Author 序列化器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Post</span><br><span class="line">        fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;created_at&#x27;</span>, <span class="string">&#x27;updated_at&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如你所見，透過<code>ModelSerializer</code>，我們只需要<strong>少少的程式碼</strong>便能定義完序列化器，從而避免了<strong>手動設定的重複與麻煩。</strong></p><hr><h2 id="ModelSerializer-的隱憂"><a href="#ModelSerializer-的隱憂" class="headerlink" title="ModelSerializer 的隱憂"></a>ModelSerializer 的隱憂</h2><p>然而，這樣的方便也帶來<strong>一定的隱憂</strong>。</p><p>因為不用自己定義欄位，所以<code>ModelSerializer</code>幫你做了許多欄位的<strong>隱式轉換</strong>——從 Django Model 欄位轉換為序列化器欄位。</p><p>為何說「<strong>隱式</strong>」呢？因為<strong>自動轉換</strong>後的序列化器欄位，其欄位的型別、特性、是否唯讀（<code>read_only</code>）等細節，你<strong>未必清楚</strong>。</p><h3 id="自動轉換的範圍"><a href="#自動轉換的範圍" class="headerlink" title="自動轉換的範圍"></a>自動轉換的範圍</h3><p>換言之，<code>ModelSerializer</code>不僅會自動生成欄位，還會<strong>自動推斷</strong>欄位的型別、屬性、屬性的參數等。</p><p>以<a href="https://www.django-rest-framework.org/api-guide/serializers/#modelserializer">官方文件</a>中的例子為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Account</span><br><span class="line">        fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;account_name&#x27;</span>, <span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;created&#x27;</span>]</span><br></pre></td></tr></table></figure><p>Model 中的<code>name</code>欄位，被<code>ModelSerializer</code>轉換為序列化器的<code>name</code>欄位時，自動被加上了<code>allow_blank=True</code>、<code>max_length=100</code>、<code>required=False</code>等屬性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = serializers.CharField(</span><br><span class="line">    allow_blank=<span class="literal">True</span>,</span><br><span class="line">    max_length=<span class="number">100</span>,</span><br><span class="line">    required=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>這些序列化器的<strong>屬性設定</strong>，都是<code>ModelSerializer</code>從 Account Model 中<strong>推斷</strong>而來的。</p><p>它背後有很多轉換邏輯，讓開發者在某些情況下<strong>必須</strong>去理解這些「<strong>隱藏規則</strong>」——因為這個推斷有時<strong>可能不符合你的需求</strong>，導致你需要<strong>手動覆寫</strong>。</p><p>總之，自動推斷與轉換固然省去了手動設定的麻煩，但當你需要調整某些細節，或理解具體的轉換邏輯時，這種隱式行為可能會<strong>讓你感到困惑</strong>。</p><h3 id="魔法的代價"><a href="#魔法的代價" class="headerlink" title="魔法的代價"></a>魔法的代價</h3><p>在實際開發中，這種隱式轉換的「魔法」會讓開發者<strong>失去</strong>對轉換過程的<strong>理解與掌控</strong>。你很可能會發現，序列化的結果和你想的<strong>並不完全一致！</strong></p><p>此時我們往往需要翻閱 DRF 的官方文件來理解內部如何處理這些欄位轉換，但也不是每個細節都寫得清楚明白。</p><p>對開發者而言，特別是在處理複雜 API 時，會明顯增加學習和維護成本。</p><p><strong>以上正是我的經驗！</strong></p><p>即使寫了 2 年 DRF，遇到序列化問題，我還是<strong>很常需要重新查看文件</strong>。</p><hr><h2 id="ModelSchema"><a href="#ModelSchema" class="headerlink" title="ModelSchema"></a>ModelSchema</h2><p>Django Ninja 的 <a href="https://django-ninja.dev/guides/response/django-pydantic/#modelschema">ModelSchema</a> 相較於 ModelSerializer，則顯得「<strong>單純</strong>」許多。</p><p>怎麼說？我們看一下<a href="https://django-ninja.dev/guides/response/django-pydantic/#modelschema">官方文件</a>中的例示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> ModelSchema</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserSchema</span>(<span class="title class_ inherited__">ModelSchema</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = User</span><br><span class="line">        fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will create schema like this:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class UserSchema(Schema):</span></span><br><span class="line"><span class="comment">#     id: int</span></span><br><span class="line"><span class="comment">#     username: str</span></span><br><span class="line"><span class="comment">#     first_name: str</span></span><br><span class="line"><span class="comment">#     last_name: str</span></span><br></pre></td></tr></table></figure><p>說它「單純」，因為它<strong>只會</strong>幫你自動轉換、定義欄位的「<strong>型別</strong>」而已。其他欄位細節，比如<code>max_length</code>，都要靠<code>Field</code>來設定——ModelSchema <strong>不會</strong>幫你做這些。</p><p>而 DRF 的<code>ModelSerializer</code>，如前所述，則是會「<strong>做更多</strong>」。</p><p>既然 ModelSchema 的自動轉換相對單純，那為何<strong>我還是不建議使用</strong>呢？有兩個理由。</p><p>其中<strong>第一個理由</strong>，就是標題所說「<strong>為何我更偏愛 Django Ninja</strong>」的理由。</p><hr><h2 id="理由一：低耦合-明確優於隱晦"><a href="#理由一：低耦合-明確優於隱晦" class="headerlink" title="理由一：低耦合 + 明確優於隱晦"></a>理由一：低耦合 + 明確優於隱晦</h2><p>Django Ninja 更強調開發者對 API 結構的掌握，而 DRF 則偏向於提供高度整合且便利的工具。</p><p>這種差異反映在它們<strong>對待 Django 模型序列化的方式</strong>上，也影響了開發者在使用這兩個框架時的<strong>風格和思維方式</strong>。</p><h3 id="Django-REST-Framework-和-Django-高度耦合"><a href="#Django-REST-Framework-和-Django-高度耦合" class="headerlink" title="Django REST Framework 和 Django 高度耦合"></a>Django REST Framework 和 Django 高度耦合</h3><p>我們可以發現， DRF 幾乎是一個「<strong>為 Django 高度定製</strong>」的 API 開發工具。</p><p>這種<strong>緊密的結合</strong>雖然帶來了便利性，但也意味著 DRF 在很大程度上依賴於 Django 的內部結構和功能。不管是 <a href="https://www.django-rest-framework.org/api-guide/generic-views/#generic-views">Generic views</a>，還是本文的 <a href="https://www.django-rest-framework.org/api-guide/serializers/#modelserializer">ModelSerializer</a>，都是如此。</p><p>高耦合的優點就是<strong>你可以少做很多事</strong>，而代價則是<strong>你要很了解自己在做什麼</strong>。</p><h3 id="明確優於隱晦"><a href="#明確優於隱晦" class="headerlink" title="明確優於隱晦"></a>明確優於隱晦</h3><p>相較於 DRF，Django Ninja 與 Django 的耦合程度則要<strong>低得多</strong>。</p><p>在我看來，Django Ninja 更偏好「<strong>明確優於隱晦</strong>」，Django Ninja 的 Schema 定義是基於 Pydantic，它要求開發者明確定義每個欄位，無論是輸入還是輸出。</p><p>雖然這樣相對繁瑣，但它帶來的好處是<strong>顯而易見</strong>的。</p><h3 id="明確的兩大優點"><a href="#明確的兩大優點" class="headerlink" title="明確的兩大優點"></a>明確的兩大優點</h3><p>首先，手動定義 Schema 讓開發者對資料結構有著<strong>絕對的掌控權</strong>。沒有任何隱藏規則或暗箱操作，一切都清晰可見。</p><p>其次，這種方法<strong>有效地降低了模型層與 API 層之間的耦合</strong>。在實際開發中，模型設計可能會隨著需求變化而更新，但這不應該直接影響到 API。</p><p>總的來說，Django Ninja 強調<strong>以 Schema 為核心的控制</strong>，讓 API 的設計更具穩定性和靈活性，並賦予開發者對資料流的完全掌控。</p><hr><h2 id="理由二：更好、更可讀的-API-文件"><a href="#理由二：更好、更可讀的-API-文件" class="headerlink" title="理由二：更好、更可讀的 API 文件"></a>理由二：更好、更可讀的 API 文件</h2><p>在第 18 篇，我們會詳細討論 Schema 欄位設定對 API 文件的影響。</p><p>簡言之，如果使用 ModelSchema，那麼渲染出來的 API 文件將會<strong>相當陽春</strong>。</p><p>這<strong>並不符合</strong>我對 API 文件清晰與明確性的追求。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>不可否認，Django REST framework 有一些非常方便且貼心的設計，比如上一篇提到的<code>source=</code>參數，它直觀而優雅。</p><p>Django Ninja 則要求開發者，盡可能手動定義每個欄位，減少模型與 API 層的耦合，這更符合 <a href="https://zh.wikipedia.org/zh-tw/Python%E4%B9%8B%E7%A6%85">Python 哲學</a>中的「<strong>明確優於隱晦</strong>」，同時避免隱式行為帶來的潛在問題。</p><p>這正是我更偏愛 Django Ninja 的原因。</p><p>Django Ninja 對明確性的追求，讓我在開發和維護 API 時，<strong>多數時候感覺更加輕鬆</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;Django API 回應，常常是對 Model 物件（即 db 資料）內容進行一定的&lt;strong&gt;篩選與加工&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如「取得單一文章資訊」API，實際上就是從&lt;code&gt;Post&lt;/code&gt;物件挑選欄位，再進行序列化。&lt;/p&gt;
&lt;p&gt;這個過程中，我們需要考慮如何將&lt;strong&gt;模型物件&lt;/strong&gt;轉換為 API 的回應結構，同時保持程式碼的可維護性與靈活。&lt;/p&gt;
&lt;p&gt;對此，Django REST Framework（&lt;strong&gt;以下簡稱 DRF&lt;/strong&gt;）提供了&lt;strong&gt;非常實用的「特製」序列化器&lt;/strong&gt;——&lt;code&gt;ModelSerializer&lt;/code&gt;，可說是 DRF 開發者必學的核心功能。&lt;/p&gt;
&lt;p&gt;Django Ninja 雖然也有類似的實踐——&lt;code&gt;ModelSchema&lt;/code&gt;，對我而言卻是雞肋般的存在，&lt;strong&gt;我幾乎不曾使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這樣的差異，無疑是兩者的核心設計理念不同所導致。&lt;/p&gt;
&lt;p&gt;我們曾在第 3 篇中討論過，兩者在功能上的主要區別。本文將透過「&lt;strong&gt;Django 模型物件的序列化&lt;/strong&gt;」這個頗具代表性的議題，說明「&lt;strong&gt;為何相比於 DRF，我更喜歡寫 Django Ninja&lt;/strong&gt;」。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 14：回應（二）巢狀結構回應</title>
    <link href="https://blog.kyomind.tw/django-ninja-14/"/>
    <id>https://blog.kyomind.tw/django-ninja-14/</id>
    <published>2024-09-26T02:56:38.000Z</published>
    <updated>2024-09-26T05:20:11.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>在 API 開發中，我們經常會遇到<strong>關聯模型</strong>之間的資料需要<strong>同時返回</strong>的情況。</p><p>特別是在處理「一對一」或「一對多」關聯時，<strong>多層結構</strong>往往是常態。</p><p>我們希望以<strong>巢狀結構</strong>（<a href="https://django-ninja.dev/guides/response/#nested-objects">Nested Objects</a>）的方式返回資料，這樣可以讓 API 的使用者<strong>一次取得必要資訊</strong>，而不需要進行多次請求。</p><p>本文將繼續使用並擴充「單一文章資訊」API 這個範例，講述如何在 Django Ninja 中實現<strong>巢狀結構回應</strong>，讓我們的 API 回應更加豐富、有體系。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/6">這個 PR</a>。</p><hr><h2 id="一、問題背景"><a href="#一、問題背景" class="headerlink" title="一、問題背景"></a>一、問題背景</h2><p>在之前的 API 設計中，「取得單一文章資訊」的回應包括了文章資訊及<strong>作者的 id</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    content: <span class="built_in">str</span></span><br><span class="line">    author_id: <span class="built_in">int</span></span><br><span class="line">    created_at: datetime</span><br><span class="line">    updated_at: datetime</span><br></pre></td></tr></table></figure><p>有經驗的開發者都知道，無論是<code>id</code>還是<code>author_id</code>，通常<strong>不是</strong>給服務的使用者看的——而是<strong>給前端人員靈活運用</strong>的。</p><p>比如在系統的畫面中，文章可能包括作者的<strong>個人資訊連結</strong>，點進去可以看到作者資訊。此時前端必須<strong>透過 id</strong>，再呼叫另一支 API「取得用戶資訊」來獲得額外的內容。</p><p>如果額外資訊很多，這樣的「<strong>解耦</strong>」設計是非常合理的。但如果我們希望<strong>一併呈現</strong>作者的「<strong>必要資訊</strong>」，那分次呼叫的設計就<strong>略嫌拖沓</strong>。</p><p>所以我們需要<strong>巢狀結構</strong>！</p><p>API 可以直接在回應中，嵌入作者的「必要資訊」，這樣用戶就不必再進行多次請求。這裡我們以一併顯示作者的「<strong>名字</strong>」和「<strong>email</strong>」為例。</p><span id="more"></span><hr><h2 id="二、API-改進：重新定義-Schema"><a href="#二、API-改進：重新定義-Schema" class="headerlink" title="二、API 改進：重新定義 Schema"></a>二、API 改進：重新定義 Schema</h2><p>只需要做一件事，就可以讓回應的內容、結構有所不同——重新定義<code>PostResponse</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Schema</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_AuthorInfo</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    content: <span class="built_in">str</span></span><br><span class="line">    author: _AuthorInfo  <span class="comment"># 巢狀結構，包含作者資訊</span></span><br><span class="line">    created_at: datetime</span><br><span class="line">    updated_at: datetime</span><br></pre></td></tr></table></figure><p><code>_AuthorInfo</code>包含了作者的<code>id</code>、<code>name</code>和<code>email</code>，並將這個結構<strong>嵌入</strong><code>PostResponse</code>中的<code>author</code>欄位（從<code>author_id</code>易名而來，因為資訊內涵已有所不同）。</p><p>如此一來，我們便可以<strong>同時獲得</strong>文章和作者的必要資訊。</p><h3 id="命名小建議"><a href="#命名小建議" class="headerlink" title="命名小建議"></a>命名小建議</h3><p>你可能留意到我在<code>_AuthorInfo</code>使用了「底線開頭」這個命名原則。在 Python 中，這是一種<strong>慣例</strong>，用來表示這個<strong>屬性、函式、類別</strong>主要是作為<strong>內部使用</strong>。</p><p>所謂的「<strong>內部</strong>」可以有<strong>很多種解讀</strong>，而這裡我的用意是：<strong>它只是某個或多個 Schema 的一部分，不直接供 view 函式調用。</strong></p><p>別小看這個命名細節。隨著你的 Schema 數量增加，在開發新 API 時，你總是需要先瀏覽現有的 Schema，以決定是重新定義還是延用既有的。</p><p>此時有這樣的命名區別就顯得很「<strong>貼心</strong>」了——你不必在大大小小的 Schema 中翻來覆去，看得眼睛要脫窗。</p><p>撰寫巢狀 Schema 的機會不少，所以我認為養成這樣的好習慣是值得的。</p><h3 id="Nested-Response"><a href="#Nested-Response" class="headerlink" title="Nested Response"></a>Nested Response</h3><p>我們來看 API 的回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8000/posts/2/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1 content&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>看看新的<code>author</code>欄位內容，巢狀結構，非常完美！</p><p>用戶可以直接到看文章作者的名字與 email，如果想看更多作者資訊，依舊能透過<code>id</code>欄位，再讓前端呼叫另一支 API。</p><p>這是一個理想的<strong>折衷方案</strong>。</p><hr><h2 id="三、「攤平」巢狀資訊"><a href="#三、「攤平」巢狀資訊" class="headerlink" title="三、「攤平」巢狀資訊"></a>三、「攤平」巢狀資訊</h2><p>前面的「折衷方案」確實挺理想。不過，有時我們的需求<strong>更簡單</strong>。</p><p>比如在「取得文章列表」API 中，我們可能也需要顯示作者的資訊——但此時只要<strong>名字</strong>就足夠了。</p><p>不需要作者 id，更不用 email，只要名字即可。</p><p>那麼，為何稱之為「<strong>攤平巢狀資訊</strong>」呢？因為作者的名字並非<code>Post</code>模型的直接屬性，它實際上來自於關聯模型——<code>User</code>。</p><p>我們必須要把有關作者的巢狀資訊進行<strong>化簡</strong>。</p><p>本來是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>現在變成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;author_name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br></pre></td></tr></table></figure><p>從兩層變回一層（但不是作者 id 而是名字了），所以稱為「<strong>攤平</strong>」（flatten）。</p><h3 id="Schema-解耦"><a href="#Schema-解耦" class="headerlink" title="Schema 解耦"></a>Schema 解耦</h3><p>還記得「取得文章列表」API 的回應格式，其實是和「取得單一文章資訊」<strong>共用</strong>的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span>, response=<span class="built_in">list</span>[PostResponse]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>兩者都使用了<code>PostResponse</code>。</p><p>本文上半部對「取得單一文章資訊」回應的修改，<strong>也會影響到</strong>「取得文章列表」——這通常不是我們想要的結果。</p><p>所以，我們要為「取得文章列表」API 建立一個<strong>屬於自己的回應 Schema</strong>，並依照前面提到的需求，簡化資訊！</p><p>我打算：</p><ol><li>省略文章的內容（<code>content</code>）還有更新時間（<code>updated_at</code>）這兩個欄位，因為在列表中並不需要。</li><li>作者的部分只留下「名字」即可。</li></ol><hr><h2 id="四、實作攤平巢狀資訊——使用-property"><a href="#四、實作攤平巢狀資訊——使用-property" class="headerlink" title="四、實作攤平巢狀資訊——使用@property"></a>四、實作攤平巢狀資訊——使用<code>@property</code></h2><p>我們先看看新 Schema 如何定義：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostListResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    created_at: datetime</span><br><span class="line">    author_name: <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>你可能覺得奇怪，哪來的<code>author_name</code>屬性？<code>Post</code>模型並沒有啊？</p><p>沒錯！因為那是我們<strong>自己定義</strong>的——使用<code>@property</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/models.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">author_name</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> self.author.username</span><br></pre></td></tr></table></figure><p>如此一來，你的 Post 模型物件，就會有<code>author_name</code>這個屬性了。</p><p>但要注意，呼叫這個屬性通常意味著<strong>觸發第二次查詢</strong>（因為它是<strong>關聯模型</strong>上的屬性），所以 view 函式中要搭配 Django QuerySet 方法<code>select_related</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts.<span class="built_in">filter</span>(title__icontains=title).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這是 Django ORM 中常見的「<a href="https://medium.com/ichef/django-performance-optimization-1-orm-n-1-problem-493ddbfbe07a">N+1</a>」議題，在此先不展開。</p><h3 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h3><p>你可能覺得這個方式好像<strong>不怎麼優雅</strong>（至少我第一次看到時就是這麼想！）——尤其是和 Django REST framework 的做法相比。</p><p>Django REST framework 會在序列化器中這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">author_name = serializers.CharField(source=<span class="string">&quot;author.name&quot;</span>)</span><br></pre></td></tr></table></figure><p>是不是簡潔很多？</p><p>但這確實是 Django Ninja 作者<strong>早期</strong><a href="https://github.com/vitalik/django-ninja/issues/291#issuecomment-981395267">推薦的方式</a>。</p><p>別擔心，第 16 篇我們會介紹更好、更現代化的做法。不過<code>@property</code>在<strong>某些情況下</strong>，還是很有用的。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章中，我們展示了如何在 Django Ninja 中使用 Schema 實現巢狀結構回應。</p><p>接著介紹如何「攤平」這個巢狀結構，把原來的作者 id 替換成名字欄位。</p><p>這些方法大大增加了 API 回應的靈活性。</p><p>下一篇文章，我們將討論 Django Ninja 和 Django REST Framework 在序列化與回應結構處理上的不同設計理念，並比較兩者的優劣。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 API 開發中，我們經常會遇到&lt;strong&gt;關聯模型&lt;/strong&gt;之間的資料需要&lt;strong&gt;同時返回&lt;/strong&gt;的情況。&lt;/p&gt;
&lt;p&gt;特別是在處理「一對一」或「一對多」關聯時，&lt;strong&gt;多層結構&lt;/strong&gt;往往是常態。&lt;/p&gt;
&lt;p&gt;我們希望以&lt;strong&gt;巢狀結構&lt;/strong&gt;（&lt;a href=&quot;https://django-ninja.dev/guides/response/#nested-objects&quot;&gt;Nested Objects&lt;/a&gt;）的方式返回資料，這樣可以讓 API 的使用者&lt;strong&gt;一次取得必要資訊&lt;/strong&gt;，而不需要進行多次請求。&lt;/p&gt;
&lt;p&gt;本文將繼續使用並擴充「單一文章資訊」API 這個範例，講述如何在 Django Ninja 中實現&lt;strong&gt;巢狀結構回應&lt;/strong&gt;，讓我們的 API 回應更加豐富、有體系。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/6&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、問題背景&quot;&gt;&lt;a href=&quot;#一、問題背景&quot; class=&quot;headerlink&quot; title=&quot;一、問題背景&quot;&gt;&lt;/a&gt;一、問題背景&lt;/h2&gt;&lt;p&gt;在之前的 API 設計中，「取得單一文章資訊」的回應包括了文章資訊及&lt;strong&gt;作者的 id&lt;/strong&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;PostResponse&lt;/span&gt;(&lt;span class=&quot;title class_ inherited__&quot;&gt;Schema&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title: &lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    content: &lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    author_id: &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    created_at: datetime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    updated_at: datetime&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;有經驗的開發者都知道，無論是&lt;code&gt;id&lt;/code&gt;還是&lt;code&gt;author_id&lt;/code&gt;，通常&lt;strong&gt;不是&lt;/strong&gt;給服務的使用者看的——而是&lt;strong&gt;給前端人員靈活運用&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;比如在系統的畫面中，文章可能包括作者的&lt;strong&gt;個人資訊連結&lt;/strong&gt;，點進去可以看到作者資訊。此時前端必須&lt;strong&gt;透過 id&lt;/strong&gt;，再呼叫另一支 API「取得用戶資訊」來獲得額外的內容。&lt;/p&gt;
&lt;p&gt;如果額外資訊很多，這樣的「&lt;strong&gt;解耦&lt;/strong&gt;」設計是非常合理的。但如果我們希望&lt;strong&gt;一併呈現&lt;/strong&gt;作者的「&lt;strong&gt;必要資訊&lt;/strong&gt;」，那分次呼叫的設計就&lt;strong&gt;略嫌拖沓&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以我們需要&lt;strong&gt;巢狀結構&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;API 可以直接在回應中，嵌入作者的「必要資訊」，這樣用戶就不必再進行多次請求。這裡我們以一併顯示作者的「&lt;strong&gt;名字&lt;/strong&gt;」和「&lt;strong&gt;email&lt;/strong&gt;」為例。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 13：回應（一）Django Ninja 處理 HTTP 回應概論</title>
    <link href="https://blog.kyomind.tw/django-ninja-13/"/>
    <id>https://blog.kyomind.tw/django-ninja-13/</id>
    <published>2024-09-25T06:37:21.000Z</published>
    <updated>2024-09-27T07:04:00.071Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這一篇要正式進入「<strong>HTTP 回應</strong>」環節，也就是第三小節。</p><p>本節將透過 4 篇文章，介紹 Django Ninja <strong>如何處理 HTTP 回應</strong>：</p><ul><li><strong>卷 13：回應（一）Django Ninja 處理 HTTP 回應概論</strong>（本文）</li><li><a href="https://blog.kyomind.tw/django-ninja-14/">卷 14：回應（二）巢狀結構回應</a></li><li><a href="https://blog.kyomind.tw/django-ninja-15/">卷 15：回應（三）為何不用 ModelSchema？——相比 DRF，我更偏愛 Django Ninja 的理由</a></li><li><a href="https://blog.kyomind.tw/django-ninja-16/">卷 16：回應（四）Resolver 方法——欄位資料格式化</a></li></ul><p>我們會講述更多 Schema 用法，透過這些技巧，你能夠精確地控制 API 的輸出格式。無論是<strong>單一物件回應</strong>，還是複雜的<strong>嵌套結構</strong>，接下來都會一一提及。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/5">這個 PR</a>。</p><span id="more"></span><hr><p>本文將一步一步，從簡單到複雜，介紹如何透過 Django Ninja 建立 HTTP 回應。</p><p>並且用既有的 <strong>3 個 API</strong> 進行示範（<strong>會依需求為它們增補不同內容</strong>）：</p><ol><li>新增文章：示範<strong>簡單回應</strong>，加上狀態碼。</li><li>取得單一文章：示範<strong>單一物件回應</strong>，需要 Schema 與定義<code>response=</code>參數。</li><li>取得文章列表：示範<strong>多個物件回應</strong>。</li></ol><p>開始吧！</p><h2 id="一、簡單回應：新增文章"><a href="#一、簡單回應：新增文章" class="headerlink" title="一、簡單回應：新增文章"></a>一、簡單回應：新增文章</h2><p>先來看最簡單的回應格式，這個例子會展示如何<strong>回應一個 Python 字典</strong>，並手動設定 HTTP 回應狀態碼。</p><p>以「新增文章」API 為例：（省略部分程式碼）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_post</span>(<span class="params">...</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;id&#x27;</span>: post.<span class="built_in">id</span>, <span class="string">&#x27;title&#x27;</span>: post.title&#125;</span><br></pre></td></tr></table></figure><p>這裡回應的是一個 Python 字典，事實上，你<strong>可以</strong> return「<strong>任何能夠 JSON 序列化</strong>」的 Python 資料。（所以 Django 模型物件不行，因為它無法直接序列化）</p><p>因此，以下這些都可以 return：</p><ul><li>單純的字串：<code>&quot;Hello World !&quot;</code></li><li>Python list：<code>[1 , 2 , 3]</code></li><li>巢狀的資料結構：<code>&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;hobbies&quot;: [&quot;reading&quot;, &quot;swimming&quot;]&#125;</code></li></ul><p>這些都會被 Django Ninja 自動<strong>序列化為 JSON 格式</strong>，並作為 API 的回應。</p><hr><h2 id="為回應加上-HTTP-狀態碼"><a href="#為回應加上-HTTP-狀態碼" class="headerlink" title="為回應加上 HTTP 狀態碼"></a>為回應加上 HTTP 狀態碼</h2><p>View 函式處理回應，往往要<strong>加入 HTTP 狀態碼</strong>。尤其在有<strong>多種回應狀態</strong>的時候，需要透過狀態碼來<strong>區分</strong>。</p><p>做法很簡單，就是在回應的內容前面直接加上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">201</span>, &#123;<span class="string">&#x27;id&#x27;</span>: post.<span class="built_in">id</span>, <span class="string">&#x27;title&#x27;</span>: post.title&#125;</span><br></pre></td></tr></table></figure><p>如此一來，函式的回傳型別就從原來的<code>dict</code>變成<code>tuple</code>了。</p><p>所以我們函式簽名的 type hints 也要跟著修正：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_post</span>(<span class="params">...</span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]:</span><br></pre></td></tr></table></figure><p>如果你沒有加前面這個狀態碼數字，Django Ninja 就將其<strong>預設為 200。</strong></p><p>值得注意的是，當你的 view 函式要 return「<strong>非 200</strong>」回應時，必須在<code>router</code>裝飾器聲明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span>, response=&#123;<span class="number">201</span>: <span class="built_in">dict</span>&#125;</span>)  </span><span class="comment"># 這裡</span></span><br></pre></td></tr></table></figure><p><code>response=&#123;201: dict&#125;</code>就是聲明的方式，採用 Python 字典來一一對應<strong>狀態碼</strong>與<strong>回傳內容格式</strong>。</p><blockquote><p>創作當時，這部分的範例專案程式碼還未補上，所以這個 API 無法正常回應😅，特此提醒。</p></blockquote><hr><p>上述第一種回應很簡單，不過大部分 API 回應都<strong>沒這麼單純</strong>。</p><p>我們來看第二種回應。</p><h2 id="二、單一模型物件回應：取得單一文章"><a href="#二、單一模型物件回應：取得單一文章" class="headerlink" title="二、單一模型物件回應：取得單一文章"></a>二、單一模型物件回應：取得單一文章</h2><p>開發 Django API，回應中的資料，有很大部分是<strong>從 Django 模型物件序列化</strong>而來。</p><p>但通常我們不會直接將資料庫中的所有資訊傳送給前端。相反，我們會進行<strong>欄位篩選、驗證或格式轉換</strong>。</p><p>這樣不僅能夠精確控制 API 的輸出，還能確保資料的正確與安全性。</p><p>Django Ninja 中，這些「篩選、驗證、格式轉換」等需求，都是透過 Schema 實現。</p><p>我們來為「單得取一文章」API 設計一個回應格式，<strong>使用 Schema</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/schemas.py</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostResponse</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    content: <span class="built_in">str</span></span><br><span class="line">    author_id: <span class="built_in">int</span></span><br><span class="line">    created_at: datetime</span><br><span class="line">    updated_at: datetime</span><br></pre></td></tr></table></figure><p>這個<code>PostResponse</code> Schema 包含了<code>Post</code>幾乎所有的欄位。</p><p>注意，<strong>Schema 定義將決定輸出的欄位</strong>。如果 Schema 中只有<code>id</code>一欄，那輸出結果就只會有該欄的資料。</p><p>接著，我們在 view 函式中使用這個 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#123;int:post_id&#125;/&#x27;</span>, response=PostResponse</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params">request: HttpRequest, post_id: <span class="built_in">int</span></span>) -&gt; Post:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得單一文章</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    post = Post.objects.get(<span class="built_in">id</span>=post_id)</span><br><span class="line">    <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure><p>只有改一行！——在<code>router</code>裝飾器加上<code>response=PostSchema</code>。</p><p>有了<code>response=PostSchema</code>設定，Django Ninja 會將函式回傳的<code>Post</code>模型物件，丟給<code>PostSchema</code>進行驗證，成功之後直接轉為 JSON 格式並送回前端。</p><p>看看回應結果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8000/posts/2/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&#x27;s Django Ninja Post 1 content&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-09-12T02:28:16.801Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>非常好！</p><hr><h2 id="三、多個模型物件回應：取得文章列表"><a href="#三、多個模型物件回應：取得文章列表" class="headerlink" title="三、多個模型物件回應：取得文章列表"></a>三、多個模型物件回應：取得文章列表</h2><p>「<strong>清單、列表</strong>」也是 API 的常見回應形態，包含<strong>多筆資料</strong>。</p><p>我們繼續使用剛剛的<code>PostSchema</code>，不作任何更動，直接套用在「取得文章列表」這個 API。</p><p>一樣，只要更改一行即可，但與前面<strong>略有不同</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span>, response=<span class="built_in">list</span>[PostResponse]</span>)</span></span><br></pre></td></tr></table></figure><p>我們使用了<code>list[PostSchema]</code>，表示回應會是一個<code>PostSchema</code>物件的 list。</p><h3 id="Django-Ninja-自動處理-Iterable"><a href="#Django-Ninja-自動處理-Iterable" class="headerlink" title="Django Ninja 自動處理 Iterable"></a>Django Ninja 自動處理 Iterable</h3><p>然而實際上，此時你<strong>不需要</strong>「真的」return 一個 Python list，<strong>可以直接回傳 QuerySet</strong> 就好，Django Ninja 會自行處理物件的<strong>迭代與序列化</strong>。</p><p>甚至，只要你 return 的是一個 <a href="https://myapollo.com.tw/blog/python-iterable-iterator-generator/#iterable-%e6%98%af%e4%bb%80%e9%ba%bc">iterable</a>，而且 iterable 中的每一個元素，<strong>都能夠通過</strong><code>PostSchema</code>驗證（符合格式），那就足夠了！</p><p>來看看結果，因為列表太長了，我改用截圖呈現：</p><p><img src="https://i.imgur.com/vwh3t3R.png" alt="API 回應：取得文章列表"><span class="cap">API 回應：取得文章列表</span></p><hr><h2 id="多重狀態碼回應"><a href="#多重狀態碼回應" class="headerlink" title="多重狀態碼回應"></a>多重狀態碼回應</h2><p>上面提到的回應，不是 200 就是 201，但通常 API 往往還會有 400、401、403 甚至 500 等回應，如何處理它們之間的<strong>對應關係</strong>？</p><p>沒錯，就是擴大<code>response=</code>中的字典！我們直接看<a href="https://django-ninja.dev/guides/response/#multiple-response-schemas">官方文件</a>的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    token: <span class="built_in">str</span></span><br><span class="line">    expires: date</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    message: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@api.post(<span class="params"><span class="string">&#x27;/login&#x27;</span>, response=&#123;<span class="number">200</span>: Token, <span class="number">401</span>: Message, <span class="number">402</span>: Message&#125;</span>)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>值得留意的是，字典的 key 不可重複，但值可以！——<code>Message</code>出現了兩次。</p><p>但我覺得這個「多重狀態碼回應」設定在實務上沒有很實用，為何？我們後續再談。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>本文中，我們從最簡單的回應開始，逐步介紹了如何在回應中返回單一和多筆資料，並提到了 Django Ninja 如何設定多重狀態碼回應。</p><p>下一篇將探討，如何處理回應中複雜的<strong>巢狀結構</strong>，讓我們的 API 愈來愈健全。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這一篇要正式進入「&lt;strong&gt;HTTP 回應&lt;/strong&gt;」環節，也就是第三小節。&lt;/p&gt;
&lt;p&gt;本節將透過 4 篇文章，介紹 Django Ninja &lt;strong&gt;如何處理 HTTP 回應&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;卷 13：回應（一）Django Ninja 處理 HTTP 回應概論&lt;/strong&gt;（本文）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/django-ninja-14/&quot;&gt;卷 14：回應（二）巢狀結構回應&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/django-ninja-15/&quot;&gt;卷 15：回應（三）為何不用 ModelSchema？——相比 DRF，我更偏愛 Django Ninja 的理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/django-ninja-16/&quot;&gt;卷 16：回應（四）Resolver 方法——欄位資料格式化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們會講述更多 Schema 用法，透過這些技巧，你能夠精確地控制 API 的輸出格式。無論是&lt;strong&gt;單一物件回應&lt;/strong&gt;，還是複雜的&lt;strong&gt;嵌套結構&lt;/strong&gt;，接下來都會一一提及。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/5&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 12：請求（四）Request Body 與 Schema 介紹</title>
    <link href="https://blog.kyomind.tw/django-ninja-12/"/>
    <id>https://blog.kyomind.tw/django-ninja-12/</id>
    <published>2024-09-24T06:22:23.000Z</published>
    <updated>2024-09-24T07:18:21.402Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>經過前幾篇的介紹，我們已經學習了如何處理路徑與查詢參數。但在現實世界中，我們往往還需要處理<strong>更複雜的請求資料</strong>。</p><p>比如用戶提交的表單、上傳的檔案等等。對於 API 而言，最常見的就是 JSON 格式的 <strong>request body</strong>。</p><p>這一篇將探討 Django Ninja 如何處理 request body，並介紹如何透過 Schema 來定義與驗證資料。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/4">這個 PR</a>。</p><hr><h2 id="一、什麼是-Request-Body？"><a href="#一、什麼是-Request-Body？" class="headerlink" title="一、什麼是 Request Body？"></a>一、什麼是 Request Body？</h2><p><strong>Request body</strong> 指的是隨著 HTTP 請求一同傳送的資料，通常用於<code>POST</code>、<code>PUT</code>等<strong>需要建立或更新「資源」的請求。</strong></p><p>這些資料不會出現在 URL 中，而是以 JSON 或其他格式（如 XML、form-data）作為請求的主體。</p><p>例如，當用戶要發表一篇新文章時，可能會傳送以下 JSON 格式的 request body：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我的第一篇文章&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;這是我在忍者論壇的第一篇文章，希望大家喜歡！&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>這個 request body 包含了<code>title</code>和<code>content</code>兩個欄位，Django Ninja 將協助我們處理這些資料並進行驗證。</p><span id="more"></span><hr><h2 id="二、範例專案改動"><a href="#二、範例專案改動" class="headerlink" title="二、範例專案改動"></a>二、範例專案改動</h2><p>我們要在<a href="https://github.com/kyomind/Django-Ninja-Tutorial">範例專案</a>中建立一個<strong>接收 request body</strong> 的 API——「新增文章」。</p><p>此外，還要在 Django post app 目錄下，新增一個 Python 模組：<code>schemas.py</code>。這是用來放置 API 中<strong>所有用到的 Schema</strong> 的地方。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── NinjaForum</span><br><span class="line">│   ├── ...</span><br><span class="line">├── post</span><br><span class="line">│   ├── api.py</span><br><span class="line">│   ├── schemas.py <span class="comment"># 新增這個模組</span></span><br><span class="line">│   ├── ...</span><br></pre></td></tr></table></figure><p>具體程式碼，我們會在接下來的說明中介紹。</p><p>從本篇開始，分支名稱不再使用中文，因為中文分支名稱會<strong>一直被 GitHub 提醒：</strong></p><blockquote><p>The head ref <strong>may contain hidden characters</strong>: “11-\u8ACB\u6C42\uFF08\u4E09\uFF09Query-Parameters”</p></blockquote><p>而且應該也很少人使用中文來命名 git 分支！當初用中文是為了讀者比較好讀🥹</p><p>所以從這個分支開始，改成<code>數字+英文</code>，比如本篇的「<code>12-request-body</code>」。但 PR 的標題仍維持中文。</p><hr><h2 id="三、使用-Schema-定義與驗證-Request-Body"><a href="#三、使用-Schema-定義與驗證-Request-Body" class="headerlink" title="三、使用 Schema 定義與驗證 Request Body"></a>三、使用 Schema 定義與驗證 Request Body</h2><p>與 FastAPI 相同，Django Ninja 使用 <a href="https://docs.pydantic.dev/latest/api/base_model/">Pydantic BaseModel</a> 來處理請求 body。</p><p>不過因為 BaseModel 這個名稱容易和 Django 的 Models 混淆，所以 Django Ninja 將其重新命名為 Schema。</p><p>Schema 繼承自 BaseModel，因此兩者的<strong>實際內涵非常接近</strong>（Django Ninja 有自己加一點料）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Django Ninja 原始碼</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Schema</span>(BaseModel, metaclass=ResolverMetaclass):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>回到專案，讓我們來看專案中的例子，這是定義「新增文章」API 的 request body 的 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/schemas.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Schema</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreatePostRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    content: <span class="built_in">str</span></span><br><span class="line">    user_id: <span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>這個 Schema 要求 body 資料<strong>必須包含</strong>這三個欄位：<code>title</code>、<code>content</code>和<code>user_id</code>，而且<strong>資料的型別也要相符</strong>。</p><h3 id="在-View-函式中使用-Schema"><a href="#在-View-函式中使用-Schema" class="headerlink" title="在 View 函式中使用 Schema"></a>在 View 函式中使用 Schema</h3><p>定義好了「請求」Schema，就可以在 view 函式中以「<strong>函式參數</strong>」的形式使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> post.schemas <span class="keyword">import</span> CreatePostRequest</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_post</span>(<span class="params">..., payload: CreatePostRequest</span>):  <span class="comment"># 這裡</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我們將函式<code>payload</code>參數的 type hint 設定為我們剛剛定義的<code>CreatePostRequest</code>。</p><p>當請求發送到這個 API 時，Django Ninja 會透過<code>CreatePostRequest</code>這個 Schema 來<strong>解析</strong>（<strong>parsing</strong>）並<strong>驗證</strong> body 中的資料。</p><p>驗證成功後，再將資料傳入 view 函式的<code>payload</code>。此時<strong>函式內部</strong>的<code>payload</code>參數，本質上是一個 Schema（即 Pydantic BaseModel）物件。</p><h3 id="自動資料驗證與錯誤處理"><a href="#自動資料驗證與錯誤處理" class="headerlink" title="自動資料驗證與錯誤處理"></a>自動資料驗證與錯誤處理</h3><p>如果請求 body 中有欄位缺少，或者資料的型別不對，Django Ninja 會自動返回 <strong>422 回應</strong>，並提供<strong>具體的錯誤資訊</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;missing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;body&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;payload&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;content&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Field required&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>錯誤訊息表示：body 中缺少了<code>content</code>這個 field。</p><hr><h2 id="四、可選的（Optional）欄位與預設值"><a href="#四、可選的（Optional）欄位與預設值" class="headerlink" title="四、可選的（Optional）欄位與預設值"></a>四、可選的（Optional）欄位與預設值</h2><p>在實際 API 開發中，<strong>並不是</strong>所有請求欄位都是必須的。</p><p>我們可以透過 Pydantic 與 type hints 來定義<strong>可選欄位</strong>。假設，現在文章的內容是完全可選的：（留意<code>content</code>欄位）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreatePostRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    content: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    user_id: <span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>使用<code>=</code>運算子，將<code>content</code>欄位的<strong>預設值</strong>設定為<code>None</code>，該欄位<strong>就會變成可選欄位</strong>。此時<code>content</code>的 type hints 也要改為<code>str | None</code>。</p><p>值得一提的是，如果 Schema 用在<strong>請求</strong>，這樣設定即使<strong>能通過驗證</strong>，你也要注意後續對應的 Django Model 欄位（也就是 db 欄位）<strong>是否允許 NULL</strong>。不然還是會出錯：</p><blockquote><p>django.db.utils.IntegrityError: NOT NULL constraint failed: post_post.content</p></blockquote><p>除了將欄位設為可選，也可以直接<strong>給定預設值</strong>，比如這裡的空字串。在使用者未輸入時，就會直接填入預設值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreatePostRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    content: <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    user_id: <span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>然而，除了預設值為<code>None</code>，在 Schema 中<strong>給定預設值</strong>的行為要「<strong>非常慎用</strong>」。這部分我們在〈卷 18：用 Pydantic Field 設定範例與預設值〉還會再次討論。</p><hr><h2 id="五、Django-Ninja-判斷參數的順序"><a href="#五、Django-Ninja-判斷參數的順序" class="headerlink" title="五、Django Ninja 判斷參數的順序"></a>五、Django Ninja 判斷參數的順序</h2><p>你是否想過，一個 view 函式參數這麼多種，Django Ninja 怎麼知道<strong>誰要對應誰</strong>？</p><p>事實上，Django Ninja 確實會根據 view 函式的<strong>參數簽名</strong>，自動判斷參數的來源（究竟是路徑參數、查詢參數或請求 body）。其<a href="https://django-ninja.dev/guides/input/body/#request-body-path-query-parameters">判斷順序</a>如下：</p><ol><li><strong>路徑參數</strong>：任何定義在 URL path 中的變數（比如<code>/items/&#123;id&#125;</code>中的<code>id</code>）會<strong>優先被識別為路徑參數</strong>。</li><li><strong>查詢參數</strong>：函式中的其他<strong>單數類型</strong>參數（比如<code>int</code>、<code>float</code>、<code>bool</code>、<code>str</code>，而不是<code>list</code>、<code>dict</code>），若<strong>未標註為路徑參數</strong>，則會被識別為查詢參數。</li><li><strong>Request body</strong>：Schema 型別參數，才會被視為請求 body。</li></ol><p>原則上，view 函式<strong>只能有一個</strong> Schema 參數。畢竟一個請求就只有一個 body 而已。</p><hr><h2 id="第二節尾聲"><a href="#第二節尾聲" class="headerlink" title="第二節尾聲"></a>第二節尾聲</h2><p>本節的內容已差不多結束。</p><p>在這一節中，我們學習了如何使用 Django Ninja 處理 HTTP 請求，並介紹了 Schema 的基本用法。</p><p>Schema 的用法與變化還很多，這裡只是「牛刀小試」而已。在第三節「HTTP 回應」中，你將看到更多關於 Schema 的設定。</p><p>進入下一節之前，我們先進行中場休息——和<strong>一些準備</strong>。</p><hr><h2 id="中場休息與準備"><a href="#中場休息與準備" class="headerlink" title="中場休息與準備"></a>中場休息與準備</h2><p>下一節，我們要讓專案的 API <strong>真正運作起來</strong>，還記得前面提到為何目前無法使用嗎？</p><ol><li>沒有 db 資料。</li><li>沒有建立 Schema。</li></ol><p>我們已經學到怎麼使用 Schema 了——雖然<strong>還不全面</strong>。那「db 資料」問題也需要獲得解決。</p><h3 id="Django-Fixtures"><a href="#Django-Fixtures" class="headerlink" title="Django Fixtures"></a>Django Fixtures</h3><p>我們固然可以透過呼叫 POST API 去<strong>手動新增</strong>用戶與文章資料，但太麻煩了！更別說，專案目前<strong>還沒有</strong>「新增使用者」這個 API。</p><p>所以，不用麻煩了。</p><p>我們直接透過 <a href="https://docs.djangoproject.com/en/5.1/topics/db/fixtures/">Django fixtures</a> 來匯入由我預先定義好的<strong>假資料</strong>。</p><p>有關 Django fixtures 的介紹，可參考文章〈<a href="https://blog.kyomind.tw/django-fixtures/">用 Django Fixture 匯入與導出資料</a>〉。</p><p>在下一篇<code>13-response</code>分支進度底下，你已經可以看到我<strong>導出</strong>的 fixtures 資料：</p><ol><li><code>users.json</code>。</li><li><code>posts.json</code>。</li></ol><p>想要使用它們，直接<strong>依序匯入</strong>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py loaddata users.json</span><br><span class="line">python manage.py loaddata posts.json</span><br></pre></td></tr></table></figure><p>一定要<strong>先匯入</strong> users，否則文章沒有作者會<strong>關聯失敗</strong>。</p><p>匯入完成後，你會獲得 2 個使用者——Alice 和 Bob，還有他們各發表的 30 篇文章。</p><p><img src="https://i.imgur.com/dHCBf4T.png"></p><p>呃，夾雜了第一篇我的測試文章，請多包涵😅</p><p>成功匯入後，我們就可以繼續了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;經過前幾篇的介紹，我們已經學習了如何處理路徑與查詢參數。但在現實世界中，我們往往還需要處理&lt;strong&gt;更複雜的請求資料&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如用戶提交的表單、上傳的檔案等等。對於 API 而言，最常見的就是 JSON 格式的 &lt;strong&gt;request body&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這一篇將探討 Django Ninja 如何處理 request body，並介紹如何透過 Schema 來定義與驗證資料。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/4&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、什麼是-Request-Body？&quot;&gt;&lt;a href=&quot;#一、什麼是-Request-Body？&quot; class=&quot;headerlink&quot; title=&quot;一、什麼是 Request Body？&quot;&gt;&lt;/a&gt;一、什麼是 Request Body？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Request body&lt;/strong&gt; 指的是隨著 HTTP 請求一同傳送的資料，通常用於&lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;等&lt;strong&gt;需要建立或更新「資源」的請求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這些資料不會出現在 URL 中，而是以 JSON 或其他格式（如 XML、form-data）作為請求的主體。&lt;/p&gt;
&lt;p&gt;例如，當用戶要發表一篇新文章時，可能會傳送以下 JSON 格式的 request body：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;我的第一篇文章&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;這是我在忍者論壇的第一篇文章，希望大家喜歡！&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;這個 request body 包含了&lt;code&gt;title&lt;/code&gt;和&lt;code&gt;content&lt;/code&gt;兩個欄位，Django Ninja 將協助我們處理這些資料並進行驗證。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 11：請求（三）查詢參數（Query Parameters）</title>
    <link href="https://blog.kyomind.tw/django-ninja-11/"/>
    <id>https://blog.kyomind.tw/django-ninja-11/</id>
    <published>2024-09-23T03:03:49.000Z</published>
    <updated>2024-09-23T04:09:31.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇我們討論了，請求 URL 中關於<strong>路徑參數</strong>的處理方式。</p><p>本文將介紹<strong>查詢參數（query parameters）</strong>，這是 RESTful API 中用來傳遞<strong>過濾條件</strong>等<strong>額外資訊</strong>的重要部分。</p><p>處理查詢參數在 Django Ninja 中非常簡單直觀，我們可以透過多種方式來達成。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/3">這個 PR</a>。</p><hr><h2 id="一、什麼是查詢參數？"><a href="#一、什麼是查詢參數？" class="headerlink" title="一、什麼是查詢參數？"></a>一、什麼是查詢參數？</h2><p>查詢參數是 URL 中的可選參數，通常位於 path 的後方，以<code>?key=value</code>的形式出現，用來傳遞<strong>額外的資訊</strong>。</p><p>例如，當我們需要過濾某位作者的文章時，URL 的 path 可能會這樣寫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/posts/?author=john</span><br></pre></td></tr></table></figure><p>URL 傳遞了一個查詢參數<code>author=john</code>，表示我們希望過濾出由 John 撰寫的文章。</p><span id="more"></span><h2 id="二、範例專案改動"><a href="#二、範例專案改動" class="headerlink" title="二、範例專案改動"></a>二、範例專案改動</h2><p>為了更真實地介紹<strong>查詢參數</strong>，我們需要修改原先的「取得所有文章」API，加入簡單的「<strong>過濾</strong>」功能。</p><p>附帶一提，複雜的過濾功能，我們會在〈卷 23：過濾（Filtering）〉進行介紹。</p><p>修改後，當請求帶有查詢參數時，API 就能透過這些參數來<strong>限制查詢結果</strong>。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">request: HttpRequest, title: <span class="literal">None</span> | <span class="built_in">str</span> = <span class="literal">None</span></span>):</span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> title:</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(title__icontains=title)  <span class="comment"># 實現過濾邏輯</span></span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這裡我們以「<strong>文章標題</strong>」來進行過濾。</p><blockquote><p>小提醒：專案 API <strong>目前還無法使用</strong>，一來 db 沒有資料，二來我們還沒有撰寫相關的 Schema。現階段僅作為閱讀理解上的參考。不過別擔心，我們很快會讓它 work ☺️</p></blockquote><p>好，改完程式碼，接下來進行講解。</p><hr><h2 id="三、在-Django-Ninja-中使用-Query-Parameters"><a href="#三、在-Django-Ninja-中使用-Query-Parameters" class="headerlink" title="三、在 Django Ninja 中使用 Query Parameters"></a>三、在 Django Ninja 中使用 Query Parameters</h2><p>在 Django Ninja 中，處理<strong>查詢參數</strong>的最簡單方式，是直接將它們作為 view 函式的<strong>可選參數——透過參數預設值</strong><code>None</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">request: HttpRequest, title: <span class="literal">None</span> | <span class="built_in">str</span> = <span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure><p>在這個例子中，<code>title</code>參數被定義為一個<strong>可選的字串</strong>（<code>None | str = None</code>）。</p><ul><li>如果 URL 中<strong>包含</strong><code>title</code>查詢參數，Django Ninja 會自動將其值作為引數，並傳遞給<code>get_posts</code>函式。</li><li>如果 URL 中<strong>沒有</strong>這個查詢參數，則函式<strong>不會收到引數</strong>，此時<code>title</code>在函式中的值將會是<code>None</code>——因為它有<strong>預設值</strong>。</li></ul><p>關於這個例子，我們<strong>還需要留意</strong>以下這些地方：</p><ol><li>查詢參數<strong>不需要</strong>寫在<code>router</code>裝飾器的<code>path</code>參數路徑中。</li><li>查詢參數<strong>通常有預設值</strong>，無論是具體的值還是上述的<code>None</code>。如果<strong>缺少預設值</strong>，當查詢參數不存在時，Django Ninja 會返回 422 回應。</li><li>當預設值為<code>None</code>時，需留意 type hints 的寫法：<code>None | str = None</code>。（相當於<code>Optional[str] = None</code>）</li><li>查詢參數和路徑參數一樣，都會依照函式的 type hints 進行型別轉換。如果沒有標記型別，那兩者的<strong>預設型別皆為</strong><code>str</code>——因為 URL 本質都是<strong>字串</strong>。</li></ol><p>以上寫法簡單直接，適用於大多數情況。</p><p>然而，當我們需要對查詢參數進行<strong>更複雜的驗證或限制</strong>時，就需要使用進階的技巧——<code>Query</code>。</p><hr><h2 id="四、使用-Query-物件"><a href="#四、使用-Query-物件" class="headerlink" title="四、使用 Query 物件"></a>四、使用 Query 物件</h2><p>當我們需要進行更詳細的控制，例如限制查詢參數的長度、範圍，或為 API 文件加上額外資訊時，可以使用<code>Query</code>來設定、處理查詢參數。</p><p>必須承認，我之前開發其實也很少用到<code>Query</code>，但了解它 <strong>20% 最重要的特性</strong>，肯定會很有幫助。</p><h3 id="Query類別介紹"><a href="#Query類別介紹" class="headerlink" title="Query類別介紹"></a><code>Query</code>類別介紹</h3><p>透過<code>Query</code>物件，我們可以對查詢參數進行更精細的定義與驗證。</p><p>事實上，如果你看過 Django Ninja 的<a href="https://github.com/vitalik/django-ninja/blob/master/ninja/params/functions.py#L50">原始碼</a>，你會發現：它其實是一個<strong>函式</strong>。只不過會<strong>返回相同名稱的類別物件</strong>。為了解說方便，我們暫且當它是類別吧！</p><p>參考這個修改後的範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Query, Router</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">request: HttpRequest, title: <span class="literal">None</span> | <span class="built_in">str</span> = Query(<span class="params"><span class="literal">None</span></span>)</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>它和原來的寫法是「<strong>等價</strong>」的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">request: HttpRequest, title: <span class="literal">None</span> | <span class="built_in">str</span> = <span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure><p>你可能會覺得奇怪，那我沒事幹嘛要換一個更複雜的寫法，卻沒有額外的好處？</p><p>這當然是因為，更複雜的寫法，能做的事情也更多。</p><h3 id="限制查詢字串的長度"><a href="#限制查詢字串的長度" class="headerlink" title="限制查詢字串的長度"></a>限制查詢字串的長度</h3><p>比如我們想要限制<code>title</code>這個查詢字串，不可以太長也不可以太短。</p><p>假設要求長度在 2 到 10 個字元好了。</p><p>此時你就可以這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    title: <span class="literal">None</span> | <span class="built_in">str</span> = Query(<span class="params"><span class="literal">None</span>, min_length=<span class="number">2</span>, max_length=<span class="number">10</span></span>),</span></span><br><span class="line"><span class="params"></span>):</span><br></pre></td></tr></table></figure><p>這個範例中，我們使用了<code>Query</code>來定義<code>title</code>查詢參數，並額外給予了<code>min_length</code>和<code>max_length</code>這兩個初始化<code>Query</code>的參數設定。</p><p>這樣做可以確保<code>title</code>查詢參數的長度在 2 到 10 個字元之間。</p><p>如果用戶輸入的<code>title</code>不符合這個長度要求，如之前所述，Django Ninja 會自動返回一個<strong>狀態碼為 422 的回應</strong>，無需我們手動處理這些驗證邏輯與相關回應。</p><h3 id="Query的其他常用參數"><a href="#Query的其他常用參數" class="headerlink" title="Query的其他常用參數"></a><code>Query</code>的其他常用參數</h3><p>除了<code>min_length</code>和<code>max_length</code>，<code>Query</code>還提供了許多實用的參數，供你限制查詢條件、為 API 文件補充額外資訊，常見的有：</p><ul><li><code>gt</code>、<code>ge</code>：查詢參數的值必須大於或大於等於某個數字。</li><li><code>lt</code>、<code>le</code>：查詢參數的值必須小於或小於等於某個數字。</li><li><code>example</code>、<code>examples</code>：為 API 文件提供查詢<strong>參數的範例值</strong>，讓用戶更容易理解參數用法。</li></ul><p>這部分我們就不示範了。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>查詢參數是 RESTful API 常見且重要的組成部分。Django Ninja 中，我們可以透過簡單的方式來處理查詢參數，也可以使用<code>Query</code>進行更高級的驗證和控制。</p><p>了解了 Django Ninja 如何處理 URL 的相關參數後，接下來則是<strong>重頭戲</strong>。</p><p>下一步，我們將探討如何在 Django Ninja 中處理 HTTP <strong>request body</strong>，介紹如何使用 Schema 來進行<strong>資料驗證與反序列化</strong>，讓我們能夠靈活地處理複雜的請求資訊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇我們討論了，請求 URL 中關於&lt;strong&gt;路徑參數&lt;/strong&gt;的處理方式。&lt;/p&gt;
&lt;p&gt;本文將介紹&lt;strong&gt;查詢參數（query parameters）&lt;/strong&gt;，這是 RESTful API 中用來傳遞&lt;strong&gt;過濾條件&lt;/strong&gt;等&lt;strong&gt;額外資訊&lt;/strong&gt;的重要部分。&lt;/p&gt;
&lt;p&gt;處理查詢參數在 Django Ninja 中非常簡單直觀，我們可以透過多種方式來達成。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/3&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、什麼是查詢參數？&quot;&gt;&lt;a href=&quot;#一、什麼是查詢參數？&quot; class=&quot;headerlink&quot; title=&quot;一、什麼是查詢參數？&quot;&gt;&lt;/a&gt;一、什麼是查詢參數？&lt;/h2&gt;&lt;p&gt;查詢參數是 URL 中的可選參數，通常位於 path 的後方，以&lt;code&gt;?key=value&lt;/code&gt;的形式出現，用來傳遞&lt;strong&gt;額外的資訊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，當我們需要過濾某位作者的文章時，URL 的 path 可能會這樣寫：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/posts/?author=john&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;URL 傳遞了一個查詢參數&lt;code&gt;author=john&lt;/code&gt;，表示我們希望過濾出由 John 撰寫的文章。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 10：請求（二）路徑參數（Path Parameters）</title>
    <link href="https://blog.kyomind.tw/django-ninja-10/"/>
    <id>https://blog.kyomind.tw/django-ninja-10/</id>
    <published>2024-09-22T03:11:34.000Z</published>
    <updated>2024-09-23T06:45:24.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇文章中，我們介紹了 Django Ninja 如何處理 HTTP 請求，並強調了它與 Python type hints 之間的緊密結合。</p><p>本篇將探討 Django Ninja 中，<strong>路徑參數（<a href="https://django-ninja.dev/guides/input/path-params/">path parameters</a>）</strong>的應用與細節，這在處理 HTTP 請求時<strong>極為常見</strong>，尤其是在 RESTful API 中。</p><p>本文對範例專案的程式碼改動，都集中在<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/2">這個 PR</a>。</p><hr><h2 id="一、什麼是-Path-Parameters？"><a href="#一、什麼是-Path-Parameters？" class="headerlink" title="一、什麼是 Path Parameters？"></a>一、什麼是 Path Parameters？</h2><p>Path parameters 是構成 URL 的一部分，它們位於網址路徑（path）中的<strong>特定</strong>位置，<strong>根據不同的值（參數）</strong>來決定傳入的內容，用來<strong>動態指定資源</strong>。</p><p>我們不妨先了解一下，<strong>path</strong> 在整個 URL 中的位置：（圖片取自<a href="https://en.wikipedia.org/wiki/URL">維基百科</a>）</p><p><img src="https://i.imgur.com/o2JxS9I.png" alt="點圖可放大"><span class="cap">點圖可放大</span></p><p>從圖中可以看出，路徑（path）是 URL 的一部分——而且是<strong>必要部分</strong>。</p><p>不過請注意，path parameters 只是 Django、Django Ninja 這類框架所提供的一種「<strong>功能</strong>」。對 URL 本身而言，path 就是 path，也就是<strong>單純的字串</strong>而已。</p><h3 id="路徑參數例子"><a href="#路徑參數例子" class="headerlink" title="路徑參數例子"></a>路徑參數例子</h3><p>舉一個簡單的例子，讓我們可以更好地理解 path parameters 的概念。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#123;post_id&#125;/&#x27;</span></span>)  </span><span class="comment"># &#123;post_id&#125; 就是路徑參數</span></span><br></pre></td></tr></table></figure><p>實際請求時，<code>123</code>就是<strong>透過</strong>路徑參數，代表特定文章的 id：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /posts/123</span><br></pre></td></tr></table></figure><p>可想而知，如果是<code>456</code>或<code>789</code>，你會得到不同的結果。</p><p>這使得 API 具有<strong>彈性</strong>，可以針對不同的資源進行操作，而<strong>不必為每一個資源建立不同的路由</strong>——它們的端點與路由<strong>都是相同的</strong>，只是「<strong>參數</strong>」不同。</p><span id="more"></span><hr><h2 id="二、範例專案改動"><a href="#二、範例專案改動" class="headerlink" title="二、範例專案改動"></a>二、範例專案改動</h2><p>接下來，讓我們透過<a href="https://github.com/kyomind/Django-Ninja-Tutorial">範例專案</a>的程式碼，一邊講解一邊演示本文內容。</p><p>但我們要先進行兩個改動。</p><h3 id="改動一：取消一級路由前綴"><a href="#改動一：取消一級路由前綴" class="headerlink" title="改動一：取消一級路由前綴"></a>改動一：取消一級路由前綴</h3><p>取消一級路由前綴<code>/posts/</code>和<code>/user/</code>，讓 view 函式的 router 裝飾器上的路徑，更加完整、好讀。</p><p>本來是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/&#123;post_id&#125;/&#x27;</span></span>)  </span><span class="comment"># 前綴路由在專案一級路由定義了</span></span><br></pre></td></tr></table></figure><p>現在是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#123;post_id&#125;/&#x27;</span></span>)  </span><span class="comment"># 全部改在 app 的二級路由定義</span></span><br></pre></td></tr></table></figure><p>注意，這是為了<strong>提升教學體驗</strong>，工作中我們通常不會這麼做，不然就失去了<strong>模組化路由</strong>的優勢。</p><h3 id="改動二：新增-API"><a href="#改動二：新增-API" class="headerlink" title="改動二：新增 API"></a>改動二：新增 API</h3><p>為了示範 path parameters，我們必須有一個實踐這個功能的 API。</p><p>我們新增一個「<strong>取得單一文章資訊</strong>」API。</p><hr><p>好，先這樣，我們可以開始了解 path parameters 了。</p><p>以下程式碼皆取自於範例專案。</p><h2 id="三、在-Django-Ninja-中使用-Path-Parameters"><a href="#三、在-Django-Ninja-中使用-Path-Parameters" class="headerlink" title="三、在 Django Ninja 中使用 Path Parameters"></a>三、在 Django Ninja 中使用 Path Parameters</h2><p>在 Django Ninja 中，<strong>定義路徑參數</strong>非常簡單。透過 router 裝飾器與 type hints，我們可以輕鬆處理這些參數，自動進行類型轉換。</p><h3 id="定義「帶有路徑參數」的-API"><a href="#定義「帶有路徑參數」的-API" class="headerlink" title="定義「帶有路徑參數」的 API"></a>定義「帶有路徑參數」的 API</h3><p>讓我們看看如何在 Django Ninja 中定義一個帶有路徑參數的 API：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#123;post_id&#125;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params">request: HttpRequest, post_id: <span class="built_in">int</span></span>) -&gt; Post:</span><br><span class="line">    post = Post.objects.get(<span class="built_in">id</span>=post_id)</span><br><span class="line">    <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure><p>範例中，<code>&#123;post_id&#125;</code>是一個路徑參數，<strong>整個 path 字串</strong>將被<strong>解析</strong>（parsing）並傳遞給<code>get_post</code><strong>函式中</strong>的<code>post_id</code>參數。</p><p>Django Ninja 會依照<strong>函式簽名</strong>中定義的類型，自動進行型別轉換。</p><p>例如，我們在 view 函式中標記了 <code>post_id: int</code>，Django Ninja 會自動將<strong>來自 URL 的字串參數</strong>轉換成<code>int</code>。</p><p>換言之，處理 path parameters 的流程，同時具有<strong>兩種效果</strong>：</p><ol><li><strong>參數型別驗證</strong>：避免前端傳來<code>post_id</code>內容是<strong>錯誤的型別</strong>，而在 view 函式內部<strong>還繼續嘗試處理這個值</strong>，直到發生錯誤。</li><li><strong>View 函式內部的自動型別轉換</strong>：省下在函式內自行轉換的功夫。</li></ol><hr><h2 id="四、與-Django-原生-Path-Converters-兼容"><a href="#四、與-Django-原生-Path-Converters-兼容" class="headerlink" title="四、與 Django 原生 Path Converters 兼容"></a>四、與 Django 原生 Path Converters 兼容</h2><p>Django 在處理 URL 時，本來就提供了「<a href="https://docs.djangoproject.com/en/5.1/topics/http/urls/#path-converters">path converters</a>」來讓你對請求路徑進行「嚴格配對」。</p><p><strong>配對成功，才會把 HTTP 請求「轉發」給特定的 view 函式</strong>。</p><p>這裡的「嚴格」，指的是<strong>型別</strong>要<strong>與 path converter 所定義的相符</strong>，才能夠<strong>配對成功</strong>。</p><p>常見的 converters 類型包括<code>str</code>、<code>int</code>和<code>slug</code>，它們能夠限制 URL 中參數的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">&#x27;posts/&lt;int:post_id&gt;/&#x27;</span>, views.get_post),</span><br></pre></td></tr></table></figure><p><code>&lt;int:post_id&gt;</code>就是一個 path converter，它要求<code>post_id</code>必須是一個整數。</p><p>值得強調的是，path converters 的主要目的<strong>不是</strong>為了型別轉換——這只是附帶的。而是為了端點路徑的「<strong>模式比對</strong>」（pattern matching）。</p><p>在模式不符合的情況下，<strong>根本不會配對成功</strong>，當然也不會進行轉型。</p><h3 id="Django-Ninja-中的-Path-Converters"><a href="#Django-Ninja-中的-Path-Converters" class="headerlink" title="Django Ninja 中的 Path Converters"></a>Django Ninja 中的 Path Converters</h3><p>在 Django Ninja 中，這些原生的 path converters <strong>仍然可以使用</strong>，而且<strong>進一步簡化</strong>了。</p><p>直接寫在<code>router</code>裝飾器的路徑字串中即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/posts/&#123;int:post_id&#125;/&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>如前所述，有了 path converter 後，如果<code>post_id</code>不是有效的<code>int</code> ，<strong>則 URL 模式配對將直接失敗</strong>——請求<strong>不會進入 view 函式</strong>，更不會有型別轉換。</p><p>如果沒有其他路徑被成功配對，<strong>Django 將直接返回「404 Not Found」。</strong></p><p>個人認為，在 Django Ninja 中，path converters 的功能已部分被 type hints 所取代。如果要同時使用 path converters，須留意兩者的<strong>判斷順序</strong>（path converters 先判斷）與兩者設定的型別一定要相同。</p><hr><h2 id="五、請求的基本錯誤處理"><a href="#五、請求的基本錯誤處理" class="headerlink" title="五、請求的基本錯誤處理"></a>五、請求的基本錯誤處理</h2><p>當請求中的路徑參數不符合 type hints 定義的型別時，Django Ninja 會自動返回一個<strong>帶有錯誤訊息與提示內容</strong>的 HTTP 回應，狀態碼為 422。</p><p>比如說，如果用戶請求的路徑是 <code>/posts/abc/</code>（<code>post_id</code>參數沒有給數字），將得到下列回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8000/posts/abc/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int_parsing&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;path&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;post_id&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Input should be a valid integer, unable to parse string as an integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>這樣的自動錯誤處理機制，不僅提高了 API 的穩定性，同時<strong>簡化了開發者的錯誤處理邏輯</strong>。</p><p>內建的 422 回應在 Django Ninja 中極為常見，省下了我們不少時間。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>路徑參數是 RESTful API 中的<strong>重要組成部分</strong>，Django Ninja 透過 type hints 和自動化的錯誤處理，讓我們能夠輕鬆處理路徑中的動態參數。</p><p>此外，它與 Django 原生的 path converters 保持了<strong>良好的相容性</strong>，提供高效、簡潔的開發體驗。</p><p>下一篇，我們將深入探討<strong>查詢參數</strong>（<strong>query parameters</strong>），說明如何在 Django Ninja 中處理這些參數，進一步提升 API 的靈活性與功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章中，我們介紹了 Django Ninja 如何處理 HTTP 請求，並強調了它與 Python type hints 之間的緊密結合。&lt;/p&gt;
&lt;p&gt;本篇將探討 Django Ninja 中，&lt;strong&gt;路徑參數（&lt;a href=&quot;https://django-ninja.dev/guides/input/path-params/&quot;&gt;path parameters&lt;/a&gt;）&lt;/strong&gt;的應用與細節，這在處理 HTTP 請求時&lt;strong&gt;極為常見&lt;/strong&gt;，尤其是在 RESTful API 中。&lt;/p&gt;
&lt;p&gt;本文對範例專案的程式碼改動，都集中在&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/2&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、什麼是-Path-Parameters？&quot;&gt;&lt;a href=&quot;#一、什麼是-Path-Parameters？&quot; class=&quot;headerlink&quot; title=&quot;一、什麼是 Path Parameters？&quot;&gt;&lt;/a&gt;一、什麼是 Path Parameters？&lt;/h2&gt;&lt;p&gt;Path parameters 是構成 URL 的一部分，它們位於網址路徑（path）中的&lt;strong&gt;特定&lt;/strong&gt;位置，&lt;strong&gt;根據不同的值（參數）&lt;/strong&gt;來決定傳入的內容，用來&lt;strong&gt;動態指定資源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們不妨先了解一下，&lt;strong&gt;path&lt;/strong&gt; 在整個 URL 中的位置：（圖片取自&lt;a href=&quot;https://en.wikipedia.org/wiki/URL&quot;&gt;維基百科&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/o2JxS9I.png&quot; alt=&quot;點圖可放大&quot;&gt;&lt;/p&gt;
&lt;p&gt;從圖中可以看出，路徑（path）是 URL 的一部分——而且是&lt;strong&gt;必要部分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過請注意，path parameters 只是 Django、Django Ninja 這類框架所提供的一種「&lt;strong&gt;功能&lt;/strong&gt;」。對 URL 本身而言，path 就是 path，也就是&lt;strong&gt;單純的字串&lt;/strong&gt;而已。&lt;/p&gt;
&lt;h3 id=&quot;路徑參數例子&quot;&gt;&lt;a href=&quot;#路徑參數例子&quot; class=&quot;headerlink&quot; title=&quot;路徑參數例子&quot;&gt;&lt;/a&gt;路徑參數例子&lt;/h3&gt;&lt;p&gt;舉一個簡單的例子，讓我們可以更好地理解 path parameters 的概念。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@router.get(&lt;span class=&quot;params&quot;&gt;path=&lt;span class=&quot;string&quot;&gt;&amp;#x27;/posts/&amp;#123;post_id&amp;#125;/&amp;#x27;&lt;/span&gt;&lt;/span&gt;)  &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;# &amp;#123;post_id&amp;#125; 就是路徑參數&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;實際請求時，&lt;code&gt;123&lt;/code&gt;就是&lt;strong&gt;透過&lt;/strong&gt;路徑參數，代表特定文章的 id：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET /posts/123&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可想而知，如果是&lt;code&gt;456&lt;/code&gt;或&lt;code&gt;789&lt;/code&gt;，你會得到不同的結果。&lt;/p&gt;
&lt;p&gt;這使得 API 具有&lt;strong&gt;彈性&lt;/strong&gt;，可以針對不同的資源進行操作，而&lt;strong&gt;不必為每一個資源建立不同的路由&lt;/strong&gt;——它們的端點與路由&lt;strong&gt;都是相同的&lt;/strong&gt;，只是「&lt;strong&gt;參數&lt;/strong&gt;」不同。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 09：請求（一）Django Ninja 處理 HTTP 請求概論（兼論 FBVs）</title>
    <link href="https://blog.kyomind.tw/django-ninja-09/"/>
    <id>https://blog.kyomind.tw/django-ninja-09/</id>
    <published>2024-09-21T02:28:23.000Z</published>
    <updated>2024-09-27T07:03:27.655Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>歡迎來到第三章第二節！</p><p>作為 API 的核心邏輯實現，<strong>view 函式</strong>無疑是 Django Ninja API 的靈魂所在。</p><p>Django Ninja 和 FastAPI、Flask 一樣，都是以 Function-Based Views（<strong>以下簡稱 FBVs</strong>）為主。所以它的學習重點，<strong>幾乎都繞圍在 view 函式的 input 和 output。</strong></p><p>換句話說，整個 Django Ninja 框架的能力，<strong>構成了 view 函式的這些關鍵部分</strong>，包括但不限於：</p><ol><li>處理 HTTP 請求的參數與 body。</li><li>處理 HTTP 回應內容的序列化與格式化。</li><li>資料驗證與錯誤處理。</li></ol><p>它們共同構成了 Django Ninja 的主要功能。</p><p>本節和下一節，將集中討論上述 3 點中的前兩點——請求與回應。至於第三點，將留到第五章再行介紹。</p><span id="more"></span><hr><h2 id="本節導覽"><a href="#本節導覽" class="headerlink" title="本節導覽"></a>本節導覽</h2><p>繼上一節的「路由」後，本節將探討 Django Ninja <strong>如何處理 HTTP 請求</strong>——如何解析 path、URL 查詢參數和 body。</p><p>本節一共有 4 篇：</p><ul><li><strong>卷 9：請求（一）Django Ninja 處理 HTTP 請求概論（兼論 FBVs）</strong></li><li><a href="https://blog.kyomind.tw/django-ninja-10/">卷 10：請求（二）路徑參數（Path Parameters）</a></li><li><a href="https://blog.kyomind.tw/django-ninja-11/">卷 11：請求（三）查詢參數（Query Parameters）</a></li><li><a href="https://blog.kyomind.tw/django-ninja-12/">卷 12：請求（四）Request Body 與 Schema 介紹</a></li></ul><p>此外，因為 view 函式處理請求功能，已涉及 Django Ninja 如何使用 type hints 來驗證請求資料。我們的範例程式碼會<strong>開始加上 Python 型別提示</strong>。</p><p>Type hints 的語法以 Python 3.12 為準。</p><h2 id="官方文件"><a href="#官方文件" class="headerlink" title="官方文件"></a>官方文件</h2><p>本系列的寫作不時會參考「<a href="https://django-ninja.dev/">Django Ninja 官方文件</a>」，尤其是架構的呈現。</p><p>但文件畢竟是給<strong>全體</strong>開發者看的，<strong>並沒有充分考慮到學習的順序。</strong></p><p>而本列系主要面向<strong>入門者</strong>，所以我們會更加注重實際操作與入門者的需求，並適時補充一些背景知識，<strong>確保學習曲線能相對平緩</strong>。</p><p>此外，就框架本身，我們也會提供更多實例和解釋，讓新概念更好理解和掌握。</p><p>但無論如何，官方文件仍是你在使用 Django Ninja 時，需要時時參考的內容——雖然它寫得比 Django 或 Django REST framework 的文件，相對「簡單」很多！</p><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文作為第二節的概論，目標是讓你對 Django Ninja 的 view 函式與它如何處理 HTTP 請求<strong>有基本的認識</strong>。</p><p>我們將透過以下三個重點來讓你逐步熟悉：</p><ol><li>FBVs 的優點。</li><li>Django Ninja 對 HTTP 請求的處理流程。</li><li>Django Ninja 與 Type Hints 的緊密結合。</li></ol><p>話不說多，我們直接開始。</p><hr><p>Class-based views (CBVs) 和 FBVs 都是實現 <a href="https://zoejoyuliao.medium.com/%E6%AF%94%E8%BC%83-mvc-%E8%88%87-django-%E7%9A%84-mtv-6c93ea9484fc">Django MTV 架構</a> 中的 <strong>Views</strong> 手段，各有其適用場景。</p><p>CBVs 有<strong>重用程式碼</strong>優勢，適合大型專案。而 FBVs 則以<strong>簡單、直接</strong>為賣點，方便快速開發中小型專案。</p><p>兩者的比較，可參考這篇〈<a href="https://ithelp.ithome.com.tw/articles/10205779">Day27 : CBV vs. FBV</a>〉。</p><p>因為 Django Ninja 採 FBVs，本文只探討 FBVs 的優點。</p><h2 id="一、FBV-的優點"><a href="#一、FBV-的優點" class="headerlink" title="一、FBV 的優點"></a>一、FBV 的優點</h2><p>FBVs 是 Django Ninja 採用的 view 形式。與 CBVs 相比，FBVs 更加簡潔、靈活，能夠讓開發者輕鬆編寫出 API 邏輯而<strong>不需要了解太多背景知識</strong>，比如「如何正確覆寫某個 CBV 屬性」。</p><h3 id="簡潔與靈活"><a href="#簡潔與靈活" class="headerlink" title="簡潔與靈活"></a>簡潔與靈活</h3><p>FBVs <strong>不需要繼承或覆寫</strong>類別方法，所有的邏輯都集中在一個函式中。</p><p>這使得寫作和維護程式碼更加直觀。</p><p>由於 FBVs 本質是個函式，它可以更靈活地應用各種邏輯和條件，開發者能<strong>在單一函式中完全控制整個請求的處理流程</strong>，而<strong>不需要考慮類別的結構或繼承關係</strong>。</p><h3 id="容易-Debug"><a href="#容易-Debug" class="headerlink" title="容易 Debug"></a>容易 Debug</h3><p>FBVs 的程式碼相對直觀，對於初學者來說，閱讀、理解起來更加容易。發生錯誤時，你可以<strong>快速定位問題</strong>，這是 CBVs 不易達到的便利性。</p><h3 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h3><p>Django 是個功能全面的框架，但也常被批評為「笨重」。<strong>FBVs 在一定程度上緩解了這種笨重感</strong>。</p><p>試想，一個剛接觸 Django 的新手，在理解完各種框架的環境設定後，還要深入 CBVs 的世界，是否太過沉重？</p><p>總之，如果你問我，我絕對更偏好 FBVs——而且「<strong>輕量化</strong>」是現代開發的趨勢。</p><hr><h2 id="二、Django-Ninja-對-HTTP-請求的處理流程"><a href="#二、Django-Ninja-對-HTTP-請求的處理流程" class="headerlink" title="二、Django Ninja 對 HTTP 請求的處理流程"></a>二、Django Ninja 對 HTTP 請求的處理流程</h2><p>Django Ninja 對「請求」的處理可以分為幾個關鍵步驟：</p><ol><li><strong>路由配對</strong>：當請求進來時，框架首先會將來源 URL 與定義的路徑規則（端點）進行配對。若配對成功，則將 HTTP 請求與相關參數傳遞給 view 函式。</li><li><strong>參數解析</strong>：從 URL 中提取<strong>路徑參數</strong>（<strong>path parameters</strong>）和<strong>查詢參數</strong>（<strong>query parameters</strong>），將它們轉換為 view 函式的「<strong>引數</strong>」（arguments）。根據函式的 type hints 自動進行型別轉換和驗證。</li><li><strong>Request body 處理</strong>：對於 POST 或 PUT 等帶有 body 的請求，Django Ninja 讓開發者使用 Schema（Pydantic BaseModel）定義 body 資料模型，並自動將傳入的資料對應到這些模型。</li></ol><p>上述第 1 點已在本章第一節詳細解說。</p><p>第 2 和第 3 點則是本節共 4 篇文章的主要內容。</p><hr><h2 id="三、Django-Ninja-與-Type-Hints-的緊密結合"><a href="#三、Django-Ninja-與-Type-Hints-的緊密結合" class="headerlink" title="三、Django Ninja 與 Type Hints 的緊密結合"></a>三、Django Ninja 與 Type Hints 的緊密結合</h2><p>Django Ninja 非常依賴 Python 的 type hints 來處理 HTTP 請求中的資料。</p><p>並透過 Pydantic 實現了<strong>自動資料驗證</strong>和<strong>類別轉換</strong>，減少了開發者手動檢查和轉換資料的負擔。</p><p>例如以下程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/posts/&#123;post_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params">request, post_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;post_id&quot;</span>: post_id&#125;</span><br></pre></td></tr></table></figure><p>當<code>post_id</code>參數被標記為<code>int</code>時，Django Ninja 會進行型別檢查。如果傳入的參數無法轉換為<code>int</code>，框架會直接返回狀態碼為 422 的 HTTP 回應。</p><p>換言之，如果你將<code>post_id</code>標記為<code>str</code>，則 Django Ninja 會自動將<code>post_id</code>轉換為字串。</p><p>還記得剛開始接觸 Django Ninja時，我非常驚嘆竟然可以充分運用 Python type hints 到這般程度，讓它<strong>不僅僅是為了型別安全而服務，而是融入到整個 API 開發流程中</strong>。</p><h2 id="View-函式中的-request-參數"><a href="#View-函式中的-request-參數" class="headerlink" title="View 函式中的 request 參數"></a>View 函式中的 request 參數</h2><p>上面的例子中，有個值得注意的細節，就是 view 函式的<strong>第一參數</strong>——<code>request</code>。</p><p>在 Django 中，view 函式的第一個參數必定為 request。這個參數名稱<strong>可以自行定義</strong>，但通常會命名為<code>request</code>。</p><p>收到 HTTP 請求時，Django 會將整個請求打包成一個<code>HttpRequest</code>物件，並<strong>將它作為第一個參數傳給 view 函式</strong>，所以它<strong>必不可少</strong>。</p><blockquote><p>相關文章：<a href="/django-request/">Django HttpRequest 常用屬性介紹</a></p></blockquote><p><code>request</code>參數在 Django 和 Django REST framework 中非常重要，因為它常用來取得<strong>請求的查詢參數、body</strong> 等內容。</p><p>在 Django Ninja 中，這些資料會<strong>直接透過函式參數來取得</strong>，因此<code>request</code>雖然仍不可少，但<strong>使用頻率較低</strong>。</p><hr><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>接下來，我們將深入探討 Django Ninja 處理請求的<strong>具體細節</strong>。</p><p>下一篇將聚焦於<strong>路徑參數</strong>（<strong>path parameters</strong>），並探討如何與 Django 原生的 <strong>path converters</strong> 搭配使用。敬請期待！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;歡迎來到第三章第二節！&lt;/p&gt;
&lt;p&gt;作為 API 的核心邏輯實現，&lt;strong&gt;view 函式&lt;/strong&gt;無疑是 Django Ninja API 的靈魂所在。&lt;/p&gt;
&lt;p&gt;Django Ninja 和 FastAPI、Flask 一樣，都是以 Function-Based Views（&lt;strong&gt;以下簡稱 FBVs&lt;/strong&gt;）為主。所以它的學習重點，&lt;strong&gt;幾乎都繞圍在 view 函式的 input 和 output。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;換句話說，整個 Django Ninja 框架的能力，&lt;strong&gt;構成了 view 函式的這些關鍵部分&lt;/strong&gt;，包括但不限於：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;處理 HTTP 請求的參數與 body。&lt;/li&gt;
&lt;li&gt;處理 HTTP 回應內容的序列化與格式化。&lt;/li&gt;
&lt;li&gt;資料驗證與錯誤處理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它們共同構成了 Django Ninja 的主要功能。&lt;/p&gt;
&lt;p&gt;本節和下一節，將集中討論上述 3 點中的前兩點——請求與回應。至於第三點，將留到第五章再行介紹。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 08：路由（下）Django Ninja 路由設定</title>
    <link href="https://blog.kyomind.tw/django-ninja-08/"/>
    <id>https://blog.kyomind.tw/django-ninja-08/</id>
    <published>2024-09-20T00:54:07.000Z</published>
    <updated>2024-09-28T08:34:21.006Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇文章中，我們介紹了 Django 傳統的路由設定方式。</p><p>如前所述，雖然有一個「路由清單」確實不錯。但隨著專案規模的擴大，<strong>不斷來回切換</strong><code>urls.py</code>和<code>views.py</code>將大幅增加開發者的<strong>認知負擔</strong>——拉長了開發時間，還更容易導致錯誤。</p><p>Django Ninja 採用了一種<strong>更現代化</strong>的路由設計，結合了 Flask 和 FastAPI 的設計理念。不僅簡化了路由的定義，還提升了程式碼的可讀性，讓路由與 view 函式<strong>緊密結合</strong>。</p><h2 id="範例專案動態"><a href="#範例專案動態" class="headerlink" title="範例專案動態"></a>範例專案動態</h2><p>本文關於路由設定的程式碼改動，可以參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/1">這個 PR</a>（<strong>Pull Request</strong>）。</p><p>範例專案合併了本文的 PR 後，已經正式成為一個「<strong>API 專案</strong>」，不過它<strong>目前（指這個 <a href="https://github.com/kyomind/Django-Ninja-Tutorial/commit/396e06338d615d3ec74e7c5bf871b85c9a06f0ec">commit</a> 狀態）尚無法正常運作</strong>，因為我們還沒有完善 view 函式的基本功能。</p><p>你可以一步步地跟著每一篇的 PR，來學習當次的新內容。這也是我為文章建立 PR 的用意所在。</p><span id="more"></span><hr><p>現在，我們開始介紹 Django Ninja 的路由設定。</p><h2 id="Django-Ninja-路由概述"><a href="#Django-Ninja-路由概述" class="headerlink" title="Django Ninja 路由概述"></a>Django Ninja 路由概述</h2><p>Django Ninja 使用 Python 裝飾器（<a href="https://myapollo.com.tw/blog/python-decorator-tutorial/">decorator</a>）來定義路由和 HTTP 方法。這種方式將路由與 view 函式緊密結合，大大提高了程式碼的可讀性。</p><p>熟悉 Python 的都知道，其實這種「<strong>使用裝飾器定義路由</strong>」的方式，最早來自 <a href="https://flask.palletsprojects.com/en/3.0.x/">Flask</a>。作為一個輕量級框架，Flask 率先引入了這種<strong>簡潔優雅的設計</strong>，堪稱<strong>典範級的創舉</strong>。</p><p>這個設計後續被其他框架採用，比如 FastAPI 和本文的 Django Ninja，都繼承了這種靈活的路由定義模式。</p><p>在 Flask 中，開發者可以這樣定義路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, Flask!&#x27;</span></span><br></pre></td></tr></table></figure><p>Django Ninja 也採用了<strong>類似的概念</strong>，只是在語法上更融入 Django 生態，並結合了型別提示（type hint）和 Pydantic 的資料驗證功能，讓 API 開發變得更加現代化。</p><p>以下是 Django Ninja 的一個簡單範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, Django Ninja!&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>Flask 與 Django Ninja 這兩種寫法，與其說非常相似，不如說一模一樣😎</p><hr><h2 id="更有組織的做法：使用-Router-物件"><a href="#更有組織的做法：使用-Router-物件" class="headerlink" title="更有組織的做法：使用 Router 物件"></a>更有組織的做法：使用 Router 物件</h2><p>雖然直接使用上述範例中的<code>NinjaAPI</code>來定義路由簡單而直觀。但實際工作中，我們更推薦使用<code>Router</code>物件（<a href="https://django-ninja.dev/guides/routers/">官方文件</a>）來管理不同 Django app 的路由。</p><p>這和 Django 傳統做法中「區分一級與二級路由」的基本精神相符。不僅讓專案的架構保持清晰，還能讓每個 app 的邏輯獨立。</p><p>在 Django Ninja 中，<code>Router</code>物件提供了一種<strong>模組化的路由設定方式</strong>，讓每個 Django app 可以管理自己的路由，並在專案層級的<code>api.py</code><strong>統一整合起來</strong>——也就是取代傳統的<code>urls.py</code>功能。</p><p>以下程式碼範例，我們都會以<code>Router</code>物件來實作。</p><hr><h2 id="專案架構變化"><a href="#專案架構變化" class="headerlink" title="專案架構變化"></a>專案架構變化</h2><p>先來看看採用 Django Ninja 以後，傳統 Django 專案的結構會有<strong>怎麼樣的變化</strong>。</p><h3 id="Django-傳統路由結構"><a href="#Django-傳統路由結構" class="headerlink" title="Django 傳統路由結構"></a>Django 傳統路由結構</h3><p>以範例專案為例，這是傳統 Django 的典型結構：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── NinjaForum</span><br><span class="line">│   ├── urls.py  <span class="comment"># 專案一級路由</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── post</span><br><span class="line">│   ├── urls.py  <span class="comment"># app 二級路由</span></span><br><span class="line">│   ├── view.py  <span class="comment"># 放置 app 所屬 view 函式的地方</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── user</span><br><span class="line">│   ├── urls.py  <span class="comment"># app 二級路由</span></span><br><span class="line">│   ├── view.py  <span class="comment"># 放置 app 所屬 view 函式的地方</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── ...</span><br></pre></td></tr></table></figure><p>Django app 層級的<code>urls.py</code>負責定義所有 app 內的路由，然後再由專案的<code>urls.py</code>進行統合。井然有序，權責分明。</p><h3 id="Django-Ninja-路由結構"><a href="#Django-Ninja-路由結構" class="headerlink" title="Django Ninja 路由結構"></a>Django Ninja 路由結構</h3><p>在採用 Django Ninja 後，專案結構會有一些變化。以下是一個典型的 Django Ninja 專案結構：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── NinjaForum</span><br><span class="line">│   ├── urls.py  <span class="comment"># 專案「零級」路由</span></span><br><span class="line">│   ├── api.py   <span class="comment"># 專案一級路由</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── post</span><br><span class="line">│   ├── api.py   <span class="comment"># post app 的路由 + view 函式</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── user</span><br><span class="line">│   ├── api.py   <span class="comment"># user app 的路由 + view 函式</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── ...</span><br></pre></td></tr></table></figure><p>在這個結構中，每個 Django app 都有一個<code>api.py</code>，用於<strong>定義該 app 的所有 API 路由和 view 函式</strong>，取代了傳統 Django 中的<code>urls.py</code>和<code>views.py</code>的功能。</p><p>專案級別的<code>api.py</code>則負責整合所有 Django app 的 API。</p><p>此外，專案的<code>urls.py</code><strong>仍然是必要的</strong>，它負責將 Django Ninja 的 API 路由<strong>再整合</strong>到 Django 的 URL 設定中。同時，還可以化身為「零級」路由，為所有 API 加上<strong>全專案統一的路由前綴</strong>，比如<code>/api/</code>。</p><hr><h2 id="Django-Ninja-路由實作"><a href="#Django-Ninja-路由實作" class="headerlink" title="Django Ninja 路由實作"></a>Django Ninja 路由實作</h2><p>了解了 Django Ninja 的路由結構，我們直接在範例專案的兩個 Django app 分別實作「取得所有使用者」和「取得文章列表」兩個 API。</p><p>我們會在接下來的數篇文章中，循序漸進地完善這些 API。<strong>目前只是雛形</strong>，先把焦點放在路由設定上。</p><h3 id="一、建立二級路由"><a href="#一、建立二級路由" class="headerlink" title="一、建立二級路由"></a>一、建立二級路由</h3><p>在 user app 中建立一個<code>api.py</code>， 內容為：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Router</span><br><span class="line"></span><br><span class="line">router = Router()</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_users</span>(<span class="params">request</span>):</span><br><span class="line">    users = User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> users</span><br></pre></td></tr></table></figure><p>同理，我們在<code>post/api.py</code>中建立類似的路由與 view 函式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Router</span><br><span class="line"></span><br><span class="line">router = Router()</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">request</span>):</span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這樣，我們就為 user 和 post 兩個 app 分別建立了 API。接下來，我們需要將這些路由整合到<strong>專案級別</strong>的 API 路由中。</p><h3 id="二、建立一級路由"><a href="#二、建立一級路由" class="headerlink" title="二、建立一級路由"></a>二、建立一級路由</h3><p>在 Django 專案目錄（指 NinjaForum 目錄）底下，我們也需要建立一個<code>api.py</code>。它將作為我們的<strong>一級路由</strong>，整合所有 app 的 API。以下是這個<code>api.py</code>的內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI()</span><br><span class="line"></span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/users/&#x27;</span>, router=<span class="string">&#x27;user.api.router&#x27;</span>)</span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/posts/&#x27;</span>, router=<span class="string">&#x27;post.api.router&#x27;</span>)</span><br></pre></td></tr></table></figure><p>值得留意的是，這裡的路由整合有<strong>兩種寫法</strong>，上面我習慣使用的。</p><p>另一種寫法是直接 import <code>router</code>物件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> user.api <span class="keyword">import</span> router <span class="keyword">as</span> user_router</span><br><span class="line"><span class="keyword">from</span> post.api <span class="keyword">import</span> router <span class="keyword">as</span> post_router</span><br><span class="line"></span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/users/&#x27;</span>, router=user_router)</span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/posts/&#x27;</span>, router=post_router)</span><br></pre></td></tr></table></figure><p>這兩種方法在功能上是等效的，選擇哪種主要取決於個人偏好和專案的組織方式。</p><h3 id="三、專案-urls-py"><a href="#三、專案-urls-py" class="headerlink" title="三、專案 urls.py"></a>三、專案 <code>urls.py</code></h3><p>在 Django Ninja 中，專案層級的<code>urls.py</code>化身為連接 Django 和 Django Ninja API 的<strong>橋梁</strong>。</p><p>在專案<code>urls.py</code>中，我們還能再定義<strong>全專案共用的路由前綴</strong>。長這樣：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line"></span><br><span class="line">from NinjaForum.api import api</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;api/&#x27;</span>, api.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這裡定義了一個專案路由前綴——<code>/api/</code>。</p><p>如此一來，「取得所有文章」的 API 端點將會是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/posts/</span><br></pre></td></tr></table></figure><p>當然，如果你不需要額外的路由前綴，也可以直接省略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, api.urls),  <span class="comment"># 省略前綴</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>至此，我們完成了 Django Ninja 的路由設定。</p><p>這樣的結構不僅保持了 Django 原有的模組化設計，還為我們的 API 開發提供了更大的靈活性。</p><hr><h2 id="本節收尾與下一步"><a href="#本節收尾與下一步" class="headerlink" title="本節收尾與下一步"></a>本節收尾與下一步</h2><p>在第一節中，我們學習了如何使用 Django Ninja 定義路由，並了解 Django 傳統路由與 Django Ninja 路由的差異。</p><p>Django Ninja 的路由做法不僅讓程式碼更具可讀性，還保持了專案的清晰結構，改善了 Django 傳統路由的一些缺點。</p><p>下一篇，我們將進入 Django Ninja API 的核心部分——view 函式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章中，我們介紹了 Django 傳統的路由設定方式。&lt;/p&gt;
&lt;p&gt;如前所述，雖然有一個「路由清單」確實不錯。但隨著專案規模的擴大，&lt;strong&gt;不斷來回切換&lt;/strong&gt;&lt;code&gt;urls.py&lt;/code&gt;和&lt;code&gt;views.py&lt;/code&gt;將大幅增加開發者的&lt;strong&gt;認知負擔&lt;/strong&gt;——拉長了開發時間，還更容易導致錯誤。&lt;/p&gt;
&lt;p&gt;Django Ninja 採用了一種&lt;strong&gt;更現代化&lt;/strong&gt;的路由設計，結合了 Flask 和 FastAPI 的設計理念。不僅簡化了路由的定義，還提升了程式碼的可讀性，讓路由與 view 函式&lt;strong&gt;緊密結合&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;範例專案動態&quot;&gt;&lt;a href=&quot;#範例專案動態&quot; class=&quot;headerlink&quot; title=&quot;範例專案動態&quot;&gt;&lt;/a&gt;範例專案動態&lt;/h2&gt;&lt;p&gt;本文關於路由設定的程式碼改動，可以參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/1&quot;&gt;這個 PR&lt;/a&gt;（&lt;strong&gt;Pull Request&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;範例專案合併了本文的 PR 後，已經正式成為一個「&lt;strong&gt;API 專案&lt;/strong&gt;」，不過它&lt;strong&gt;目前（指這個 &lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/commit/396e06338d615d3ec74e7c5bf871b85c9a06f0ec&quot;&gt;commit&lt;/a&gt; 狀態）尚無法正常運作&lt;/strong&gt;，因為我們還沒有完善 view 函式的基本功能。&lt;/p&gt;
&lt;p&gt;你可以一步步地跟著每一篇的 PR，來學習當次的新內容。這也是我為文章建立 PR 的用意所在。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
</feed>
