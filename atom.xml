<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-10-12T06:59:11.556Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django Ninja 教學 30：系列回顧與完賽心得</title>
    <link href="https://blog.kyomind.tw/django-ninja-30/"/>
    <id>https://blog.kyomind.tw/django-ninja-30/</id>
    <published>2024-10-12T03:39:06.000Z</published>
    <updated>2024-10-12T06:59:11.556Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>系列最終章，我們的「<strong>Django Ninja 探險</strong>」將暫時告一段落。</p><p>這當然不是結束，畢竟 Django Ninja 還只是一個<strong>相對新的專案</strong>——我對它的未來充滿期待。</p><p>本文將分為兩個部分：</p><ol><li>回顧整個系列，檢視我們在各章中學到的概念與技術——盡可能只提重點。</li><li>分享我在寫作過程中的最大挑戰、對 Django Ninja 的期待，最後則是我的鐵人賽完賽心得。</li></ol><p>受限於篇幅，更多的<strong>幕後花絮、創作細節及個人心得</strong>，我將在與正賽無關的第 31、32 篇中，再行分享。</p><p>此外，我還會不定期更新「<strong>Django Ninja 番外篇</strong>」，補充正篇中未能詳述的內容。有興趣的讀者，<strong>歡迎訂閱本系列唷！</strong></p><p>話不多說，我們直接開始。</p><hr><h2 id="一、系列目標與主要學習成果"><a href="#一、系列目標與主要學習成果" class="headerlink" title="一、系列目標與主要學習成果"></a>一、系列目標與主要學習成果</h2><p>回到第 1 篇的開頭，整個系列的目標是：</p><blockquote><p>在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的<strong>基礎實作</strong>，透過<strong>文字教學</strong>與<strong>範例專案</strong>的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。</p></blockquote><p>沒錯，而我們具體做了哪些事呢？</p><h3 id="主要學習成果"><a href="#主要學習成果" class="headerlink" title="主要學習成果"></a>主要學習成果</h3><p>透過本系列，讀者掌握了以下 Django Ninja 核心技能：</p><ol><li>設定 Django Ninja 路由。（卷 7-8）</li><li>處理各種 HTTP 請求及參數——路徑參數、查詢參數、body。（卷 9-12）</li><li>使用 Schema 設計和定義 API 回應的資料結構。（卷 13-16）</li><li>自動產生 API 文件、透過 Pydantic 驗證資料、有效處理系統拋出的錯誤。（卷 17-22）</li><li>靈活運用進階功能，包括檔案上傳、分頁和資料過濾。（卷 23-27）</li></ol><p>還有最後的身分認證與單元測試。可說是一段<strong>相當完整的旅程</strong>。</p><span id="more"></span><hr><p>其中的精妙與困難，這裡不再贅述。</p><p>讓我們一起回顧，我認為學習 Django Ninja 的一些重點，以及它帶來的<strong>滿足感</strong>——這很重要！</p><h2 id="二、各章節重點回顧"><a href="#二、各章節重點回顧" class="headerlink" title="二、各章節重點回顧"></a>二、各章節重點回顧</h2><p>我們只挑各章節中<strong>特別值得一提</strong>的部分。有我<strong>個人的觀點</strong>。</p><h3 id="第二章：範例專案與環境設定"><a href="#第二章：範例專案與環境設定" class="headerlink" title="第二章：範例專案與環境設定"></a><strong>第二章：範例專案與環境設定</strong></h3><p>本章最重要的，莫過於對「Python 現代開發工具」的介紹。再次推薦「<a href="https://blog.wei-lee.me/posts/tech/2020/02/python-table-manners-series/">Python Table Manners</a>」系列。</p><p>從 Poetry 到 Mypy，我認為這些工具都是現代專案中的<strong>必備要素</strong>。它們各有替代品，你可以選擇自己偏好的工具，只要確保這些要素都已整合到開發流程中。</p><p>我相信，無論 AI 如何發展，專案的「<strong>基礎建設</strong>」總是不可少的。</p><h3 id="第三章第一節：路由"><a href="#第三章第一節：路由" class="headerlink" title="第三章第一節：路由"></a>第三章第一節：路由</h3><p>Django Ninja 的路由設定與傳統的 Django、Django REST framework 有<strong>很大的不同</strong>。</p><p>這部分，後起之秀基本上都向 Flask 首創的「<strong>路由裝飾器</strong>」看齊——優秀的設計，值得相互借鑑、學習🫡</p><p>新寫法不僅更直覺、簡單，還減少了路由設定<strong>分散</strong>在不同檔案的<strong>窘境</strong>。</p><p>不過，路由也因此成了一開始學習 Django Ninja 的<strong>小小門檻</strong>。所以我花了足足兩篇，比較兩者的差異，讓你能更清楚其中的思路與考慮。</p><h3 id="第三章第三節：HTTP-回應"><a href="#第三章第三節：HTTP-回應" class="headerlink" title="第三章第三節：HTTP 回應"></a>第三章第三節：HTTP 回應</h3><p>表面上是講 HTTP 回應，其實重點在介紹 Django Ninja Schema——也就是 Pydantic BaseModel。</p><p>說本節是「<strong>Pydantic 入門</strong>」，一點也不為過。</p><p>而且，對 Pydantic 的了解，其重要性還延伸至 API 文件、資料驗證等後續章節。可說是一切的基礎。</p><p>Django Ninja 用 Schema 來<strong>組織與序列化</strong> HTTP 回應，這與 Django REST framework 使用的<strong>序列化器</strong>，<strong>本質上並無區別</strong>。</p><p>但兩者在<strong>使用思維上的差異</strong>，卻帶給我<strong>截然不同</strong>的體驗。主要見解我已寫在〈卷 15：回應（三）為何不用 ModelSchema？——相比 DRF，我更偏愛 Django Ninja 的理由〉，值得你再三回顧。</p><h3 id="第四章：API-文件"><a href="#第四章：API-文件" class="headerlink" title="第四章：API 文件"></a>第四章：API 文件</h3><p>這還有什麼好說的呢？太關鍵了！</p><p>如果沒有「依程式碼、type hints 自動產生 API 文件」這個<strong>殺手級功能</strong>，習慣 Django REST framework 的開發者如我，怎麼會有動力再學習一個<strong>定位類似</strong>的新框架？</p><p><strong>懶就是一切的動力！</strong></p><h3 id="第五章：資料驗證與錯誤處理"><a href="#第五章：資料驗證與錯誤處理" class="headerlink" title="第五章：資料驗證與錯誤處理"></a>第五章：資料驗證與錯誤處理</h3><p>這一章是我的血與淚😂</p><p>Django Ninja 的資料驗證與錯誤處理方式，和 Django REST framework <strong>很不一樣</strong>。更讓我頭痛的是，之前工作中我並非以「最正規」的方式實踐——仍受到 Django REST framework 開發習慣的影響。</p><p>那時還想：「這也太難用了吧！」——原來是我自己誤解了。所以為了寫好這 4 篇，我幾乎是<strong>重新學習</strong>。不得不說，有一種<strong>豁然開朗</strong>的感覺。</p><p>因此，你在本系列看到的實作方式，應該是相當合理、道地的用法。結合經驗，那些坑我都幫你踩過了，請勿擔心。</p><hr><p>接下來是個人心得部分。</p><h2 id="三、寫作上的最大挑戰"><a href="#三、寫作上的最大挑戰" class="headerlink" title="三、寫作上的最大挑戰"></a>三、寫作上的最大挑戰</h2><p>我覺得，整個系列在創作上的<strong>最大挑戰</strong>，就是要盡可能<strong>搭配</strong> <a href="https://github.com/kyomind/Django-Ninja-Tutorial">GitHub 專案</a>中的<strong>程式碼</strong>，來為文章提供<strong>稱職且連貫的範例</strong>。</p><p>（不用說，這個專案非常歡迎「<strong>來自你的星星</strong>」唷🌟）</p><p>這比單純的舉例要<strong>麻煩許多</strong>，我必須事先規劃整個系列的內容進度，思考 API 實作如何跟每一篇的主題<strong>契合</strong>，讓人有「<strong>帶入感</strong>」。</p><p>此外，還得考慮到敘事上的<strong>連貫性</strong>——程式碼要循序漸進，從簡單到複雜，而不能反過來。這樣讀者才能夠順暢地跟著專案一起學習。</p><p>這樣的規劃不僅需要技術知識，更多的是教學思維與<strong>讀者意識</strong>——知道讀者可能會在哪裡「卡關」。</p><p>整體而言，是個<strong>極具挑戰但也非常有趣</strong>的過程。</p><hr><h2 id="四、對-Django-Ninja-的評價與期待"><a href="#四、對-Django-Ninja-的評價與期待" class="headerlink" title="四、對 Django Ninja 的評價與期待"></a>四、對 Django Ninja 的評價與期待</h2><p>Django Ninja 是烏克蘭開發者 <a href="https://github.com/vitalik">Vitaliy Kucheryaviy</a> 一人維護的開源專案，更新的頻率不高，通常無法立刻回應用戶們的期待。</p><p>但我想說：「如果可以，我真的不願再回去寫 Django REST framework 了。」</p><p>原因只有一個，就是第 15 篇提到的——「<strong>明確優於隱晦</strong>」（Explicit is better than implicit）。</p><p>Django Ninja 也許沒讓開發更「快」，但絕對更透明、更可控。</p><p>我相信，從長遠來看，這種<strong>透明與可控</strong>，最終可以省下的 debug 時間，遠不是簡單的「快」所能比擬的。</p><h3 id="未來期待"><a href="#未來期待" class="headerlink" title="未來期待"></a>未來期待</h3><p>隨著 Django 本身對<strong>非同步</strong>（async）的支援日益增加，我相信 Django Ninja 的潛力正被逐步釋放。</p><p>我期待，在不久的將來，當人們談到「<strong>用 Django 寫 API</strong>」時，不再只有想到 Django REST framework，還會提及這個<strong>強而有力的新選擇——Django Ninja</strong>。</p><hr><h2 id="五、完賽心得"><a href="#五、完賽心得" class="headerlink" title="五、完賽心得"></a>五、完賽心得</h2><p>呼！終於寫完了，這個過程比我想像的更加漫長。</p><p>從 9 月初到雙十節，整整 40 天（包含開賽前的備稿），我每天早上醒來就是寫作，全心全意投入到這場盛宴當中。最終，我交出了一份自己也覺得滿意的作品。</p><p>在我看來，寫作的滿足感在於「<strong>提供價值、發揮影響力</strong>」。這份價值不僅是對讀者，也包括對作者自己——透過這 30 篇文章創作，我對 Django Ninja 的理解又增進許多。</p><p>希望這個系列能為你帶來些許價值，讓你在接下來的開發旅程中更加得心應手。</p><p>每一次的寫作都是一次學習，而每一次的學習都是一次成長。這個系列或許已經結束，但我們的軟體工程師之路，還遠遠沒有。</p><p>而且，如果可以，我希望這能成為一生的追求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;系列最終章，我們的「&lt;strong&gt;Django Ninja 探險&lt;/strong&gt;」將暫時告一段落。&lt;/p&gt;
&lt;p&gt;這當然不是結束，畢竟 Django Ninja 還只是一個&lt;strong&gt;相對新的專案&lt;/strong&gt;——我對它的未來充滿期待。&lt;/p&gt;
&lt;p&gt;本文將分為兩個部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回顧整個系列，檢視我們在各章中學到的概念與技術——盡可能只提重點。&lt;/li&gt;
&lt;li&gt;分享我在寫作過程中的最大挑戰、對 Django Ninja 的期待，最後則是我的鐵人賽完賽心得。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;受限於篇幅，更多的&lt;strong&gt;幕後花絮、創作細節及個人心得&lt;/strong&gt;，我將在與正賽無關的第 31、32 篇中，再行分享。&lt;/p&gt;
&lt;p&gt;此外，我還會不定期更新「&lt;strong&gt;Django Ninja 番外篇&lt;/strong&gt;」，補充正篇中未能詳述的內容。有興趣的讀者，&lt;strong&gt;歡迎訂閱本系列唷！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;話不多說，我們直接開始。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、系列目標與主要學習成果&quot;&gt;&lt;a href=&quot;#一、系列目標與主要學習成果&quot; class=&quot;headerlink&quot; title=&quot;一、系列目標與主要學習成果&quot;&gt;&lt;/a&gt;一、系列目標與主要學習成果&lt;/h2&gt;&lt;p&gt;回到第 1 篇的開頭，整個系列的目標是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的&lt;strong&gt;基礎實作&lt;/strong&gt;，透過&lt;strong&gt;文字教學&lt;/strong&gt;與&lt;strong&gt;範例專案&lt;/strong&gt;的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;沒錯，而我們具體做了哪些事呢？&lt;/p&gt;
&lt;h3 id=&quot;主要學習成果&quot;&gt;&lt;a href=&quot;#主要學習成果&quot; class=&quot;headerlink&quot; title=&quot;主要學習成果&quot;&gt;&lt;/a&gt;主要學習成果&lt;/h3&gt;&lt;p&gt;透過本系列，讀者掌握了以下 Django Ninja 核心技能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定 Django Ninja 路由。（卷 7-8）&lt;/li&gt;
&lt;li&gt;處理各種 HTTP 請求及參數——路徑參數、查詢參數、body。（卷 9-12）&lt;/li&gt;
&lt;li&gt;使用 Schema 設計和定義 API 回應的資料結構。（卷 13-16）&lt;/li&gt;
&lt;li&gt;自動產生 API 文件、透過 Pydantic 驗證資料、有效處理系統拋出的錯誤。（卷 17-22）&lt;/li&gt;
&lt;li&gt;靈活運用進階功能，包括檔案上傳、分頁和資料過濾。（卷 23-27）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;還有最後的身分認證與單元測試。可說是一段&lt;strong&gt;相當完整的旅程&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 29：單元測試——使用 Test Client 與 pytest 測試 API</title>
    <link href="https://blog.kyomind.tw/django-ninja-29/"/>
    <id>https://blog.kyomind.tw/django-ninja-29/</id>
    <published>2024-10-11T02:48:06.000Z</published>
    <updated>2024-10-11T09:55:48.300Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>「請問你們的專案有單元測試嗎？」</p><p>面試中如果你提出這個問題，可能會讓面試官面有難色。</p><p>測試的重要性，大部分開發者都心知肚明。只是願意認真對待的人未必很多。</p><p>但如果真心想提高程式碼品質、減少 bug，讓專案更容易維護，那單元測試依舊是<strong>不可或缺</strong>的工具。</p><p>良好的測試不僅能幫助我們<strong>及早發現問題</strong>，還能在專案<strong>重構或新增功能</strong>時，確保現有的功能不會被破壞。</p><p>雖然寫測試會增加初期的開發時間，而且維護上也需要花費心力——這本來就不是一件輕鬆的事。但長期而言，它能為專案帶來持續的健全與穩定性。</p><p>所以，我們還是好好寫測試吧！</p><hr><h2 id="本文大綱"><a href="#本文大綱" class="headerlink" title="本文大綱"></a>本文大綱</h2><p>這是整個系列中唯一一篇有全文大綱的教學。</p><p>原因是，本文<strong>要提及的事項較多</strong>，畢竟單元測試這麼大的主題，怎麼可能靠一篇 2500 字的文章說完。限於篇幅，無法一一詳談——但也不能直接省略。</p><p>所以需要有一個供讀者鳥瞰的全文輪廓，讓你更容易了解、吸收。大綱如下：</p><ol><li>單元測試的理想與現實。</li><li>Django API 測試重要概念說明。<ul><li>Test Client 的意義與用途。</li><li>pytest 和 pytest-django 簡介。</li><li>pytest fixtures 與測試函式。</li></ul></li><li>測試程式碼的實作與解說。</li><li>結語。</li></ol><p>簡單來說，本文不會講解所有的程式碼改動，而是在<strong>必要時提及</strong>。其餘部分，由我直接實作並收錄在範例專案中，讓讀者自行參考。</p><p>在有限的篇幅中，帶你了解<strong>整體概念</strong>比關注細節更重要。當你掌握了基本概念，再去看程式碼會更加得心應手。</p><p>有關單元測試的<strong>更多討論</strong>，歡迎參考這篇心得〈<a href="https://blog.kyomind.tw/python-craftsman-02/">《Python 工匠》筆記（二）對「單元測試」的看法與建議</a>〉。這是一本立論紮實的好書，相信你會有所收獲。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/20">這個 PR</a>。</p><span id="more"></span><hr><h2 id="一、單元測試的理想與現實"><a href="#一、單元測試的理想與現實" class="headerlink" title="一、單元測試的理想與現實"></a>一、單元測試的理想與現實</h2><p>我覺得，討論單元測試，就必須先<strong>直面現實</strong>。</p><p>在軟體測試領域，充斥著各種關於測試的狂熱與教條主義，有時反而讓人卻步。</p><h3 id="單元測試的理想"><a href="#單元測試的理想" class="headerlink" title="單元測試的理想"></a>單元測試的理想</h3><p>理論上，撰寫單元測試應該是每位開發者都要做的事（我確實是這麼想的） 。</p><p>此外，還有「<a href="https://zh.wikipedia.org/zh-tw/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">測試驅動開發</a>（TDD）」的理念，這是一種以測試為主導的開發模式，要求在撰寫功能程式碼之前，先撰寫測試。</p><p>甚至有少部分人認為，測試覆蓋率就是要 100%。因為如果不是 100%，比如 70%，那我們就可以問：「為什麼不是其它數字？」</p><h3 id="現實：大部分人不在乎那些理想"><a href="#現實：大部分人不在乎那些理想" class="headerlink" title="現實：大部分人不在乎那些理想"></a>現實：大部分人不在乎那些理想</h3><p>然而，現實中，我們很少能看到理想的測試——甚至常常沒有測試。</p><p>現實中的專案因為時間、資源等諸多限制，往往不願投入心力去撰寫測試。</p><p>一些老舊專案，由於前期沒有測試基礎，後續要再補上測試變得更加困難（畢竟都亂成一團💩了），這就是我們常說的「<strong>技術債</strong>」。</p><p>再者，過度的「測試理想主義」有時也會讓初學者<strong>望而卻步</strong>。許多新手在接觸測試時，會擔心自己無法達到 100% 的覆蓋率，因此對測試產生了<strong>抗拒</strong>或<strong>懷疑</strong>。</p><p>這樣的完美主義往往有害無利，我們需要在理想與現實之間找到一個<strong>折衷</strong>。</p><h3 id="折衷：務實的測試策略"><a href="#折衷：務實的測試策略" class="headerlink" title="折衷：務實的測試策略"></a>折衷：務實的測試策略</h3><p>在實際開發中，我們應秉持著一個<strong>實用且可行</strong>的測試策略，重點放在測試專案中最核心的功能，例如 API 的呼叫與 200 回應。</p><p>多數情況下，只要能覆蓋 <strong>60-70%</strong> 功能，就已經能<strong>明顯提高</strong>專案程式碼的品質，並為後續開發提供一定的<strong>安全感</strong>——這真的很重要。</p><p>不必追求完美的測試覆蓋率，只要<strong>願意開始行動</strong>，測試就能發揮它<strong>應有的價值</strong>。</p><hr><h2 id="二、Django-API-測試重要概念說明"><a href="#二、Django-API-測試重要概念說明" class="headerlink" title="二、Django API 測試重要概念說明"></a>二、Django API 測試重要概念說明</h2><p>回到專案本身。</p><p>雖然本文無法提及太多 API 單元測試的具體細節，但重要的概念仍不可略過。以下一一說明。</p><h3 id="Test-Client-的意義與用途"><a href="#Test-Client-的意義與用途" class="headerlink" title="Test Client 的意義與用途"></a>Test Client 的意義與用途</h3><p>Test client 對 API 的測試至關重要，因為它能模擬真實的 HTTP 請求——注意，只是模擬。</p><p>API 測試和一般的程式碼測試<strong>略有不同</strong>，一般的測試，只要寫好相關的測試函式、邏輯並執行即可。但在 API 測試中，還需要一個「<strong>假的客戶端</strong>」來模擬請求的發送。</p><p>手動測試 API，我們通常會使用 API client，比如 Postman。而自動化的單元測試，則需要把這個「假的客戶端」直接寫在測試程式碼中——即 test client。</p><p>它相當於一個「<strong>專案內部的 API client</strong>」，而且能<strong>自動執行</strong>。</p><p>Django Ninja 有提供自己的 <a href="https://github.com/vitalik/django-ninja/blob/master/ninja/testing/client.py">test client</a>，但我建議你先不要用，因為它還<strong>不夠健全</strong>。</p><p>在範例專案中，我使用的是 Django 內建的 <a href="https://docs.djangoproject.com/en/5.1/topics/testing/tools/#the-test-client">test client</a>——歷史悠久、穩定可靠。</p><h3 id="pytest-簡介"><a href="#pytest-簡介" class="headerlink" title="pytest 簡介"></a>pytest 簡介</h3><p><a href="https://docs.pytest.org/en/stable/">pytest</a>（對，它的 p 是小寫，同 <a href="https://github.com/pyenv/pyenv">pyenv</a>）是一個廣受歡迎的 Python 測試框架，擁有自己的<strong>生態系</strong>——包含大量實用的外掛。</p><p>相較於 Python 內建的<code>unittest</code>模組，pytest 的<strong>語法更直觀</strong>、使用上的靈活性更好。尤其是它的 <strong>fixtures</strong>、<strong>參數化測試</strong>等功能，讓測試的撰寫更加簡單、高效。</p><h3 id="pytest-django"><a href="#pytest-django" class="headerlink" title="pytest-django"></a>pytest-django</h3><p><a href="https://pytest-django.readthedocs.io/en/latest/">pytest-django</a> 是一個專為 Django 設計的 pytest 整合套件。它提供了豐富的 Django 整合功能，包括許多內建的 fixtures 和實用的裝飾器。</p><p>其中又以<code>@pytest.mark.django_db</code>裝飾器最常用，它能自動管理測試過程中的<strong>資料庫狀態</strong>。</p><p>它讓 pytest 在每次測試執行前自動建立一個全新的資料庫，並在測試結束後刪除。這確保每次測試的<strong>環境一致</strong>，防止<strong>資料殘留</strong>導致的測試結果不準確。</p><h3 id="pytest-Fixtures-與測試函式"><a href="#pytest-Fixtures-與測試函式" class="headerlink" title="pytest Fixtures 與測試函式"></a>pytest Fixtures 與測試函式</h3><p><a href="https://docs.pytest.org/en/stable/fixture.html">Fixtures</a> 是 pytest 提供的一種<strong>機制</strong>，用來<strong>設定</strong>測試所需的<strong>初始環境</strong>。它們本質上是<strong>函式</strong>，但用法卻不像一般的函式。只要事先定義好，即可在測試函式中<strong>作為參數引用</strong>。</p><p>Fixtures 可以定義在 Django app 的<code>tests.py</code>中，但我們通常將它們放在可供全專案共用的<code>conftest.py</code>模組。</p><p>測試 API 時，我們經常需要一些初始資料，例如使用者、產品等。這些資料可以<strong>透過 fixtures 自動產生</strong>，無需每次手動重建。</p><p>如此一來，撰寫測試的效率提高，還避免了重複的狀態設定。</p><hr><h2 id="五、測試程式碼實作與解說"><a href="#五、測試程式碼實作與解說" class="headerlink" title="五、測試程式碼實作與解說"></a>五、測試程式碼實作與解說</h2><p>本篇我實作 3 個 fixture 和 3 個測試函式，它們都與 user 有關，容我<strong>擇要</strong>解說其中的細節。</p><h3 id="強大而靈活的-pytest-Fixtures"><a href="#強大而靈活的-pytest-Fixtures" class="headerlink" title="強大而靈活的 pytest Fixtures"></a>強大而靈活的 pytest Fixtures</h3><p>這是專案的 3 個 fixture，定義在<code>conftest.py</code>中：（為減少篇幅我省略了 docstring）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> Client</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;session&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client</span>() -&gt; Client:</span><br><span class="line">    <span class="keyword">return</span> Client()</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>() -&gt; User:</span><br><span class="line">    <span class="keyword">return</span> User.objects.create_user(</span><br><span class="line">        username=<span class="string">&#x27;testuser&#x27;</span>,</span><br><span class="line">        email=<span class="string">&#x27;testuser@example.com&#x27;</span>,</span><br><span class="line">        password=<span class="string">&#x27;testpassword123&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticated_client</span>(<span class="params">client: Client, user: User</span>) -&gt; Client:</span><br><span class="line">    response = client.post(</span><br><span class="line">        <span class="string">&#x27;/users/login/&#x27;</span>,</span><br><span class="line">        &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;testuser&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;testpassword123&#x27;</span>&#125;,</span><br><span class="line">        content_type=<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">    <span class="comment"># 設定登入後的 cookies</span></span><br><span class="line">    client.cookies.update(response.cookies)</span><br><span class="line">    <span class="keyword">return</span> client</span><br></pre></td></tr></table></figure><p>在這段程式碼中：</p><ol><li><code>client</code>：提供了一個可以用來模擬發送請求的 Django test client。（未認證）</li><li><code>user</code>：自動建立一個測試用的使用者，供測試函式甚至<strong>其它 fixture</strong> 引用。</li><li><code>authenticated_client</code>：引用上述的 2 個 fixture，組合並模擬了一個<strong>登入過的 client</strong>，這樣才能測試那些有「認證保護」的 API。</li></ol><p>Fixtures 的<strong>定義、組合與使用</strong>，是 pytest 的<strong>一大特色</strong>。</p><p>不僅能簡化測試的環境設定，還能提高測試程式碼的可讀性——把<strong>測試狀態</strong>和<strong>測試邏輯</strong>分開，這也是一種「<strong>關注點分離</strong>」。</p><p>在實際的測試函式中，我們只需要將所需的 fixtures <strong>作為參數傳入</strong>，pytest 會<strong>自動處理</strong>它們的<strong>初始化和清理</strong>工作。</p><p>這種設計大大減少了重複程式碼，讓測試更加<strong>專注於</strong> API 的邏輯驗證而非環境設定。</p><h3 id="測試函式"><a href="#測試函式" class="headerlink" title="測試函式"></a>測試函式</h3><p>最後是測試函式，我們看其中的兩個就好：（我省略了參數的 type hints，讓你聚焦於 fixtures 本身）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_get_users</span>(<span class="params">authenticated_client</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    測試取得所有使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = authenticated_client.get(<span class="string">&#x27;/users/&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_login_user</span>(<span class="params">client, user</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    測試登入使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = client.post(</span><br><span class="line">        <span class="string">&#x27;/users/login/&#x27;</span>,</span><br><span class="line">        data=&#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;testuser&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;testpassword123&#x27;</span>&#125;,</span><br><span class="line">        content_type=<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure><p>選擇這兩個函式是有<strong>教學用意</strong>的：</p><ol><li><code>test_login_user</code>函式測試「使用者登入」API，該 API 是給「<strong>未登入</strong>」的用戶存取，所以引用<strong>一般的 client</strong>（未認證）即可。<ul><li>函式也引用了 user fixture，因為登入成功的前提是：該用戶已經「<strong>存在</strong>」。</li><li>而 user fixture 的作用正是在測試開始前，<strong>先建立</strong>該用戶。</li></ul></li><li><code>test_get_users</code>測試的是「<strong>有認證保護</strong>」的 API，需要登入才能存取，所以我們引用了<code>authenticated_client</code>。<ul><li>這個測試函式「<strong>只有</strong>」引用 authenticated_client，但實際的測試結果會是：清單中存在一個用戶。（程式碼不包含這部分）</li><li>因為 authenticated_client 引用了 user 和 client 這兩個 fixture。所以<strong>只要</strong>引用了authenticated_client，<strong>就相當於引用了上述二者</strong>。</li></ul></li></ol><p>該「<strong>引用</strong>」哪些 fixture，就看各函式需要什麼樣的<strong>測試狀態與條件</strong>。</p><p>Fixtures 本身可以重複使用，這樣的設計讓測試本身也非常「<strong>模組化</strong>」——這是 pytest 如此受歡迎的原因之一。</p><h3 id="執行單元測試"><a href="#執行單元測試" class="headerlink" title="執行單元測試"></a>執行單元測試</h3><p>最後，來跑一下測試！</p><p>你可以在專案的根目錄直接使用<code>pytest</code>指令，或透過 VS Code 的 Testing UI 來執行單元測試：</p><p><img src="https://i.imgur.com/OtM4FXn.png" alt="VS Code - Testing"><span class="cap">VS Code - Testing</span></p><p>Beautiful！</p><hr><h2 id="六、結語"><a href="#六、結語" class="headerlink" title="六、結語"></a>六、結語</h2><p>理想與現實總有差距，透過務實的測試策略，我們可以在不過度追求完美的前提下，為專案提供足夠的品質保證。</p><p>Test client 和 pytest 等工具，讓 API 測試變得簡單、有條理。測試覆蓋率不必是百分之百，只要能達到<strong>一定水準</strong>，就可以為開發過程帶來<strong>巨大的助力</strong>。</p><p>本系列教學<strong>已接近尾聲</strong>。我們探討了 Django Ninja 的核心功能與進階特性——從路由設計到單元測試。這是一個<strong>辛苦但充實</strong>的過程——無論對你我而言。</p><p>下一篇，也就是最後一篇。我們要簡單回顧整個系列，並分享我在本次鐵人賽的創作與完賽心得。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;「請問你們的專案有單元測試嗎？」&lt;/p&gt;
&lt;p&gt;面試中如果你提出這個問題，可能會讓面試官面有難色。&lt;/p&gt;
&lt;p&gt;測試的重要性，大部分開發者都心知肚明。只是願意認真對待的人未必很多。&lt;/p&gt;
&lt;p&gt;但如果真心想提高程式碼品質、減少 bug，讓專案更容易維護，那單元測試依舊是&lt;strong&gt;不可或缺&lt;/strong&gt;的工具。&lt;/p&gt;
&lt;p&gt;良好的測試不僅能幫助我們&lt;strong&gt;及早發現問題&lt;/strong&gt;，還能在專案&lt;strong&gt;重構或新增功能&lt;/strong&gt;時，確保現有的功能不會被破壞。&lt;/p&gt;
&lt;p&gt;雖然寫測試會增加初期的開發時間，而且維護上也需要花費心力——這本來就不是一件輕鬆的事。但長期而言，它能為專案帶來持續的健全與穩定性。&lt;/p&gt;
&lt;p&gt;所以，我們還是好好寫測試吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文大綱&quot;&gt;&lt;a href=&quot;#本文大綱&quot; class=&quot;headerlink&quot; title=&quot;本文大綱&quot;&gt;&lt;/a&gt;本文大綱&lt;/h2&gt;&lt;p&gt;這是整個系列中唯一一篇有全文大綱的教學。&lt;/p&gt;
&lt;p&gt;原因是，本文&lt;strong&gt;要提及的事項較多&lt;/strong&gt;，畢竟單元測試這麼大的主題，怎麼可能靠一篇 2500 字的文章說完。限於篇幅，無法一一詳談——但也不能直接省略。&lt;/p&gt;
&lt;p&gt;所以需要有一個供讀者鳥瞰的全文輪廓，讓你更容易了解、吸收。大綱如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;單元測試的理想與現實。&lt;/li&gt;
&lt;li&gt;Django API 測試重要概念說明。&lt;ul&gt;
&lt;li&gt;Test Client 的意義與用途。&lt;/li&gt;
&lt;li&gt;pytest 和 pytest-django 簡介。&lt;/li&gt;
&lt;li&gt;pytest fixtures 與測試函式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;測試程式碼的實作與解說。&lt;/li&gt;
&lt;li&gt;結語。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;簡單來說，本文不會講解所有的程式碼改動，而是在&lt;strong&gt;必要時提及&lt;/strong&gt;。其餘部分，由我直接實作並收錄在範例專案中，讓讀者自行參考。&lt;/p&gt;
&lt;p&gt;在有限的篇幅中，帶你了解&lt;strong&gt;整體概念&lt;/strong&gt;比關注細節更重要。當你掌握了基本概念，再去看程式碼會更加得心應手。&lt;/p&gt;
&lt;p&gt;有關單元測試的&lt;strong&gt;更多討論&lt;/strong&gt;，歡迎參考這篇心得〈&lt;a href=&quot;https://blog.kyomind.tw/python-craftsman-02/&quot;&gt;《Python 工匠》筆記（二）對「單元測試」的看法與建議&lt;/a&gt;〉。這是一本立論紮實的好書，相信你會有所收獲。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/20&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 28：身分認證——Session 認證與全域設定</title>
    <link href="https://blog.kyomind.tw/django-ninja-28/"/>
    <id>https://blog.kyomind.tw/django-ninja-28/</id>
    <published>2024-10-10T01:42:57.000Z</published>
    <updated>2024-10-10T14:01:04.914Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>歡迎來到第七章！本章總共有兩篇內容：</p><ul><li>卷 28：身分認證——Session 認證與全域設定</li><li>卷 29：單元測試——使用 Test Client 與 pytest 測試 API</li></ul><p>這些主題的核心功能，<strong>並非由 Django Ninja 實作</strong>，但框架仍提供了<strong>一定程度的整合</strong>。並且，這些功能對於任何 Django 專案來說，都至關重要。</p><p>本文介紹幾乎所有 API 專案都需要的——<strong>身分認證</strong>（<a href="https://django-ninja.dev/guides/authentication/">Authentication</a>）。</p><p>我們將探討如何在 Django Ninja 中利用 Django 內建的 session-based 認證，實現完整的登入驗證功能，並進一步說明如何設定<strong>全域認證</strong>，以減少程式碼的重複。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/19">這個 PR</a>。</p><hr><h2 id="認證的兩個層次"><a href="#認證的兩個層次" class="headerlink" title="認證的兩個層次"></a>認證的兩個層次</h2><p>進入實作前，我們要先了解，所謂的<strong>身分認證</strong>，究竟代表什麼。</p><p>以「帳號密碼 + session 認證」為例，身分認證的範圍主要涵蓋<strong>兩個階段</strong>。</p><p>首先，當使用者透過帳號密碼進行登入時，系統會檢查這些內容、確認身分<strong>合法</strong>。登入成功後，系統會將使用者資訊（比如用戶 id）儲存至 session，以<strong>維持登入狀態</strong>。</p><p>這是<strong>登入時的認證</strong>，也是我們最常說的認證。（<strong>狹義的認證</strong>）</p><p>接著，當使用者嘗試存取受「<strong>認證保護</strong>」的 API 時，系統會檢查 session 並確認身分，確保每個 API 請求都來自<strong>合法登入</strong>的使用者。</p><p>簡言之：</p><ul><li>第一階段：初次登入時的身分確認。</li><li>第二階段：後續請求時的身分確認。</li></ul><p>兩個層次相輔相成、一體兩面，確保服務能夠在使用者<strong>登入</strong>和<strong>後續操作</strong>中，提供適當的安全保障。</p><span id="more"></span><hr><h2 id="實作「使用者登入」API"><a href="#實作「使用者登入」API" class="headerlink" title="實作「使用者登入」API"></a>實作「使用者登入」API</h2><p>了解了上述兩個層次後，我們要先來實作「<strong>狹義</strong>」的認證——也就是<strong>登入驗證</strong>本身。</p><p>我們將建立一個「使用者登入」API，並直接透過 Django 的<code>authenticate</code>和<code>login</code>函式處理<strong>帳號密碼驗證</strong>和<strong>登入狀態</strong>——非常方便！</p><p><code>authenticate</code>用來<strong>驗證</strong>使用者輸入的帳號（<code>username</code>）和密碼是否正確，<code>login</code>則將使用者的登入狀態<strong>儲存</strong>至 session。</p><h3 id="程式碼實作"><a href="#程式碼實作" class="headerlink" title="程式碼實作"></a>程式碼實作</h3><p>先新增一個登入請求 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/schemas.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    username: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line">    password: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;password123&#x27;</span>])</span><br></pre></td></tr></table></figure><p>然後是 view 函式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate, login</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> user.schemas <span class="keyword">import</span> CreateUserRequest, LoginRequest</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/login/&#x27;</span>, summary=<span class="string">&#x27;登入使用者&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_user</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest, payload: LoginRequest</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    登入使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    user = authenticate(</span><br><span class="line">        request,</span><br><span class="line">        username=payload.username,</span><br><span class="line">        password=payload.password</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        login(request, user)  <span class="comment"># 將使用者登入狀態儲存至 session</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;登入成功&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">401</span>, <span class="string">&#x27;帳號或密碼錯誤&#x27;</span>)</span><br></pre></td></tr></table></figure><p>非常簡單！</p><p>附帶一提，我不太喜歡程式中有「不必要」的<code>else</code>，此時的寫法仍不盡理想——因為<code>else</code><strong>完全可以省略</strong>。</p><p>在最新的程式碼中，你可以看到我已改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = authenticate(...)</span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">401</span>, <span class="string">&#x27;帳號或密碼錯誤&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login(request, user)  <span class="comment"># 將使用者登入狀態儲存至 session</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;登入成功&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>這樣的做法即所謂的 <a href="https://zh.wikipedia.org/zh-tw/%E5%8D%AB%E8%AF%AD%E5%8F%A5">Guard Clause</a> 或 <a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/early-return-coding-skill-9f3016d4b88d">Early Return</a>（雖然這裡是 raise）。</p><h3 id="簡評與重要補充"><a href="#簡評與重要補充" class="headerlink" title="簡評與重要補充"></a>簡評與重要補充</h3><p><code>authenticate</code>和<code>login</code>的用法幾乎是固定的，很容易理解：</p><ul><li><code>authenticate</code>在驗證成功時會 return 對應的<code>User</code>物件，失敗時則返回<code>None</code>。</li><li><code>login</code>不會 return，但<code>request</code>和<code>user</code>為必要的參數。</li></ul><p>成功登入後，你會得到 200 回應，並獲得兩組 cookie：</p><p><img src="https://i.imgur.com/c6gMBDY.png"></p><p>這對於 API client（比如 Postman）使用者很重要，畢竟瀏覽器會自動幫你存，但這些工具可不會——好吧，我錯了，至少我用的 RapidAPI 會<strong>自動存儲、發送</strong>！</p><p>（我測試 API 時還覺得奇怪，怎麼認證防護都失效了🤣）</p><p>如果工具沒有幫你做，記得自己在請求的 headers 加上：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/users/2/avatar/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">...</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>csrftoken=...; sessionid=...</span><br><span class="line"><span class="attribute">X-CSRFToken</span><span class="punctuation">: </span>...</span><br></pre></td></tr></table></figure><p><code>authenticate</code>預設是以<code>AbstractUser</code>的<code>username</code>欄位和密碼作為認證基準，如果想用別的欄位，比如<code>email</code>，則要自己覆寫 Django 的認證後端。</p><hr><h2 id="為-API-加上「認證保護」"><a href="#為-API-加上「認證保護」" class="headerlink" title="為 API 加上「認證保護」"></a>為 API 加上「認證保護」</h2><p>登入功能完成後，接下來要將「需要登入才能存取」的 API，分別加上<strong>認證保護</strong>，使用 Django Ninja 提供的<code>django_auth</code>——這是專門給 Django 內建的 session 認證使用。</p><p>我們以「上傳 avatar」API 為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja.security <span class="keyword">import</span> django_auth</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    path=<span class="string">&#x27;/users/&#123;int:user_id&#125;/avatar/&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    summary=<span class="string">&#x27;上傳 avatar&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    auth=django_auth  <span class="comment"># 加上這組參數</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br></pre></td></tr></table></figure><p>這個例子中，<code>auth=django_auth</code>確保只有「已登入的使用者」才能存取此 API，否則將得到 401 或 403 回應。</p><hr><h2 id="Django-Ninja-的-request-auth"><a href="#Django-Ninja-的-request-auth" class="headerlink" title="Django Ninja 的 request.auth"></a>Django Ninja 的 request.auth</h2><p>但你可能會想到：</p><blockquote><p>光是驗證「已登入」還不夠吧？</p></blockquote><p>「上傳 avatar」應該只能幫「<strong>自己</strong>」上傳，總不能幫「<strong>別人</strong>」上傳大頭照吧！</p><p>沒錯，所以我們在 <strong>view 函式內部</strong>，還要<strong>多一層驗證</strong>。</p><h3 id="Django-的request-user"><a href="#Django-的request-user" class="headerlink" title="Django 的request.user"></a>Django 的<code>request.user</code></h3><p>傳統的 Django 專案，我們會透過函式的第一參數——<code>request</code>，用<code>request.user</code>來獲得<strong>當前使用者資訊</strong>，比如：（參考<a href="https://docs.djangoproject.com/en/5.1/topics/auth/default/#authentication-in-web-requests">文件</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.user.is_authenticated:</span><br><span class="line">    <span class="comment"># Do something for authenticated users.</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Do something for anonymous users.</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>具體來說：</p><ul><li>當使用者已登入，<code>request.user</code>會是一個<code>User</code>實例，代表<strong>當前登入的使用者</strong>。</li><li>未登入時，<code>request.user</code>則是一個<code>AnonymousUser</code>實例，代表<strong>未登入使用者</strong>。</li></ul><p>當使用者已登入，我們可以檢查<code>request.user</code>的屬性，比如<code>request.user.id</code>，來確認<strong>是否為「本人」</strong>。</p><h3 id="Django-Ninja-的request-auth"><a href="#Django-Ninja-的request-auth" class="headerlink" title="Django Ninja 的request.auth"></a>Django Ninja 的<code>request.auth</code></h3><p>但寫 Django Ninja 則需要使用它提供的<code>request.auth</code>，實作結果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_avatar</span>(<span class="params">...</span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上傳 avatar</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 檢查登入的使用者是否為「本人」</span></span><br><span class="line">    <span class="keyword">if</span> request.auth.<span class="built_in">id</span> != user_id:</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">403</span>, <span class="string">&#x27;無權限上傳其他使用者的 avatar&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>測試一下，登入後在 URL path 打別人的 id 來呼叫此 API：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 403 Forbidden</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;無權限上傳其他使用者的 avatar&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>非常好！</p><hr><h2 id="request-auth-解析"><a href="#request-auth-解析" class="headerlink" title="request.auth 解析"></a>request.auth 解析</h2><p>雖然這裡用<code>request.auth</code>來取代<code>request.user</code>，但其實兩者的內涵有<strong>很大的不同</strong>。</p><p>在 Django Ninja 中，<code>request.auth</code>代表的是<strong>認證流程 return 的結果</strong>。此外，Django Ninja 允許你<strong>自定義認證方法</strong>，所以<code>request.auth</code>的內容是<strong>不固定的</strong>。</p><p>讓我們深入了解一下。</p><h3 id="認證結果"><a href="#認證結果" class="headerlink" title="認證結果"></a>認證結果</h3><p><code>request.auth</code>包含了<strong>當前認證方法</strong>返回的值。</p><ul><li>這個值可以是<strong>任何類型</strong>，取決於你<strong>如何實現認證邏輯</strong>。</li><li>這給了開發者極大的靈活性，它可以是<code>User</code>物件、字串、Python 字典等等。</li></ul><h3 id="認證方法與常見用例"><a href="#認證方法與常見用例" class="headerlink" title="認證方法與常見用例"></a>認證方法與常見用例</h3><ul><li>使用 Django 的 session 認證時，<code>request.auth</code>是 Django 的<code>User</code>物件。</li><li>對於 API key 認證，<code>request.auth</code>可能是 API key 本身或與之相關的資訊。</li><li>在 JWT 認證中，<code>request.auth</code>可能包含解碼後的 token 資訊。</li></ul><p>總之，只要記得，想在 view 函式內進一步取得<strong>認證資訊</strong>，要透過<code>request.auth</code>。</p><hr><p>這樣就已經實作完認證了，但我們可以讓事情更「簡單」一點。</p><h2 id="全域認證的設定與例外"><a href="#全域認證的設定與例外" class="headerlink" title="全域認證的設定與例外"></a>全域認證的設定與例外</h2><p>一一對每個 API 設定認證保護，感覺有點<strong>繁瑣</strong>——尤其在 API 多的時候。</p><p>對此，Django Ninja 支援<strong>全域認證</strong>，讓所有 API <strong>預設都直接受到保護</strong>，開發者只需在特定路由中進行<strong>例外</strong>處理，<strong>排除</strong>不想套用的 API 即可。</p><p>實作上非常簡單，Django Ninja 直接提供了<code>SessionAuth</code>認證類別，用來處理全域的 session-based 認證。</p><h3 id="實作全域認證：使用SessionAuth"><a href="#實作全域認證：使用SessionAuth" class="headerlink" title="實作全域認證：使用SessionAuth"></a>實作全域認證：使用<code>SessionAuth</code></h3><p>在專案的<code>api.py</code>中加入下面內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja.security <span class="keyword">import</span> SessionAuth</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">api = NinjaAPI(</span><br><span class="line">    auth=SessionAuth(),  <span class="comment"># 設定全域認證</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如此一來，全部的 API 都<strong>預設擁有認證保護</strong>，你可以在特定 API 中排除，比如「登入使用者」：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/users/login/&#x27;</span>, summary=<span class="string">&#x27;登入使用者&#x27;</span>, auth=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure><p>在路由裝飾器中，把<code>auth</code>定義為<code>None</code>，<strong>解除</strong>認證保護。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>在這篇文章中，我們探討了 Django 的 session 認證與 Django Ninja 的整合，實作了「使用者登入」API，並為其他 API 加上認證保護。最後還示範了如何實現全域認證，讓整個流程更加簡單。</p><p>這個系列的<strong>最後實踐</strong>，我們要來為專案——<strong>寫測試</strong>！</p><p>下一篇將探討，如何使用 test client 和 pytest 來為我們的 Django API 撰寫<strong>單元測試</strong>。這不僅能幫助我們驗證現有功能，還能為未來的開發和重構提供多一層的保障。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;歡迎來到第七章！本章總共有兩篇內容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷 28：身分認證——Session 認證與全域設定&lt;/li&gt;
&lt;li&gt;卷 29：單元測試——使用 Test Client 與 pytest 測試 API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些主題的核心功能，&lt;strong&gt;並非由 Django Ninja 實作&lt;/strong&gt;，但框架仍提供了&lt;strong&gt;一定程度的整合&lt;/strong&gt;。並且，這些功能對於任何 Django 專案來說，都至關重要。&lt;/p&gt;
&lt;p&gt;本文介紹幾乎所有 API 專案都需要的——&lt;strong&gt;身分認證&lt;/strong&gt;（&lt;a href=&quot;https://django-ninja.dev/guides/authentication/&quot;&gt;Authentication&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;我們將探討如何在 Django Ninja 中利用 Django 內建的 session-based 認證，實現完整的登入驗證功能，並進一步說明如何設定&lt;strong&gt;全域認證&lt;/strong&gt;，以減少程式碼的重複。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/19&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;認證的兩個層次&quot;&gt;&lt;a href=&quot;#認證的兩個層次&quot; class=&quot;headerlink&quot; title=&quot;認證的兩個層次&quot;&gt;&lt;/a&gt;認證的兩個層次&lt;/h2&gt;&lt;p&gt;進入實作前，我們要先了解，所謂的&lt;strong&gt;身分認證&lt;/strong&gt;，究竟代表什麼。&lt;/p&gt;
&lt;p&gt;以「帳號密碼 + session 認證」為例，身分認證的範圍主要涵蓋&lt;strong&gt;兩個階段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，當使用者透過帳號密碼進行登入時，系統會檢查這些內容、確認身分&lt;strong&gt;合法&lt;/strong&gt;。登入成功後，系統會將使用者資訊（比如用戶 id）儲存至 session，以&lt;strong&gt;維持登入狀態&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是&lt;strong&gt;登入時的認證&lt;/strong&gt;，也是我們最常說的認證。（&lt;strong&gt;狹義的認證&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;接著，當使用者嘗試存取受「&lt;strong&gt;認證保護&lt;/strong&gt;」的 API 時，系統會檢查 session 並確認身分，確保每個 API 請求都來自&lt;strong&gt;合法登入&lt;/strong&gt;的使用者。&lt;/p&gt;
&lt;p&gt;簡言之：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一階段：初次登入時的身分確認。&lt;/li&gt;
&lt;li&gt;第二階段：後續請求時的身分確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兩個層次相輔相成、一體兩面，確保服務能夠在使用者&lt;strong&gt;登入&lt;/strong&gt;和&lt;strong&gt;後續操作&lt;/strong&gt;中，提供適當的安全保障。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 27：資料查詢與過濾（下）FilterSchema 多欄位查詢</title>
    <link href="https://blog.kyomind.tw/django-ninja-27/"/>
    <id>https://blog.kyomind.tw/django-ninja-27/</id>
    <published>2024-10-09T06:04:46.000Z</published>
    <updated>2024-10-09T13:01:53.719Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上篇中，我們學習了 Django ORM 的<code>Q</code>物件和 Django Ninja 的 FilterSchema，但後者感覺只學了一半。</p><p>討論比較多的是，view 函式中使用 FilterSchema 的<strong>參數定義方式</strong>——這確實很重要，但這只是 FilterSchema 的一部分。</p><p>本篇要來補完剩下的內容：</p><ol><li>完善 FilterSchema：使用「<strong>更道地</strong>」的寫法，釋放 FilterSchema <strong>真正的力量</strong>。</li><li>實作更進階的欄位查詢功能：<strong>多欄位查詢——篩選日期區間。</strong></li><li>追加實作第 20 篇學到的「<strong>跨欄位驗證</strong>」：驗證查詢參數的<strong>日期區間是否合法</strong>。</li></ol><p>看來又是資訊滿滿的一篇，話不多說，直接開始吧！</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/18">這個 PR</a>。</p><span id="more"></span><hr><h2 id="一、將查詢邏輯遷移到-FilterSchema"><a href="#一、將查詢邏輯遷移到-FilterSchema" class="headerlink" title="一、將查詢邏輯遷移到 FilterSchema"></a>一、將查詢邏輯遷移到 FilterSchema</h2><p>還記得我們上一篇的程式碼實作嗎？</p><p>明明多定義了 FilterSchema，但 view 函式中的程式碼<strong>不僅沒有減少，反而還增加了</strong>！（雖然查詢邏輯也變多了，因為要同時查詢兩個欄位）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">CustomPagination</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    filters: PostFilterSchema = Query(<span class="params"></span>),  <span class="comment"># 使用 FilterSchema</span></span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> filters.query:</span><br><span class="line">        q = Q(title__icontains=filters.query) | \</span><br><span class="line">            Q(content__icontains=filters.query)</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(q)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這簡直莫名其妙🐸</p><p>那是因為，FilterSchema 不是這麼用的！</p><h3 id="FilterSchema-的「正確」用法"><a href="#FilterSchema-的「正確」用法" class="headerlink" title="FilterSchema 的「正確」用法"></a>FilterSchema 的「正確」用法</h3><p>我們應該盡可能將查詢邏輯<strong>封裝到 FilterSchema 中</strong>，這樣可以讓 view 函式更簡潔，並達到「<strong>關注點分離</strong>」的效果。</p><p>來看看更合理的寫法——將查詢邏輯遷移到 FilterSchema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    query: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        q=[<span class="string">&#x27;title__icontains&#x27;</span>, <span class="string">&#x27;author__username__icontains&#x27;</span>],</span><br><span class="line">        min_length=<span class="number">2</span>,</span><br><span class="line">        max_length=<span class="number">10</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>主要的變動是<code>query</code>欄位的 Field 部分，現在加上了<code>q=</code>參數內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=[<span class="string">&quot;title__icontains&quot;</span>, <span class="string">&quot;author__name__icontains&quot;</span>]</span><br></pre></td></tr></table></figure><p>很眼熟吧？沒錯，它們實際上就是<code>Q</code>物件的<strong>條件語句</strong>，Django Ninja 會在背後自動調用<code>Q</code>物件來執行這些查詢。</p><h3 id="來自-Mypy-的提醒"><a href="#來自-Mypy-的提醒" class="headerlink" title="來自 Mypy 的提醒"></a>來自 Mypy 的提醒</h3><p>一旦使用<code>q=</code>參數，Mypy 又會提醒你：</p><blockquote><p>Unexpected keyword argument “q” for “Field”</p></blockquote><p>它說的並沒有錯，因為 Pydantic Field <strong>確實沒有</strong>這個參數——這是 Django Ninja 自行實作的。</p><p>你可以無視它，或加上必要的註解。</p><h3 id="View-函式簡化"><a href="#View-函式簡化" class="headerlink" title="View 函式簡化"></a>View 函式簡化</h3><p>如此一來，view 函式<strong>只需要</strong>這樣寫就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    filters: PostFilterSchema = Query(<span class="params"></span>),</span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.select_related(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    posts = filters.<span class="built_in">filter</span>(posts)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>是不是<strong>簡單很多</strong>？</p><p>因為查詢邏輯從 view 函式「分離」出來了，這使得 view 函式的職責更單一、更利於維護。</p><hr><h2 id="二、多欄位查詢：新增日期篩選功能"><a href="#二、多欄位查詢：新增日期篩選功能" class="headerlink" title="二、多欄位查詢：新增日期篩選功能"></a>二、多欄位查詢：新增日期篩選功能</h2><p>新需求：除了可以查文章標題或作者名稱，現在還要加入對「<strong>發文日期</strong>」的過濾！</p><p>我們將引入兩個<strong>新的 URL 查詢參數</strong>：</p><ul><li><code>start_date</code></li><li><code>end_date</code></li></ul><p>兩者將用來查詢、過濾<code>Post</code>模型中的<code>created_at</code>欄位（即發文日期），以篩選特定時間範圍內的文章資料。</p><p>還有一個<strong>額外要求</strong>：兩者必須「<strong>全有全無</strong>」——可以都沒有，但不可以只填其中一個。</p><p>這是一個典型的「<strong>多欄位</strong>」查詢。</p><h3 id="新增程式碼"><a href="#新增程式碼" class="headerlink" title="新增程式碼"></a>新增程式碼</h3><p>這是加入了上述邏輯後的 FilterSchema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    query: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">        <span class="literal">None</span>, q=[<span class="string">&quot;title__icontains&quot;</span>, <span class="string">&quot;author__username__icontains&quot;</span>])</span><br><span class="line">    start_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&quot;created_at__gte&quot;</span>)</span><br><span class="line">    end_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&quot;created_at__lte&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>start_date</code>和<code>end_date</code>都是對模型欄位<code>created_at</code>的<strong>查詢條件</strong>。</p><p>所以我們使用<code>created_at__gte</code>和<code>created_at__lte</code>來<strong>描述過濾邏輯</strong>（它們都對應了各自的<code>Q</code>物件），以<strong>篩選</strong>出符合條件的資料。</p><p>那 view 函式呢？你猜得沒錯——<strong>完全不用動</strong>！</p><p>這就是使用 FilterSchema 的好處。</p><h3 id="API-文件渲染問題"><a href="#API-文件渲染問題" class="headerlink" title="API 文件渲染問題"></a>API 文件渲染問題</h3><p>有趣的是，當我試著為這些查詢參數加上<strong>文件範例</strong>時，如果這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">    <span class="literal">None</span>, q=<span class="string">&#x27;created_at__gte&#x27;</span>, examples=[<span class="string">&#x27;2021-01-01&#x27;</span>]</span><br></pre></td></tr></table></figure><p>查看 API 文件將會得到：</p><blockquote><p>😱 Could not render Parameters, see the console.</p></blockquote><p>但寫<code>example=&#39;2021-01-01&#39;</code>卻可以成功。</p><p>這可能是 Django Ninja 與 Pydantic 在整合上的一個 bug，我們暫且就先略過吧！</p><h3 id="客戶端查詢範例"><a href="#客戶端查詢範例" class="headerlink" title="客戶端查詢範例"></a>客戶端查詢範例</h3><p>當我們要查詢某段時間內的文章時，可以使用以下的 URL 查詢參數：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?start_date=2023-01-01&amp;end_date=2023-01-31</span><br></pre></td></tr></table></figure><p>這樣就能輕鬆查詢出 2023 年 1 月份的所有文章。</p><p>附帶一提，日期中的時間因為沒有指定，預設上都是 0 點 0 分 0 秒。所以如果填同一天，就查不到任何東西。</p><p>這是一個需要<strong>改善</strong>或<strong>重新調整</strong>的細節，常見的做法是在程式內部把<code>end_date</code>加 1 天，而我直接選擇<strong>讓兩者不能相同</strong>XD。實際該怎麼做，取決於你的需求。</p><p>除了單純的期間查詢，我們也可以查詢<strong>某作者在某段時間內</strong>的文章，以查詢作者 Alice 為例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?start_date=2023-01-01&amp;end_date=2023-01-31&amp;query=alice</span><br></pre></td></tr></table></figure><p>結果顯示了 Alice 在 2023 年 1 月份的所有文章。</p><hr><h2 id="FilterSchema-的預設查詢條件關係"><a href="#FilterSchema-的預設查詢條件關係" class="headerlink" title="FilterSchema 的預設查詢條件關係"></a>FilterSchema 的預設查詢條件關係</h2><p>這部分一定要特別介紹，依<a href="https://django-ninja.dev/guides/input/filtering/#combining-expressions">文件</a>所述，預設上：</p><ul><li>Field-level expressions are joined together using <code>OR</code> operator.</li><li>The fields themselves are joined together using <code>AND</code> operator.</li></ul><p>意思就是說，單一欄位內的多個 Q 語句，彼此是 OR 關係，比如上面<code>query</code>的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=[<span class="string">&#x27;title__icontains&#x27;</span>, <span class="string">&#x27;author__username__icontains&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以查詢文章標題「<strong>或</strong>」作者名稱。</p><p>而<strong>不同欄位</strong>中的條件（如果都有），則是 AND 關係——必須<strong>同時符合</strong>才行。所以作者名稱與日期區間，兩者的條件必須同時符合。</p><p>這些預設邏輯可以自行變更，詳情請參考上述文件內容。</p><hr><h2 id="三、日期區間驗證"><a href="#三、日期區間驗證" class="headerlink" title="三、日期區間驗證"></a>三、日期區間驗證</h2><p>本例中，除了欄位查詢，我們還要確保，使用者輸入的開始日期<strong>必須早於</strong>結束日期。</p><p>並且，兩個欄位的查詢值必須是「全有」或「全無」（<strong>全無則不必驗證</strong>）。</p><p>這個需求非常眼熟——不就是第 20 篇提到的「<strong>跨欄位驗證</strong>」嗎？</p><p>沒錯，我們要透過 Pydantic 的<code>model_validator</code>來實現，它允許我們在驗證過程中，對輸入資料進行<strong>自定義的邏輯檢查</strong>。</p><h3 id="使用-Pydantic-model-validator-實作日期區間驗證"><a href="#使用-Pydantic-model-validator-實作日期區間驗證" class="headerlink" title="使用 Pydantic model_validator 實作日期區間驗證"></a>使用 Pydantic model_validator 實作日期區間驗證</h3><p>程式碼有點多，我們直接看重點：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    ...</span><br><span class="line">    start_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&#x27;created_at__gte&#x27;</span>)</span><br><span class="line">    end_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&#x27;created_at__lte&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @model_validator(<span class="params">mode=<span class="string">&#x27;after&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_date_range</span>(<span class="params">self</span>) -&gt; Self:</span><br><span class="line">        <span class="comment"># 如果開始日期和結束日期都是 None，則不進行任何檢查</span></span><br><span class="line">        <span class="keyword">if</span> self.start_date <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self.end_date <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([self.start_date, self.end_date]):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;開始日期和結束日期必須同時提供或同時不提供&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            start_date_dt = datetime.strptime(self.start_date, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">            end_date_dt = datetime.strptime(self.end_date, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;日期格式無效，應為 YYYY-MM-DD&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start_date_dt &gt; end_date_dt:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;開始日期必須早於結束日期&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>對於查詢條件，我們使用 Pydantic 的<code>model_validator</code>進行跨欄位驗證，確保使用者輸入的日期是<strong>有效且合理</strong>的。</p><p>事實上，跨欄位驗證往往要<strong>考慮很多細節</strong>，否則可能掛一漏萬，間接產生新的 bug。</p><p>這個例子就是一個典型案例。</p><p>我們必須<strong>全盤考慮</strong>各種可能的輸入情況，包括日期格式是否正確、日期範圍是否合理，以及兩個日期欄位是否同時存在或同時為空。</p><p><strong>細緻的驗證邏輯</strong>能提升 API 的<strong>可靠性</strong>，避免因為無效或不合理的輸入而導致系統出現<strong>意外行為</strong>。而粗糙的邏輯則反之。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>這兩篇文章，我們介紹了 FilterSchema 的有效用法，完成了多欄位查詢和日期篩選，並示範如何使用<code>model_validator</code>來強化資料驗證，確保查詢邏輯的正確性。</p><p>我們還看了這些應用場景的實例程式碼，幫助讀者更好地理解每個步驟的用途和效果。</p><p>下一章，我們將探討 Django Ninja 中的認證（Authentication）機制，並介紹如何使用 pytest 進行單元測試，這些都是後端開發中，不可或缺的要素。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇中，我們學習了 Django ORM 的&lt;code&gt;Q&lt;/code&gt;物件和 Django Ninja 的 FilterSchema，但後者感覺只學了一半。&lt;/p&gt;
&lt;p&gt;討論比較多的是，view 函式中使用 FilterSchema 的&lt;strong&gt;參數定義方式&lt;/strong&gt;——這確實很重要，但這只是 FilterSchema 的一部分。&lt;/p&gt;
&lt;p&gt;本篇要來補完剩下的內容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完善 FilterSchema：使用「&lt;strong&gt;更道地&lt;/strong&gt;」的寫法，釋放 FilterSchema &lt;strong&gt;真正的力量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;實作更進階的欄位查詢功能：&lt;strong&gt;多欄位查詢——篩選日期區間。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;追加實作第 20 篇學到的「&lt;strong&gt;跨欄位驗證&lt;/strong&gt;」：驗證查詢參數的&lt;strong&gt;日期區間是否合法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看來又是資訊滿滿的一篇，話不多說，直接開始吧！&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/18&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 26：資料查詢與過濾（上）FilterSchema 介紹</title>
    <link href="https://blog.kyomind.tw/django-ninja-26/"/>
    <id>https://blog.kyomind.tw/django-ninja-26/</id>
    <published>2024-10-08T02:31:58.000Z</published>
    <updated>2024-10-11T10:12:33.811Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>「<strong>查詢</strong>」是 API 中常見的附加需求，本質上是<strong>對資料的過濾（filtering）與篩選</strong>。</p><p>無論是篩選文章、商品，還是查詢用戶，<strong>根據不同條件來過濾資料並獲得結果</strong>，可說是大部分專案的必備功能。</p><p>在 view 函式中，實作查詢<strong>最簡單</strong>的方式，就是使用 Django ORM 的過濾方法。例如，我們可以用<code>filter</code>方法來根據特定條件篩選 QuerySet。</p><p>這種方法簡單直接，適合基本的查詢需求。然而，它也有其<strong>局限性</strong>——隨著欄位與需求的增加，查詢條件可能變得<strong>越來越複雜</strong>，導致程式碼<strong>冗長</strong>且難以維護。</p><p>為了解決這一問題，Django Ninja 提供了 FilterSchema，讓我們可以用更「<strong>結構化</strong>」的方式，定義並管理查詢條件。</p><p>本文將介紹 FilterSchema，一步步實作與講解，讓你了解如何在 Django Ninja 中使用 FilterSchema，實現<strong>更加靈活、模組化</strong>的 API 查詢功能。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/17">這個 PR</a>。</p><span id="more"></span><hr><h2 id="傳統查詢方法與問題"><a href="#傳統查詢方法與問題" class="headerlink" title="傳統查詢方法與問題"></a>傳統查詢方法與問題</h2><p>上一篇我們提到「取得文章列表」API，還記得我們在〈卷 11：請求（三）查詢參數 - Query Parameters〉為它加上的「<strong>依文章標題查詢</strong>」功能嗎？</p><p>這是目前程式碼的現況：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    title: <span class="literal">None</span> | <span class="built_in">str</span> = Query(<span class="params"><span class="literal">None</span>, min_length=<span class="number">2</span>, max_length=<span class="number">10</span></span>),</span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> title:</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">            title__icontains=title).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>那時我們就是用了<code>filter</code>方法！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts.<span class="built_in">filter</span>(title__icontains=title).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最後的<code>select_related(&#39;author&#39;)</code>是為了避免「N+1」問題，和查詢邏輯<strong>無關</strong>，可以先不管。</p><h3 id="新需求：同時查詢作者名字"><a href="#新需求：同時查詢作者名字" class="headerlink" title="新需求：同時查詢作者名字"></a>新需求：同時查詢作者名字</h3><p>新的需求是，用<strong>同一個關鍵字</strong>， 同時查詢<strong>文章的標題或作者的名字</strong>， 只要任一符合就顯示在結果中。（二者滿足其一即可，也可以<strong>都符合</strong>）</p><p>這需求類似於 iThome 鐵人賽官網的<a href="https://ithelp.ithome.com.tw/2024ironman/signup/list">這個查詢功能</a>：</p><p><img src="https://i.imgur.com/nCU56Bk.png"></p><p>不過我們只能查 2 種，而它可以同時查 3 種：題目、簡介、參賽者暱稱。</p><p>但本質上是一樣的。</p><h3 id="用傳統方法實作"><a href="#用傳統方法實作" class="headerlink" title="用傳統方法實作"></a>用傳統方法實作</h3><p>這時如果用傳統方法實作，查詢會長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    Q(title__icontains=title) | Q(author__name__icontains=title)</span><br><span class="line">).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此時查詢參數不適合再叫<code>title</code>，因為它要查詢<strong>兩個欄位</strong>。沒關係，我們之後會改成<code>query</code>。</p><p>這段程式碼還有兩個重點：</p><ol><li>查詢果然<strong>變長</strong>了！之後如果還有新的查詢條件，那豈不是……</li><li>這個<code>Q</code>是什麼東西？</li></ol><p><code>Q</code>則是 Django ORM 的 <a href="https://docs.djangoproject.com/en/5.1/topics/db/queries/#complex-lookups-with-q-objects">Q 物件</a>，它在<strong>複雜查詢邏輯</strong>中佔據了重要地位。因此，我們有必要先簡單介紹一下。</p><hr><h2 id="Django-Q-物件簡介"><a href="#Django-Q-物件簡介" class="headerlink" title="Django Q 物件簡介"></a>Django Q 物件簡介</h2><p>為了改善<strong>多條件查詢</strong>時，程式<strong>結構複雜</strong>的問題，Django 提供了<code>Q</code>物件。</p><p><code>Q</code>物件允許我們<strong>靈活地組織查詢條件</strong>，使用<strong>邏輯運算子</strong>（如<code>&amp;</code>、<code>|</code>）進行<strong>條件合併</strong>。在處理<strong>複雜條件過濾</strong>時非常有用。</p><p>比如說，我們想要篩選出標題包含「Ninja」<strong>並且</strong>作者名稱包含「Alice」的文章，可以這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    Q(title__icontains=<span class="string">&#x27;Ninja&#x27;</span>) &amp; Q(author__name__icontains=<span class="string">&#x27;Alice&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上述寫法，其實就<strong>等價</strong>於我們常見的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    title__icontains=<span class="string">&#x27;Ninja&#x27;</span>, author__name__icontains=<span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>所以你通常不會在「AND」需求時使用<code>Q</code>物件。</p><p>「OR」查詢條件才是<code>Q</code>的<strong>經典場景</strong>。</p><p>現在條件改為——文章標題「<strong>或</strong>」作者名字有「Alice」就行。可以使用<code>|</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    Q(title__icontains=<span class="string">&#x27;Ninja&#x27;</span>) | Q(author__name__icontains=<span class="string">&#x27;Alice&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>Q</code>物件讓查詢更加靈活且清晰，特別是在面對<strong>多個可選條件</strong>時。</p><hr><h2 id="使用-FilterSchema-改進查詢"><a href="#使用-FilterSchema-改進查詢" class="headerlink" title="使用 FilterSchema 改進查詢"></a>使用 FilterSchema 改進查詢</h2><p>了解傳統查詢方法容易造成<strong>程式冗長</strong>的問題，並學習了<code>Q</code>物件的基礎後，我們要開始介紹今天的主角——<a href="https://django-ninja.dev/guides/input/filtering/">FilterSchema</a>。</p><p>Django Ninja 提供的 FilterSchema，主要的功能是讓查詢語句更加<strong>結構化、模組化</strong>，避免 view 函式變得冗長、難讀。</p><p>而且，與 Schema 中的驗證方法相同，它也一定程度實現了「<strong>關注點分離</strong>」原則——藉由將查詢邏輯從 view 函式中<strong>抽離</strong>出來。</p><p>不過，我們先不急著一步到位，容我<strong>分階段地改進</strong>程式碼。</p><p>這樣雖然有點笨拙，但你會對 FilterSchema 與複雜查詢的實作，有更深刻的了解。</p><h2 id="第一版「改進」"><a href="#第一版「改進」" class="headerlink" title="第一版「改進」"></a>第一版「改進」</h2><p>我們先用 FilterSchema 實現上述的「新需求：同時查詢作者名字」。</p><p>在<code>schemas.py</code>中建立新的 Schema，不過這次是 FilterSchema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/schemas.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Field, FilterSchema, Schema</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    query: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, min_length=<span class="number">2</span>, max_length=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>這個 FilterSchema，其實是給「<strong>查詢參數</strong>（query parameters）」使用的。所以它的欄位（屬性）名稱，就是你認為客戶端<strong>應該使用的查詢參數名稱</strong>。</p><p>因為同時要查「文章標題」和「作者名字」，所以我命名為<code>query</code>。</p><p>接下來，我們在 view 函式中使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">CustomPagination</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    filters: PostFilterSchema = Query(<span class="params"></span>),  <span class="comment"># 使用 FilterSchema</span></span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> filters.query:</span><br><span class="line">        q = Q(title__icontains=filters.query) | \</span><br><span class="line">            Q(author__username__icontains=filters.query)</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(q)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>PS：這裡的<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/17/files">專案範例程式碼</a><strong>有誤</strong>，第二個<code>Q</code>查詢誤植為「<code>content__icontains</code>」，請讀者留意。我已在下一個分支中修復。</p><p>看完這個新的 view 函式，你可能不禁心想：</p><blockquote><p>這是在搞笑吧？完全沒有變簡單啊！</p></blockquote><p>沒錯，因為這只是 FilterSchema 的「<strong>半成品</strong>」，所以看起來比不用還冗長。</p><p>儘管如此，其中還是有一些看點，值得我們了解。</p><h2 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = Q(title__icontains=filters.query) | \</span><br><span class="line">    Q(content__icontains=filters.query)</span><br><span class="line">posts = posts.<span class="built_in">filter</span>(q)</span><br></pre></td></tr></table></figure><p>從這段能看出，<code>Q</code>物件可以<strong>單獨進行各種合併操作</strong>，最後再丟給 Django <code>filter</code>方法作為參數。</p><h3 id="Django-Ninja-常見句型"><a href="#Django-Ninja-常見句型" class="headerlink" title="Django Ninja 常見句型"></a>Django Ninja 常見句型</h3><p>本例中，這樣的 view <strong>函式參數</strong>「句型」在 Django Ninja 非常普遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filters: PostFilterSchema = Query()</span><br></pre></td></tr></table></figure><p>而初學者看了會很容易「<strong>誤解</strong>」。</p><p>為什麼？因為你可能會以為，<code>filters</code>的型別是<code>PostFilterSchema</code>（這沒問題），然後它的<strong>預設值</strong>是<code>Query()</code>，因為 Python 函式就是這樣定義的。</p><p>但並不是。</p><p><code>Query()</code>並不是<code>filters</code>參數的預設值，否則它的型別不應該是<code>Query</code>嗎？</p><p>事實上，<code>= Query()</code>這段標記<strong>不是給你看的</strong>，是給 Django Ninja 看的，它相當於是在告訴 Django Ninja：</p><blockquote><p>這個參數內容應該從 HTTP 請求中的查詢參數（query parameters）中取得，而不是從 body 或 path。</p></blockquote><p>這樣想就很容易明白了。</p><p>Django Ninja 會試圖從查詢參數獲取字串，拆解它們（如果有複數個查詢字串），然後一一丟給<code>PostFilterSchema</code>進行<strong>初始化與驗證：</strong></p><ol><li>驗證失敗：回傳 422。</li><li>驗證成功：將 Schema 物件傳入 view 函式作為<strong>函式的參數</strong>（<strong>區域變數</strong>）。</li></ol><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>本篇先講到這裡，我們已經接觸了兩個新概念——Q 物件和 FilterSchema。</p><p>我們還分析了 Django Ninja 中常見的 view 函式參數「句型」，這對於理解框架的使用方式、習慣非常重要。</p><p>這些概念需要時間消化，但我可以向你保證，這樣的鋪陳是值得的。</p><p>比起直接深入 FilterSchema 的進階用法，這種循序漸進的學習方式更有助於理解。</p><p>下一篇你將會看到，<strong>為什麼認識 Q 物件很重要</strong>。以及如何透過 FilterSchema，來建立結構化、符合「關注點分離」的<strong>多欄位查詢</strong>。</p><p>我們下篇見。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;查詢&lt;/strong&gt;」是 API 中常見的附加需求，本質上是&lt;strong&gt;對資料的過濾（filtering）與篩選&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;無論是篩選文章、商品，還是查詢用戶，&lt;strong&gt;根據不同條件來過濾資料並獲得結果&lt;/strong&gt;，可說是大部分專案的必備功能。&lt;/p&gt;
&lt;p&gt;在 view 函式中，實作查詢&lt;strong&gt;最簡單&lt;/strong&gt;的方式，就是使用 Django ORM 的過濾方法。例如，我們可以用&lt;code&gt;filter&lt;/code&gt;方法來根據特定條件篩選 QuerySet。&lt;/p&gt;
&lt;p&gt;這種方法簡單直接，適合基本的查詢需求。然而，它也有其&lt;strong&gt;局限性&lt;/strong&gt;——隨著欄位與需求的增加，查詢條件可能變得&lt;strong&gt;越來越複雜&lt;/strong&gt;，導致程式碼&lt;strong&gt;冗長&lt;/strong&gt;且難以維護。&lt;/p&gt;
&lt;p&gt;為了解決這一問題，Django Ninja 提供了 FilterSchema，讓我們可以用更「&lt;strong&gt;結構化&lt;/strong&gt;」的方式，定義並管理查詢條件。&lt;/p&gt;
&lt;p&gt;本文將介紹 FilterSchema，一步步實作與講解，讓你了解如何在 Django Ninja 中使用 FilterSchema，實現&lt;strong&gt;更加靈活、模組化&lt;/strong&gt;的 API 查詢功能。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/17&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 25：分頁（下）自定義分頁類別</title>
    <link href="https://blog.kyomind.tw/django-ninja-25/"/>
    <id>https://blog.kyomind.tw/django-ninja-25/</id>
    <published>2024-10-07T02:44:36.000Z</published>
    <updated>2024-10-11T12:49:59.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇我們介紹了 Django Ninja 的內建分頁器，並用它實作了簡單的分頁功能。</p><p>雖然內建的<code>PageNumberPagination</code>確實方便，但在很多時候，我們仍需要一些<strong>客製化</strong>功能。</p><p>為了實現這個目的，你需要<strong>自定義一個分頁類別</strong>。</p><p>不過別擔心，這種自定義，<strong>並非從零開始</strong>。而是繼承 Django Ninja 所提供的基礎分頁類別，再進行自己的「<strong>加工</strong>」。</p><p>這篇文章就要來教你怎麼做。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/16">這個 PR</a>。</p><hr><h2 id="客製化需求"><a href="#客製化需求" class="headerlink" title="客製化需求"></a>客製化需求</h2><p>除了基本的分頁，我們還希望能夠：</p><ul><li><strong>允許客戶端選擇</strong>每頁顯示的資料數量，<strong>可選範圍</strong>限定在 1 至 100 之間。</li><li>在回應中<strong>新增兩個欄位</strong>，顯示當前的<strong>分頁資訊</strong>：<ul><li>當前頁數（<code>page</code>）。</li><li>每頁顯示數量（<code>per_page</code>）。</li></ul></li></ul><p>這無疑是很常見的需求。我們將透過自定義分頁類別，來實現這些功能。</p><p>話不多說，直接開始！</p><span id="more"></span><h2 id="實作：自定義分頁類別"><a href="#實作：自定義分頁類別" class="headerlink" title="實作：自定義分頁類別"></a>實作：自定義分頁類別</h2><p>分頁器（分頁類別）通常是是<strong>供全專案使用</strong>，所以不適合放在 Django app 目錄中。但也不能像 exception handlers 一樣，放在專案的<code>api.py</code>，因為會引發<strong>循環引用</strong>。</p><p>所以，我在專案目錄 NinjaForum 建立一個新的 Python 模組——<code>pagination.py</code>。</p><p>在這個新模組中，直接撰寫一個名為<code>CustomPagination</code>的分頁類別，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models.query <span class="keyword">import</span> QuerySet</span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Field, Schema</span><br><span class="line"><span class="keyword">from</span> ninja.pagination <span class="keyword">import</span> PaginationBase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomPagination</span>(<span class="title class_ inherited__">PaginationBase</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line">        per_page: <span class="built_in">int</span> = Field(<span class="number">10</span>, ge=<span class="number">1</span>, le=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Output</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        items: <span class="built_in">list</span></span><br><span class="line">        page: <span class="built_in">int</span> = Field(examples=[<span class="number">1</span>])</span><br><span class="line">        per_page: <span class="built_in">int</span> = Field(examples=[<span class="number">10</span>])</span><br><span class="line">        total: <span class="built_in">int</span> = Field(examples=[<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paginate_queryset</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        queryset: QuerySet,</span></span><br><span class="line"><span class="params">        pagination: Input,</span></span><br><span class="line"><span class="params">        **params: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        start = (pagination.page - <span class="number">1</span>) * pagination.per_page</span><br><span class="line">        end = start + pagination.per_page</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;items&#x27;</span>: queryset[start:end],</span><br><span class="line">            <span class="string">&#x27;page&#x27;</span>: pagination.page,</span><br><span class="line">            <span class="string">&#x27;per_page&#x27;</span>: pagination.per_page,</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: queryset.count(),</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>這個分頁類別<strong>允許我們透過查詢參數</strong>——<code>page</code>和<code>per_page</code>——來決定分頁的大小與頁數，而且回應中<strong>還多了兩個同名的新欄位</strong>，作為額外的分頁資訊。</p><hr><h2 id="自定義分頁類別解說"><a href="#自定義分頁類別解說" class="headerlink" title="自定義分頁類別解說"></a>自定義分頁類別解說</h2><p>雖然程式碼看起來細節繁多，但仔細閱讀後，你會發現它其實不難理解。</p><p>限於篇幅，我們只挑一些重點來講。</p><h3 id="重點一：整體結構來自繼承的類別——PaginationBase"><a href="#重點一：整體結構來自繼承的類別——PaginationBase" class="headerlink" title="重點一：整體結構來自繼承的類別——PaginationBase"></a>重點一：整體結構來自繼承的類別——<code>PaginationBase</code></h3><p>第一個疑惑應該是：「啊我<strong>怎麼會知道</strong>分頁類別要這樣寫？」</p><p>沒錯，我們<strong>當然不知道</strong>，所以要看<a href="https://django-ninja.dev/guides/response/pagination/#creating-custom-pagination-class">官方文件</a>，還有<a href="https://github.com/vitalik/django-ninja/blob/master/ninja/pagination.py">原始碼</a>。</p><p>從官方文件我們可以得知，要繼承一個叫<code>PaginationBase</code>的類別。但文件中對該類別的描寫還是有點簡略，所以需要看原始碼來了解更多的具體資訊。</p><p>然後模仿並覆寫類別中的一些屬性、方法——差不多就是如此。</p><h3 id="重點二：Input-Schema"><a href="#重點二：Input-Schema" class="headerlink" title="重點二：Input Schema"></a>重點二：Input Schema</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line">    per_page: <span class="built_in">int</span> = Field(<span class="number">10</span>, ge=<span class="number">1</span>, le=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>你一定能看出來，這個 Schema 就是拿來<strong>定義和驗證</strong>與分頁有關的 <strong>URL 查詢參數</strong>。</p><p>此外，<code>Input</code>類別會作為<strong>引數</strong>傳入<code>paginate_queryset</code>方法中，作為實現分頁邏輯的一部分。</p><p><code>Input</code>中的每一個屬性，就<strong>代表一個查詢參數</strong>（限分頁相關）——而且一樣可以使用<code>Field</code>來設定細節！</p><p>這裡的<code>Field</code>是 Pydantic 的<code>Field</code>，我們在第 18 篇詳細介紹過。它允許我們為每個參數設定<strong>預設值</strong>、<strong>文件範例</strong>和<strong>基本的驗證規則</strong>。</p><p>本例中，<code>page</code>的預設值是 1，且必須大於等於 1；<code>per_page</code>的預設值是 10，且必須在 1 到 100 之間。這樣可以確保我們的分頁參數<strong>始終在合理的範圍內</strong>。</p><p>同樣的道理也適用於<code>Output</code>，它決定了 HTTP 回應「<strong>應該要有</strong>」的格式，相當於分頁回應的 Schema。</p><h3 id="重點三：paginate-queryset-方法"><a href="#重點三：paginate-queryset-方法" class="headerlink" title="重點三：paginate_queryset 方法"></a>重點三：paginate_queryset 方法</h3><p>這個方法是所有分頁類別的<strong>核心</strong>，它實現了<strong>具體的分頁邏輯</strong>。</p><p>它的第一參數是<code>self</code>，可見它是一個「<strong>實例方法</strong>」。</p><p><strong>最值得注意</strong>的是<strong>第二參數</strong>——<code>queryset</code>，它實際上就是 view 函式的 return 值，而且類型<strong>必須是</strong> <a href="https://docs.djangoproject.com/en/5.1/ref/models/querysets/">QuerySet</a>。</p><p><code>paginate_queryset</code>會利用我們熟悉的「<a href="https://vocus.cc/article/649392c3fd8978000166bbc5">切片與索引</a>」，對傳入的 QuerySet 進行「切割」。這是 Django 為 QuerySet 自行實作的功能，行為上類似 Python 的<code>list</code>、<code>tuple</code>等容器。</p><p>當它回應給客戶端時，我們就得到了<strong>切片後的 QuerySet</strong> 和<strong>自定義的回應格式</strong>。</p><hr><h2 id="測試自定義分頁"><a href="#測試自定義分頁" class="headerlink" title="測試自定義分頁"></a>測試自定義分頁</h2><p>寫完上述的自定義類別，view 函式只要多一行<code>@paginate(CustomPagination)</code>即可，這裡就省略程式碼。</p><p>直接看結果吧！我使用了<code>/?page=2&amp;per_page=5</code>（第 2 頁、每頁 5 筆）查詢參數：</p><p><img src="https://i.imgur.com/GuYj6Bk.png"></p><p>十分理想！</p><p>那如果每頁數量設定為<strong>超過 100</strong> 會怎樣呢？</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;less_than_equal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;query&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;per_page&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Input should be less than or equal to 100&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ctx&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;le&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>答案是 422 回應。</p><hr><h2 id="分頁功能總結"><a href="#分頁功能總結" class="headerlink" title="分頁功能總結"></a>分頁功能總結</h2><p>透過這兩篇文章，我們展示了如何在 DjangoNinja 中實作分頁，從簡單的內建方法，到複雜的自定義分頁類別。</p><p>根據專案需求，你可以選擇<strong>適合自己的分頁策略</strong>，讓每一個回應，都能以最適合的方式呈現給使用者。</p><hr><h2 id="為什麼「多重狀態碼回應」不實用？"><a href="#為什麼「多重狀態碼回應」不實用？" class="headerlink" title="為什麼「多重狀態碼回應」不實用？"></a>為什麼「多重狀態碼回應」不實用？</h2><p>還記得我們在第 13 篇、第 21 篇留下的<strong>伏筆</strong>嗎？</p><p>在〈卷 13：回應（一）Django Ninja 處理 HTTP 回應〉中我提到：</p><blockquote><p>但我覺得這個「多重狀態碼回應」設定在實務上<strong>沒有很實用</strong>，為何？我們後續再談。</p></blockquote><p>幫你複習一下，「多重狀態碼回應」指的是這個用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.post(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    ...,</span></span></span><br><span class="line"><span class="params"><span class="meta">    response=&#123;<span class="number">200</span>: Token, <span class="number">401</span>: Message, <span class="number">402</span>: Message&#125;  <span class="comment"># 這裡</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br></pre></td></tr></table></figure><p>然後在 view 函式中，依照不同情況，給出不同的 return。</p><p>我在〈卷 21：錯誤處理（上）HttpError 與自定義 HTTP 回應〉又說了：</p><blockquote><p>這樣看起來確實不錯，也很符合直覺，我以前寫 Django REST framework，都是這樣寫的。</p></blockquote><blockquote><p>可是，這個寫法在 Django Ninja 中，使用「分頁裝飾器」時，就會<strong>踢到鐵板</strong>了。</p></blockquote><blockquote><p>目前<strong>時機未到</strong>，在後續的〈卷 25：分頁（下）自定義分頁類別〉中，我們再把這件說清楚。</p></blockquote><p><strong>這不就來了嗎！</strong></p><p>理由很簡單，關鍵就在於本文「重點三：paginate_queryset 方法」中的那句：</p><blockquote><p>最值得注意的是第二參數——<code>queryset</code>，它實際上就是 view 函式的 return 值，而且類型<strong>必須是 QuerySet</strong>。</p></blockquote><p>因為<code>paginate_queryset</code>方法中，第二參數的類型<strong>必須是 QuerySet！</strong></p><p>在<code>paginate_queryset</code>內部，我們將這個參數視為 QuerySet 使用、操作。若傳入的<strong>不是</strong> QuerySet，分頁邏輯就會<strong>出錯</strong>。</p><h3 id="「多重狀態碼回應」與-paginate-queryset-方法的衝突"><a href="#「多重狀態碼回應」與-paginate-queryset-方法的衝突" class="headerlink" title="「多重狀態碼回應」與 paginate_queryset 方法的衝突"></a>「多重狀態碼回應」與 paginate_queryset 方法的衝突</h3><p>然而，多重狀態碼的回應，return 型別<strong>未必</strong>是 QuerySet——很可能是<code>tuple</code>。</p><p>我舉一個簡單的例子你就懂，我們把「取得文章列表」API 改成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.get(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    path=<span class="string">&quot;/posts&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    response=&#123;<span class="number">200</span>: <span class="built_in">list</span>[PostResponse], <span class="number">404</span>: ErrorMessage&#125;</span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">CustomPagination</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post] | <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]：</span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> posts.exists()：</span><br><span class="line">        <span class="keyword">return</span> <span class="number">404</span>， &#123;<span class="string">&quot;message&quot;</span>： <span class="string">&quot;沒有找到符合條件的文章&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這個例子清楚地顯示了「多重狀態碼回應」與分頁器之間的<strong>衝突</strong>：</p><ul><li>當查詢結果<strong>正常</strong>時，view 函式 return 一個 <strong>QuerySet</strong>（即<code>posts</code>），丟給分頁器進行分頁，一切運作良好。</li><li>當<strong>沒有找到文章</strong>時，view 函式試圖回傳一個<code>tuple</code>（因為 Django Ninja 非 200 回應必須有狀態碼，所以是<code>tuple</code>），而<strong>不是</strong> QuerySet。</li></ul><p>這將導致<code>paginate_queryset</code>方法出錯，因為它預期接收一個 QuerySet，後續的內部操作也是以此為前提。</p><hr><p>如果專案中所有的 API <strong>都沒有分頁</strong>，使用「多重狀態碼回應」來處理「非 200」回應是<strong>完全可行</strong>的。</p><p>但<strong>只要有一個</strong> API 需要分頁，這個有分頁的 API，為了避免上述衝突，就要改用一樣是第 21 篇提到的方式——<code>raise HttpError</code>。</p><p>考慮到<strong>專案整體的一致性</strong>，其餘的 API，也應該採用<code>raise HttpError</code>這個方式。</p><p>而分頁需求是<strong>如此的常見</strong>，所以「多重狀態碼回應」也就成為了<strong>雞肋</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇我們介紹了 Django Ninja 的內建分頁器，並用它實作了簡單的分頁功能。&lt;/p&gt;
&lt;p&gt;雖然內建的&lt;code&gt;PageNumberPagination&lt;/code&gt;確實方便，但在很多時候，我們仍需要一些&lt;strong&gt;客製化&lt;/strong&gt;功能。&lt;/p&gt;
&lt;p&gt;為了實現這個目的，你需要&lt;strong&gt;自定義一個分頁類別&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過別擔心，這種自定義，&lt;strong&gt;並非從零開始&lt;/strong&gt;。而是繼承 Django Ninja 所提供的基礎分頁類別，再進行自己的「&lt;strong&gt;加工&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;這篇文章就要來教你怎麼做。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/16&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;客製化需求&quot;&gt;&lt;a href=&quot;#客製化需求&quot; class=&quot;headerlink&quot; title=&quot;客製化需求&quot;&gt;&lt;/a&gt;客製化需求&lt;/h2&gt;&lt;p&gt;除了基本的分頁，我們還希望能夠：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;允許客戶端選擇&lt;/strong&gt;每頁顯示的資料數量，&lt;strong&gt;可選範圍&lt;/strong&gt;限定在 1 至 100 之間。&lt;/li&gt;
&lt;li&gt;在回應中&lt;strong&gt;新增兩個欄位&lt;/strong&gt;，顯示當前的&lt;strong&gt;分頁資訊&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;當前頁數（&lt;code&gt;page&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;每頁顯示數量（&lt;code&gt;per_page&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這無疑是很常見的需求。我們將透過自定義分頁類別，來實現這些功能。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 24：分頁（上）Django Ninja 的內建分頁器</title>
    <link href="https://blog.kyomind.tw/django-ninja-24/"/>
    <id>https://blog.kyomind.tw/django-ninja-24/</id>
    <published>2024-10-06T04:11:19.000Z</published>
    <updated>2024-10-07T05:52:25.603Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>分頁（<a href="https://django-ninja.dev/guides/response/pagination/">pagination</a>）功能，就算在資料量較少的小型專案，也具有相當的重要性。</p><p>沒分頁，API 照樣能運作——只是效能會受到影響，特別是在資料量大的情況下。</p><p>當 API 一次回傳大量資料時，不僅會增加伺服器負擔，還可能導致客戶端處理緩慢，甚至出現<strong>超時</strong>或<strong>記憶體不足</strong>等問題。</p><p>透過分頁，我們可以避免一次性傳輸大量資料，提高 API 的效能，同時提升使用者的體驗。</p><p>這個主題將分為<strong>上、下兩篇</strong>，介紹如何在 Django Ninja 中實作分頁功能——從<strong>內建的分頁器</strong>到<strong>自定義分頁類別</strong>，以滿足不同需求。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/15">這個 PR</a>。</p><hr><h2 id="分頁的重要性"><a href="#分頁的重要性" class="headerlink" title="分頁的重要性"></a>分頁的重要性</h2><p>分頁的<strong>核心作用</strong>是<strong>將大量資料拆分成小部分傳輸，每次只給一些</strong>，從而避免效能問題。</p><p>具體而言，分頁能夠幫助我們：</p><ol><li><strong>減少伺服器壓力</strong>：不必一次回傳全部資料，只需處理<strong>單個頁面</strong>的資料。</li><li><strong>提升網路傳輸速度</strong>：傳輸太大量的資料會增加網路延遲和資料丟失的風險，通過分頁，能<strong>有效降低傳輸需求</strong>。</li><li><strong>提升使用者體驗</strong>：客戶端可以快速獲取並顯示初步資料，無需等待所有資料傳輸完成。同時，分頁還能<strong>減少客戶端處理大量資料的壓力</strong>。</li></ol><p>因此，無論專案規模大小，實作<strong>高效的分頁策略</strong>，對 API 的擴充性與使用者體驗，都有<strong>明顯幫助</strong>。</p><p>了解了分頁的重要性後，我們來開始實作吧！</p><span id="more"></span><hr><p>這次的範例 API 是——「<strong>取得文章列表</strong>」。</p><p>因為專案的資料庫中已經有<strong>超過 60 筆文章資料</strong>，非常適合演示。</p><p>什麼？你說你沒有？歡迎參考〈<a href="/django-ninja-12/#%E4%B8%AD%E5%A0%B4%E4%BC%91%E6%81%AF%E8%88%87%E6%BA%96%E5%82%99">卷 12：請求（四）Request Body 與 Schema 介紹</a>〉結尾的「<a href="/django-ninja-12/#%E4%B8%AD%E5%A0%B4%E4%BC%91%E6%81%AF%E8%88%87%E6%BA%96%E5%82%99">中場休息與準備</a>」段落。</p><p>本篇我們將使用 Django Ninja 內建的<code>PageNumberPagination</code>分頁器，來實作簡單、有效的分頁功能。自定義部分，則留在下一篇。</p><h2 id="Django-Ninja-內建的分頁器"><a href="#Django-Ninja-內建的分頁器" class="headerlink" title="Django Ninja 內建的分頁器"></a>Django Ninja 內建的分頁器</h2><p>在 Django Ninja 中，分頁功能可以透過內建的<code>paginate</code>裝飾器加上<strong>分頁器</strong>（即<strong>分頁類別</strong>）實現。</p><p>Django Ninja 提供了兩個內建分頁器，為方便你理解，以下是它們的<strong>白話文介紹</strong>：</p><ol><li><code>LimitOffsetPagination</code>：根據「<strong>從哪一筆資料開始</strong>」和「<strong>要抓多少筆資料</strong>」來進行分頁，適合資料量很大時使用。例如：「從第 20 筆開始，抓 10 筆資料」。</li><li><code>PageNumberPagination</code>：透過<strong>頁碼</strong>進行分頁，用戶只需要<strong>指定想要的頁數</strong>，例如「抓第 2 頁的資料」。每頁的<strong>資料數量</strong>可以由開發者自行設定。</li></ol><p>我個人偏好使用<code>PageNumberPagination</code>，或自定義一個類似的版本（也就是下一篇的內容）。</p><p>但<strong>預設</strong>的分頁器是<code>LimitOffsetPagination</code>，所以在使用<code>paginate</code>裝飾器時，需要你<strong>主動聲明</strong>第一參數。等一下你就知道了。</p><p>在那之前，我們先來回顧「取得文章列表」的 API 現狀。</p><h2 id="API-現狀"><a href="#API-現狀" class="headerlink" title="API 現狀"></a>API 現狀</h2><p>如下所示，由於尚未實作分頁功能，它會<strong>一次性回傳所有文章資料</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&#x27;/posts/&#x27;</span>, response=<span class="built_in">list</span>[PostListResponse], ...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    title: <span class="literal">None</span> | <span class="built_in">str</span> = Query(<span class="params"><span class="literal">None</span>, min_length=<span class="number">2</span>, max_length=<span class="number">10</span></span>),</span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> title:</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">            title__icontains=title).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這在文章少的時候可以運作如常，但隨著資料量增加，效能將會<strong>受到影響</strong>。</p><p>接下來，我們要透過 Django Ninja 內建的分頁器來<strong>改善</strong>這個問題。</p><hr><h2 id="PageNumberPagination-實作分頁"><a href="#PageNumberPagination-實作分頁" class="headerlink" title="PageNumberPagination 實作分頁"></a>PageNumberPagination 實作分頁</h2><p>使用內建的<code>PageNumberPagination</code>，我們可以輕鬆為 API 加上分頁功能。</p><p>只要在 view 函式上使用<code>@paginate</code>裝飾器並加入參數，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja.pagination <span class="keyword">import</span> PageNumberPagination, paginate</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">PageNumberPagination, page_size=<span class="number">10</span></span>)  </span><span class="comment"># 分頁實作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我省略了大部分內容，這裡只需要關注分頁的實作。</p><p>如前所述，第一參數<code>PageNumberPagination</code>必須由你主動聲明——如果是用<code>LimitOffsetPagination</code>則不必。</p><p>實作的效果是，每頁改為顯示 10 筆文章，這數量可以透過<code>page_size</code>參數控制。</p><p>咦，那<strong>換頁</strong>怎麼辦？我們看一下<code>PageNumberPagination</code>的原始碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageNumberPagination</span>(<span class="title class_ inherited__">AsyncPaginationBase</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>Input</code>代表請求的<strong>查詢參數</strong>（下一篇會細論），換句話說，你可以在 URL 的<strong>查詢參數</strong>（query parameters）中使用參數<code>page</code>來指定「頁碼」，以達到換頁效果。</p><h3 id="測試分頁效果"><a href="#測試分頁效果" class="headerlink" title="測試分頁效果"></a>測試分頁效果</h3><p>呼叫 API，並使用<code>?page=2</code>作為查詢參數，看看效果如何：</p><p><img src="https://i.imgur.com/3H3ej9J.png"></p><p>符合預期！</p><p>回應中顯示的確實是第 2 頁內容——文章 id 從 11 開始，總共 10 筆。</p><hr><h2 id="使用內建分頁器的優點與局限"><a href="#使用內建分頁器的優點與局限" class="headerlink" title="使用內建分頁器的優點與局限"></a>使用內建分頁器的優點與局限</h2><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a><strong>優點</strong></h3><ul><li>只用簡單的<strong>分頁裝飾器 + 內建分頁器</strong>即可實現分頁，而且可以控制每頁的數量，非常方便且實用。</li><li>適合不需要複雜自定義的情況。</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a><strong>局限</strong></h3><ul><li>缺乏靈活性，例如我們<strong>無法讓使用者指定</strong>每頁顯示多少筆資料。</li><li>回應的欄位與格式是<strong>固定</strong>的——而且有點簡略。</li></ul><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過 Django Ninja 內建的分頁器，我們能夠迅速為 API 加入分頁功能，立即實現簡單的分頁需求。</p><p>然而，內建分頁器在<strong>控制靈活性</strong>上有所不足，也無法建立客製化回應。當分頁需求變得複雜時，就顯得有點捉襟見肘。</p><p>此時，<strong>自定義分頁器</strong>會是一個更好的解決方案。</p><p>下一篇，我們將探討如何在 Django Ninja 中自定義分頁類別，以滿足這些進階需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;分頁（&lt;a href=&quot;https://django-ninja.dev/guides/response/pagination/&quot;&gt;pagination&lt;/a&gt;）功能，就算在資料量較少的小型專案，也具有相當的重要性。&lt;/p&gt;
&lt;p&gt;沒分頁，API 照樣能運作——只是效能會受到影響，特別是在資料量大的情況下。&lt;/p&gt;
&lt;p&gt;當 API 一次回傳大量資料時，不僅會增加伺服器負擔，還可能導致客戶端處理緩慢，甚至出現&lt;strong&gt;超時&lt;/strong&gt;或&lt;strong&gt;記憶體不足&lt;/strong&gt;等問題。&lt;/p&gt;
&lt;p&gt;透過分頁，我們可以避免一次性傳輸大量資料，提高 API 的效能，同時提升使用者的體驗。&lt;/p&gt;
&lt;p&gt;這個主題將分為&lt;strong&gt;上、下兩篇&lt;/strong&gt;，介紹如何在 Django Ninja 中實作分頁功能——從&lt;strong&gt;內建的分頁器&lt;/strong&gt;到&lt;strong&gt;自定義分頁類別&lt;/strong&gt;，以滿足不同需求。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/15&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;分頁的重要性&quot;&gt;&lt;a href=&quot;#分頁的重要性&quot; class=&quot;headerlink&quot; title=&quot;分頁的重要性&quot;&gt;&lt;/a&gt;分頁的重要性&lt;/h2&gt;&lt;p&gt;分頁的&lt;strong&gt;核心作用&lt;/strong&gt;是&lt;strong&gt;將大量資料拆分成小部分傳輸，每次只給一些&lt;/strong&gt;，從而避免效能問題。&lt;/p&gt;
&lt;p&gt;具體而言，分頁能夠幫助我們：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;減少伺服器壓力&lt;/strong&gt;：不必一次回傳全部資料，只需處理&lt;strong&gt;單個頁面&lt;/strong&gt;的資料。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提升網路傳輸速度&lt;/strong&gt;：傳輸太大量的資料會增加網路延遲和資料丟失的風險，通過分頁，能&lt;strong&gt;有效降低傳輸需求&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提升使用者體驗&lt;/strong&gt;：客戶端可以快速獲取並顯示初步資料，無需等待所有資料傳輸完成。同時，分頁還能&lt;strong&gt;減少客戶端處理大量資料的壓力&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，無論專案規模大小，實作&lt;strong&gt;高效的分頁策略&lt;/strong&gt;，對 API 的擴充性與使用者體驗，都有&lt;strong&gt;明顯幫助&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;了解了分頁的重要性後，我們來開始實作吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 23：檔案上傳——Django UploadedFile 介紹</title>
    <link href="https://blog.kyomind.tw/django-ninja-23/"/>
    <id>https://blog.kyomind.tw/django-ninja-23/</id>
    <published>2024-10-05T08:33:59.000Z</published>
    <updated>2024-10-07T15:24:44.455Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>現代 Web 服務中，<strong>檔案上傳</strong>是一個常見的情境。</p><p>無論是使用者上傳照片、夾帶附件，檔案上傳都是不可或缺的功能。</p><p>本文介紹如何在 Django Ninja 中實現<strong>圖片上傳</strong>功能，以使用者「上傳大頭貼」（以下都稱為 avatar，因為大頭貼感覺太可愛🥹）API 為例，帶你一步步了解這個過程。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/14">這個 PR</a>。</p><hr><p>不過，在此之前，我們要先了解，本章有哪些主題。</p><h2 id="第六章「API-進階功能」簡介"><a href="#第六章「API-進階功能」簡介" class="headerlink" title="第六章「API 進階功能」簡介"></a>第六章「API 進階功能」簡介</h2><p>對 API 專案而言，<strong>進階功能</strong>能幫助我們應對<strong>複雜場景</strong>與<strong>大型專案</strong>的挑戰。</p><p>雖然這是一個入門指南，但我們仍會涵蓋一些常見的進階功能，這些功能不僅提升 API 的靈活性，還能增強了系統效能與使用者體驗。</p><p>本章將介紹 3 個重要的進階功能：</p><ul><li>卷 23：檔案上傳——Django UploadedFile 介紹</li><li>卷 24：分頁（上）Django Ninja 的內建分頁器</li><li>卷 25：分頁（下）自定義分頁類別</li><li>卷 26：資料查詢與過濾（上）FilterSchema 介紹</li><li>卷 27：資料查詢與過濾（下）FilterSchema 多欄位查詢</li></ul><p>這些技術不僅對大型專案至關重要，也讓你能在 API 開發中，有效應對多變的需求。</p><span id="more"></span><hr><p>了解了本章重點後，我們開始講述第一個功能——檔案上傳。</p><h2 id="檔案上傳的主角——UploadedFile"><a href="#檔案上傳的主角——UploadedFile" class="headerlink" title="檔案上傳的主角——UploadedFile"></a>檔案上傳的主角——UploadedFile</h2><p>在 Django Ninja 中，我們可以使用<code>UploadedFile</code>來接收上傳的檔案，它是 Django <code>UploadedFile</code>的<strong>重新封裝</strong>，兩者基本上大同小異。</p><h3 id="UploadedFile-概述"><a href="#UploadedFile-概述" class="headerlink" title="UploadedFile 概述"></a>UploadedFile 概述</h3><p><a href="https://docs.djangoproject.com/en/5.1/ref/files/uploads/">UploadedFile</a> 是 Django 處理檔案上傳的核心物件。當使用者上傳檔案時，Django 會自動將檔案封裝成<code>UploadedFile</code>實例，方便我們進行<strong>後續的檔案處理和儲存</strong>。</p><p><code>UploadedFile</code>物件有很多屬性，其中比較常用的有：</p><ul><li><code>name</code>：上傳檔案的名稱。這可以用來存取檔案的<strong>原始檔名</strong>。</li><li><code>size</code>：檔案的大小（以<strong>位元組</strong>計算）。我們可以用來進行檔案大小的驗證。</li><li><code>content_type</code>：檔案的 <a href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 類型。這對於驗證上傳檔案的<strong>格式</strong>非常有用，比如確保檔案是圖片格式。我們後面會用到！</li><li><code>read()</code>：用來<strong>讀取檔案的內容</strong>。當需要進行自訂檔案處理時，我們可以使用這個方法來取得檔案的二進位資料。</li><li><code>chunks()</code>：當檔案非常大時，使用這個方法可以<strong>分塊讀取檔案</strong>，避免過多的記憶體佔用。</li></ul><p>這些特性使得<code>UploadedFile</code>非常靈活，能夠應對各種上傳需求，從簡單的圖片上傳到大型檔案的處理。</p><p>OK，關於檔案上傳，了解<code>UploadedFile</code>這個核心元件就足夠了。</p><p>開始實作「上傳 avatar」API 的程式碼之前，我們要先進行一些「<strong>前置作業</strong>」。</p><hr><p>檔案上傳，有很多部分其實<strong>和 Django 比較有關</strong>，而非 Django Ninja 範疇，所以我會重點帶過。</p><h2 id="Django-專案相關設定"><a href="#Django-專案相關設定" class="headerlink" title="Django 專案相關設定"></a>Django 專案相關設定</h2><p>在實作檔案上傳功能之前，我們需要先告訴 Django：<strong>如何處理上傳的檔案</strong>。這涉及到<code>MEDIA_URL</code>和<code>MEDIA_ROOT</code>的設定。</p><h3 id="MEDIA-URL和MEDIA-ROOT設定"><a href="#MEDIA-URL和MEDIA-ROOT設定" class="headerlink" title="MEDIA_URL和MEDIA_ROOT設定"></a><code>MEDIA_URL</code>和<code>MEDIA_ROOT</code>設定</h3><ul><li><code>MEDIA_URL</code>：這是檔案的 URL 前綴，所有上傳的檔案會透過這個 URL 來存取。</li><li><code>MEDIA_ROOT</code>：這是 Django 伺服器內部，實際儲存上傳檔案的路徑。</li></ul><p>在專案的<code>settings.py</code>新增程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/settings.py</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span></span><br><span class="line">MEDIA_ROOT = BASE_DIR / <span class="string">&#x27;media&#x27;</span></span><br></pre></td></tr></table></figure><p>如此一來，上傳的檔案會儲存在專案根目錄的<code>media</code>資料夾中，並通過<code>/media/</code>路徑來存取。</p><h3 id="開發環境下的檔案存取"><a href="#開發環境下的檔案存取" class="headerlink" title="開發環境下的檔案存取"></a>開發環境下的檔案存取</h3><p>我們需要 Django 提供的<code>static</code>方法，來讓<strong>開發環境</strong>能夠直接存取這些檔案。</p><p>在專案的<code>urls.py</code>加上這行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, api.urls),</span><br><span class="line">    <span class="comment"># 讓開發環境可以存取上傳的檔案，僅供開發環境使用</span></span><br><span class="line">] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure><p>這段程式碼允許 Django 在開發環境下提供靜態檔案的存取。</p><h3 id="建立ImageField欄位"><a href="#建立ImageField欄位" class="headerlink" title="建立ImageField欄位"></a>建立<code>ImageField</code>欄位</h3><p><code>ImageField</code>是 Django 專門用來存放圖片的欄位，它實際上是存儲圖片的<strong>檔案路徑</strong>。類似的欄位還有<code>FileField</code>。</p><p>程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/models.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">AbstractUser</span>):</span><br><span class="line">    ...</span><br><span class="line">    avatar = models.ImageField(upload_to=<span class="string">&#x27;avatars/&#x27;</span>, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>搭配之前的<code>settings.py</code>設定，<code>avatar</code>欄位會將上傳的圖片存在<code>media/avatars/</code>資料夾中——這個路徑由<code>MEDIA_ROOT</code>與欄位<code>upload_to</code>共同決定。</p><p>移至本分支後，專案中已經有新的遷移檔，記得要<strong>資料庫遷移</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">make migrate</span><br></pre></td></tr></table></figure><p>附帶一提，<code>ImageField</code>依賴第三方套件——<a href="https://pypi.org/project/pillow/">Pillow</a>。這個套件為欄位提供了處理圖片功能，要先安裝欄位才能正常運作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add pillow</span><br></pre></td></tr></table></figure><p>使用 Poetry 的讀者，直接在合併後的分支<code>poetry install</code>即可。</p><hr><h2 id="實作：上傳-avatar"><a href="#實作：上傳-avatar" class="headerlink" title="實作：上傳 avatar"></a>實作：上傳 avatar</h2><p>前置作業結束，我們終於可以進入重頭戲。</p><p>以下是完整的「上傳 avatar」功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> File, Router, UploadedFile</span><br><span class="line"><span class="keyword">from</span> ninja.errors <span class="keyword">import</span> HttpError</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/&#123;int:user_id&#125;/avatar/&#x27;</span>,summary=<span class="string">&#x27;上傳 avatar&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_avatar</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    user_id: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    avatar_file: UploadedFile = File(<span class="params"></span>)</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上傳 avatar</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 檢查檔案類型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> avatar_file.content_type.startswith(<span class="string">&#x27;image/&#x27;</span>):</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">400</span>, <span class="string">&#x27;檔案必須是圖片格式&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    user = User.objects.get(<span class="built_in">id</span>=user_id)</span><br><span class="line">    user.avatar = avatar_file</span><br><span class="line">    user.save()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;圖片上傳成功&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>以下是對這段程式碼的重點解析。</p><h3 id="一、UploadedFile參數定義"><a href="#一、UploadedFile參數定義" class="headerlink" title="一、UploadedFile參數定義"></a>一、<code>UploadedFile</code>參數定義</h3><p>在 view 函式的簽名中，<code>UploadedFile</code>作為 type hint 使用，而<code>avatar_file</code>參數則代表上傳的檔案。</p><p>你可以<strong>任意命名</strong><code>avatar_file</code>這個參數，比如<a href="https://django-ninja.dev/guides/input/file-params/">文件範例</a>中是叫<code>file</code>。我特地取不同名字，就是要強調它的名字是<strong>完全可自訂</strong>的。</p><p>但是！無論你取什麼名稱，在發請求時，<strong>body 中的 key</strong> 也要使用<strong>相同的名稱</strong>。</p><p>此時的 body 可能長這樣：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /users/1/avatar/</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;avatar_file&quot;; filename=&quot;example.jpg&quot;</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>image/jpeg</span><br><span class="line"></span><br><span class="line">(binary image data here)</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure><p>Header 中的<code>Content-Type</code>為<code>multipart/form-data</code>，而且每個 key-value 對都是以<code>Content-Disposition: form-data;</code>開頭。這種格式允許<strong>在一個請求中同時傳送多個不同類型的資料</strong>，包括文字和二進位檔案。</p><p>其中的細節，可以參考這篇〈<a href="https://blog.errorbaker.tw/posts/cwc329/multipart-form-data/">multipart&#x2F;form-data 初探</a>〉。</p><h3 id="二、File函式"><a href="#二、File函式" class="headerlink" title="二、File函式"></a>二、<code>File</code>函式</h3><p>定義<code>=File()</code>的<strong>目的</strong>是在告訴 Django Ninja，這個參數<strong>應該從 HTTP 請求中的「上傳檔案」部分獲取</strong>。類似做法還有我們第 11 篇提到的<code>Query</code>。</p><p>如果沒有這個標記，框架可能無法正確識別並處理上傳的內容。</p><h3 id="三、檢查檔案類型"><a href="#三、檢查檔案類型" class="headerlink" title="三、檢查檔案類型"></a>三、檢查檔案類型</h3><p>我們使用了<code>UploadedFile</code>的<code>content_type</code>屬性，獲得這個 body 內容的檔案類型，確認它是圖片，然後才發行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢查檔案類型</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> avatar_file.content_type.startswith(<span class="string">&#x27;image/&#x27;</span>):</span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">400</span>, <span class="string">&#x27;檔案必須是圖片格式&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這個方法雖然粗糙，但對於簡單的圖片上傳功能來說已經足夠。</p><p>在生產環境中，你需要<strong>更嚴格的檢查</strong>，例如使用專門的圖片處理套件來驗證檔案內容。</p><h3 id="四、儲存圖片"><a href="#四、儲存圖片" class="headerlink" title="四、儲存圖片"></a>四、儲存圖片</h3><p>最後，我們將圖片賦值給<code>User</code>的<code>avatar</code>欄位，並呼叫<code>save()</code>方法。</p><p>Django 會自動處理檔案的儲存，如果<strong>名稱重複</strong>，它還會<strong>自動產生唯一的檔名</strong>，然後把檔案放到我們之前指定的位置。</p><p>透過 API 上傳了兩次一模一樣的 avatar 後，我們在專案根目錄使用<code>tree</code>指令看一下結果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ tree media</span><br><span class="line">media</span><br><span class="line">└── avatars</span><br><span class="line">    ├── my-avatar.png</span><br><span class="line">    └── my-avatar_gVwgCiG.png  <span class="comment"># 相同檔名第二次上傳，自動更名</span></span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure><p>可以看到，第二次上傳的圖片被「<strong>自動更名</strong>」了。這<strong>保證</strong>了檔名的<strong>唯一性</strong>。</p><p>在生產環境中，最好自行定義檔案的統一命名格式，以確保更好的管理和安全性。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>本文介紹了如何在 Django Ninja 中實作檔案上傳功能，從前置設定到 API 實作，詳述了<code>UploadedFile</code>的使用方式。</p><p>接下來，我們將介紹另一項進階功能——分頁（Pagination），它能幫助你在回應大量資料時，有效提升效能與使用者體驗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;現代 Web 服務中，&lt;strong&gt;檔案上傳&lt;/strong&gt;是一個常見的情境。&lt;/p&gt;
&lt;p&gt;無論是使用者上傳照片、夾帶附件，檔案上傳都是不可或缺的功能。&lt;/p&gt;
&lt;p&gt;本文介紹如何在 Django Ninja 中實現&lt;strong&gt;圖片上傳&lt;/strong&gt;功能，以使用者「上傳大頭貼」（以下都稱為 avatar，因為大頭貼感覺太可愛🥹）API 為例，帶你一步步了解這個過程。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/14&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不過，在此之前，我們要先了解，本章有哪些主題。&lt;/p&gt;
&lt;h2 id=&quot;第六章「API-進階功能」簡介&quot;&gt;&lt;a href=&quot;#第六章「API-進階功能」簡介&quot; class=&quot;headerlink&quot; title=&quot;第六章「API 進階功能」簡介&quot;&gt;&lt;/a&gt;第六章「API 進階功能」簡介&lt;/h2&gt;&lt;p&gt;對 API 專案而言，&lt;strong&gt;進階功能&lt;/strong&gt;能幫助我們應對&lt;strong&gt;複雜場景&lt;/strong&gt;與&lt;strong&gt;大型專案&lt;/strong&gt;的挑戰。&lt;/p&gt;
&lt;p&gt;雖然這是一個入門指南，但我們仍會涵蓋一些常見的進階功能，這些功能不僅提升 API 的靈活性，還能增強了系統效能與使用者體驗。&lt;/p&gt;
&lt;p&gt;本章將介紹 3 個重要的進階功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷 23：檔案上傳——Django UploadedFile 介紹&lt;/li&gt;
&lt;li&gt;卷 24：分頁（上）Django Ninja 的內建分頁器&lt;/li&gt;
&lt;li&gt;卷 25：分頁（下）自定義分頁類別&lt;/li&gt;
&lt;li&gt;卷 26：資料查詢與過濾（上）FilterSchema 介紹&lt;/li&gt;
&lt;li&gt;卷 27：資料查詢與過濾（下）FilterSchema 多欄位查詢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些技術不僅對大型專案至關重要，也讓你能在 API 開發中，有效應對多變的需求。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 22：錯誤處理（下）全域錯誤處理——使用 Exception Handlers</title>
    <link href="https://blog.kyomind.tw/django-ninja-22/"/>
    <id>https://blog.kyomind.tw/django-ninja-22/</id>
    <published>2024-10-04T03:03:51.000Z</published>
    <updated>2024-10-11T13:02:46.701Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇文章，我們學習了如何操作<code>HttpError</code>，並建議你<strong>只在</strong> view 函式中使用它。</p><p>但光是這樣，專案 API 的錯誤處理，還遠遠<strong>不夠完善</strong>，至少有 3 個常見問題待解：</p><ol><li>Schema 中的驗證方法 ，如果不要<code>raise HttpError</code>，那要怎麼做才好？</li><li>我們應該如何處理<strong>其他類型的錯誤</strong>，例如資料庫操作錯誤？</li><li>如何確保不同 API 錯誤的<strong>回應格式一致</strong>？</li></ol><p>這些問題都指向了一個<strong>更大的需求</strong>：我們需要一個<strong>全面的錯誤處理機制</strong>。</p><p>這篇文章，就要來回答這些問題。所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/13">這個 PR</a>。</p><span id="more"></span><hr><h2 id="改用-Django-ValidationError"><a href="#改用-Django-ValidationError" class="headerlink" title="改用 Django ValidationError"></a>改用 Django ValidationError</h2><p>還記得驗證方法中，最原始的版本是拋出<code>ValueError</code>嗎？</p><p><code>ValueError</code>會被 Django Ninja 自動捕捉並給出 422 回應，這是好事，但不符合我們的<strong>自定義需求</strong>。</p><p>所以後來我們改採了<code>HttpError</code>，它雖然也會被捕捉，但回應的格式與內容比較簡潔——而且除了錯誤訊息，還能<strong>自訂狀態碼</strong>。</p><p>然而，如上一篇所述，這樣做雖然簡單，卻並不合適。</p><blockquote><p><strong>那究竟要拋出什麼錯誤？</strong></p></blockquote><h3 id="避免使用-Pydantic-或-Django-Ninja-提供的錯誤"><a href="#避免使用-Pydantic-或-Django-Ninja-提供的錯誤" class="headerlink" title="避免使用 Pydantic 或 Django Ninja 提供的錯誤"></a>避免使用 Pydantic 或 Django Ninja 提供的錯誤</h3><p>上一篇還提到，無論 Pydantic 或 Django Ninja，都有自己內建的<code>ValidationError</code>。</p><p>但它們更多是<strong>供框架內部使用</strong>，而且回傳的錯誤格式過於詳細，<strong>初始化方式也很龜毛</strong>。比如 Django Ninja 的驗證錯誤，需要這樣初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValidationError(</span><br><span class="line">    [&#123;<span class="string">&#x27;loc&#x27;</span>: (<span class="string">&#x27;confirm_password&#x27;</span>,),</span><br><span class="line">      <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;密碼和確認密碼必須相同&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;value_error&#x27;</span>&#125;])</span><br></pre></td></tr></table></figure><p>這不是我們熟悉的「塞一個錯誤訊息字串」就好了。</p><p>因此，我<strong>並不推薦</strong>在驗證邏輯中<strong>直接使用</strong>這些錯誤類型。</p><h3 id="請愛用-Django-ValidationError"><a href="#請愛用-Django-ValidationError" class="headerlink" title="請愛用 Django ValidationError"></a>請愛用 Django ValidationError</h3><p>在 Schema 驗證邏輯中，我們更應該使用 Django 內建的<code>ValidationError</code>。</p><p>它的設計已經<strong>完整考慮到了開發者的需求</strong>，初始化方式<strong>可簡單</strong>（使用單一字串）<strong>可複雜</strong>（使用<code>list</code>或<code>dict</code>），適合絕大多數場景。</p><p>這裡我們用<strong>字串</strong>來初始化即可，程式碼修正如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    confirm_password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @model_validator(<span class="params">mode=<span class="string">&#x27;after&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_passwords_match</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.password != self.confirm_password:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;密碼和確認密碼必須相同&#x27;</span>)</span><br></pre></td></tr></table></figure><p>將原本的<code>HttpError</code>改為了 Django 的<code>ValidationError</code>。</p><p>並以「錯誤訊息字串」作為初始化方式，少了原本的第一參數「狀態碼」。</p><hr><h2 id="Django-Ninja-不會自動處理這些錯誤"><a href="#Django-Ninja-不會自動處理這些錯誤" class="headerlink" title="Django Ninja 不會自動處理這些錯誤"></a>Django Ninja 不會自動處理這些錯誤</h2><p>將拋出的錯誤類型改為 Django 的<code>ValidationError</code> 後，你可能會注意到一個問題：Django Ninja <strong>並不會</strong>自動捕捉這些錯誤！</p><p>也就是說，當我們拋出<code>ValidationError</code>時，Django Ninja 不會像處理<code>HttpError</code>一樣，自動格式化並返回 422 錯誤回應——而是<strong>直接 500</strong>。</p><p>這部分我們在〈<a href="/django-ninja-20/">卷 20：資料驗證（下）Pydantic 跨欄位驗證</a>〉的結尾處提過。</p><p>現在，則要介紹<strong>具體的解決之道</strong>——<code>exception_handler</code>。</p><p>我們需要<strong>自行處理</strong>這些拋出的錯誤，這正是<code>exception_handler</code>發揮作用的地方。</p><hr><h2 id="全域錯誤處理器——Exception-Handlers"><a href="#全域錯誤處理器——Exception-Handlers" class="headerlink" title="全域錯誤處理器——Exception Handlers"></a>全域錯誤處理器——Exception Handlers</h2><p>為了<strong>統一處理</strong>這些<strong>不同來源</strong>（不限於 Schema 驗證方法）的<strong>同類型</strong>錯誤，我們可以使用 Django Ninja 提供的<code>@api.exception_handler</code>裝飾器。</p><p>這個裝飾器允許我們<strong>針對「特定類型的錯誤」定義專屬的回應邏輯</strong>，並套用到<strong>整個 API 範圍</strong>內。</p><h3 id="定義exception-handler"><a href="#定義exception-handler" class="headerlink" title="定義exception_handler"></a>定義<code>exception_handler</code></h3><p>我們可以為 Django 的<code>ValidationError</code>定義一個全域錯誤處理器，確保當任何地方<strong>拋出</strong>這個錯誤時，handler 都會<strong>加以捕捉</strong>，讓 API 返回我們<strong>自定義的回應格式</strong>。</p><p>在專案<code>api.py</code>中，加入下列程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpRequest, HttpResponse</span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI(...)</span><br><span class="line"></span><br><span class="line">api.add_router(...)</span><br><span class="line">api.add_router(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增的 exception handler</span></span><br><span class="line"><span class="meta">@api.exception_handler(<span class="params">exc_class=ValidationError</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">django_validation_error_handler</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest, exception: ValidationError</span></span><br><span class="line"><span class="params"></span>) -&gt; HttpResponse:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    處理 Django ValidationError 例外</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> api.create_response(</span><br><span class="line">        request, &#123;<span class="string">&#x27;detail&#x27;</span>: exception.message&#125;, status=<span class="number">400</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>我們定義了一個 exception handler 函式，當遇到 Django 的<code>ValidationError</code>時，會回傳 HTTP 400 回應，包含<strong>自定義錯誤訊息</strong>，這樣可以保持<strong>回應的格式一致性</strong>。</p><p>程式碼很簡單，但其中的重點不少，讓我們逐一解析。</p><hr><h2 id="Exception-Handlers-重點解析"><a href="#Exception-Handlers-重點解析" class="headerlink" title="Exception Handlers 重點解析"></a>Exception Handlers 重點解析</h2><p>我們從「專案組織」這個議題講起。</p><h3 id="一、Exception-Handlers-函式放哪好？"><a href="#一、Exception-Handlers-函式放哪好？" class="headerlink" title="一、Exception Handlers 函式放哪好？"></a>一、Exception Handlers 函式放哪好？</h3><p>如前所述，這個錯誤處理器的影響範圍是<strong>全域</strong>的，所以可以把它放在專案的<strong>任何地方</strong>。</p><p>不過，還是建議將它放在<strong>最適合的位置</strong>。我認為主要有<strong>兩個選擇</strong>：</p><ol><li>如果你的錯誤處理函式不多，可以直接放在<strong>專案的</strong><code>api.py</code><strong>中</strong>——我們的例子就是這麼做的。這符合專案<code>api.py</code>的<strong>全域管理</strong>屬性。</li><li>如果錯誤處理比較多，建議獨立出一個 Python 模組來管理。</li></ol><h3 id="二、函式與參數命名"><a href="#二、函式與參數命名" class="headerlink" title="二、函式與參數命名"></a>二、函式與參數命名</h3><p>又到了我喜聞樂見的「<strong>命名</strong>」部分☺️</p><p>Exception handler 是一個（被裝飾的）函式，理論上應該要遵循「<strong>動詞開頭</strong>」的<strong>函式命名慣例</strong>。</p><p>但我卻使用了<code>django_validation_error_handler</code>這樣偏「<strong>名詞</strong>」的命名。</p><p>因為它的本質更接近於一個<strong>處理裝置</strong>或<strong>機制</strong>，而非傳統意義上的函式。</p><p>當然，這取決於你<strong>從什麼角度看</strong>！你也可以說它就是有「處理的行為」，所以還是得用動詞開頭來命名。我完全同意。</p><p>接著是<code>exception</code>參數，Django Ninja <a href="https://django-ninja.dev/guides/errors/">文件</a>都會命名為<code>exc</code>，我個人很不喜歡，因為我覺得<code>exc</code><strong>一點也不直觀</strong>，屬於<strong>完全沒必要的縮寫</strong>。</p><p>退一步來說，我寧可使用單字母<code>e</code>——類似 Pydantic 驗證方法中的<code>v</code>。</p><h3 id="三、函式邏輯解析"><a href="#三、函式邏輯解析" class="headerlink" title="三、函式邏輯解析"></a>三、函式邏輯解析</h3><p>Exception handler 的函式邏輯，可長可短、可簡單可複雜，但<strong>不外乎做這兩件事</strong>：</p><ol><li><strong>接收特定錯誤類型</strong>。</li><li><strong>返回特定 HTTP 回應</strong>。</li></ol><p>本例中，我們接收 Django 的<code>ValidationError</code>，並返回「400 Bad Request」回應，而且錯誤訊息的內容<strong>來自於拋出的錯誤</strong>——由我們自行定義。</p><p>這樣的<strong>錯誤處理靈活性</strong>已經算不錯。如果你的<code>ValidationError</code>採用<code>list</code>或<code>dict</code>初始化，那這個處理函式就需要寫得更複雜一些。</p><hr><h2 id="牛刀小試：以處理-404-回應為例"><a href="#牛刀小試：以處理-404-回應為例" class="headerlink" title="牛刀小試：以處理 404 回應為例"></a>牛刀小試：以處理 404 回應為例</h2><p>我們再來實作另一個 exception handler，處理常見的 404。</p><p>以「取得單一文章資訊」API 為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params">request: HttpRequest, post_id: <span class="built_in">int</span></span>) -&gt; Post:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得單一文章資訊</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    post = Post.objects.get(<span class="built_in">id</span>=post_id)</span><br><span class="line">    <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure><p>目前，如果前端輸入的文章 id 不存在，伺服器將直接 500：</p><blockquote><p>raise self.model.DoesNotExist(<br>post.models.Post.DoesNotExist: <strong>Post matching query does not exist.</strong></p></blockquote><p>而且還曝露內部訊息——這實在太瞎了！🤣</p><p>因為 Django ORM 中 QuerySet 的<code>get</code>方法，在<strong>查詢不到結果</strong>或<strong>查到複數結果</strong>時，都會<strong>拋出錯誤</strong>。而我們並沒有捕捉或處理這些錯誤，所以伺服器直接 500 了。</p><p>兩種錯誤並不相同——錯訊訊息也要不同。這裡先處理<strong>第一種</strong>情況就好。</p><h3 id="查無結果時，返回-404-回應"><a href="#查無結果時，返回-404-回應" class="headerlink" title="查無結果時，返回 404 回應"></a>查無結果時，返回 404 回應</h3><p>經過這兩篇的介紹，你有<strong>兩種方式</strong>來回應 404。</p><p>第一，直接使用<code>HttpError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    post = Post.objects.get(<span class="built_in">id</span>=post_id)</span><br><span class="line"><span class="keyword">except</span> Post.DoesNotExist:</span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">404</span>, <span class="string">&#x27;文章不存在&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這是我們前一篇的做法，<strong>也相當推薦</strong>。</p><p>第二，使用 exception handler：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.exception_handler(<span class="params">exc_class=ObjectDoesNotExist</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">object_does_not_exist_handler</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest, exception: ObjectDoesNotExist</span></span><br><span class="line"><span class="params"></span>) -&gt; HttpResponse:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    處理 Django ObjectDoesNotExist 例外</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> api.create_response(</span><br><span class="line">        request, &#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;查無資料&#x27;</span>&#125;, status=<span class="number">404</span>)</span><br></pre></td></tr></table></figure><p>這個做法相比於第一種，有其優點和缺點：</p><ul><li>優點：<strong>不必變更</strong> view 函式的內容（<strong>寫法更簡潔</strong>），而且可以捕捉<strong>所有 API</strong> 拋出的<code>ObjectDoesNotExist</code>錯誤。（它是<code>Post.DoesNotExist</code>的父類別）</li><li>缺點：無法自定義「<strong>詳細</strong>」的錯誤訊息——因為我們不知道<code>ObjectDoesNotExist</code>是發生在查詢什麼模型物件。<ul><li>當然，如果你願意為<strong>不同錯誤</strong>定義各自的 exception handler，就能夠實現！——比如只捕捉<code>Post.DoesNotExist</code>，錯誤訊息就可以寫「文章不存在」。</li><li>但就要定義很多個 exception handlers，有點麻煩啦！</li></ul></li></ul><p>選擇第一種還是第二種做法，需要你<strong>視情況而定</strong>。</p><hr><h2 id="第五章總結"><a href="#第五章總結" class="headerlink" title="第五章總結"></a>第五章總結</h2><p>第五章說真的，資訊量頗大，這 4 篇文章我寫了很久，而且還「<strong>重構</strong>」過！——本來只有 2 篇而已。</p><p>我們先討論了如何自定義單一欄位驗證，以及跨欄位驗證。然後再循序漸進地學習如何處理 API 拋出的錯誤——<strong>愈來愈優雅、愈來愈全面</strong>。</p><p>如果你是從第 1 篇看到這裡，真的，完全可以為自己感到驕傲。</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>接下來，比較輕鬆了嗎？——並沒有。</p><p>我們要介紹 API 的<strong>常見進階功能</strong>。</p><p>這些功能相比於處理請求、回應，可以說「<strong>不一定</strong>」要有，但對許多 API 專案來說仍相當重要。</p><p>下一章，我們將逐一探討這些進階功能，並學習如何在 Django Ninja 中實現它們。讓我們繼續深入 API 開發的世界吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章，我們學習了如何操作&lt;code&gt;HttpError&lt;/code&gt;，並建議你&lt;strong&gt;只在&lt;/strong&gt; view 函式中使用它。&lt;/p&gt;
&lt;p&gt;但光是這樣，專案 API 的錯誤處理，還遠遠&lt;strong&gt;不夠完善&lt;/strong&gt;，至少有 3 個常見問題待解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Schema 中的驗證方法 ，如果不要&lt;code&gt;raise HttpError&lt;/code&gt;，那要怎麼做才好？&lt;/li&gt;
&lt;li&gt;我們應該如何處理&lt;strong&gt;其他類型的錯誤&lt;/strong&gt;，例如資料庫操作錯誤？&lt;/li&gt;
&lt;li&gt;如何確保不同 API 錯誤的&lt;strong&gt;回應格式一致&lt;/strong&gt;？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這些問題都指向了一個&lt;strong&gt;更大的需求&lt;/strong&gt;：我們需要一個&lt;strong&gt;全面的錯誤處理機制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這篇文章，就要來回答這些問題。所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/13&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 21：錯誤處理（上）HttpError 與自定義 HTTP 回應</title>
    <link href="https://blog.kyomind.tw/django-ninja-21/"/>
    <id>https://blog.kyomind.tw/django-ninja-21/</id>
    <published>2024-10-03T02:46:01.000Z</published>
    <updated>2024-10-07T05:52:25.603Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>在軟體開發中，<strong>錯誤處理</strong>是一個不容忽視——但<strong>常常被忽視</strong>——的環節。</p><p>不誇張地說，錯誤處理是一個「<strong>做得好沒人誇，做不好系統就慘兮兮</strong>」的議題。</p><p>沒關係，我們還是<strong>盡可能把自己做好</strong>。</p><p>Django Ninja 使用 Pydantic 進行資料驗證，失敗時，預設回應「422 Unprocessable Entity」。</p><p>然而，我們有時候需要回應「400 Bad Request」或別的狀態碼，以符合<strong>現實業務需求</strong>或<strong>團隊開發習慣</strong>。</p><p>總之，無論出於何種原因，我們想<strong>自訂錯誤訊息、格式，以及回應的狀態碼</strong>，而<strong>不使用</strong> Django Ninja 預設的 422 回應——不得不說，這個制式回應的資訊有點多、結構有點複雜，因為它要兼容各種情況。</p><p>本文將介紹如何<strong>自定義錯誤處理與回應</strong>——使用 Django Ninja 內建的<code>HttpError</code>。</p><p>所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/12">這個 PR</a>。</p><hr><h2 id="Django-Ninja-的自動錯誤處理"><a href="#Django-Ninja-的自動錯誤處理" class="headerlink" title="Django Ninja 的自動錯誤處理"></a>Django Ninja 的自動錯誤處理</h2><p>上一篇我們提到，如果你在 Schema 的驗證方法中，拋出<code>ValueError</code>錯誤，Django Ninja 將會<strong>自動捕捉並回應</strong>。</p><p>事實上，不止<code>ValueError</code>，Django Ninja 還會替你處理以下這幾種錯誤：</p><ul><li><code>pydantic.ValidationError</code>，來自 Pydantic 的驗證錯誤，這是<strong>為何</strong>當 Schema 欄位有問題時，我們會直接收到 422 回應。</li><li>此外，Django Ninja 還內建了一個 <code>ninja.errors.ValidationError</code>，這些錯誤同樣會返回 422。</li><li><code>ninja.errors.HttpError</code>：這是本文的重點，下面會介紹。</li></ul><p>這些都是 Django Ninja 會自動捕捉的錯誤，但不是每一種都給出制式的 422 回應——第三種就不是。</p><span id="more"></span><hr><h2 id="新需求：驗證失敗時，改用-400-回應"><a href="#新需求：驗證失敗時，改用-400-回應" class="headerlink" title="新需求：驗證失敗時，改用 400 回應"></a>新需求：驗證失敗時，改用 400 回應</h2><p>如果我們希望 Schema 驗證失敗時，要返回「400 Bad Request」而不是 422，怎麼做最簡單？</p><p>答：使用 Django Ninja 的<code>HttpError</code>。</p><p>以下是 Schema 的程式碼改動，只改了兩行！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> ninja.errors <span class="keyword">import</span> HttpError  <span class="comment"># 第一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreateUserRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @model_validator(<span class="params">mode=<span class="string">&#x27;after&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_passwords_match</span>(<span class="params">self</span>) -&gt; Self:</span><br><span class="line">        <span class="keyword">if</span> self.password != self.confirm_password:</span><br><span class="line">            <span class="keyword">raise</span> HttpError(<span class="number">400</span>, <span class="string">&#x27;密碼和確認密碼必須相同&#x27;</span>)  <span class="comment"># 第二行</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>沒錯，就這麼簡單！</p><p>只是把驗證方法拋出的錯誤，從<code>ValueError</code>替換為<code>HttpError</code>即可。</p><p>值得留意的是，<code>HttpError</code>實例的<strong>初始化</strong>，需要<strong>兩個參數</strong>，第一個是 HTTP 狀態碼，第二個才是錯誤訊息。</p><h3 id="回應內容"><a href="#回應內容" class="headerlink" title="回應內容"></a>回應內容</h3><p>看看同樣的驗證失敗，回應有何不同：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 400 Bad Request</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;密碼和確認密碼必須相同&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>變成我們熟悉的格式——只有錯誤訊息。</p><hr><h2 id="在驗證方法中使用-HttpError-的不妥之處"><a href="#在驗證方法中使用-HttpError-的不妥之處" class="headerlink" title="在驗證方法中使用 HttpError 的不妥之處"></a>在驗證方法中使用 HttpError 的不妥之處</h2><p>直接在 Schema 的驗證方法中拋出<code>HttpError</code>，是一種便捷的方式，因為它能夠<strong>簡化回應處理</strong>。</p><p>我們<strong>無需</strong>額外捕捉錯誤或手動指定回應格式。驗證失敗時，API 會<strong>直接回應</strong>我們定義的狀態碼和錯誤訊息，既簡單又方便。</p><p>然而，這麼做其實<strong>並不妥當</strong>，主要有幾個問題，比如降低可測試性、限制回應的靈活性等等。但其中<strong>最關鍵</strong>的，還是是我們上一篇提到的——「<strong>關注點分離</strong>」。</p><h3 id="違反「關注點分離」"><a href="#違反「關注點分離」" class="headerlink" title="違反「關注點分離」"></a>違反「關注點分離」</h3><p><strong>這個做法違反了「關注點分離」原則。</strong></p><p>驗證邏輯的職責是檢查資料的正確性，而<strong>回應</strong>應該由 view 函式負責。</p><p>將回應邏輯混入驗證過程中，會讓驗證和回應這兩個<strong>本應獨立</strong>的部分<strong>耦合在一起</strong>，導致<strong>職責混亂</strong>，不利於程式碼維護。</p><p>因此，雖然在驗證方法內使用<code>HttpError</code>，看似能夠方便地實現需求，但從<strong>架構設計</strong>的角度考慮，將<strong>回應處理</strong>放在 view 函式中，才是一個更合理的選擇。</p><p>別擔心，下一篇我們會換個做法，但本文的主角還是<code>HttpError</code>。</p><hr><h2 id="HttpError-的典型情境：在-view-函式中使用"><a href="#HttpError-的典型情境：在-view-函式中使用" class="headerlink" title="HttpError 的典型情境：在 view 函式中使用"></a>HttpError 的典型情境：在 view 函式中使用</h2><p>相比於在 Schema 中使用<code>HttpError</code>，把它放在 view 函式裡執行，方為正道。</p><p>以下就是一個經典場景。</p><p>儘管資料驗證邏輯應盡可能放在 Schema 中，<strong>但也不是所有的驗證都適合丟給 Schema 做</strong>。</p><p>比如，使用者的 email 欄位具有「<strong>唯一性</strong>」——不能重複。所以我們希望先確認使用者輸入的 email <strong>是否和 db 中的資料重複</strong>，是的話，直接回應<code>409 Conflict</code>。</p><p>這無疑也是一種<strong>驗證</strong>，但它涉及了「<strong>資料庫查詢</strong>」。</p><p>這種涉及資料庫查詢的驗證，更適合在 view 函式中進行，而不是在 Schema 裡。因為資料庫查詢屬於<strong>比較重的動態操作</strong>，與 Schema 的<strong>靜態資料檢查</strong>有著<strong>本質的不同</strong>。</p><p>因此，我們更常在 view 函式中使用<code>HttpError</code>處理這類需求。</p><p>新增程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_user</span>(<span class="params">..., payload: CreateUserRequest</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> User.objects.<span class="built_in">filter</span>(email=payload.email).exists():</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">409</span>, <span class="string">&#x27;使用者 email 已存在&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上面是「預先查詢」，和下面這個寫法，在結果上是類似的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    user.save()</span><br><span class="line"><span class="keyword">except</span> IntegrityError:  <span class="comment"># Django ORM 唯一性錯誤</span></span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">409</span>, <span class="string">&#x27;使用者 email 已存在&#x27;</span>)</span><br></pre></td></tr></table></figure><p>只不過一個是<strong>事前驗證並拋出錯誤</strong>，一個是<strong>事後捕捉錯誤</strong>（然後再拋出）。</p><p>驗證失敗的回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 409 Conflict</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用者 email 已存在&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>確實還不錯！</p><hr><h2 id="為什麼不直接-return-409-回應就好？"><a href="#為什麼不直接-return-409-回應就好？" class="headerlink" title="為什麼不直接 return 409 回應就好？"></a>為什麼不直接 return 409 回應就好？</h2><p>聰明的你可能會想到：</p><blockquote><p>咦，那我<strong>何不直接 return</strong> 一個帶有錯誤訊息的 Python 字典就好了？為什麼非得在 view 函式中<code>raise HttpError</code>？</p></blockquote><p>這個想法，大概的程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/&#x27;</span>, response=&#123;<span class="number">201</span>: <span class="built_in">dict</span>, <span class="number">409</span>: <span class="built_in">dict</span>&#125;, ...</span>)</span></span><br><span class="line"><span class="keyword">def</span> (...) -&gt; <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> User.objects.<span class="built_in">filter</span>(email=payload.email).exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="number">409</span>, &#123;<span class="string">&quot;detail&quot;</span>: <span class="string">&quot;使用者 email 已存在&quot;</span>&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>這樣不是<strong>更加直觀</strong>嗎？</p><p>這是一個<strong>好問題</strong>。</p><h3 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h3><p>我們還是先來看一下，這段程式碼中有哪些重點：</p><ul><li><code>response=&#123;201: dict, 409: dict&#125;</code>：第 13 篇提過的「<strong>多重狀態碼回應</strong>」，這不就派上用場了！</li><li>用<code>return</code>取代<code>raise</code>。</li><li>如果想驗證錯誤訊息格式，可以定義一個 Schema。這個例子只是簡化版。</li></ul><p>看起來確實不錯，也很符合直覺，其實我以前寫 Django REST framework，<strong>都是</strong>這樣寫的。</p><p><strong>可是</strong>，這個寫法在 Django Ninja 中，使用「分頁裝飾器」時，就會<strong>踢到鐵板</strong>了。</p><p>目前時機未到，在後續的〈卷 25：分頁（下）自定義分頁類別〉中，我們再把這件事說清楚。</p><p>總之，現階段我們只要知道，類似情況還是<code>raise HttpError</code>會比較妥當。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在這篇文章中，我們學習了如何使用 Django Ninja 內建的<code>HttpError</code>來自定義錯誤回應，以避免預設的 422。</p><p>並解釋了為何<code>HttpError</code>不適合用在 Schema 中（雖然我們暫時這麼做了😅），而是應該放到 view 函式裡。</p><p>下一篇，我們將改善 Schema 拋出的錯誤、探討全域錯誤處理機制，並且使用 Django Ninja 所提供的<code>exception_handler</code>裝飾器，進一步提升 API 的錯誤處理能力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;在軟體開發中，&lt;strong&gt;錯誤處理&lt;/strong&gt;是一個不容忽視——但&lt;strong&gt;常常被忽視&lt;/strong&gt;——的環節。&lt;/p&gt;
&lt;p&gt;不誇張地說，錯誤處理是一個「&lt;strong&gt;做得好沒人誇，做不好系統就慘兮兮&lt;/strong&gt;」的議題。&lt;/p&gt;
&lt;p&gt;沒關係，我們還是&lt;strong&gt;盡可能把自己做好&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Django Ninja 使用 Pydantic 進行資料驗證，失敗時，預設回應「422 Unprocessable Entity」。&lt;/p&gt;
&lt;p&gt;然而，我們有時候需要回應「400 Bad Request」或別的狀態碼，以符合&lt;strong&gt;現實業務需求&lt;/strong&gt;或&lt;strong&gt;團隊開發習慣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;總之，無論出於何種原因，我們想&lt;strong&gt;自訂錯誤訊息、格式，以及回應的狀態碼&lt;/strong&gt;，而&lt;strong&gt;不使用&lt;/strong&gt; Django Ninja 預設的 422 回應——不得不說，這個制式回應的資訊有點多、結構有點複雜，因為它要兼容各種情況。&lt;/p&gt;
&lt;p&gt;本文將介紹如何&lt;strong&gt;自定義錯誤處理與回應&lt;/strong&gt;——使用 Django Ninja 內建的&lt;code&gt;HttpError&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/12&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Django-Ninja-的自動錯誤處理&quot;&gt;&lt;a href=&quot;#Django-Ninja-的自動錯誤處理&quot; class=&quot;headerlink&quot; title=&quot;Django Ninja 的自動錯誤處理&quot;&gt;&lt;/a&gt;Django Ninja 的自動錯誤處理&lt;/h2&gt;&lt;p&gt;上一篇我們提到，如果你在 Schema 的驗證方法中，拋出&lt;code&gt;ValueError&lt;/code&gt;錯誤，Django Ninja 將會&lt;strong&gt;自動捕捉並回應&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;事實上，不止&lt;code&gt;ValueError&lt;/code&gt;，Django Ninja 還會替你處理以下這幾種錯誤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pydantic.ValidationError&lt;/code&gt;，來自 Pydantic 的驗證錯誤，這是&lt;strong&gt;為何&lt;/strong&gt;當 Schema 欄位有問題時，我們會直接收到 422 回應。&lt;/li&gt;
&lt;li&gt;此外，Django Ninja 還內建了一個 &lt;code&gt;ninja.errors.ValidationError&lt;/code&gt;，這些錯誤同樣會返回 422。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ninja.errors.HttpError&lt;/code&gt;：這是本文的重點，下面會介紹。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些都是 Django Ninja 會自動捕捉的錯誤，但不是每一種都給出制式的 422 回應——第三種就不是。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
</feed>
