<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-09-21T14:43:15.920Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django Ninja 教學 09：Django Ninja 處理請求概論（兼論 FBVs）</title>
    <link href="https://blog.kyomind.tw/django-ninja-09/"/>
    <id>https://blog.kyomind.tw/django-ninja-09/</id>
    <published>2024-09-21T02:42:13.000Z</published>
    <updated>2024-09-21T14:43:15.920Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>歡迎來到第三章第二節！</p><p>作為 API 的核心邏輯實現，<strong>view 函式</strong>無疑是 Django Ninja API 的靈魂所在。</p><p>Django Ninja 和 FastAPI、Flask 一樣，都是以 Function-Based Views（<strong>以下簡稱 FBVs</strong>）為主。所以它的學習重點，<strong>幾乎都繞圍在 view 函式的 input 和 output。</strong></p><p>換句話說，整個 Django Ninja 框架的能力，<strong>構成了 view 函式的這些關鍵部分</strong>，包括但不限於：</p><ol><li>處理 HTTP 請求的參數與 body。</li><li>處理 HTTP 回應內容的序列化與格式化。</li><li>資料驗證與錯誤處理。</li></ol><p>它們共同構成了 Django Ninja 的主要功能。</p><p>本節和下一節，將集中討論上述 3 點中的前兩點——請求與回應。至於第三點，將留到第五章再行介紹。</p><span id="more"></span><hr><h2 id="本節導覽"><a href="#本節導覽" class="headerlink" title="本節導覽"></a>本節導覽</h2><p>繼上一節的「路由」後，本節將探討 Django Ninja <strong>如何處理 HTTP 請求</strong>——如何解析 path、URL 查詢參數和 body。</p><p>本節一共有 4 篇：</p><ul><li>卷 9：請求（一）Django Ninja 處理請求概論（兼論 FBVs）</li><li>卷 10：請求（二）Path Parameters</li><li>卷 11：請求（三）Query Parameters</li><li>卷 12：請求（四）Request Body 與 Schema 介紹</li></ul><p>此外，因為 view 函式處理請求功能，已涉及 Django Ninja 如何使用 type hints 來驗證請求資料。我們的範例程式碼會<strong>開始加上 Python 型別提示</strong>。</p><p>Type hints 的語法以 Python 3.12 為準。</p><h2 id="官方文件"><a href="#官方文件" class="headerlink" title="官方文件"></a>官方文件</h2><p>本系列的寫作不時會參考「<a href="https://django-ninja.dev/">Django Ninja 官方文件</a>」，尤其是架構的呈現。</p><p>但文件畢竟是給<strong>全體</strong>開發者看的，<strong>並沒有充分考慮到學習的順序。</strong></p><p>而本列系主要面向<strong>入門者</strong>，所以我們會更加注重實際操作與入門者的需求，並適時補充一些背景知識，<strong>確保學習曲線能相對平緩</strong>。</p><p>此外，就框架本身，我們也會提供更多實例和解釋，讓新概念更好理解和掌握。</p><p>但無論如何，官方文件仍是你在使用 Django Ninja 時，需要時時參考的內容——雖然它寫得比 Django 或 Django REST framework 的文件，相對「簡單」很多！</p><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文作為第二節的概論，目標是讓你對 Django Ninja 的 view 函式與它如何處理 HTTP 請求<strong>有基本的認識</strong>。</p><p>我們將透過以下三個重點來讓你逐步熟悉：</p><ol><li>FBVs 的優點。</li><li>Django Ninja 對 HTTP 請求的處理流程。</li><li>Django Ninja 與 Type Hints 的緊密結合。</li></ol><p>話不說多，我們直接開始。</p><hr><p>Class-based views (CBVs) 和 FBVs 都是實現 <a href="https://zoejoyuliao.medium.com/%E6%AF%94%E8%BC%83-mvc-%E8%88%87-django-%E7%9A%84-mtv-6c93ea9484fc">Django MTV 架構</a> 中的 <strong>Views</strong> 手段，各有其適用場景。</p><p>CBVs 有<strong>重用程式碼</strong>優勢，適合大型專案。而 FBVs 則以<strong>簡單、直接</strong>為賣點，方便快速開發中小型專案。</p><p>兩者的比較，可參考這篇〈<a href="https://ithelp.ithome.com.tw/articles/10205779">Day27 : CBV vs. FBV</a>〉。</p><p>因為 Django Ninja 採 FBVs，本文只探討 FBVs 的優點。</p><h2 id="一、FBV-的優點"><a href="#一、FBV-的優點" class="headerlink" title="一、FBV 的優點"></a>一、FBV 的優點</h2><p>FBVs 是 Django Ninja 採用的 view 形式。與 CBVs 相比，FBVs 更加簡潔、靈活，能夠讓開發者輕鬆編寫出 API 邏輯而<strong>不需要了解太多背景知識</strong>，比如「如何正確覆寫某個 CBV 屬性」。</p><h3 id="簡潔與靈活"><a href="#簡潔與靈活" class="headerlink" title="簡潔與靈活"></a>簡潔與靈活</h3><p>FBVs <strong>不需要繼承或覆寫</strong>類別方法，所有的邏輯都集中在一個函式中。</p><p>這使得寫作和維護程式碼更加直觀。</p><p>由於 FBVs 本質是個函式，它可以更靈活地應用各種邏輯和條件，開發者能<strong>在單一函式中完全控制整個請求的處理流程</strong>，而<strong>不需要考慮類別的結構或繼承關係</strong>。</p><h3 id="容易-Debug"><a href="#容易-Debug" class="headerlink" title="容易 Debug"></a>容易 Debug</h3><p>FBVs 的程式碼相對直觀，對於初學者來說，閱讀、理解起來更加容易。發生錯誤時，你可以<strong>快速定位問題</strong>，這是 CBVs 不易達到的便利性。</p><h3 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h3><p>Django 是個功能全面的框架，但也常被批評為「笨重」。<strong>FBVs 在一定程度上緩解了這種笨重感</strong>。</p><p>試想，一個剛接觸 Django 的新手，在理解完各種框架的環境設定後，還要深入 CBVs 的世界，是否太過沉重？</p><p>總之，如果你問我，我絕對更偏好 FBVs——而且「<strong>輕量化</strong>」是現代開發的趨勢。</p><hr><h2 id="二、Django-Ninja-對-HTTP-請求的處理流程"><a href="#二、Django-Ninja-對-HTTP-請求的處理流程" class="headerlink" title="二、Django Ninja 對 HTTP 請求的處理流程"></a>二、Django Ninja 對 HTTP 請求的處理流程</h2><p>Django Ninja 對「請求」的處理可以分為幾個關鍵步驟：</p><ol><li><strong>路由配對</strong>：當請求進來時，框架首先會將來源 URL 與定義的路徑規則（端點）進行配對。若配對成功，則將 HTTP 請求與相關參數傳遞給 view 函式。</li><li><strong>參數解析</strong>：從 URL 中提取<strong>路徑參數</strong>（<strong>path parameters</strong>）和<strong>查詢參數</strong>（<strong>query parameters</strong>），將它們轉換為 view 函式的「<strong>引數</strong>」（arguments）。根據函式的 type hints 自動進行型別轉換和驗證。</li><li><strong>Request body 處理</strong>：對於 POST 或 PUT 等帶有 body 的請求，Django Ninja 讓開發者使用 Schema（Pydantic BaseModel）定義 body 資料模型，並自動將傳入的資料對應到這些模型。</li></ol><p>上述第 1 點已在本章第一節詳細解說。</p><p>第 2 和第 3 點則是本節共 4 篇文章的主要內容。</p><hr><h2 id="三、Django-Ninja-與-Type-Hints-的緊密結合"><a href="#三、Django-Ninja-與-Type-Hints-的緊密結合" class="headerlink" title="三、Django Ninja 與 Type Hints 的緊密結合"></a>三、Django Ninja 與 Type Hints 的緊密結合</h2><p>Django Ninja 非常依賴 Python 的 type hints 來處理 HTTP 請求中的資料。</p><p>並透過 Pydantic 實現了<strong>自動資料驗證</strong>和<strong>類別轉換</strong>，減少了開發者手動檢查和轉換資料的負擔。</p><p>例如以下程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/posts/&#123;post_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params">request, post_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;post_id&quot;</span>: post_id&#125;</span><br></pre></td></tr></table></figure><p>當<code>post_id</code>參數被標記為<code>int</code>時，Django Ninja 會進行型別檢查。如果傳入的參數無法轉換為<code>int</code>，框架會直接返回狀態碼為 422 的 HTTP 回應。</p><p>換言之，如果你將<code>post_id</code>標記為<code>str</code>，則 Django Ninja 會自動將<code>post_id</code>轉換為字串。</p><p>還記得剛開始接觸 Django Ninja時，我非常驚嘆竟然可以充分運用 Python type hints 到這般程度，讓它<strong>不僅僅是為了型別安全而服務，而是融入到整個 API 開發流程中</strong>。</p><h2 id="View-函式中的-request-參數"><a href="#View-函式中的-request-參數" class="headerlink" title="View 函式中的 request 參數"></a>View 函式中的 request 參數</h2><p>上面的例子中，有個值得注意的細節，就是 view 函式的<strong>第一參數</strong>——<code>request</code>。</p><p>在 Django 中，view 函式的第一個參數必定為 request。這個參數名稱<strong>可以自行定義</strong>，但通常會命名為<code>request</code>。</p><p>收到 HTTP 請求時，Django 會將整個請求打包成一個<code>HttpRequest</code>物件，並<strong>將它作為第一個參數傳給 view 函式</strong>，所以它<strong>必不可少</strong>。</p><blockquote><p>相關文章：<a href="/django-request/">Django HttpRequest 常用屬性介紹</a></p></blockquote><p><code>request</code>參數在 Django 和 Django REST framework 中非常重要，因為它常用來取得<strong>請求的查詢參數、body</strong> 等內容。</p><p>在 Django Ninja 中，這些資料會<strong>直接透過函式參數來取得</strong>，因此<code>request</code>雖然仍不可少，但<strong>使用頻率較低</strong>。</p><hr><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>接下來，我們將深入探討 Django Ninja 處理請求的<strong>具體細節</strong>。</p><p>下一篇將聚焦於<strong>路徑參數</strong>（<strong>path parameters</strong>），並探討如何與 Django 原生的 <strong>path converters</strong> 搭配使用。敬請期待！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;歡迎來到第三章第二節！&lt;/p&gt;
&lt;p&gt;作為 API 的核心邏輯實現，&lt;strong&gt;view 函式&lt;/strong&gt;無疑是 Django Ninja API 的靈魂所在。&lt;/p&gt;
&lt;p&gt;Django Ninja 和 FastAPI、Flask 一樣，都是以 Function-Based Views（&lt;strong&gt;以下簡稱 FBVs&lt;/strong&gt;）為主。所以它的學習重點，&lt;strong&gt;幾乎都繞圍在 view 函式的 input 和 output。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;換句話說，整個 Django Ninja 框架的能力，&lt;strong&gt;構成了 view 函式的這些關鍵部分&lt;/strong&gt;，包括但不限於：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;處理 HTTP 請求的參數與 body。&lt;/li&gt;
&lt;li&gt;處理 HTTP 回應內容的序列化與格式化。&lt;/li&gt;
&lt;li&gt;資料驗證與錯誤處理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它們共同構成了 Django Ninja 的主要功能。&lt;/p&gt;
&lt;p&gt;本節和下一節，將集中討論上述 3 點中的前兩點——請求與回應。至於第三點，將留到第五章再行介紹。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 08：路由（下）Django Ninja 路由</title>
    <link href="https://blog.kyomind.tw/django-ninja-08/"/>
    <id>https://blog.kyomind.tw/django-ninja-08/</id>
    <published>2024-09-20T00:54:07.000Z</published>
    <updated>2024-09-20T00:56:05.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇文章中，我們介紹了 Django 傳統的路由設定方式。</p><p>如前所述，雖然有一個「路由清單」確實不錯。但隨著專案規模的擴大，<strong>不斷來回切換</strong><code>urls.py</code>和<code>views.py</code>將大幅增加開發者的認知負擔——不僅增加開發時間，還容易導致錯誤。</p><p>Django Ninja 採用了一種<strong>更現代化</strong>的路由設計，結合了 Flask 和 FastAPI 的設計理念。不僅簡化了路由的定義，還提升了程式碼的可讀性，讓路由與 view 函式<strong>緊密結合</strong>。</p><h2 id="範例專案動態"><a href="#範例專案動態" class="headerlink" title="範例專案動態"></a>範例專案動態</h2><p>本文關於路由設定的程式碼改動，可以參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/1">這個 PR</a>（<strong>Pull Request</strong>）。</p><p>範例專案合併了本文的 PR 後，已經正式成為一個「<strong>API 專案</strong>」，不過它<strong>目前（指這個 <a href="https://github.com/kyomind/Django-Ninja-Tutorial/commit/396e06338d615d3ec74e7c5bf871b85c9a06f0ec">commit</a> 狀態）尚無法正常運作</strong>，因為我們還沒有完善 view 函式的基本功能。</p><p>你可以一步步地跟著每一篇的 PR，來學習當次的新內容。這也是我為文章建立 PR 的用意所在。</p><span id="more"></span><hr><p>現在，我們開始介紹 Django Ninja 的路由設定。</p><h2 id="Django-Ninja-路由概述"><a href="#Django-Ninja-路由概述" class="headerlink" title="Django Ninja 路由概述"></a>Django Ninja 路由概述</h2><p>Django Ninja 使用 Python 裝飾器（<a href="https://myapollo.com.tw/blog/python-decorator-tutorial/">decorator</a>）來定義路由和 HTTP 方法。這種方式將路由與 view 函式緊密結合，大大提高了程式碼的可讀性。</p><p>熟悉 Python 的都知道，其實這種「<strong>使用裝飾器定義路由</strong>」的方式，最早來自 <a href="https://flask.palletsprojects.com/en/3.0.x/">Flask</a>。作為一個輕量級框架，Flask 率先引入了這種<strong>簡潔優雅的設計</strong>，堪稱<strong>典範級的創舉</strong>。</p><p>這個設計後續被其他框架採用，比如 FastAPI 和本文的 Django Ninja，都繼承了這種靈活的路由定義模式。</p><p>在 Flask 中，開發者可以這樣定義路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, Flask!&#x27;</span></span><br></pre></td></tr></table></figure><p>Django Ninja 也採用了<strong>類似的概念</strong>，只是在語法上更融入 Django 生態，並結合了型別提示（type hint）和 Pydantic 的資料驗證功能，讓 API 開發變得更加現代化。</p><p>以下是 Django Ninja 的一個簡單範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, Django Ninja!&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>Flask 與 Django Ninja 這兩種寫法，與其說非常相似，不如說一模一樣😎</p><hr><h2 id="更有組織的做法：使用-Router-物件"><a href="#更有組織的做法：使用-Router-物件" class="headerlink" title="更有組織的做法：使用 Router 物件"></a>更有組織的做法：使用 Router 物件</h2><p>雖然直接使用上述範例中的<code>NinjaAPI</code>來定義路由簡單而直觀。但實際工作中，我們更推薦使用<code>Router</code>物件（<a href="https://django-ninja.dev/guides/routers/">官方文件</a>）來管理不同 Django app 的路由。</p><p>這和 Django 傳統做法中「區分一級與二級路由」的基本精神相符。不僅讓專案的架構保持清晰，還能讓每個 app 的邏輯獨立。</p><p>在 Django Ninja 中，<code>Router</code>物件提供了一種<strong>模組化的路由設定方式</strong>，讓每個 Django app 可以管理自己的路由，並在專案層級的<code>api.py</code><strong>統一整合起來</strong>——也就是取代傳統的<code>urls.py</code>功能。</p><p>以下程式碼範例，我們都會以<code>Router</code>物件來實作。</p><hr><h2 id="專案架構變化"><a href="#專案架構變化" class="headerlink" title="專案架構變化"></a>專案架構變化</h2><p>先來看看採用 Django Ninja 以後，傳統 Django 專案的結構會有<strong>怎麼樣的變化</strong>。</p><h3 id="Django-傳統路由結構"><a href="#Django-傳統路由結構" class="headerlink" title="Django 傳統路由結構"></a>Django 傳統路由結構</h3><p>以範例專案為例，這是傳統 Django 的典型結構：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── NinjaForum</span><br><span class="line">│   ├── urls.py  <span class="comment"># 專案一級路由</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── post</span><br><span class="line">│   ├── urls.py  <span class="comment"># app 二級路由</span></span><br><span class="line">│   ├── view.py  <span class="comment"># 放置 app 所屬 view 函式的地方</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── user</span><br><span class="line">│   ├── urls.py  <span class="comment"># app 二級路由</span></span><br><span class="line">│   ├── view.py  <span class="comment"># 放置 app 所屬 view 函式的地方</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── ...</span><br></pre></td></tr></table></figure><p>Django app 層級的<code>urls.py</code>負責定義所有 app 內的路由，然後再由專案的<code>urls.py</code>進行統合。井然有序，權責分明。</p><h3 id="Django-Ninja-路由結構"><a href="#Django-Ninja-路由結構" class="headerlink" title="Django Ninja 路由結構"></a>Django Ninja 路由結構</h3><p>在採用 Django Ninja 後，專案結構會有一些變化。以下是一個典型的 Django Ninja 專案結構：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── NinjaForum</span><br><span class="line">│   ├── urls.py  <span class="comment"># 專案「零級」路由</span></span><br><span class="line">│   ├── api.py   <span class="comment"># 專案一級路由</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── post</span><br><span class="line">│   ├── api.py   <span class="comment"># post app 的路由 + view 函式</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── user</span><br><span class="line">│   ├── api.py   <span class="comment"># user app 的路由 + view 函式</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── ...</span><br></pre></td></tr></table></figure><p>在這個結構中，每個 Django app 都有一個<code>api.py</code>，用於<strong>定義該 app 的所有 API 路由和 view 函式</strong>，取代了傳統 Django 中的<code>urls.py</code>和<code>views.py</code>的功能。</p><p>專案級別的<code>api.py</code>則負責整合所有 Django app 的 API。</p><p>此外，專案的<code>urls.py</code><strong>仍然是必要的</strong>，它負責將 Django Ninja 的 API 路由<strong>再整合</strong>到 Django 的 URL 設定中。同時，還可以化身為「零級」路由，為所有 API 加上<strong>全專案統一的路由前綴</strong>，比如<code>/api/</code>。</p><hr><h2 id="Django-Ninja-路由實作"><a href="#Django-Ninja-路由實作" class="headerlink" title="Django Ninja 路由實作"></a>Django Ninja 路由實作</h2><p>了解了 Django Ninja 的路由結構，我們直接在範例專案的兩個 Django app 分別實作「取得所有使用者」和「取得文章列表」兩個 API。</p><p>我們會在接下來的數篇文章中，循序漸進地完善這些 API。<strong>目前只是雛形</strong>，先把焦點放在路由設定上。</p><h3 id="一、建立二級路由"><a href="#一、建立二級路由" class="headerlink" title="一、建立二級路由"></a>一、建立二級路由</h3><p>在 user app 中建立一個<code>api.py</code>， 內容為：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Router</span><br><span class="line"></span><br><span class="line">router = Router()</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_users</span>(<span class="params">request</span>):</span><br><span class="line">    users = User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> users</span><br></pre></td></tr></table></figure><p>同理，我們在<code>post/api.py</code>中建立類似的路由與 view 函式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Router</span><br><span class="line"></span><br><span class="line">router = Router()</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params">path=<span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">request</span>):</span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這樣，我們就為 user 和 post 兩個 app 分別建立了 API。接下來，我們需要將這些路由整合到<strong>專案級別</strong>的 API 路由中。</p><h3 id="二、建立一級路由"><a href="#二、建立一級路由" class="headerlink" title="二、建立一級路由"></a>二、建立一級路由</h3><p>在 Django 專案目錄（指 NinjaForum 目錄）底下，我們也需要建立一個<code>api.py</code>。它將作為我們的<strong>一級路由</strong>，整合所有 app 的 API。以下是這個<code>api.py</code>的內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> NinjaAPI</span><br><span class="line"></span><br><span class="line">api = NinjaAPI()</span><br><span class="line"></span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/users/&#x27;</span>, router=<span class="string">&#x27;user.api.router&#x27;</span>)</span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/posts/&#x27;</span>, router=<span class="string">&#x27;post.api.router&#x27;</span>)</span><br></pre></td></tr></table></figure><p>值得留意的是，這裡的路由整合有<strong>兩種寫法</strong>，上面我習慣使用的。</p><p>另一種寫法是直接 import <code>router</code>物件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> user.api <span class="keyword">import</span> router <span class="keyword">as</span> user_router</span><br><span class="line"><span class="keyword">from</span> post.api <span class="keyword">import</span> router <span class="keyword">as</span> post_router</span><br><span class="line"></span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/users/&#x27;</span>, router=user_router)</span><br><span class="line">api.add_router(prefix=<span class="string">&#x27;/posts/&#x27;</span>, router=post_router)</span><br></pre></td></tr></table></figure><p>這兩種方法在功能上是等效的，選擇哪種主要取決於個人偏好和專案的組織方式。</p><h3 id="三、專案-urls-py"><a href="#三、專案-urls-py" class="headerlink" title="三、專案 urls.py"></a>三、專案 <code>urls.py</code></h3><p>在 Django Ninja 中，專案層級的<code>urls.py</code>化身為連接 Django 和 Django Ninja API 的<strong>橋梁</strong>。</p><p>在專案<code>urls.py</code>中，我們還能再定義<strong>全專案共用的路由前綴</strong>。長這樣：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line"></span><br><span class="line">from NinjaForum.api import api</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;api/&#x27;</span>, api.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這裡定義了一個專案路由前綴——<code>/api/</code>。</p><p>如此一來，「取得所有文章」的 API 端點將會是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/posts/</span><br></pre></td></tr></table></figure><p>當然，如果你不需要額外的路由前綴，也可以直接省略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, api.urls),  <span class="comment"># 省略前綴</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>至此，我們完成了 Django Ninja 的路由設定。</p><p>這樣的結構不僅保持了 Django 原有的模組化設計，還為我們的 API 開發提供了更大的靈活性。</p><hr><h2 id="本節收尾與下一步"><a href="#本節收尾與下一步" class="headerlink" title="本節收尾與下一步"></a>本節收尾與下一步</h2><p>在第一節中，我們學習了如何使用 Django Ninja 定義路由，並了解 Django 傳統路由與 Django Ninja 路由的差異。</p><p>Django Ninja 的路由做法不僅讓程式碼更具可讀性，還保持了專案的清晰結構，改善了 Django 傳統路由的一些缺點。</p><p>下一篇，我們將進入 Django Ninja API 的核心部分——view 函式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章中，我們介紹了 Django 傳統的路由設定方式。&lt;/p&gt;
&lt;p&gt;如前所述，雖然有一個「路由清單」確實不錯。但隨著專案規模的擴大，&lt;strong&gt;不斷來回切換&lt;/strong&gt;&lt;code&gt;urls.py&lt;/code&gt;和&lt;code&gt;views.py&lt;/code&gt;將大幅增加開發者的認知負擔——不僅增加開發時間，還容易導致錯誤。&lt;/p&gt;
&lt;p&gt;Django Ninja 採用了一種&lt;strong&gt;更現代化&lt;/strong&gt;的路由設計，結合了 Flask 和 FastAPI 的設計理念。不僅簡化了路由的定義，還提升了程式碼的可讀性，讓路由與 view 函式&lt;strong&gt;緊密結合&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;範例專案動態&quot;&gt;&lt;a href=&quot;#範例專案動態&quot; class=&quot;headerlink&quot; title=&quot;範例專案動態&quot;&gt;&lt;/a&gt;範例專案動態&lt;/h2&gt;&lt;p&gt;本文關於路由設定的程式碼改動，可以參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/1&quot;&gt;這個 PR&lt;/a&gt;（&lt;strong&gt;Pull Request&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;範例專案合併了本文的 PR 後，已經正式成為一個「&lt;strong&gt;API 專案&lt;/strong&gt;」，不過它&lt;strong&gt;目前（指這個 &lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/commit/396e06338d615d3ec74e7c5bf871b85c9a06f0ec&quot;&gt;commit&lt;/a&gt; 狀態）尚無法正常運作&lt;/strong&gt;，因為我們還沒有完善 view 函式的基本功能。&lt;/p&gt;
&lt;p&gt;你可以一步步地跟著每一篇的 PR，來學習當次的新內容。這也是我為文章建立 PR 的用意所在。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 07：路由（上）傳統 Django 路由做法（兼章節概論）</title>
    <link href="https://blog.kyomind.tw/django-ninja-07/"/>
    <id>https://blog.kyomind.tw/django-ninja-07/</id>
    <published>2024-09-19T03:04:07.000Z</published>
    <updated>2024-09-20T05:34:00.021Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>第三章是全系列的重頭戲，因為我們要介紹 Django Ninja 的<strong>核心部分——API</strong>。</p><p>我把本章分成了三個小節：</p><ol><li><strong>第一節：路由（Router）</strong></li><li><strong>第二節：請求（Request）</strong></li><li><strong>第三節：回應（Response）</strong></li></ol><p>第三章也是<strong>唯一</strong>有區分小節的篇章。</p><p>現在我們進入第一節——<strong>路由</strong>。讓我們先了解一下本節的學習重點。</p><hr><h2 id="本節導覽"><a href="#本節導覽" class="headerlink" title="本節導覽"></a>本節導覽</h2><p>本節一共有兩篇，分別是：</p><ul><li>卷 7：路由（上）傳統 Django 路由做法（兼章節概論）</li><li>卷 8：路由（下）Django Ninja 路由設定</li></ul><p>為什麼要這樣安排呢？因為<strong>端點與路由是 API 請求的起點</strong>。</p><p>沒有它們，你的 view 函式根本無法接收請求，更不用說回應了。因此，路由設定必須放在第一位，作為 API 開發的學習入口。</p><p>所謂的「<strong>端點</strong>」（endpoints），你就簡單想成 <strong>API 所在的 URL</strong> 就可以了。</p><h3 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h3><p>其次，Django Ninja 的路由設定與傳統 Django 或 Django REST Framework（<strong>以下簡稱 DRF</strong>）的路由設定有<strong>很大的不同</strong>，反而更接近 FastAPI 或 Flask 風格。</p><p>這是我在學習 Django Ninja 時遇到的<strong>第一個門檻</strong>（畢竟我寫了 2 年的 DRF😅），所以決定分成上下兩篇文章詳細解說，幫助你打好基礎、減少混淆。</p><p>本文的重點是<strong>介紹 Django 傳統路由</strong>的設定方式。讓我們開始吧！</p><span id="more"></span><hr><h2 id="什麼是路由（Routers）"><a href="#什麼是路由（Routers）" class="headerlink" title="什麼是路由（Routers）"></a>什麼是路由（Routers）</h2><p><strong>路由（Router）</strong>是 Web 服務的<strong>重要元件</strong>之一，它負責將<strong>客戶端</strong>（通常是瀏覽器）發送的 HTTP 請求，<strong>對應到正確的處理邏輯</strong>。</p><p>在 Django 中，路由就是決定「<strong>哪個請求應該由哪個 View 來處理</strong>」的機制。</p><p>當客戶端訪問<strong>特定的 URL</strong>（我們稱為「<strong>端點</strong>」）時，Django 伺服器會根據這個 URL，找到對應的處理函式來執行特定邏輯。</p><p>這個「<strong>對應（mapping）</strong>」的過程，就是路由的核心職責。</p><hr><h2 id="Django-路由介紹"><a href="#Django-路由介紹" class="headerlink" title="Django 路由介紹"></a>Django 路由介紹</h2><p>Django 的路由機制主要透過<code>urls.py</code>中的設定，來管理不同層級的路由結構，並通過一級路由和二級路由，加以整合、組織所有端點。</p><p>至此，我們已經提到了 Django 路由的<strong>三個關鍵元素</strong>：</p><ul><li><strong>一級路由</strong></li><li><strong>二級路由</strong></li><li><code>urls.py</code></li></ul><p>以下是對它們的介紹。</p><h3 id="一級路由"><a href="#一級路由" class="headerlink" title="一級路由"></a>一級路由</h3><p><strong>一級路由</strong>是「<strong>專案級別</strong>」的路由，通常位於 Django 專案目錄底下（即範例專案中的<code>NinjaForum</code>目錄）的<code>urls.py</code>中。</p><p>一級路由主要用來為每一個 Django app <strong>分別加上全 app 統一的「路由前綴」</strong>，並<strong>整合來自所有 app 的路由</strong>。</p><p>以本專案為例，它可能會長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;posts/&#x27;</span>, include(<span class="string">&#x27;post.urls&#x27;</span>)),  <span class="comment"># 處理 post app 的路由</span></span><br><span class="line">    path(<span class="string">&#x27;users/&#x27;</span>, include(<span class="string">&#x27;user.urls&#x27;</span>)),  <span class="comment"># 處理 user app 的路由</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這裡的<code>urlpatterns</code>是 Django 的一級路由。它將<code>/posts/</code>和<code>/users/</code>路徑分別指向 post 和 user app 的二級路由，作為各 app 二級路由的統一前綴。</p><h3 id="二級路由"><a href="#二級路由" class="headerlink" title="二級路由"></a>二級路由</h3><p><strong>二級路由</strong>是各 Django app 自行管理的路由。<strong>直接對應</strong> app 本身的 view 函式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> post <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.get_posts)</span><br><span class="line">    path(<span class="string">&#x27;&lt;int:post_id&gt;/&#x27;</span>, views.post_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>將一級與二級路由的邏輯<strong>重新組合</strong>後，上述兩個 app 級路由，實際的端點是：</p><ol><li><code>/posts/</code> ：取得所有文章。</li><li><code>/posts/&lt;int:post_id&gt;/</code>：取得特定文章細節。</li></ol><p>這種<strong>層級式的路由結構</strong>不僅使 URL 更有組織，也讓不同 app 的功能<strong>更加模組化</strong>。</p><p>舉例而言，如果我們想要為 user app 新增一個「獲取用戶資料」API，我們只需要在 user app 的<code>urls.py</code>中建立相對應的路由即可，不需修改專案級別的路由設定。</p><hr><h2 id="專案架構圖"><a href="#專案架構圖" class="headerlink" title="專案架構圖"></a>專案架構圖</h2><p>用<strong>鳥瞰</strong>的角度可能會更清楚。</p><p>就 Django 傳統路由部分，整個範例專案的目錄與檔案結構如下（已省略無關部分）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── NinjaForum</span><br><span class="line">│   ├── urls.py  <span class="comment"># 專案一級路由</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── post</span><br><span class="line">│   ├── urls.py  <span class="comment"># app 二級路由</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── user</span><br><span class="line">│   ├── urls.py  <span class="comment"># app 二級路由</span></span><br><span class="line">│   ├── ...</span><br><span class="line">├── ...</span><br></pre></td></tr></table></figure><p>這樣的結構在 Django 專案中十分常見，同時也是 DRF 的標準做法。</p><p>專案一級路由負責<strong>全域的入口</strong>，二級路由負責 app 中 <strong>view 函式的配對</strong>。這樣的設計，使得專案架構更具模組化與擴展性。</p><hr><h2 id="Django-傳統路由的優點與缺點"><a href="#Django-傳統路由的優點與缺點" class="headerlink" title="Django 傳統路由的優點與缺點"></a>Django 傳統路由的優點與缺點</h2><p>Django 傳統的路由機制藉由專案與 app 層級的<code>urls.py</code>，來組織並定義完整的 URL 路徑（端點），這樣的設計<strong>有好有壞</strong>，讓我們來探討<strong>其中的利弊</strong>。</p><h3 id="優點：清晰的端點清單"><a href="#優點：清晰的端點清單" class="headerlink" title="優點：清晰的端點清單"></a>優點：清晰的端點清單</h3><p>Django 傳統路由的一大優點就是<strong>所有的端點、路由都集中在 <code>urls.py</code> 中</strong>。這意味著開發者可以<strong>一眼看出</strong>目前所有的 API 端點（app 部分），例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app 層級 urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;home/&#x27;</span>, views.home, name=<span class="string">&#x27;home&#x27;</span>),</span><br><span class="line">    path(<span class="string">&#x27;about/&#x27;</span>, views.about, name=<span class="string">&#x27;about&#x27;</span>),</span><br><span class="line">    path(<span class="string">&#x27;contact/&#x27;</span>, views.contact, name=<span class="string">&#x27;contact&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>urls.py</code>就像<strong>路由目錄</strong>一樣，一目了然。</p><h3 id="缺點：對照端點與-view-函式需要來回跳轉"><a href="#缺點：對照端點與-view-函式需要來回跳轉" class="headerlink" title="缺點：對照端點與 view 函式需要來回跳轉"></a>缺點：對照端點與 view 函式需要來回跳轉</h3><p>如前所述，路由負責<strong>連接</strong>端點與 view 函式。</p><p>由於<strong>每個端點都需要對應一個 view 函式</strong>，而對應的 view 函式通常放在<code>views.py</code>。</p><p>這帶來了一個問題：開發者需要在<code>urls.py</code>和<code>views.py</code>之間<strong>來回切換</strong>，<strong>才能完整理解一個端點與背後的實現邏輯。</strong></p><p>這樣的「不直觀」不僅增加了開發時的<strong>認知負擔</strong>，也容易在修改 API 時發生錯誤。</p><p>此外，隨著專案規模不斷擴大，<code>urls.py</code>中的端點清單會<strong>越來越長</strong>——要找到對應的 view 函式<strong>變得耗時且繁瑣</strong>，進一步增加了出錯的可能。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>本文中，我們深入了解了傳統 Django 的路由設計，並探討了其優缺點。</p><p>這種結構化的設計讓路由的管理更加模組化，但也引發了在大型專案中維護和閱讀困難的問題。</p><p>接下來，我們將探索 Django Ninja 如何提供更簡潔的路由機制，並與傳統 Django 路由進行比較。</p><h3 id="The-Django-Ninja-Way"><a href="#The-Django-Ninja-Way" class="headerlink" title="The Django Ninja Way"></a>The Django Ninja Way</h3><p>Django Ninja 採用了一種<strong>更現代化</strong>的方式，來處理路由和 view 函式——它將兩者<strong>緊密結合</strong>，提供了一種更直觀的手段來定義 API 端點。（其實大家都是學 Flask 的☺️）</p><p>不僅大幅減少了在不同檔案間切換的需求，還提高了程式碼的可讀性和維護性。</p><p>下一篇，就讓我們來了解 Django Ninja 的路由機制，看看它是如何改善這些問題的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三章是全系列的重頭戲，因為我們要介紹 Django Ninja 的&lt;strong&gt;核心部分——API&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我把本章分成了三個小節：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一節：路由（Router）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二節：請求（Request）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三節：回應（Response）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第三章也是&lt;strong&gt;唯一&lt;/strong&gt;有區分小節的篇章。&lt;/p&gt;
&lt;p&gt;現在我們進入第一節——&lt;strong&gt;路由&lt;/strong&gt;。讓我們先了解一下本節的學習重點。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本節導覽&quot;&gt;&lt;a href=&quot;#本節導覽&quot; class=&quot;headerlink&quot; title=&quot;本節導覽&quot;&gt;&lt;/a&gt;本節導覽&lt;/h2&gt;&lt;p&gt;本節一共有兩篇，分別是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷 7：路由（上）傳統 Django 路由做法（兼章節概論）&lt;/li&gt;
&lt;li&gt;卷 8：路由（下）Django Ninja 路由設定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;為什麼要這樣安排呢？因為&lt;strong&gt;端點與路由是 API 請求的起點&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;沒有它們，你的 view 函式根本無法接收請求，更不用說回應了。因此，路由設定必須放在第一位，作為 API 開發的學習入口。&lt;/p&gt;
&lt;p&gt;所謂的「&lt;strong&gt;端點&lt;/strong&gt;」（endpoints），你就簡單想成 &lt;strong&gt;API 所在的 URL&lt;/strong&gt; 就可以了。&lt;/p&gt;
&lt;h3 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h3&gt;&lt;p&gt;其次，Django Ninja 的路由設定與傳統 Django 或 Django REST Framework（&lt;strong&gt;以下簡稱 DRF&lt;/strong&gt;）的路由設定有&lt;strong&gt;很大的不同&lt;/strong&gt;，反而更接近 FastAPI 或 Flask 風格。&lt;/p&gt;
&lt;p&gt;這是我在學習 Django Ninja 時遇到的&lt;strong&gt;第一個門檻&lt;/strong&gt;（畢竟我寫了 2 年的 DRF😅），所以決定分成上下兩篇文章詳細解說，幫助你打好基礎、減少混淆。&lt;/p&gt;
&lt;p&gt;本文的重點是&lt;strong&gt;介紹 Django 傳統路由&lt;/strong&gt;的設定方式。讓我們開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 06：環境設定 × 如何使用本專案</title>
    <link href="https://blog.kyomind.tw/django-ninja-06/"/>
    <id>https://blog.kyomind.tw/django-ninja-06/</id>
    <published>2024-09-18T04:17:02.000Z</published>
    <updated>2024-09-18T05:00:48.591Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>前一篇我們了解了整個專案所使用的 Python 開發工具。</p><p>本文將帶領你一步步完成，有關範例專案的環境設定：<strong>從安裝 Python、Poetry、clone 專案至本地、建立 Python 虛擬環境，到成功啟動 Django</strong>。</p><p>即使你從未接觸過這些工具，按著本文的指南，應該也能順利完成環境設定並運行。</p><p>值得一提的是，我已經使用 Mac 很長一段時間，對 Windows 環境不甚熟悉，但我會盡可能提供相關的替代方案或指引。</p><p>好，我們開始吧！</p><span id="more"></span><hr><h2 id="一、安裝-Python-3-12"><a href="#一、安裝-Python-3-12" class="headerlink" title="一、安裝 Python 3.12"></a>一、安裝 Python 3.12</h2><p>因為不是每個人的環境都方便安裝 pyenv（尤其它<strong>不支援 Windows</strong>）， 這裡只講沒有 pyenv 的替代方案。</p><p>如果想透過 pyenv 安裝 Python， 可以參考上一篇提到的教學文章。</p><p>我們直接從 <a href="https://www.python.org/">Python 官方網站</a>下載並安裝 Python 3.12。</p><h3 id="Windows-使用者"><a href="#Windows-使用者" class="headerlink" title="Windows 使用者"></a>Windows 使用者</h3><ol><li>前往 Python 官方的<a href="https://www.python.org/downloads/">下載頁面</a>，下載 Python 3.12 的 Windows 安裝程式。</li><li>執行下載的安裝檔，記得勾選「<strong>Add Python 3.12 to PATH</strong>」選項。</li><li>完成安裝後，開啟<strong>命令提示字元</strong>並輸入<code>python --version</code>來確認是否安裝成功。</li></ol><h3 id="macOS-使用者"><a href="#macOS-使用者" class="headerlink" title="macOS 使用者"></a>macOS 使用者</h3><p>對於 macOS 使用者，我們有幾種安裝 Python 3.12 的方法：</p><ol><li>一樣使用官方安裝程式：前往 Python 官方網站下載 macOS 版本的安裝程式，並按照指示完成安裝。</li><li>使用 Homebrew：如果你已經安裝了 Homebrew，可以在終端中執行 <code>brew install python@3.12</code> 來安裝 Python 3.12。</li><li>安裝完成後，在終端中輸入 <code>python3 --version</code> 來確認安裝是否成功。</li></ol><p>不管用哪一種方式安裝，請務必透過上述指令確認 Python 版本正確。<strong>只要是 3.12.x 即可</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ python3 --version</span><br><span class="line">Python 3.12.5</span><br></pre></td></tr></table></figure><hr><h2 id="二、安裝與設定-Poetry"><a href="#二、安裝與設定-Poetry" class="headerlink" title="二、安裝與設定 Poetry"></a>二、安裝與設定 Poetry</h2><p>專案中的所有 Python 套件都由 <a href="https://python-poetry.org/">Poetry</a> 管理，首先要安裝 Poetry。可以直接通過官方指令安裝：（<strong>以下指令適用 macOS 和 Linux 用戶</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL &lt;https://install.python-poetry.org&gt; | python3 -</span><br></pre></td></tr></table></figure><p>安裝完成後，將 Poetry 執行檔路徑，新增到系統的 PATH 中：（<strong>Zsh 用戶</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.local/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p><strong>Bash 用戶</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.local/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>檢查是否安裝成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry --version</span><br><span class="line">Poetry (version 1.4.0)</span><br></pre></td></tr></table></figure><h3 id="Windows-安裝與設定-Poetry"><a href="#Windows-安裝與設定-Poetry" class="headerlink" title="Windows 安裝與設定 Poetry"></a>Windows 安裝與設定 Poetry</h3><p>Windows 用戶可參考 JetBrains 的 <a href="https://www.jetbrains.com/help/dataspell/poetry.html">Poetry 設定教學</a>，我覺得寫得很清楚。</p><h3 id="修改-Poetry-config，改用-venv虛擬環境"><a href="#修改-Poetry-config，改用-venv虛擬環境" class="headerlink" title="修改 Poetry config，改用.venv虛擬環境"></a>修改 Poetry <code>config</code>，改用<code>.venv</code>虛擬環境</h3><p>預設為<code>false</code>，Poetry 會在獨立目錄下建立虛擬環境，而名稱很冗長！</p><p>改成<code>true</code>以後，<strong>則直接在專案根目錄下建立虛擬環境，且名稱固定為</strong><code>.venv</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config virtualenvs.<span class="keyword">in</span>-project true</span><br></pre></td></tr></table></figure><p>把虛擬環境放在專案中，這是我個人更偏好的做法。</p><h2 id="不使用-Poetry-的方案"><a href="#不使用-Poetry-的方案" class="headerlink" title="不使用 Poetry 的方案"></a>不使用 Poetry 的方案</h2><p>專案中準備了一份<code>requirements.txt</code>，給習慣用 pip 的讀者。省去安裝與設定 Poetry 的麻煩。</p><hr><h2 id="三、從-GitHub-下載專案、建立虛擬環境"><a href="#三、從-GitHub-下載專案、建立虛擬環境" class="headerlink" title="三、從 GitHub 下載專案、建立虛擬環境"></a>三、從 GitHub 下載專案、建立虛擬環境</h2><p>接下來是專案本身的設定。</p><h3 id="一、Clone-專案"><a href="#一、Clone-專案" class="headerlink" title="一、Clone 專案"></a>一、Clone 專案</h3><p>這是<a href="https://github.com/kyomind/Django-Ninja-Tutorial">專案連結</a>。使用<code>git clone</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kyomind/Django-Ninja-Tutorial.git</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:kyomind/Django-Ninja-Tutorial.git</span><br></pre></td></tr></table></figure><h3 id="二、建立虛擬環境並安裝套件"><a href="#二、建立虛擬環境並安裝套件" class="headerlink" title="二、建立虛擬環境並安裝套件"></a>二、建立虛擬環境並安裝套件</h3><p>進入專案目錄，使用 Poetry 建立虛擬環境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use 3.12</span><br></pre></td></tr></table></figure><p>此時在專案根目錄應該會建立一個<code>.venv</code>資料夾，即專案的虛擬環境，<strong>目前是空的</strong>。</p><p>使用<code>poetry shell</code>啟動虛擬環境。</p><p>透過<code>poetry install</code>安裝套件：Poetry 會根據<code>pyproject.toml</code>和<code>poetry.lock</code>內容，自動下載並安裝專案需要的所有套件。</p><h3 id="pip-使用者"><a href="#pip-使用者" class="headerlink" title="pip 使用者"></a>pip 使用者</h3><p>pip 用戶可以透過以下步驟建立虛擬環境：（全程在<strong>專案根目錄</strong>下進行）</p><ol><li>使用 Python 內建的 venv 模組建立虛擬環境：<code>python -m venv .venv</code></li><li>啟動虛擬環境：<ul><li>Windows: <code>.venv\Scripts\activate</code></li><li>macOS&#x2F;Linux: <code>source .venv/bin/activate</code></li></ul></li><li>安裝套件：<code>pip install -r requirements.txt</code></li></ol><hr><h2 id="四、初始化-pre-commit"><a href="#四、初始化-pre-commit" class="headerlink" title="四、初始化 pre-commit"></a>四、初始化 pre-commit</h2><p>建立虛擬環境並使用<code>poetry install</code>後，pre-commit 套件已被安裝到虛擬環境中。</p><p>如你所見，專案中有一個<code>.pre-commit-config.yaml</code>檔。這個檔案定義了每次提交前要執行的檢查項目（Git Hooks）。</p><p>我們只需要透過下列指令，安裝 Git Hooks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-commit install</span><br></pre></td></tr></table></figure><p>這個指令會在專案的 Git 目錄中建立 Git Hooks，<strong>每個專案只要執行一次即可</strong>。</p><hr><h2 id="五、安裝-VS-Code-套件"><a href="#五、安裝-VS-Code-套件" class="headerlink" title="五、安裝 VS Code 套件"></a>五、安裝 VS Code 套件</h2><p>如果你的 IDE 是 VS Code，我強烈建議安裝 <a href="https://marketplace.visualstudio.com/items?itemName=charliermarsh.ruff">Ruff</a> 和 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.mypy-type-checker">Mypy</a> 這兩個 VS Code 套件。讓你可以在第一時間知曉目前的程式碼狀態（是否有問題）。</p><p>兩者在安裝後，原則上都無須設定，因為專案內<strong>已經有了相關的設定檔</strong>：</p><ol><li>Ruff：<code>pyproject.toml</code></li><li>Mypy：<code>mypy.ini</code></li></ol><p>此外，它們都是 CLI 工具，所以你也可以<strong>手動執行</strong>它們，比如執行 Ruff 檢查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruff check</span><br><span class="line">ruff format</span><br></pre></td></tr></table></figure><p>或執行 Mypy 檢查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mypy .</span><br></pre></td></tr></table></figure><p>但還是 VS Code 套件最方便。</p><hr><h2 id="六、啟動-Django-專案"><a href="#六、啟動-Django-專案" class="headerlink" title="六、啟動 Django 專案"></a>六、啟動 Django 專案</h2><p>我們已經完成了所有必要的工具設定，接下來就可以啟動 Django 伺服器了。</p><h3 id="一、進行資料庫遷移"><a href="#一、進行資料庫遷移" class="headerlink" title="一、進行資料庫遷移"></a>一、進行資料庫遷移</h3><p>這是一開始一定要的步驟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>事實上，專案也準備了 Makefile，所以你也可以透過以下指令執行遷移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make migrate</span><br></pre></td></tr></table></figure><p>有關 Makefile 的介紹與教學，可以參考小克這篇〈<a href="https://blog.goodjack.tw/2023/01/use-makefile-to-manage-workflows-for-web-projects.html">寫 Web 也可以用 Makefile：好好管理你的環境流程</a>〉。</p><h3 id="二、啟動開發伺服器"><a href="#二、啟動開發伺服器" class="headerlink" title="二、啟動開發伺服器"></a>二、啟動開發伺服器</h3><p>執行以下命令來<strong>啟動 Django 開發伺服器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">make run</span><br></pre></td></tr></table></figure><p>接著，打開瀏覽器並訪問 <code>http://127.0.0.1:8000/</code>，你應該可以看到 Django 預設的歡迎頁面，表示專案成功啟動！</p><p><img src="https://i.imgur.com/Qb9ZeIu.png" alt="Django 預設歡迎頁面"><span class="cap">Django 預設歡迎頁面</span></p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>通過上述步驟，你已經成功完成了專案的開發環境設定，並啟動了範例 Django 專案。</p><p>如果在設定過程中遇到問題，可查閱工具的官方文件或參考我的部落格教學，這些資源能幫助你解決常見問題，或進一步理解它們的功能。</p><h2 id="最後的最後"><a href="#最後的最後" class="headerlink" title="最後的最後"></a>最後的最後</h2><p>在專案的開發過程中，我們會使用 Git 分支和 <strong>GitHub 的 PR（<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pulls">Pull requests</a>）</strong>來管理<strong>不同章節的範例程式碼改動</strong>。</p><p>這樣可以<strong>保持學習脈絡清晰有條理</strong>，避免因不同功能的程式碼混在一起而影響理解。</p><p>需要注意的是，<strong>不是</strong>每一篇文章都有自己的分支與 PR，因為有些篇章只涉及概念說明而沒有程式碼改動。</p><h2 id="CodeGPT-推薦"><a href="#CodeGPT-推薦" class="headerlink" title="CodeGPT 推薦"></a>CodeGPT 推薦</h2><p>此外，本專案<strong>幾乎所有的 commit 訊息</strong>，都是透過吳大開發的 <a href="https://github.com/appleboy/CodeGPT">CodeGPT</a> 加上 GPT-4o mini API <strong>自動生成</strong>。</p><p>畢竟，即使只是範例專案，要思考每一個 commit 訊息的內容也是不輕鬆。有了這樣的自動化工具，真的方便很多！而且風格一致性高，很適合偏執狂如我☺️</p><p>關於 CodeGPT，除了 GitHub 頁面介紹，還可以參考吳大的這篇〈<a href="https://blog.wu-boy.com/2023/11/codegpt-in-modernweb/">生成式 AI CodeGPT 開發經驗談 - 台北 ModernWeb</a>〉，內有投影片分享。</p><p>使用教學則可參考保哥的〈<a href="https://blog.miniasp.com/post/2023/12/05/Useful-tool-CodeGPT">介紹好用工具：CodeGPT (使用 GPT 自動化產生 Git 的 Commit Log 訊息)</a>〉。</p><hr><p>現在，一切準備就緒，讓我們正式進入 Django Ninja 的世界。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;前一篇我們了解了整個專案所使用的 Python 開發工具。&lt;/p&gt;
&lt;p&gt;本文將帶領你一步步完成，有關範例專案的環境設定：&lt;strong&gt;從安裝 Python、Poetry、clone 專案至本地、建立 Python 虛擬環境，到成功啟動 Django&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即使你從未接觸過這些工具，按著本文的指南，應該也能順利完成環境設定並運行。&lt;/p&gt;
&lt;p&gt;值得一提的是，我已經使用 Mac 很長一段時間，對 Windows 環境不甚熟悉，但我會盡可能提供相關的替代方案或指引。&lt;/p&gt;
&lt;p&gt;好，我們開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 05：Python 現代開發工具介紹</title>
    <link href="https://blog.kyomind.tw/django-ninja-05/"/>
    <id>https://blog.kyomind.tw/django-ninja-05/</id>
    <published>2024-09-17T02:21:18.000Z</published>
    <updated>2024-09-17T03:38:16.721Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>在現代軟體開發中，工具不僅能<strong>提高開發效率</strong>，還能<strong>改善程式碼品質</strong>，讓專案的管理與維護變得更加輕鬆。</p><p>本文將介紹幾個重要的 Python 開發工具，討論它們在專案中的應用，讓讀者<strong>快速了解它們的定位與價值</strong>。</p><p>如果你看過我的部落格，應該會發現，我花了不少篇幅在大力推廣這些現代開發工具，為它們撰寫了一篇又一篇的詳細文章教學。</p><p>因此，我們不會深入這些工具的操作細節，而是<strong>著眼於概念</strong>，以及它們<strong>如何解決開發中的痛點</strong>。我會附上相關教學文章的連結，讓有興趣的讀者可以進一步學習。</p><p>值得一提的是，這些 Python 的現代開發實踐，都是我看了開發者 <a href="https://blog.wei-lee.me/pages/about-me.html">Wei Lee（李唯）</a>的「<a href="https://blog.wei-lee.me/posts/tech/2020/02/python-table-manners-series/">Python Table Manners</a>」系列後，才一一學習並落實的。<strong>個人強力推薦此系列！</strong></p><span id="more"></span><hr><p>本專案使用 Python 3.12.5、Django 4.2 LTS 及 Django Ninja 1.3.0，這部分只要知道即可。</p><p>我們現在進入各個工具的介紹。</p><h2 id="pyenv：Python-版本管理"><a href="#pyenv：Python-版本管理" class="headerlink" title="pyenv：Python 版本管理"></a>pyenv：Python 版本管理</h2><p><a href="https://github.com/pyenv/pyenv">pyenv</a>（對，它的 p 是小寫，同 <a href="https://docs.pytest.org/en/stable/">pytest</a>）是一個<strong>管理多個 Python 版本</strong>的強大工具，它允許你在不同專案中使用不同版本的 Python，而不會產生衝突。</p><p>這也是為什麼，專案中有一個<code>.python-version</code>檔——它向 pyenv 聲明了專案所使用的 Python 版本。</p><p>pyenv 在處理多個使用不同 Python 版本的專案時特別有幫助，尤其是當某些專案需要使用舊版 Python 時。</p><p>透過 pyenv，你可以輕鬆安裝和切換 Python 版本，確保每個專案都能在正確的環境中運行。</p><p>詳細的 pyenv 教學，可以參考我之前寫的：</p><ul><li><a href="/ubuntu-pyenv/">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a>（Linux）</li><li><a href="/pyenv-setup/">告別 Anaconda：在 macOS 上使用 pyenv 建立 Python 開發環境</a>（macOS）</li></ul><hr><h2 id="Poetry：虛擬環境與套件管理"><a href="#Poetry：虛擬環境與套件管理" class="headerlink" title="Poetry：虛擬環境與套件管理"></a>Poetry：虛擬環境與套件管理</h2><p><a href="https://python-poetry.org/">Poetry</a> 是目前相當受歡迎的 Python 套件管理工具，而套件管理——尤其是套件之間的「相依性」問題，一直是 Python 開發上的一大痛點。</p><p>Poetry 主要解決的是，<strong>套件之間對其相依套件的不同版本範圍的衝突問題</strong>。</p><p>這些細節，一言難盡，可參考我的文章〈<a href="/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a>〉，尤其是其中「<a href="/python-poetry/#%E5%90%8D%E8%A9%9E%E8%A7%A3%E9%87%8B">名詞解釋</a>」部分。</p><p>此外，Poetry 因為涉及了虛擬環境管理，<strong>怎麼樣和 pyenv 一起使用，讓虛擬環境能選擇正確的 Python 版本</strong>，也是個常見問題，可參考〈<a href="/poetry-pyenv-practical-tips/">Poetry + pyenv 教學：常用指令與注意事項</a>〉一文的介紹。</p><hr><h2 id="Ruff：Linter-與-Formatter"><a href="#Ruff：Linter-與-Formatter" class="headerlink" title="Ruff：Linter 與 Formatter"></a>Ruff：Linter 與 Formatter</h2><p>時代在變，以往我都是 Flake8 + isort + Black——現在我都用 Ruff。</p><p><a href="https://beta.ruff.rs/">Ruff</a> 是一款<strong>超高速的 Python linter 和 formatter</strong>，使用 Rust 寫成，用於快速檢查並修正程式碼中的排版格式問題。</p><p>Ruff 能夠幫助開發者<strong>維持統一的程式碼風格</strong>（主要是符合 PEP8）。由於其高效能，Ruff 特別適合用於大型專案。</p><p>除此之外，Ruff 還能夠整合眾多 Flake8 外掛，成為一個 All-in-One 方案<strong>。</strong>對我而言，這是它在速度之外的另一大賣點。</p><p>更多 Ruff 的介紹，可以參考我的文章：</p><ul><li><a href="/ruff/">Python 開發：Ruff Linter、Formatter 介紹 + 設定教學</a></li><li><a href="/migrate-to-ruff/">Python 專案從 Flake8、Black 遷移至 Ruff 指南</a></li></ul><hr><h2 id="pre-commit：Git-Hooks-管理工具"><a href="#pre-commit：Git-Hooks-管理工具" class="headerlink" title="pre-commit：Git Hooks 管理工具"></a>pre-commit：Git Hooks 管理工具</h2><p>俗話說的好：「沒有 CI，至少也要有 pre-commit」——這是我自己說的。</p><p><a href="https://pre-commit.com/">pre-commit</a>（沒錯，它的 p 也是小寫）是由 Python 所寫成的 Git Hooks 管理工具，<strong>適用於各類程式語言專案</strong>。讓使用者根據自己的需求，建立相關的 <a href="https://git-scm.com/book/zh-tw/v2/Customizing-Git-Git-Hooks">Git Hooks</a>。</p><p>以常見的「pre-commit hook」為例，它會在你執行<code>git commit</code>之際，自動運行各種檢查和格式化工具——也就是你設定的 hooks，確保提交的程式碼符合規範。</p><p>這不僅能維護程式碼品質，還能<strong>減少</strong> code review 中的<strong>瑣碎問題</strong>，讓審核者專注於邏輯和架構的審查。</p><p>在我們的範例專案中，pre-commit 被設定為運行 Ruff 和一些基本的格式確認，以確保程式碼風格的一致性。</p><p>相關文章：<a href="/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p><hr><h2 id="Mypy：靜態型別檢查"><a href="#Mypy：靜態型別檢查" class="headerlink" title="Mypy：靜態型別檢查"></a>Mypy：靜態型別檢查</h2><p>你的 Python 專案有 <a href="https://docs.python.org/3/library/typing.html">type hints</a> 嗎？</p><p>如系列第一篇所言，Django Ninja 是你學習 type hints 一個<strong>很好的開始</strong>。</p><p>想為專案加入 type hints，<strong>靜態型別檢查器（static type checker）</strong>是不可或缺的。而其中最常見的選擇，就是 <a href="https://github.com/python/mypy">Mypy</a>。</p><p>Mypy 是一個強大的工具，它不僅能檢查型別錯誤，還能在程式運行前，就捕捉到許多<strong>潛在問題</strong>。在我看來，它實際上的影響<strong>超越了型別範疇</strong>。</p><p>Mypy 是大型專案和團隊合作必備的工具。然而，我想強調的是，即便對於小型專案，Mypy 也能帶來明顯的好處。</p><p>Type hints 的成本與效益，可以用下列這張圖來說明（重繪自《<a href="https://www.tenlong.com.tw/products/9786263241015">強健的 Python</a>》）：</p><p><img src="https://i.imgur.com/y7RL42J.png"></p><p>長期而言，使用 type hints 和 Mypy 能帶來<strong>持續性的效益——其實這適用於本篇介紹的所有工具😎</strong>。雖然初期需要投入一些時間來學習和適應，但這是<strong>值得的</strong>。</p><p>關於 Mypy，歡迎參考我剛剛完成的「<a href="/series/#Mypy-%E4%B8%89%E9%83%A8%E6%9B%B2">Mypy 三部曲</a>」系列。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>pyenv 幫助我們靈活管理 Python 版本，Poetry 解決了套件的管理問題，Ruff、pre-commit 和 Mypy 等工具確保程式碼的乾淨與一致性，這些工具相輔相成，<strong>共同建構了一個高效率的開發環境</strong>。</p><p>善用它們，是我們作為現代開發者的必備素養，也是團隊合作的重要基石。學習需要一些時間成本，但習慣以後，相信這些工具會成為你開發過程中<strong>不可或缺的助力</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;在現代軟體開發中，工具不僅能&lt;strong&gt;提高開發效率&lt;/strong&gt;，還能&lt;strong&gt;改善程式碼品質&lt;/strong&gt;，讓專案的管理與維護變得更加輕鬆。&lt;/p&gt;
&lt;p&gt;本文將介紹幾個重要的 Python 開發工具，討論它們在專案中的應用，讓讀者&lt;strong&gt;快速了解它們的定位與價值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你看過我的部落格，應該會發現，我花了不少篇幅在大力推廣這些現代開發工具，為它們撰寫了一篇又一篇的詳細文章教學。&lt;/p&gt;
&lt;p&gt;因此，我們不會深入這些工具的操作細節，而是&lt;strong&gt;著眼於概念&lt;/strong&gt;，以及它們&lt;strong&gt;如何解決開發中的痛點&lt;/strong&gt;。我會附上相關教學文章的連結，讓有興趣的讀者可以進一步學習。&lt;/p&gt;
&lt;p&gt;值得一提的是，這些 Python 的現代開發實踐，都是我看了開發者 &lt;a href=&quot;https://blog.wei-lee.me/pages/about-me.html&quot;&gt;Wei Lee（李唯）&lt;/a&gt;的「&lt;a href=&quot;https://blog.wei-lee.me/posts/tech/2020/02/python-table-manners-series/&quot;&gt;Python Table Manners&lt;/a&gt;」系列後，才一一學習並落實的。&lt;strong&gt;個人強力推薦此系列！&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 04：範例專案介紹</title>
    <link href="https://blog.kyomind.tw/django-ninja-04/"/>
    <id>https://blog.kyomind.tw/django-ninja-04/</id>
    <published>2024-09-16T02:25:35.000Z</published>
    <updated>2024-09-16T03:51:59.255Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>在第一章中，我們對 Django Ninja 做了全方位的介紹，並且分析了它與 Django REST Framework 的主要區別。</p><p>相信你對 Django Ninja 已有了一定的了解。</p><p>接下來，我們將進入第二章：<strong>專案介紹與設定</strong>。</p><h2 id="本章重點"><a href="#本章重點" class="headerlink" title="本章重點"></a>本章重點</h2><p>我們將透過一個 CRUD API 範例專案，幫助你在實踐中運用 Django Ninja 的概念。</p><p>本章將對專案概念進行介紹，包括模型設計與現實世界中的對應。（卷 4）</p><p>接著介紹專案使用的 Python 開發工具（卷 5）。最後會手把手帶你，安裝專案到本機並確保它正常運行（卷 6）。</p><p>其餘有關 API 的程式碼，將在第三章陸續介紹與實作。</p><span id="more"></span><hr><h2 id="忍者論壇"><a href="#忍者論壇" class="headerlink" title="忍者論壇"></a>忍者論壇</h2><p>為了讓你更好地理解 Django Ninja 並能夠進行實際操作，我們設計了一個範例專案——<strong>忍者論壇</strong>。</p><p>這是一個<strong>討論區</strong>，讓開發者交流 Django Ninja 使用心得（而不是如何成為忍者）。</p><p>這是專案的 <a href="https://github.com/kyomind/Django-Ninja-Tutorial">GitHub 網址</a>，你可以把它加到書籤，隨時參閱程式碼，加深學習印象。</p><p>這個專案將引導你如何使用 Django Ninja 來構建 API，展示其中的知識與實踐。</p><h2 id="設計理念"><a href="#設計理念" class="headerlink" title="設計理念"></a>設計理念</h2><p>專案的主題是「忍者論壇」，它是一個基本的討論區系統，具備使用者發表文章和留言評論的核心功能。</p><p>這個設計既簡單又實用，讓你能專注於 Django Ninja 核心，而不會被過多的額外功能分散注意力。</p><p>論壇的兩大基本功能，也是我們實現 API 的重點所在：</p><ul><li><strong>使用者系統</strong>：使用者可以註冊、登入、登出，並查看自己的文章。</li><li><strong>發文系統</strong>：使用者可以建立、修改、刪除文章。</li></ul><p>透過這個專案，你將學會如何使用 Django Ninja 快速建立相關的 API。</p><p>我們會<strong>以「發文」為中心</strong>，逐步實現不同的 API。</p><hr><h2 id="三個設計原則"><a href="#三個設計原則" class="headerlink" title="三個設計原則"></a>三個設計原則</h2><p>作為一個「範例」專案，<strong>忍者論壇</strong>的設計目的，是為了讓你透過實際的操作，深入了解 Django Ninja 的基本概念與應用。</p><p>因此，我們會將專案內容<strong>嚴格控制在教學所需的範圍內</strong>，以確保學習上的專注，而不會被過多的細節所干擾。</p><p>簡言之，專案遵循以下三個設計原則。</p><h2 id="一、最小化設計原則"><a href="#一、最小化設計原則" class="headerlink" title="一、最小化設計原則"></a>一、最小化設計原則</h2><p>所謂「<strong>最小化設計</strong>」，即盡可能確保所有實作<strong>都是教學所必須</strong>的。</p><p>我們甚至會<strong>重複使用同一個 API 作為範例，演示不同階段的功能實現。</strong></p><p>這樣的設計可以<strong>讓教學內容保持簡潔</strong>，同時又能<strong>逐步深入</strong> Django Ninja 的各種特性。</p><h2 id="二、簡單易懂的程式碼結構"><a href="#二、簡單易懂的程式碼結構" class="headerlink" title="二、簡單易懂的程式碼結構"></a>二、簡單易懂的程式碼結構</h2><p>範例專案的程式碼結構應該是<strong>簡單明瞭</strong>的，讓讀者能<strong>快速了解</strong>各部分的邏輯與關聯。</p><p>相比於實際工作中的專案，範例專案更注重程式碼的清晰度與一望即知，<strong>避免不必要的複雜設計或抽象層次</strong>。</p><p>這意味著：</p><ul><li>我們不會引入過多的元件拆分或模組化設計，而是直接將功能展示出來。</li><li>每個功能的實現都力求簡潔，重點放在<strong>如何實現</strong>。</li></ul><p>這樣的設計能讓你快速理解每個程式碼片段的作用，並輕鬆應用到自己的專案中。</p><h2 id="三、簡單易用的環境"><a href="#三、簡單易用的環境" class="headerlink" title="三、簡單易用的環境"></a>三、簡單易用的環境</h2><p>範例專案需要一個<strong>簡單易用的環境</strong>，讓學習者可以<strong>立即運行專案並測試所學內容</strong>。</p><p>工作上的專案，會涉及到很多<strong>外部依賴</strong>，但範例專案的設計則側重於讓學習者能夠快速驗證所學到的概念。</p><p>這意味著：</p><ul><li>專案<strong>不依賴完整的部署</strong>，只需要簡單的本地設定，就能快速運行和測試，讓讀者能夠立刻看到 API 的回應結果。</li></ul><p>我們緊扣著 API 教學本身，其餘外部環節，可能需要你自行實踐與補足。</p><hr><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>了解了範例專案的設計後，接下來我們將進入<strong>開發環境介紹</strong>。</p><p>開發專案時，合適的工具能讓工作事半功倍，下一篇將介紹常用的 Python 開發工具，比如虛擬環境管理與程式碼格式化。</p><p>這些工具不僅能幫助你高效管理專案，還能大幅提升程式碼的品質與一致性。<strong>我相信，熟練掌握這些工具，是現代開發者的基本功。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;在第一章中，我們對 Django Ninja 做了全方位的介紹，並且分析了它與 Django REST Framework 的主要區別。&lt;/p&gt;
&lt;p&gt;相信你對 Django Ninja 已有了一定的了解。&lt;/p&gt;
&lt;p&gt;接下來，我們將進入第二章：&lt;strong&gt;專案介紹與設定&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;本章重點&quot;&gt;&lt;a href=&quot;#本章重點&quot; class=&quot;headerlink&quot; title=&quot;本章重點&quot;&gt;&lt;/a&gt;本章重點&lt;/h2&gt;&lt;p&gt;我們將透過一個 CRUD API 範例專案，幫助你在實踐中運用 Django Ninja 的概念。&lt;/p&gt;
&lt;p&gt;本章將對專案概念進行介紹，包括模型設計與現實世界中的對應。（卷 4）&lt;/p&gt;
&lt;p&gt;接著介紹專案使用的 Python 開發工具（卷 5）。最後會手把手帶你，安裝專案到本機並確保它正常運行（卷 6）。&lt;/p&gt;
&lt;p&gt;其餘有關 API 的程式碼，將在第三章陸續介紹與實作。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 03：Django Ninja 介紹——與 Django REST Framework 主要區別</title>
    <link href="https://blog.kyomind.tw/django-ninja-03/"/>
    <id>https://blog.kyomind.tw/django-ninja-03/</id>
    <published>2024-09-15T03:23:43.000Z</published>
    <updated>2024-09-16T15:26:44.291Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>選擇任何工具之前，我們通常會先了解<strong>它能解決的問題</strong>，以及<strong>是否符合與自己的需求</strong>。</p><p>本文將介紹 Django Ninja 這個現代化的 API 框架，探討它的起源和主要特點，並重點比較它與 Django REST Framework 之間的差異，讓你能夠更好地選擇適合的工具。</p><hr><h2 id="Django-Ninja-起源"><a href="#Django-Ninja-起源" class="headerlink" title="Django Ninja 起源"></a>Django Ninja 起源</h2><p>Django Ninja 的起源<strong>與 FastAPI 有著密切的關係。</strong></p><p>Django Ninja 可以被視為「<strong>Django 版的 FastAPI</strong>」，它比原生 FastAPI 能夠更好地與 Django 整合。</p><p>Django Ninja 的<a href="https://django-ninja.dev/motivation/">官方文件</a>中，作者 <a href="https://github.com/vitalik">Vitaliy Kucheryaviy</a> 解釋了<strong>為什麼建立這個框架</strong>。這源於他在 Django 專案中使用 FastAPI 時遇到的一些挑戰，特別是在整合方面。</p><p>因此，他決定自己建立一個更合適的工具，從而誕生了 Django Ninja。</p><p>可想而知，Django Ninja 深受 FastAPI 的啟發。事實上，它同時也借鑑了不少 Django REST Framework 的優秀實踐——這是<strong>後發者的優勢</strong>！</p><p>文件中引用了這麼一句話，這是個常見的疑問：</p><blockquote><p><strong>Django Ninja</strong> looks basically the same as <strong>FastAPI</strong>, so why not just use FastAPI?</p></blockquote><p>答案就是：兩者的整合不完美，而 Django Ninja 提供了一個更加適合 Django 開發者的版本。</p><span id="more"></span><hr><h2 id="Django-Ninja-特點"><a href="#Django-Ninja-特點" class="headerlink" title="Django Ninja 特點"></a>Django Ninja 特點</h2><p>Django Ninja 的一些<strong>關鍵特性</strong>，使其成為 Django API 開發者的優秀選擇：</p><ul><li><strong>自動產生 API 文件：</strong> 利用 Python 型別提示和 Pydantic，自動生成符合 OpenAPI 標準的 API 文件，大大減少了文件維護的工作量——這也是我當初選擇 Django Ninja 最大理由。</li><li><strong>請求驗證與資料序列化：</strong> 基於 Pydantic BaseModel，驗證請求資料和處理資料的序列化、反序列化，確保 API 的穩定和數據正確。</li><li><strong>簡潔且高效的 API 定義：</strong> Django Ninja 提供了一種簡單明瞭的方式來定義 API 路由和處理邏輯（view 函式），使開發者能夠快速上手。</li><li><strong>與 Django 無縫整合：</strong> 框架設計之初就考慮到了與 Django 的兼容性，它可以輕鬆整合到現有的 Django 專案中，充分使用 Django 的既有功能，比如 ORM。</li><li><strong>支援非同步</strong>：Django Ninja 支援非同步處理，讓 API 在面對大量請求時，仍能維持高效的回應速度與處理效能。</li></ul><hr><h2 id="Django-Ninja-與-Django-REST-Framework-的主要區別"><a href="#Django-Ninja-與-Django-REST-Framework-的主要區別" class="headerlink" title="Django Ninja 與 Django REST Framework 的主要區別"></a>Django Ninja 與 Django REST Framework 的主要區別</h2><p>剛進入 Python 後端開發領域的讀者，可能未必熟悉 <a href="https://www.django-rest-framework.org/">Django REST Framework</a>（<strong>以下簡稱 DRF</strong>），可以參考我寫過的這篇〈<a href="https://blog.kyomind.tw/django-rest-framework-01/">Django REST framework 教學（一）前言篇</a>〉介紹。</p><p>文章中還說明了，<a href="https://blog.kyomind.tw/django-rest-framework-01/#%E7%82%BA%E4%BD%95%E9%9C%80%E8%A6%81-DRF">為何 Django 需要像 Django Ninja、DRF 這樣的 API 框架。</a></p><p>DRF 和 Django Ninja，都是 Django 生態系中，用於快速建立 API 的強大工具，而且前者的歷史悠久得多。</p><p>但它們在設計理念、功能實現上存在顯著差異。對我而言，它們甚至可以說是<strong>完全不同</strong>的工具😎</p><p>下面三個部分，總結了我個人認為兩者的主要區別。</p><h2 id="設計理念"><a href="#設計理念" class="headerlink" title="設計理念"></a>設計理念</h2><ul><li><strong>DRF</strong>：作為一個成熟且全面的框架，它提供了<strong>豐富的元件</strong>。適合需要高度定制和複雜功能的專案，並且擁有強大的社群支持。</li><li><strong>Django Ninja</strong>：專注於<strong>簡潔</strong>和開發速度，利用現代 Python 特性（如型別提示）來簡化 API 開發過程。適合追求快速開發和高效性能的專案。</li></ul><h2 id="主要功能差異"><a href="#主要功能差異" class="headerlink" title="主要功能差異"></a>主要功能差異</h2><ul><li><strong>序列化</strong>：<ul><li><strong>DRF</strong>：使用自定義的<a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器</a>，支持更多複雜的序列化需求。</li><li><strong>Django Ninja</strong>：使用 <a href="https://docs.pydantic.dev/latest/api/base_model/">Pydantic BaseModel</a>，簡化了序列化過程，但可能不如 DRF 靈活。</li></ul></li><li><strong>API 文件生成</strong>：<ul><li><strong>DRF</strong>：需要額外的套件才能透過程式碼自動產生 API 文件，但效果不如使用 Pydantic 的框架。</li><li><strong>Django Ninja</strong>：自動生成符合 OpenAPI 標準的文件，過程更簡便且高效。</li></ul></li><li><strong>性能：（同步 vs 非同步）</strong><ul><li><strong>DRF</strong>：在功能豐富的情況下，性能可能受到一定影響。不支援非同步。</li><li><strong>Django Ninja</strong>：在請求驗證和處理方面通常表現更快，而且支援非同步。</li></ul></li></ul><h2 id="社群支持與生態"><a href="#社群支持與生態" class="headerlink" title="社群支持與生態"></a>社群支持與生態</h2><ul><li><strong>DRF</strong>：擁有成熟的社群和大量的外掛套件，由 <a href="https://github.com/encode">encode</a> 團隊開發維護。</li><li><strong>Django Ninja</strong>：較新的框架，社群規模較小，網路上的資料少很多，且主要依賴作者一人開發、維護。</li></ul><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>Django Ninja 和 DRF 有著<strong>各自的優勢</strong>：</p><ul><li>如果你追求的是快速開發、高性能、以及更現代化的 Python 型別提示，<strong>Django Ninja</strong> 是理想選擇，尤其適合需要非同步的場景。</li><li>如果你需要處理更複雜的認證、權限管理，並且需要高度自定義的 API 驗證和處理邏輯，那麼 <strong>DRF</strong> 是一個穩定且強大的選擇。</li></ul><p>透過本文的介紹，相信你對 Django Ninja 有了更加清晰的認識。</p><p>接下來的教學中，我們將深入探討 Django Ninja 的各個部分，幫助你更好地掌握這個現代化的 API 開發工具。</p><p>不過在此之前，我們還有一個重要的前置主題：<strong>範例專案與環境設定</strong>。這會是我們學習 Django Ninja 的第一步。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;選擇任何工具之前，我們通常會先了解&lt;strong&gt;它能解決的問題&lt;/strong&gt;，以及&lt;strong&gt;是否符合與自己的需求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文將介紹 Django Ninja 這個現代化的 API 框架，探討它的起源和主要特點，並重點比較它與 Django REST Framework 之間的差異，讓你能夠更好地選擇適合的工具。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Django-Ninja-起源&quot;&gt;&lt;a href=&quot;#Django-Ninja-起源&quot; class=&quot;headerlink&quot; title=&quot;Django Ninja 起源&quot;&gt;&lt;/a&gt;Django Ninja 起源&lt;/h2&gt;&lt;p&gt;Django Ninja 的起源&lt;strong&gt;與 FastAPI 有著密切的關係。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Django Ninja 可以被視為「&lt;strong&gt;Django 版的 FastAPI&lt;/strong&gt;」，它比原生 FastAPI 能夠更好地與 Django 整合。&lt;/p&gt;
&lt;p&gt;Django Ninja 的&lt;a href=&quot;https://django-ninja.dev/motivation/&quot;&gt;官方文件&lt;/a&gt;中，作者 &lt;a href=&quot;https://github.com/vitalik&quot;&gt;Vitaliy Kucheryaviy&lt;/a&gt; 解釋了&lt;strong&gt;為什麼建立這個框架&lt;/strong&gt;。這源於他在 Django 專案中使用 FastAPI 時遇到的一些挑戰，特別是在整合方面。&lt;/p&gt;
&lt;p&gt;因此，他決定自己建立一個更合適的工具，從而誕生了 Django Ninja。&lt;/p&gt;
&lt;p&gt;可想而知，Django Ninja 深受 FastAPI 的啟發。事實上，它同時也借鑑了不少 Django REST Framework 的優秀實踐——這是&lt;strong&gt;後發者的優勢&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;文件中引用了這麼一句話，這是個常見的疑問：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Django Ninja&lt;/strong&gt; looks basically the same as &lt;strong&gt;FastAPI&lt;/strong&gt;, so why not just use FastAPI?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案就是：兩者的整合不完美，而 Django Ninja 提供了一個更加適合 Django 開發者的版本。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 02：架構 × 章節導覽</title>
    <link href="https://blog.kyomind.tw/django-ninja-02/"/>
    <id>https://blog.kyomind.tw/django-ninja-02/</id>
    <published>2024-09-13T18:28:23.000Z</published>
    <updated>2024-09-14T13:42:02.257Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>上一篇中，我們講述了系列的整體方向。現在，我將進一步深入，為你詳細介紹<strong>系列的架構與各個章節安排。</strong></p><p>可以說，本文就是整個系列的<strong>藍圖。</strong></p><p>一般而言，架構介紹通常會直接放在第一篇的後半段（如果有的話），但我決定<strong>獨立成一篇。</strong></p><p>原因無他，<strong>我在整個教學架構上花費了相當的心思，希望為讀者提供一個全面的概覽</strong>。這有助於你快速進入狀況，並了解自己目前正在學習主題哪一個部分。</p><p>話不說多，讓我們一一介紹。</p><span id="more"></span><hr><p>本系列共分為八章，<strong>只有第三章有細分小節</strong>——因為內容較多。</p><p>以下是各章節介紹。（各篇名稱與內容仍可能會有小幅調整，但整體架構不變）</p><h2 id="第一章：導讀與-Django-Ninja-介紹"><a href="#第一章：導讀與-Django-Ninja-介紹" class="headerlink" title="第一章：導讀與 Django Ninja 介紹"></a>第一章：導讀與 Django Ninja 介紹</h2><p>開篇介紹本系列的主旨、定位，適合的目標讀者，以及學習 Django Ninja 的理由。</p><p>架構篇中，說明系列的安排與組成、每篇文章的主要內容與學習順序。</p><p>最後為讀者介紹 Django Ninja 與 Django REST Framework 等基本概念，包括彼此的定位與異同。</p><ul><li><strong>卷 1：系列導讀 × 目標讀者</strong></li><li><strong>卷 2：架構 × 章節導覽</strong>（本篇）</li><li><strong>卷 3：Django Ninja 介紹——與 Django REST framework 主要區別</strong></li></ul><h2 id="第二章：範例專案與環境設定"><a href="#第二章：範例專案與環境設定" class="headerlink" title="第二章：範例專案與環境設定"></a>第二章：範例專案與環境設定</h2><p>介紹系列的範例專案——<a href="https://github.com/kyomind/Django-Ninja-Tutorial">Django-Ninja-Tutorial</a>，透過具體的程式碼改動，作為學習過程中的參考。（覺得專案有用心的話，<strong>千萬不要吝嗇你的 🌟 哦！</strong>🥰）</p><p>範例程式碼是學習新技術的良師益友，也是我的嘔心瀝血之作 😭</p><p>我們也會介紹專案所使用的 Python 開發工具，讓讀者能體驗真實的開發環境。</p><p>最後，我們會一步一步帶著你，讓專案能夠在你的本機環境運行。</p><ul><li><strong>卷 4：範例專案介紹</strong></li><li><strong>卷 5：Python 現代開發工具介紹</strong></li><li><strong>卷 6：環境設定 × 如何使用本專案</strong></li></ul><hr><h2 id="第三章：Django-Ninja-基本功"><a href="#第三章：Django-Ninja-基本功" class="headerlink" title="第三章：Django Ninja 基本功"></a>第三章：Django Ninja 基本功</h2><p>Django Ninja 的核心部分，任何一個 API 開發者都需要熟悉的基本功。</p><p>本章總共分成三大部分：<strong>路由、請求與回應</strong>。</p><h3 id="第一節：路由（Routers）"><a href="#第一節：路由（Routers）" class="headerlink" title="第一節：路由（Routers）"></a>第一節：路由（Routers）</h3><p><strong>端點（endpoints）與路由是 API 的起點。</strong></p><p>Django Ninja 的路由設定方式，與傳統 Django 有很大不同。因此，我們將路由放在第一位，作為學習 API 開發的入口。</p><ul><li><strong>卷 7：路由（上）傳統 Django 路由做法（兼章節概論）</strong></li><li><strong>卷 8：路由（下）Django Ninja 路由</strong></li></ul><h3 id="第二節：請求（Request）"><a href="#第二節：請求（Request）" class="headerlink" title="第二節：請求（Request）"></a>第二節：請求（Request）</h3><p>路由之後是 HTTP 請求，講述 Django Ninja 處理請求的三大重點：路徑參數、查詢參數和請求主體（body）。</p><p>其中最重要的是 body，將使用 Django Ninja Schema（即 Pydantic BaseModel）來進行資料接收與驗證。</p><ul><li><strong>卷 9：請求（一）Django Ninja 處理請求概論（兼論 FBVs）</strong></li><li><strong>卷 10：請求（二）Path Parameters</strong></li><li><strong>卷 11：請求（三）Query Parameters</strong></li><li><strong>卷 12：請求（四）Request Body 與 Schema 介紹</strong></li></ul><h3 id="第三節：回應（Response）"><a href="#第三節：回應（Response）" class="headerlink" title="第三節：回應（Response）"></a>第三節：回應（Response）</h3><p>請求之後是回應，回應仍需要使用 Schema，<strong>但變化比請求更多。</strong></p><p>本節將介紹回應的基本架構、處理方式、巢狀 Schema，以及 Resolver 方法。</p><ul><li><strong>卷 13：回應（一）Django Ninja 處理回應概論</strong></li><li><strong>卷 14：回應（二）Nested Response</strong></li><li><strong>卷 15：回應（三）為什麼不使用 ModelSchema？—— Django Ninja 與 DRF 的設計理念比較</strong></li><li><strong>卷 16：回應（四）Resolver 方法（類似 DRF 的 SerializerMethodField）</strong></li></ul><hr><h2 id="第四章：API-文件"><a href="#第四章：API-文件" class="headerlink" title="第四章：API 文件"></a>第四章：API 文件</h2><p>掌握了 Django Ninja 如何處理請求與回應後，剩下的另一關鍵就是 API 文件。</p><p>API 文件的<strong>品質與可讀性</strong>對 API 使用者至關重要，本章將介紹 Django Ninja 在<strong>自動化產生 API 文件</strong>中的應用，並分享我認為的一些好的實踐。</p><ul><li><strong>卷 17：API 文件的實踐重點</strong></li><li><strong>卷 18：Pydantic 與 API 文件</strong></li></ul><h2 id="第五章：資料驗證與錯誤處理"><a href="#第五章：資料驗證與錯誤處理" class="headerlink" title="第五章：資料驗證與錯誤處理"></a>第五章：資料驗證與錯誤處理</h2><p>資料驗證和錯誤處理關係到 API 的穩定與可靠。本章探討如何在 Django Ninja 中有效地進行資料驗證和錯誤捕捉，確保 API 的健壯性。</p><ul><li><strong>卷 19：資料驗證</strong></li><li><strong>卷 20：錯誤處理</strong></li></ul><hr><h2 id="第六章：進階功能"><a href="#第六章：進階功能" class="headerlink" title="第六章：進階功能"></a>第六章：進階功能</h2><p>雖說是入門，但我們仍有必要介紹 API 的<strong>常見進階功能</strong>。這些技術將協助你應對大型專案中的典型挑戰。</p><p>本章目標不是逐步引導你完成每個功能的實作，而是聚焦展示它們的<strong>概念與應用場景</strong>。你可以依據這些提示，自行深入學習與應用。</p><ul><li><strong>卷 21：檔案上傳</strong></li><li><strong>卷 22：分頁（Pagination）</strong></li><li><strong>卷 23：過濾（Filtering）</strong></li><li><strong>卷 24：限流（Throttling）</strong></li><li><strong>卷 25：快取（Caching）</strong></li></ul><h2 id="第七章：其他重要事項"><a href="#第七章：其他重要事項" class="headerlink" title="第七章：其他重要事項"></a>第七章：其他重要事項</h2><p>本章將介紹幾個後端專案中不可或缺的主題，雖然它們與 Django Ninja 無直接關聯，但對於後端開發者來說，是必須掌握的技能。</p><ul><li><strong>卷 26：認證（Authentication）</strong></li><li><strong>卷 27：單元測試（一）Test Client 與 pytest Fixtures</strong></li><li><strong>卷 28：單元測試（二）測試函式與覆蓋率</strong></li><li><strong>卷 29：部署——Gunicorn 與容器化</strong></li></ul><h2 id="第八章：系列回顧與完賽心得"><a href="#第八章：系列回顧與完賽心得" class="headerlink" title="第八章：系列回顧與完賽心得"></a>第八章：系列回顧與完賽心得</h2><p>簡單回顧整個系列，並分享我在本次鐵人賽的創作心得與感想。</p><ul><li><strong>卷 30：系列回顧與完賽心得</strong></li></ul><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>通過這篇導覽，你已經對整個系列的架構有了清晰的認識。接下來的每一篇文章都會按照這個藍圖，循序漸進地帶領你學習 Django Ninja。</p><p>下一篇，我們將正式介紹 Django Ninja，並與老牌的 Django REST Framework 進行比較，了解兩者在 API 開發的主要功能差異與適用場景。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇中，我們講述了系列的整體方向。現在，我將進一步深入，為你詳細介紹&lt;strong&gt;系列的架構與各個章節安排。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以說，本文就是整個系列的&lt;strong&gt;藍圖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般而言，架構介紹通常會直接放在第一篇的後半段（如果有的話），但我決定&lt;strong&gt;獨立成一篇。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原因無他，&lt;strong&gt;我在整個教學架構上花費了相當的心思，希望為讀者提供一個全面的概覽&lt;/strong&gt;。這有助於你快速進入狀況，並了解自己目前正在學習主題哪一個部分。&lt;/p&gt;
&lt;p&gt;話不說多，讓我們一一介紹。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 教學 01：系列導讀 × 目標讀者</title>
    <link href="https://blog.kyomind.tw/django-ninja-01/"/>
    <id>https://blog.kyomind.tw/django-ninja-01/</id>
    <published>2024-09-13T01:48:14.000Z</published>
    <updated>2024-09-13T03:38:16.811Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的<strong>基礎實作</strong>，透過<strong>文字教學</strong>與<strong>範例專案</strong>的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。</p><p>作為 Django 生態系統中的新星（誕生於 2020 年），Django Ninja 融合了 Django 的穩定性和 FastAPI 的現代特性——<strong>Python 的型別提示（透過 Pydantic 實現）</strong>。這種<strong>強強結合</strong>，為開發者提供了一個健全、高效、直觀的 API 開發體驗。</p><p>不論你是經驗豐富的 Django 開發者，還是剛進入 API 開發領域的新手，這個系列都會為你提供實用的 Django Ninja 實戰經驗與技巧。</p><p>我們將從背景介紹、基礎概念開始，逐步深入探討 Django Ninja 的每個部分，幫助你快速掌握這個現代化 API 開發工具。</p><hr><h2 id="建議前置技能"><a href="#建議前置技能" class="headerlink" title="建議前置技能"></a>建議前置技能</h2><p>本系列的定位是「入門級」，但這裡所謂的入門，指的是 Django Ninja 框架的入門。</p><p>所以，要充分利用好教學內容與範例專案程式碼，<strong>仍建議讀者具備以下技能：</strong></p><ul><li><strong>Python 基礎知識</strong>：熟悉 Python 語法，有 Python 開發經驗者佳。</li><li><strong>Django 基礎</strong>：了解 Django 的基本組成，比如 ORM、Views、MTV 架構等。但無須了解 <a href="https://docs.djangoproject.com/en/5.1/topics/templates/">Templates</a> 部分——因為我們是開發 API。</li><li><strong>HTTP 與 Web API 概念</strong>：知道什麼是 HTTP、Web API、前後端分離，並對 RESTful API 設計原則有基本理解。</li><li><strong>版本控制</strong>：為了能夠善用並操作範例專案，需要熟悉 Git、GitHub 的基本操作。</li></ul><p>具備這些技能將幫助你更好地理解和應用本系列的內容。如果你對某些概念不太熟悉，也不用擔心，我們會在必要時進行一定的講解。</p><span id="more"></span><hr><h2 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h2><p>本系列「特別適合」以下讀者。你不妨看看自己屬於哪一種。</p><h3 id="一、Python-後端入門者"><a href="#一、Python-後端入門者" class="headerlink" title="一、Python 後端入門者"></a>一、Python 後端入門者</h3><p>想了解 Python 後端開發，尤其是如何建立高品質的 API。</p><h3 id="二、Django-開發者"><a href="#二、Django-開發者" class="headerlink" title="二、Django 開發者"></a>二、Django 開發者</h3><p>無論是全端或後端，所有 Django 開發者，都是本系列的目標讀者。</p><h3 id="三、FastAPI-開發者"><a href="#三、FastAPI-開發者" class="headerlink" title="三、FastAPI 開發者"></a>三、FastAPI 開發者</h3><p>對於已有 FastAPI 開發基礎的讀者，要上手 Django Ninja 應該是易如反掌🤚</p><h3 id="四、想要提升-API-開發效率的開發者"><a href="#四、想要提升-API-開發效率的開發者" class="headerlink" title="四、想要提升 API 開發效率的開發者"></a>四、想要提升 API 開發效率的開發者</h3><p>Django Ninja 提供了簡潔、快速的 API 開發方式。</p><p>其中的一大賣點是「<strong>透過 Pydantic 與 Python type hints 自動生成 API 文件</strong>」，讓你再也不用苦惱於如何撰寫優質的 API 文件。</p><p>對於非 Python 開發者，想要在一些小專案實作規模不大的功能，Django Ninja 提供了極具吸引力的選擇。</p><h3 id="五、想熟悉-Type-Hints-的-Python-開發者"><a href="#五、想熟悉-Type-Hints-的-Python-開發者" class="headerlink" title="五、想熟悉 Type Hints 的 Python 開發者"></a>五、想熟悉 Type Hints 的 Python 開發者</h3><p>我曾在〈<a href="https://blog.kyomind.tw/robust-python-01/">《強健的 Python》筆記（一）Type Hints 的成本與挑戰</a>〉提到：</p><blockquote><p>寫 Django Ninja（或 FastAPI），<strong>你本來就要書寫大量 type hints，來產生正確、合理的 API 文件</strong>。那要求為專案的其餘部分，比如自定義的函式、類別加上 type hints，<strong>阻力相對就小得多。</strong></p></blockquote><blockquote><p>在我看來，這類採用了 Pydantic 框架所帶來的效應，就像腳踏車的輔助輪，在剛起步使用 type hints 時，<strong>有著明顯的正面引導效果。</strong></p></blockquote><p>Python type hints 如果缺乏實際應用場景，往往會讓人感到<strong>寫這些東西很辛苦，甚至有點多餘</strong>，這是人之常情。</p><p>而最好的應用場景，就是<strong>工具本身就要求你一定要寫，並且你能夠從中直接獲得效益</strong>——Django Ninja 正是如此。</p><hr><h2 id="方向與取捨"><a href="#方向與取捨" class="headerlink" title="方向與取捨"></a>方向與取捨</h2><p>在本系列中，我們將專注於 Django Ninja 的核心功能和實際應用，目的是幫助開發者快速上手並實作 API。</p><p>為了確保內容的<strong>實用性和針對性</strong>，我們對內容做出了一些取捨：</p><ul><li><strong>專注於 API 開發</strong>：如何使用 Django Ninja 來定義路由、處理請求與回應等。這些功能是實際應用中最常見的需求，更是初學者應該優先掌握的部分。</li><li><strong>聚焦於同步操作</strong>：儘管 Django Ninja 支援非同步操作（async），但 Django 本身對非同步的支援仍在逐步完善中。<ul><li>為了避免初學者被不必要的技術細節混淆，<strong>我們將只涵蓋同步操作。</strong></li><li>這不僅簡化了開發流程，也能確保與目前主流的 Django 使用習慣保持一致。</li></ul></li><li><strong>略過與 API 開發無關的部分</strong>：Django 作為一個大而全的框架，包含了許多超出 API 開發範疇的功能，例如國際化（i18n）、模板引擎等。<ul><li>這些功能雖然對一些應用場景很重要，但它們與本系列主題相關性不高，因此我們會選擇略過。</li><li>單元測試、部署、容器化等部分，則會<strong>擇要提及</strong>，不會完整介紹。</li></ul></li><li><strong>特別著重於 API 文件的建立與品質</strong>：清晰且高品質的 API 文件是現代軟體開發中不可或缺的部分，特別是在團隊合作或開放 API 給第三方使用時至關重要。<ul><li>Django Ninja 擁有從程式碼自動產生 API 文件的功能，我們將深入探討如何有效利用這項功能。</li><li><strong>何謂深入？</strong>確保 API 文件不僅能自動產生，<strong>還能具備高度的可讀性和準確性</strong>——前端人員表示欣慰。</li></ul></li></ul><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>了解完系列的整體方向後，接下來，我將介紹<strong>本系列的架構與章節安排</strong>，讓你從一開始就知曉每個章節的重點，並了解如何循序漸進地學習 Django Ninja 的核心功能。</p><p>在下一篇文章中，我會具體介紹<strong>每個章節的主軸與重點</strong>，幫助你掌握整個系列的內容安排，<strong>為後續學習做好準備。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的&lt;strong&gt;基礎實作&lt;/strong&gt;，透過&lt;strong&gt;文字教學&lt;/strong&gt;與&lt;strong&gt;範例專案&lt;/strong&gt;的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。&lt;/p&gt;
&lt;p&gt;作為 Django 生態系統中的新星（誕生於 2020 年），Django Ninja 融合了 Django 的穩定性和 FastAPI 的現代特性——&lt;strong&gt;Python 的型別提示（透過 Pydantic 實現）&lt;/strong&gt;。這種&lt;strong&gt;強強結合&lt;/strong&gt;，為開發者提供了一個健全、高效、直觀的 API 開發體驗。&lt;/p&gt;
&lt;p&gt;不論你是經驗豐富的 Django 開發者，還是剛進入 API 開發領域的新手，這個系列都會為你提供實用的 Django Ninja 實戰經驗與技巧。&lt;/p&gt;
&lt;p&gt;我們將從背景介紹、基礎概念開始，逐步深入探討 Django Ninja 的每個部分，幫助你快速掌握這個現代化 API 開發工具。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;建議前置技能&quot;&gt;&lt;a href=&quot;#建議前置技能&quot; class=&quot;headerlink&quot; title=&quot;建議前置技能&quot;&gt;&lt;/a&gt;建議前置技能&lt;/h2&gt;&lt;p&gt;本系列的定位是「入門級」，但這裡所謂的入門，指的是 Django Ninja 框架的入門。&lt;/p&gt;
&lt;p&gt;所以，要充分利用好教學內容與範例專案程式碼，&lt;strong&gt;仍建議讀者具備以下技能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Python 基礎知識&lt;/strong&gt;：熟悉 Python 語法，有 Python 開發經驗者佳。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django 基礎&lt;/strong&gt;：了解 Django 的基本組成，比如 ORM、Views、MTV 架構等。但無須了解 &lt;a href=&quot;https://docs.djangoproject.com/en/5.1/topics/templates/&quot;&gt;Templates&lt;/a&gt; 部分——因為我們是開發 API。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP 與 Web API 概念&lt;/strong&gt;：知道什麼是 HTTP、Web API、前後端分離，並對 RESTful API 設計原則有基本理解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本控制&lt;/strong&gt;：為了能夠善用並操作範例專案，需要熟悉 Git、GitHub 的基本操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具備這些技能將幫助你更好地理解和應用本系列的內容。如果你對某些概念不太熟悉，也不用擔心，我們會在必要時進行一定的講解。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/categories/Django-Ninja/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>2024 iThome 鐵人賽參賽思路：主題選擇、命名與標題策略</title>
    <link href="https://blog.kyomind.tw/2024-ironman-event/"/>
    <id>https://blog.kyomind.tw/2024-ironman-event/</id>
    <published>2024-09-12T07:15:09.000Z</published>
    <updated>2024-09-12T12:56:46.004Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>明天——13 號星期五——就是我參加今年 iThome 鐵人賽的正式開賽日。</p><p>開賽前夕，我想用本文介紹一下我的參賽主題與相關花絮。</p><p>不會提及太多技術，主要以一些個人思考及感受為主。</p><hr><p>不過在開始前，歡迎在鐵人賽網站上<strong>訂閱</strong>我的「<a href="https://ithelp.ithome.com.tw/users/20167825/ironman/7451">Django 忍法帖——Django Ninja 入門指南</a>」系列 🥰。文章也會<strong>在部落格同步發表。</strong></p><p>我為此投入了大量時間心力，還辭去了工作（誤），相信不會讓你失望。</p><p>行有餘力，也可以多多支持我們「<a href="https://ithelp.ithome.com.tw/2024ironman/signup/team/339">AI 寶寶上學去！</a>」小隊成員們的作品。</p><p>大家都是第一次參賽，非常需要您的鼓勵。</p><p>好，讓我們進入「正題」。</p><span id="more"></span><hr><h2 id="參賽主題選擇"><a href="#參賽主題選擇" class="headerlink" title="參賽主題選擇"></a>參賽主題選擇</h2><p>選擇參賽主題的無疑是最難的部分，如同我在〈<a href="https://blog.kyomind.tw/weekly-review-32/">32，下半年寫作目標</a>〉說的：</p><blockquote><p>我覺得「<strong>不大不小</strong>」的主題是最適合的。主題太大，不好下筆不說，可能已經有很多人寫過了，比如 Python 相關，需要自己再細分範疇。</p></blockquote><p>這麼說的話，我今年會首次參賽，也許只是因為剛好遇到了這個不大不小的主題——Django Ninja。</p><p>在工作上用了幾個月，覺得不錯，加上 <a href="https://fastapi.tiangolo.com/">FastAPI</a> 已經蔚為風潮好幾年，是時候讓 Django 生態系也有點新花樣了！</p><p>還有另一個理由，我在自己的部落格上連載著「<a href="https://blog.kyomind.tw/series/#Django-REST-framework-%E6%95%99%E5%AD%B8">Django REST framework 教學</a>」系列。</p><p>如你所見，這個系列寫作速度非常緩慢，其中一個主要原因，就是在接觸了 Django Ninja 之後，我變得好不想再碰 Django REST framework XD</p><p>所以，我決定以「Django Ninja」為主題參加鐵人賽，暫時擺脫 DRF 這個創作上的泥淖😷</p><hr><h2 id="如何為參賽主題命名？"><a href="#如何為參賽主題命名？" class="headerlink" title="如何為參賽主題命名？"></a>如何為參賽主題命名？</h2><p>為系列取個好名稱，我想是每個參賽者都希望的——但還真是不容易。</p><p>觀察眾多參賽主題可以看出，鐵人賽的命名氛圍一定程度受到了 ACG 圈子的影響。</p><p>其中最有名的大概就是「從零開始」系列，相關的主題可說<a href="https://ithelp.ithome.com.tw/2024ironman/signup/list?keyword=%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B">不計其數</a>。這是一個不錯的切入，也符合鐵人賽大部分文章都是<strong>面向新手</strong>的特性。</p><p>而我最終選擇了「<strong>忍法帖</strong>」這個稍微不同的命名。這個名稱不僅呼應了 Django Ninja 的「<strong>忍者</strong>」意象，也暗示了這個系列將會是一本實用的「<strong>秘笈</strong>」，包含了許多有用的技巧和知識。</p><p>更重要的是，寫程式的都知道，但我們提到「<strong>某某 Ninja</strong>」的時候，就是指很厲害的意思！😎</p><p>後來我覺得，系列的命名可能還是其次，更重要的是，每篇文章標題要怎麼跟系列名稱搭配。</p><p>這就要講到下面要說的：<strong>文章標題的前綴議題。</strong></p><hr><h2 id="如何決定文章標題前綴？"><a href="#如何決定文章標題前綴？" class="headerlink" title="如何決定文章標題前綴？"></a>如何決定文章標題前綴？</h2><p>標題前綴，這什麼東西？</p><p>這是指系列中的每一篇文章，<strong>在標題中都會有的「共同元素」</strong>，這個共同元素大多是以「標題的前綴」形式出現的。</p><p>最常見的標題前綴，就是「<strong>Day XX</strong>」。</p><p>這不難理解，畢竟鐵人賽就是一個為期 30 天的比賽。使用這樣的前綴，再自然不過。</p><p>而我為了配合我的主題名稱，所以會採用「<strong>卷 1</strong>」、「<strong>卷 2</strong>」這樣形式的前綴，感覺也是別有一番趣味。</p><p>當然，這些做法並非絕對，比如去年 <a href="https://ithelp.ithome.com.tw/2023ironman/cloud-native">Cloud Native</a> 的冠軍——「<a href="https://ithelp.ithome.com.tw/users/20162175/ironman/6445">時光之鏡：透視過去、現在與未來的 Observability</a>」系列，則反其道而行，不採用任何前綴。一眼望去，是不是也有幾分「霸氣外露」之感呢？</p><p>總的來說，無論是系列名稱還是文章前綴，主要是增加寫作上的「<strong>趣味性</strong>」，自己喜歡就行。</p><hr><p>本文講得相對粗淺，但不誇張的說，我還真的花了好些時間在這些「<strong>命名</strong>」上面。</p><p>只不過這些命名，並沒有一個很明確的<strong>通用法則</strong>可以供你參考，我只能聊聊我思考過的點點滴滴。</p><p>等完賽一段時間後，我還會寫一篇更全面的準備心得，敬請期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;明天——13 號星期五——就是我參加今年 iThome 鐵人賽的正式開賽日。&lt;/p&gt;
&lt;p&gt;開賽前夕，我想用本文介紹一下我的參賽主題與相關花絮。&lt;/p&gt;
&lt;p&gt;不會提及太多技術，主要以一些個人思考及感受為主。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不過在開始前，歡迎在鐵人賽網站上&lt;strong&gt;訂閱&lt;/strong&gt;我的「&lt;a href=&quot;https://ithelp.ithome.com.tw/users/20167825/ironman/7451&quot;&gt;Django 忍法帖——Django Ninja 入門指南&lt;/a&gt;」系列 🥰。文章也會&lt;strong&gt;在部落格同步發表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我為此投入了大量時間心力，還辭去了工作（誤），相信不會讓你失望。&lt;/p&gt;
&lt;p&gt;行有餘力，也可以多多支持我們「&lt;a href=&quot;https://ithelp.ithome.com.tw/2024ironman/signup/team/339&quot;&gt;AI 寶寶上學去！&lt;/a&gt;」小隊成員們的作品。&lt;/p&gt;
&lt;p&gt;大家都是第一次參賽，非常需要您的鼓勵。&lt;/p&gt;
&lt;p&gt;好，讓我們進入「正題」。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
</feed>
