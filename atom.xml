<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/favicon-32x32.png</icon>
  <subtitle>Kyo 的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2026-02-05T14:07:36.451Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我可能會付費 Perplexity</title>
    <link href="https://blog.kyomind.tw/perplexity/"/>
    <id>https://blog.kyomind.tw/perplexity/</id>
    <published>2025-12-28T14:29:52.000Z</published>
    <updated>2026-02-05T14:07:36.451Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/img-20251221-160338.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><blockquote><p><code>2026/02/05</code>更新：這幾天 <a href="#%E6%88%91%E6%9C%80%E5%96%9C%E6%AD%A1%E7%9A%84-Research-%E5%8A%9F%E8%83%BD">Research</a> 功能的「次數」不知為何大幅減少，以前每天都剩 100 多次，今天竟然只剩 20 次——這根本不敷使用！如果這樣的緊縮額度持續，那我不會考慮付費。</p></blockquote><p>我從來沒想有過自己會考慮為 Perplexity 付費。</p><p>畢竟，我已經訂閱了好幾個 AI 聊天服務，對「又一個 AI 工具」著實沒有太多期待。</p><p>但用了三個多禮拜之後，這個想法有點動搖了。</p><h2 id="Perplexity-是什麼"><a href="#Perplexity-是什麼" class="headerlink" title="Perplexity 是什麼"></a>Perplexity 是什麼</h2><p>如果你還沒聽過 <a href="https://www.perplexity.ai/">Perplexity</a>，簡單說，它是一個主打「<strong>AI 搜尋</strong>」的服務。當你丟出一個問題時，它會幫你搜尋網路上的大量資料，整理重點，給出給答案。同時把來源清楚列出來。</p><p>它更像是一個<strong>被 AI 強化過的搜尋引擎</strong>，而不是單純的聊天機器人。</p><p>有了這東西，你可以用自然語言問問題，然後它會幫你找出相關資訊，並且用 AI 幫你整理成一個流暢易讀的答案。</p><span id="more"></span><hr><h2 id="原本不看好"><a href="#原本不看好" class="headerlink" title="原本不看好"></a>原本不看好</h2><p>大概半年前，我有用過 Perplexity 的免費版（主要是衝著它的 Research 功能），然而我對它的評價並不算高。</p><p>在我眼中，它就是一個「做得還不錯的 AI 搜尋工具」，重點放在 RAG、資料整理與引用來源。</p><p>這些東西確實有用，但我一直覺得，像 Google、OpenAI 這些大公司，只要認真做，應該很快就能追上，甚至直接輾壓過去。</p><h2 id="每月-20-美元的高級-RAG？"><a href="#每月-20-美元的高級-RAG？" class="headerlink" title="每月 20 美元的高級 RAG？"></a>每月 20 美元的高級 RAG？</h2><p>更具體來說，Perplexity 常被質疑的核心在於：AI 搜尋本質上是一種「高階 RAG」（<a href="https://aws.amazon.com/tw/what-is/retrieval-augmented-generation/">Retrieval-Augmented Generation</a>）——透過搜尋引擎抓取資料，再用 LLM 整理成答案。</p><p>這種技術路線的問題在於，它似乎<strong>沒有真正的護城河</strong>。只要你有搜尋能力、有 LLM，理論上就能做出類似的產品。</p><p>而 OpenAI、Google 這些科技巨頭，不僅有更強的模型訓練能力、更多的資料，還有近乎無限的資源可以燒。</p><p>一旦上述巨頭們決定將 AI 搜尋做得更好、更整合，Perplexity 這種夾層服務的價值就可能迅速歸零。</p><p>這也是為什麼在許多開發者眼裡，它是一個隨時可能被取代的產品。</p><hr><h2 id="免費你送一年-Pro-方案，要不要？"><a href="#免費你送一年-Pro-方案，要不要？" class="headerlink" title="免費你送一年 Pro 方案，要不要？"></a>免費你送一年 Pro 方案，要不要？</h2><p>今年——2025 年，Perplexity 官方非常積極地在推廣，透過各種管道送出免費一年的 Pro 方案。</p><p>可以想見，這種大規模的免費推廣策略，明顯就是想快速累積用戶，讓更多人真正用過之後，願意在一年後續費。</p><p>我自己的資格來源則是 PayPal：只要是 PayPal 會員，就能<a href="https://www.bnext.com.tw/article/84386/perplexity-pro-free">免費兌換</a> Perplexity 一年的 Pro 方案。</p><hr><h2 id="付費太多-AI-服務"><a href="#付費太多-AI-服務" class="headerlink" title="付費太多 AI 服務"></a>付費太多 AI 服務</h2><p>上一篇〈<a href="/essential-subscriptions-2025/">2025 我離不開的 8 項付費訂閱</a>〉提到我有訂閱  ChatGPT Plus、Claude Pro，最近還訂了 Google AI Pro。</p><p>三個聊天機器人了！</p><p>因此，對於這個免費送上門的大禮，不禁有點「用不過來」的感覺。</p><h3 id="一開始根本懶得兌換"><a href="#一開始根本懶得兌換" class="headerlink" title="一開始根本懶得兌換"></a>一開始根本懶得兌換</h3><p>當我知道 Perplexity 有送免費一年的付費方案時，我的第一個反應不是興奮，而是懶。</p><p>心裡想的是：「我現在已經有好幾個在付費使用的 AI 聊天服務了，根本沒有多餘的精力再認真用一個新的服務。」</p><h3 id="不拿白不拿"><a href="#不拿白不拿" class="headerlink" title="不拿白不拿"></a>不拿白不拿</h3><p>接近兌換的截止期限（今年年底），我心裡還是冒出那個很經典的念頭：「反正是免費的，不拿白不拿！」</p><p>我甚至很清楚，這大概就是 Perplexity 預期中的使用者心理——它就是篤定你會抱著這種「先拿再說」的心情兌換，然後在某個時刻真的願意為它付費。</p><p>我不覺得我會，但我還是兌換了。</p><hr><h2 id="好像有點意思"><a href="#好像有點意思" class="headerlink" title="好像有點意思"></a>好像有點意思</h2><p>從 12&#x2F;5 開始用，到現在差不多快一個月。</p><p>我發現，我愛上它了。</p><p>倒不是 Perplexity 有什麼特別炫的功能，而是我用它的頻率確實很高。</p><p>想想原因也不難理解，因為它解決了一個我很常遇到的需求：<strong>快速搜尋並整理資訊</strong>。</p><h2 id="AI-搜尋是一個明確的使用場景"><a href="#AI-搜尋是一個明確的使用場景" class="headerlink" title="AI 搜尋是一個明確的使用場景"></a>AI 搜尋是一個明確的使用場景</h2><p>這讓我重新意識到：AI 搜尋其實是一個<strong>非常明確的使用場景</strong>。</p><p>當我想用 AI 來搜尋資料時，我期待的不是陪我聊天、也不是幫我發揮創意——這是我對 ChatGPT、Claude 的用法。</p><p>而是快速蒐集大量資訊，幫我整理、過濾，讓我更快抓到重點。</p><p>關鍵是，我知道，這些資訊<strong>「必須」透過網路搜尋</strong>才能更加完整、正確。</p><h2 id="真的沒有護城河？"><a href="#真的沒有護城河？" class="headerlink" title="真的沒有護城河？"></a>真的沒有護城河？</h2><p>問題不在於 ChatGPT 或 Gemini 做不到這件事，而是它們沒有——未來可能也不會——把重心放在這裡。</p><p>Google：網路搜尋就是它的核心業務，怎麼可能希望你僅僅透過聊天機器人來搜尋？</p><p>OpenAI：競爭激烈，搞模型都來不及了，哪有時間優化 AI 搜尋品質？（話說回來 o3 時期曾讓我非常驚艷，但已成追憶）</p><p>Claude：<strong>AI 輔助程式設計</strong>才是它的絕對主場XD。</p><p>簡單來說，這些大公司<strong>沒有動機</strong>把 AI 搜尋做得很好，因為它們的核心業務不在這裡。</p><hr><p>講講我覺得 Perplexity 好用的地方。</p><p>附帶一提，Pro 和免費的搜尋品質有一定差距，難怪以前我並不覺得它好用。</p><h2 id="具體有用在哪？"><a href="#具體有用在哪？" class="headerlink" title="具體有用在哪？"></a>具體有用在哪？</h2><p>舉例來說，如果我想和 ChatGPT 聊聊《<a href="https://zh.wikipedia.org/zh-tw/%E5%A4%A7%E6%98%8E%E7%8E%8B%E6%9C%9D1566">大明王朝 1566</a>》的劇情，或討論「日本高度人才簽證」的細節，它肯定答不好。</p><p>要嘛是訓練的語料不夠多，要嘛就是資訊不夠新。</p><p>以前遇到這種情況，我可能會自己去搜尋資料。但坦白說，絕大部分的事，都沒有重要到需要我親自去搜尋、整理。</p><p>現在有了 Perplexity，交給它就好。這就是我最常用它的場景。</p><h2 id="我最喜歡的-Research-功能"><a href="#我最喜歡的-Research-功能" class="headerlink" title="我最喜歡的 Research 功能"></a>我最喜歡的 Research 功能</h2><p>自從 OpenAI 率先推出「<a href="https://openai.com/zh-Hant/index/introducing-deep-research/">Deep Research</a>」後，許多 AI 服務都跟進了類似的功能。</p><p>目前評價最高的是 OpenAI 和 Google。雖然搜尋用時往往比較久，但搜尋深度和品質都很好。</p><p>但是！我要說「<strong>但是</strong>」。</p><p>上述服務我都有訂，但我最常用的，還是 Perplexity 的 <a href="https://www.perplexity.ai/hub/blog/introducing-perplexity-deep-research">Research</a> 功能。</p><p>原因有三：</p><ol><li>它的搜尋深度普通，但速度較快，大概 30 秒到 2 分鐘之間就能出結果。唉！時間很重要，而且大部分的主題，也不值得我花上 5 分鐘等待😅</li><li>產出報告的排版很美！我真的很受不了 ChatGPT 那亂七八糟的排版XD</li><li>有 AI 產生的圖表支援！</li></ol><p><img src="https://img.kyomind.tw/img-20251228-223520.png" alt="附圖表的研究報告"><span class="cap">附圖表的研究報告</span></p><p>簡而言之，和「AI 搜尋」的情況類似，Perplexity 的 Research 功能，被認真視為產品的重要一環，擁有良好的使用者體驗——至少對我來說如此。</p><p>至於 AI 巨頭們，顯然暫時不會有時間、心力把這些邊緣功能做得很好。</p><hr><h2 id="結語：可能會付費"><a href="#結語：可能會付費" class="headerlink" title="結語：可能會付費"></a>結語：可能會付費</h2><p>現在才用了 Perplexity 快一個月，距離真正需要掏錢續費，還有很長一段時間。</p><p>即便如此，我已經可以很誠實地說：我可能會付費。</p><p>不是因為我特別喜歡這個產品，也不是因為它有多厲害的黑科技，而是在「AI 搜尋」這個情境下，它確實解決了我的需求。</p><p>此外，它的 UI 也得到我的高度贊賞——這讓我更願意花時間使用它。</p><p>至於一年後會不會真的續費，我還不知道。但至少現在，我已經不會輕易地說「它只是一個隨時可能被取代的產品」了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/img-20251221-160338.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;2026/02/05&lt;/code&gt;更新：這幾天 &lt;a href=&quot;#%E6%88%91%E6%9C%80%E5%96%9C%E6%AD%A1%E7%9A%84-Research-%E5%8A%9F%E8%83%BD&quot;&gt;Research&lt;/a&gt; 功能的「次數」不知為何大幅減少，以前每天都剩 100 多次，今天竟然只剩 20 次——這根本不敷使用！如果這樣的緊縮額度持續，那我不會考慮付費。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我從來沒想有過自己會考慮為 Perplexity 付費。&lt;/p&gt;
&lt;p&gt;畢竟，我已經訂閱了好幾個 AI 聊天服務，對「又一個 AI 工具」著實沒有太多期待。&lt;/p&gt;
&lt;p&gt;但用了三個多禮拜之後，這個想法有點動搖了。&lt;/p&gt;
&lt;h2 id=&quot;Perplexity-是什麼&quot;&gt;&lt;a href=&quot;#Perplexity-是什麼&quot; class=&quot;headerlink&quot; title=&quot;Perplexity 是什麼&quot;&gt;&lt;/a&gt;Perplexity 是什麼&lt;/h2&gt;&lt;p&gt;如果你還沒聽過 &lt;a href=&quot;https://www.perplexity.ai/&quot;&gt;Perplexity&lt;/a&gt;，簡單說，它是一個主打「&lt;strong&gt;AI 搜尋&lt;/strong&gt;」的服務。當你丟出一個問題時，它會幫你搜尋網路上的大量資料，整理重點，給出給答案。同時把來源清楚列出來。&lt;/p&gt;
&lt;p&gt;它更像是一個&lt;strong&gt;被 AI 強化過的搜尋引擎&lt;/strong&gt;，而不是單純的聊天機器人。&lt;/p&gt;
&lt;p&gt;有了這東西，你可以用自然語言問問題，然後它會幫你找出相關資訊，並且用 AI 幫你整理成一個流暢易讀的答案。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/img-20251221-160338.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>2025 我離不開的 8 項付費訂閱</title>
    <link href="https://blog.kyomind.tw/essential-subscriptions-2025/"/>
    <id>https://blog.kyomind.tw/essential-subscriptions-2025/</id>
    <published>2025-09-20T00:42:48.000Z</published>
    <updated>2025-09-28T04:03:35.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/weekly-review.png"></p><p>2 年前，我寫下這篇〈<a href="/essential-subscriptions-2023/">2023 那些我已不可或缺的「付費訂閱」推薦</a>〉，分享了當時對我而言最重要的 12 項付費訂閱。</p><p>並說明了「不可或缺」的定義：</p><blockquote><p>所謂的「不可或缺」，意思是一旦我停止訂閱，我的工作和生活都會出現挑戰。而挑戰的大小，就是這些訂閱項目對我的影響力與價值。</p></blockquote><p>但回頭再看，有些其實<strong>沒那麼重要</strong>啦😅</p><p>所以這個 2025 年版本，要認真檢視，只列出那些「真的無法取消」的訂閱。</p><p>本文所列出的 8 項，即使多數和 2 年前相同，我也會補充它們對我的「<strong>重要性變化</strong>」與現況。</p><p>它們都很重要，很難說哪個更優先，以下排名<strong>不分先後</strong>。</p><p>此外，和 2023 版重複的基本使用情境介紹，就不再贅述，請參考前文。</p><span id="more"></span><hr><h2 id="一、Setapp"><a href="#一、Setapp" class="headerlink" title="一、Setapp"></a>一、Setapp</h2><p>像 Cleanshot X、Paste、PopClip、TablePlus、TextSniper 這些工具，早已是我每日必備——沒有一天不用的！</p><p>和 2 年前相比，我從每個月 10 美元的單機訂閱，變成 15 美元的 Power User 方案（4 台機器），因為我開始需要<strong>多裝置使用</strong>。</p><p>無論是 10 美元或 15 美元，都不能算是便宜。我個人訂閱它的核心判斷標準，是裡面只要有 3-4 個你每天都會用到的 app，就算值得了。</p><blockquote><p>有興趣可以使用<a href="https://go.setapp.com/invite/ga4xxrhb">我的邀請連結</a>註冊，你、我皆可<strong>額外獲得一個月訂閱</strong>。</p></blockquote><hr><h2 id="二、ChatGPT-Plus"><a href="#二、ChatGPT-Plus" class="headerlink" title="二、ChatGPT Plus"></a>二、ChatGPT Plus</h2><p>前文提到：</p><blockquote><p>如果你問我，我對這個服務目前為止的定價接受度上限為何？我可能會說是每月 40 美元——可見我確實離不開它。</p></blockquote><p>兩年前的 ChatGPT，對我而言猶如神一般的存在，重要性無可比擬。</p><p>兩年過去，AI 聊天服務的選擇越來越多，有力的競爭對手也更多了。</p><p>現在的我，確確實實「<strong>只願意</strong>」花 20 美元訂閱 ChatGPT Plus。</p><p>但平心而論，目前 AI 服務付費主流多是 20 美元一個月，而 OpenAI 給的運算資源與使用量，還是很慷慨的——畢竟它很有錢！</p><hr><h2 id="三、Claude-Pro"><a href="#三、Claude-Pro" class="headerlink" title="三、Claude Pro"></a>三、Claude Pro</h2><p>Claude Pro 方案一樣是每月 20 美元，因日前的「<a href="https://www.threads.com/@code.me.maybe/post/DONWdBWgJq_/">前 3 個月半價優惠</a>」吸引而訂閱；不過另一方面，也是為了使用 <a href="https://claude.com/product/claude-code">Claude Code</a>。</p><p>Claude Pro 和 ChatGPT Plus 對我而言，存在一定程度上的<strong>互補關係</strong>。雖然兩者疊加起來的費用實在不便宜😅</p><h3 id="Claude-的專案功能（Projects）"><a href="#Claude-的專案功能（Projects）" class="headerlink" title="Claude 的專案功能（Projects）"></a>Claude 的專案功能（Projects）</h3><p>簡單來說，<a href="https://www.ithome.com.tw/news/163666">專案功能</a>是我持續訂閱 Claude Pro 的主要原因。</p><p>雖然這功能 ChatGPT 也有（或者說大家都有XD），但我個人覺得 Claude 版的 UI&#x2F;UX 設計較佳，所以我都用它的專案。</p><p>我主要用它來建立關於個人的「知識庫」，附上 10 份精心準備的個人背景資料，和 AI 一起討論人生與職涯——這需求對我來說很重要。</p><p>而且，每家 AI 的「個性」不同，我覺得 Claude 模型對 prompt 的遵守程度較高，尤其是我要求 AI 必須<strong>直白回應</strong>時。</p><p>ChatGPT 基於某種「<strong>偶像包袱</strong>」，預設的口吻往往偏溫和。但你要求它直白又容易矯枉過正。</p><p>像職涯規劃這種關鍵議題，我需要 AI 先「電」我，然後再提供適量的<strong>情緒價值</strong>（自我 PUA！——你該不會也好這口吧？）。</p><p>我目前還未大量使用 Claude Code，習慣問題！還在學習中。</p><hr><h2 id="四、GitHub-Copilot-Pro"><a href="#四、GitHub-Copilot-Pro" class="headerlink" title="四、GitHub Copilot Pro+"></a>四、GitHub Copilot Pro+</h2><p>便宜又大碗的 AI 程式開發助理。</p><p>上個月<a href="https://www.threads.com/@kyomind.tw/post/DN9hbl1gU8m">我從 Pro 升級到 Pro+</a>，每月 39 美元，年付則為 390 美元。</p><p>GitHub Copilot 仗著微軟爸爸的 Azure 算力資源作為靠山，在 LLM token 成本上就與其它競爭對手——比如 Cursor 更具優勢。</p><p>去年此時，Cursor 正火，很多人擔心 GitHub Copilot 地位不保，連我自己都<a href="https://blog.kyomind.tw/cursor/#%E7%B5%90%E8%AA%9E%EF%BC%9A%E7%AB%B6%E7%88%AD%E6%98%AF%E5%A5%BD%E4%BA%8B">不禁有此疑慮</a>。</p><p>現在看來，GitHub Copilot 仍是我最常用的 AI 開發助理。而且此刻的我，對於任何其它「IDE 型態」的 AI 開發助手，<strong>都已顯得興趣缺缺</strong>。</p><hr><h2 id="五、Bear：反璞歸真的筆記軟體"><a href="#五、Bear：反璞歸真的筆記軟體" class="headerlink" title="五、Bear：反璞歸真的筆記軟體"></a>五、Bear：反璞歸真的筆記軟體</h2><p>在〈<a href="/noteless/">逐漸被我遺忘的卡片筆記</a>〉發表後，Bear 逐漸成為我筆記的主力。</p><p>在歷經 Notion、Logseq 等「全能型」筆記軟體的洗禮後，我回到了 Bear。</p><p>唉，事情真的<strong>不用那麼複雜</strong>，筆記甚至也<strong>不是</strong>學習的神兵利器——實作才是。雖然有人說自己「<a href="https://github.com/kyomind#%E7%B0%A1%E4%BB%8B">不做筆記便不會學習</a>」，但這八成是個誤解啦！</p><p>我該放下了。</p><blockquote><p>相關文章：<a href="/bear/">Evernote 替代方案——筆記軟體 Bear 2 升級心得</a></p></blockquote><hr><h2 id="六、YouTube-Premium：內容沉迷的稅金"><a href="#六、YouTube-Premium：內容沉迷的稅金" class="headerlink" title="六、YouTube Premium：內容沉迷的稅金"></a>六、YouTube Premium：內容沉迷的稅金</h2><p>我仍然是 YouTube 的重度使用者，尤其在限制自己少碰社群平台後，YouTube 幾乎成為我獲取資訊的主要來源。</p><p>我知道看多了不健康啦！我有控制少看短影片。</p><blockquote><p>相關文章：<a href="/weekly-review-19/">AI 時代的生存指南（二）數位斷捨離</a></p></blockquote><p>恩……顯然還不夠。</p><hr><h2 id="七、TPASS：城市移動的自由感"><a href="#七、TPASS：城市移動的自由感" class="headerlink" title="七、TPASS：城市移動的自由感"></a>七、TPASS：城市移動的自由感</h2><p>TPASS 依然是我最喜歡的「物理型訂閱」，它給我的不只是通勤折扣，而是一種<strong>城市間游走的機動性與自由感</strong>。</p><p>無需計算轉乘、無需考慮里程、無需遲疑是否要改搭捷運，它讓我更像是這座城市的使用者，而不只是過客。</p><p>我酷愛這種感覺。</p><hr><h2 id="八、Hetzner：你需要一台機器"><a href="#八、Hetzner：你需要一台機器" class="headerlink" title="八、Hetzner：你需要一台機器"></a>八、Hetzner：你需要一台機器</h2><p>我從 DigitalOcean 轉向 Hetzner，單純是因為——<strong>太便宜了</strong>。</p><p>之前已經寫過兩篇文章介紹 Hetzner：</p><ul><li><a href="/hetzner/">Hetzner VPS 實測：比 DigitalOcean 更划算的選擇？</a></li><li><a href="/hetzner-vm/">在 Hetzner 開新 VM 指南：選機房、SSH 連線、設定防火牆</a></li></ul><p>Hetzner 以相同的價格，提供更好的性能與資源，<strong>這無疑是一種自由</strong>。除了延遲較高，已然無可挑剔。</p><p>我目前在 VM 上部署了：</p><ul><li><a href="https://www.usememos.com/">Memos</a>：輕量級筆記系統，參考〈<a href="/memos/">開源工具 Memos 介紹：寫日記的好選擇</a>〉</li><li><a href="https://umami.is/">Umami</a>：網站分析工具、GA4 替代品，參考〈<a href="/weekly-review-21/">在 VM 上部署 Umami 替代 GA4</a>〉</li><li><a href="https://wakapi.dev/">Wakapi</a>：開發時間統計工具、<a href="https://medium.com/code-and-me/%E7%94%A8-wakatime-%E8%87%AA%E6%88%91%E7%9B%A3%E6%8E%A7-f59599144e28">Wakatime</a> 替代品</li><li><a href="https://github.com/kyomind/WeaMind">WeaMind</a>：個人專案</li><li>Nginx、Certbot、<a href="https://www.portainer.io/">Portainer</a> 等等</li></ul><p>上述服務總共才用了 1 GB RAM，我還有 7 GB 的餘裕。</p><p>這樣 4 CPU、8GB RAM 規格的 VM，每月竟然只要 6.5 歐元，實在太划算了。</p><p>對開發者而言，用來部署工具、服務的<strong>基礎設施</strong>顯然不可或缺。而 Hetzner，就是我最喜歡的選擇，沒有之一。</p><blockquote><p>歡迎使用<a href="https://hetzner.cloud/?ref=gD26JqrE8c9t">我的推薦連結</a>註冊，你可以直接獲得 20 歐元的使用額度。</p></blockquote><hr><h2 id="結語：那些留下來的"><a href="#結語：那些留下來的" class="headerlink" title="結語：那些留下來的"></a>結語：那些留下來的</h2><p>這篇文章不算推薦文，比較像是一份選擇紀錄。</p><p>這些訂閱不一定是「最潮」、「最便宜」或「最多功能」，而是經過時間淘選後，我仍願意花錢留下來的服務。</p><p>它們對我來說，有的是生產力的延伸、有的是生活的潤滑、有的是創作的媒介。</p><p>希望這份清單對你有用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/weekly-review.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;2 年前，我寫下這篇〈&lt;a href=&quot;/essential-subscriptions-2023/&quot;&gt;2023 那些我已不可或缺的「付費訂閱」推薦&lt;/a&gt;〉，分享了當時對我而言最重要的 12 項付費訂閱。&lt;/p&gt;
&lt;p&gt;並說明了「不可或缺」的定義：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所謂的「不可或缺」，意思是一旦我停止訂閱，我的工作和生活都會出現挑戰。而挑戰的大小，就是這些訂閱項目對我的影響力與價值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但回頭再看，有些其實&lt;strong&gt;沒那麼重要&lt;/strong&gt;啦😅&lt;/p&gt;
&lt;p&gt;所以這個 2025 年版本，要認真檢視，只列出那些「真的無法取消」的訂閱。&lt;/p&gt;
&lt;p&gt;本文所列出的 8 項，即使多數和 2 年前相同，我也會補充它們對我的「&lt;strong&gt;重要性變化&lt;/strong&gt;」與現況。&lt;/p&gt;
&lt;p&gt;它們都很重要，很難說哪個更優先，以下排名&lt;strong&gt;不分先後&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此外，和 2023 版重複的基本使用情境介紹，就不再贅述，請參考前文。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/weekly-review.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
    <category term="Claude" scheme="https://blog.kyomind.tw/tags/Claude/"/>
    
    <category term="GitHub Copilot" scheme="https://blog.kyomind.tw/tags/GitHub-Copilot/"/>
    
    <category term="Setapp" scheme="https://blog.kyomind.tw/tags/Setapp/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
  </entry>
  
  <entry>
    <title>用 Side Project 學 CI：WeaMind 的 CI 實作策略</title>
    <link href="https://blog.kyomind.tw/weamind-ci/"/>
    <id>https://blog.kyomind.tw/weamind-ci/</id>
    <published>2025-08-31T06:56:59.000Z</published>
    <updated>2025-10-04T08:40:12.223Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/WeaMind-logo-min.png"></p><blockquote><p>📌 這是 <a href="https://github.com/kyomind/WeaMind/blob/main/blogs/README.md">WeaMind 系列</a> 的第 4 篇。<br>本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。</p></blockquote><p>〈<a href="/github-actions">GitHub Actions 入門：自動化 Lint、Format 與 Type Check</a>〉一文中，我們使用了 GitHub Actions 作為 CI（<a href="https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">持續整合</a>）的入門工具。</p><p>同時建立了軟體開發專案中最基本且常見的 CI 流程。</p><p>接下來，我將繼續介紹，WeaMind 專案中<strong>所有實作的 CI 項目</strong>，並說明我選擇它們的原因與設計原則。</p><p>本文依據的專案程式碼版本為 <a href="https://github.com/kyomind/WeaMind/tree/v0.5.1">v0.5.1</a>。</p><span id="more"></span><hr><h2 id="從-CRUD-到-CI-CD"><a href="#從-CRUD-到-CI-CD" class="headerlink" title="從 CRUD 到 CI&#x2F;CD"></a>從 CRUD 到 CI&#x2F;CD</h2><p>當我們剛開始軟體開發職涯時，確保功能與邏輯的正確，無疑是工作上的第一要務。</p><p>我們專注於「<strong>寫出正確的程式碼</strong>」（這時可能連「優雅」都還稱不上），而不太關心整個開發流程的健全度——或者說「還沒有能力」去關心。</p><p>我們忙著學習框架、查資料、確認 API response 是否符合 spec、debug 各種問題。</p><p>隨著年資增長，我們會發現一個殘酷現實：<strong>即使程式碼寫得再好，若部署流程設計不當，系統的穩定性仍然會大打折扣</strong>。</p><p>而 CI 正是<strong>連接開發與部署的關鍵橋樑</strong>，是守護程式碼品質與服務穩定的核心機制。</p><hr><p>那麼，一個專案的 CI 應該包含哪些項目？如何在「實用」與「簡潔」之間取得平衡？</p><p>這個答案自然得因地制宜——但也有一些<strong>共通原則</strong>。</p><p>這裡我以 WeaMind 專案為例，說明我在 CI 設計上的實作與考慮。</p><h2 id="WeaMind-CI-項目一覽"><a href="#WeaMind-CI-項目一覽" class="headerlink" title="WeaMind CI 項目一覽"></a>WeaMind CI 項目一覽</h2><p>我不會在這裡提供詳細的設定教學，因為每個專案的需求不同，而且<strong>只有在自己的專案中實際操作，才能真正理解每個設定的意義</strong>。</p><p>所以我們<strong>點到為止</strong>，但仍會提供一些基本的指引與參考。比起做法（問 AI 就足夠了），更重要的是其中的<strong>思路</strong>。</p><p>WeaMind 專案目前整合的 CI 項目如下，每一項都會說明實作方式與用途。</p><p>不過，一到五才是<strong>嚴格意義上的 CI</strong>；六、七則屬於<strong>自動化流程</strong>的一部分。</p><hr><h2 id="一、程式碼品質檢查：Lint、Format、Type-Check"><a href="#一、程式碼品質檢查：Lint、Format、Type-Check" class="headerlink" title="一、程式碼品質檢查：Lint、Format、Type Check"></a>一、程式碼品質檢查：Lint、Format、Type Check</h2><p>實作概要：</p><ul><li>使用<code>ruff check</code>、<code>ruff format</code>、<code>pyright</code>等指令檢查程式碼品質</li><li>全部定義在 <a href="https://github.com/kyomind/WeaMind/blob/v0.5.1/.github/workflows/ci.yml">ci.yml</a> 中，執行環境使用 uv 官方容器</li><li>檢查會在 PR 或 push 到 main 時自動執行，避免髒 commit 混入 main</li></ul><p>這些是上述文章的介紹重點，屬於<strong>基本中的基本</strong>。</p><h2 id="二、覆蓋率分析報告：Codecov"><a href="#二、覆蓋率分析報告：Codecov" class="headerlink" title="二、覆蓋率分析報告：Codecov"></a>二、覆蓋率分析報告：Codecov</h2><p>實作概要：</p><ul><li>使用<code>pytest</code>搭配<code>pytest-cov</code>收集測試覆蓋率，產生<code>coverage.xml</code></li><li>在<code>ci.yml</code>中設定資料自動上傳至 Codecov，產出覆蓋率分析報告</li><li>使用  <a href="https://github.com/kyomind/WeaMind/blob/v0.5.1/.github/codecov.yml">codecov.yml</a> 對 GitHub App 的行為進行客製化——主要是關閉成功留言、比對 patch 覆蓋率</li></ul><p><strong>單元測試</strong>無疑是 CI 中最重要的環節之一。</p><p>做<strong>覆蓋率分析報告</strong>的工具有很多，我選擇 <a href="https://about.codecov.io/">Codecov</a> 因為它與 GitHub 整合度高，且對開源專案來說非常友善。</p><p>不過，測試函式和覆蓋率報告<strong>仍需要你在 CI 流程中預先準備好</strong>。分析報告只是提供了一個<strong>視覺化結果</strong>，幫助你快速了解測試覆蓋的情況。</p><p>你可以透過 GitHub Actions 執行（需要定義自己的 YAML 檔） Codecov，或連接官方提供的 <a href="https://github.com/marketplace/codecov">GitHub App</a>，直接在 CI 流程中上傳覆蓋率報告即可。</p><p>我選擇後者。因為它更簡單，且已能夠自動處理許多細節。</p><h2 id="三、Docker-Build-驗證"><a href="#三、Docker-Build-驗證" class="headerlink" title="三、Docker Build 驗證"></a>三、Docker Build 驗證</h2><p>實作概要：</p><ul><li>使用<code>docker/setup-buildx-action</code>建立建置環境，執行<code>docker buildx build</code>驗證 Dockerfile</li><li>這項檢查對我來說是一種「部署預演」，能在尚未正式上線前提早發現問題</li><li>定義在<code>ci.yml</code>，<strong>平行執行</strong>，不影響主流程速度</li></ul><p>雖然尚未導入 CD，但透過建構 Image 的預演流程，能及早發現 Dockerfile 中潛在的錯誤，有助於減少部署時的風險。</p><hr><h2 id="四、安全掃描：GitHub-CodeQL"><a href="#四、安全掃描：GitHub-CodeQL" class="headerlink" title="四、安全掃描：GitHub CodeQL"></a>四、安全掃描：GitHub CodeQL</h2><blockquote><p><code>2025/09/16</code>補充：請留意，只有<strong>公開專案</strong>才能<strong>免費</strong>使用 CodeQL 功能。私有專案則須付費 <a href="https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security">GitHub Advanced Security</a> 才行。</p></blockquote><p>實作概要：</p><ul><li>採用 GitHub 官方 <a href="https://github.com/kyomind/WeaMind/blob/v0.5.1/.github/workflows/codeql.yml">codeql.yml</a> 設定，支援 Python 與 GitHub Actions 安全分析</li><li>push 到 main、PR 時觸發，另外每週日也會<strong>定期執行</strong></li><li><strong>排除</strong>資料庫 migrations 等目錄（需要自行額外撰寫 <a href="https://github.com/kyomind/WeaMind/blob/v0.5.1/.github/codeql/codeql-config.yml">codeql-config.yml</a> 控制）</li></ul><p>安全掃描或許不是必須，但我認為它是一種對「<strong>技術成熟度</strong>」追求的象徵。</p><p>要建立這份 YAML 檔很簡單，只要去 GitHub 倉庫設定那邊開啟該功能，系統就會自動幫你產生一份 template。</p><p>不過我還是有進行一些客製化，這部分就跟 AI 討論吧！</p><h2 id="五、程式碼品質分析：SonarCloud"><a href="#五、程式碼品質分析：SonarCloud" class="headerlink" title="五、程式碼品質分析：SonarCloud"></a>五、程式碼品質分析：SonarCloud</h2><p>實作概要：</p><ul><li>使用 <a href="https://github.com/marketplace/sonarcloud">SonarQube Cloud GitHub App</a>，透過官方整合自動執行程式碼品質分析</li><li>分析專案中包括 code smells、bugs、security hotspots、technical debt 等事項</li><li>每次 PR 都會產生品質報告，幫助維持程式碼健康度</li></ul><p>老牌的<strong>程式碼品質分析工具</strong>——<a href="https://www.sonarsource.com/products/sonarqube/">SonarQube</a>，提供比基本 lint 更深入的程式碼分析，包括複雜度、重複程度、潛在安全風險等。</p><p>對於想提升程式碼品質的專案來說，是很好的工具，且不限程式語言。</p><p>我同樣選擇使用 GitHub App 而非自己定義 Action，因為我比較懶。</p><p>自定義的話，可以更靈活地控制分析條件與操作細節。</p><hr><p>以下兩項不算嚴格意義上的 CI，而屬於<strong>專案自動化流程</strong>的一部分。</p><h2 id="六、相依套件更新：Dependabot"><a href="#六、相依套件更新：Dependabot" class="headerlink" title="六、相依套件更新：Dependabot"></a>六、相依套件更新：Dependabot</h2><p>實作概要：</p><ul><li>使用<code>dependabot.yml</code>設定 uv 與 GitHub Actions 的週期性更新</li><li>設定 commit message 格式與自動 rebase，減少手動維護成本</li><li>每週自動檢查並<strong>自動建立 PR</strong>（如果有新版），讓套件更新變得可控且透明</li></ul><p><strong>套件的管理</strong>是專案維護中容易被忽略的環節之一。套件版本過舊可能帶來安全風險，但手動更新又容易忘記。</p><p>Dependabot 讓這個過程自動化，同時透過 PR 機制讓每次更新都經過 CI 驗證。</p><p>更重要的是，<strong>它讓「更新」這件事變得可見、可追蹤</strong>，而不是藏在某個角落的技術債。</p><h2 id="七、自動-GitHub-Release"><a href="#七、自動-GitHub-Release" class="headerlink" title="七、自動 GitHub Release"></a>七、自動 GitHub Release</h2><p>實作概要：</p><ul><li>使用<code>softprops/action-gh-release</code>，當 tag 以<code>v*</code>命名時自動建立 release 並附上 notes</li><li>定義在<code>auto-release.yml</code>，適合小型專案做版本整理</li></ul><p>其實就是<strong>取代手動發布 Release</strong>的流程。</p><p>主要是受到 Will 保哥的《<a href="https://github.com/doggy8088/ask-page-extension">頁問 AskPage</a>》和其它開源專案的啟發。</p><p>先是實作了<a href="https://www.threads.com/@kyomind.tw/post/DN5rYhNge8x">半自動的 CHANGELOG 更新機制</a>，後來乾脆連 <a href="https://github.com/kyomind/WeaMind/releases">Release Notes</a> 都一起自動產生。</p><p>實際的效果就是：每次 push 帶有<code>v*</code>的 tag 時，會自動建立對應的 GitHub release。</p><p>雖然格式稍嫌呆板，但感覺就是兩個字——愉悅！</p><hr><h2 id="流程概覽"><a href="#流程概覽" class="headerlink" title="流程概覽"></a>流程概覽</h2><p>為方便回顧，再次整理 WeaMind 專案中各 CI 流程的關鍵步驟。</p><h3 id="核心-CI-流程（每次程式碼時變更觸發）"><a href="#核心-CI-流程（每次程式碼時變更觸發）" class="headerlink" title="核心 CI 流程（每次程式碼時變更觸發）"></a>核心 CI 流程（每次程式碼時變更觸發）</h3><ol><li><strong>程式碼品質檢查</strong>：使用 Lint、Format、Type Check 確保程式碼風格一致性</li><li><strong>測試與覆蓋率上傳</strong>：執行單元測試並上傳覆蓋率報告至 Codecov</li><li><strong>Docker Build 驗證</strong>：驗證 Dockerfile 的正確性，確保容器化部署不出錯</li><li><strong>安全掃描</strong>：GitHub CodeQL 掃描，檢查潛在安全風險（push + 週期性觸發）</li><li><strong>程式碼品質分析</strong>：使用 SonarCloud 進行深入的程式碼品質分析</li></ol><h3 id="輔助自動化工具"><a href="#輔助自動化工具" class="headerlink" title="輔助自動化工具"></a>輔助自動化工具</h3><ol><li><strong>相依套件更新</strong>：透過 Dependabot 自動更新相依套件，減少手動維護成本</li><li><strong>自動發布</strong>：使用 GitHub Release 自動建立版本釋出</li></ol><p>最後附上 CI 流程的示意圖：</p><p><img src="https://img.kyomind.tw/20250831-160911-ci-min.png" alt="WeaMind CI 流程圖"><span class="cap">WeaMind CI 流程圖</span></p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>以上就是 WeaMind 專案目前的 CI 設計全貌。</p><p>這套設計不是為了炫技，而是出於對品質的堅持，讓一個產品型 Side Project 能在成長過程中<strong>穩定運作——並累積信任</strong>。</p><p>如果你也有在開發 Side Project，不妨參考本文實作幾項 CI 流程，建立屬於自己的品質防線。</p><p>CI 不必一次到位，但每一步都在為未來的穩定與信任打底。</p><hr><blockquote><p><strong>如果這篇文章對你有幫助，歡迎到 <a href="https://github.com/kyomind/WeaMind">WeaMind GitHub 首頁</a> 給我一個星星</strong><br>想試用 WeaMind，可掃描下方 QR Code 或搜尋 LINE ID <code>@370ndhmf</code> 加入好友<br>你的支持是我持續分享的動力</p></blockquote><p><img src="https://img.kyomind.tw/wea-qrcode-min-20250929-223022.png" alt="WeaMind QR Code"><span class="cap">WeaMind QR Code</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/WeaMind-logo-min.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 這是 &lt;a href=&quot;https://github.com/kyomind/WeaMind/blob/main/blogs/README.md&quot;&gt;WeaMind 系列&lt;/a&gt; 的第 4 篇。&lt;br&gt;本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;〈&lt;a href=&quot;/github-actions&quot;&gt;GitHub Actions 入門：自動化 Lint、Format 與 Type Check&lt;/a&gt;〉一文中，我們使用了 GitHub Actions 作為 CI（&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88&quot;&gt;持續整合&lt;/a&gt;）的入門工具。&lt;/p&gt;
&lt;p&gt;同時建立了軟體開發專案中最基本且常見的 CI 流程。&lt;/p&gt;
&lt;p&gt;接下來，我將繼續介紹，WeaMind 專案中&lt;strong&gt;所有實作的 CI 項目&lt;/strong&gt;，並說明我選擇它們的原因與設計原則。&lt;/p&gt;
&lt;p&gt;本文依據的專案程式碼版本為 &lt;a href=&quot;https://github.com/kyomind/WeaMind/tree/v0.5.1&quot;&gt;v0.5.1&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="GitHub Actions" scheme="https://blog.kyomind.tw/tags/GitHub-Actions/"/>
    
    <category term="WeaMind" scheme="https://blog.kyomind.tw/tags/WeaMind/"/>
    
    <category term="Side Project" scheme="https://blog.kyomind.tw/tags/Side-Project/"/>
    
    <category term="Continuous Integration" scheme="https://blog.kyomind.tw/tags/Continuous-Integration/"/>
    
  </entry>
  
  <entry>
    <title>在 Hetzner 開新 VM 指南：選機房、SSH 連線、設定防火牆</title>
    <link href="https://blog.kyomind.tw/hetzner-vm/"/>
    <id>https://blog.kyomind.tw/hetzner-vm/</id>
    <published>2025-07-27T15:03:31.000Z</published>
    <updated>2025-07-27T15:42:50.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/GhElIMy.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><p>〈<a href="/hetzner/">Hetzner VPS 實測：比 DigitalOcean 更划算的選擇？</a>〉介紹了 Hetzner 這個來自德國的 VPS 供應商，該篇文章在 VM 價格與規格上，與 DigitalOcean 進行比較。</p><p>使用下來已超過 3 個月，除了台灣連歐洲的延遲較高，以這樣的價格，整體表現仍讓我十分滿意。</p><p>我之後絕大部分的服務，都會部署在目前租用的 Hetzner VM 上。</p><p>上一篇是介紹與推廣，本篇則是進一步教你怎麼在 Hetzner 平台上建立新 VM，簡單實用。</p><p>話不多說，直接開始。</p><span id="more"></span><hr><p>登入後，先打開 Hetzner 的 <a href="https://console.hetzner.com/">Console 頁面</a>。</p><p><img src="https://img.kyomind.tw/20250727-230712-hz1-min.png" alt="Hetzner Console"><span class="cap">Hetzner Console</span>  </p><p>新增專案並點擊「Create Server」後，我們會在該頁面完成全部流程。</p><p>大部分步驟都不難理解，以下只針對其中幾步進行重點解說。</p><hr><h2 id="一、資料中心選擇"><a href="#一、資料中心選擇" class="headerlink" title="一、資料中心選擇"></a>一、資料中心選擇</h2><p>如圖，全世界有 6 處資料中心可供選擇，3 個在歐洲，2 個在美國，1 個在新加坡。</p><p><img src="https://img.kyomind.tw/20250727-230936-hz2-min.png" alt="機房選擇"><span class="cap">機房選擇</span>  </p><p>但如果你和我一樣選 ARM 版的 CPU，那就只剩下歐洲的 3 個可選。</p><p>這部分請參考上一篇的「<a href="/hetzner/#%E5%AF%A6%E9%9A%9B%E6%B8%AC%E8%A9%A6%EF%BC%9ALatency-%E6%AF%94%E8%BC%83">實際測試：Latency 比較</a>」（包含我的測試結果），並用你的電腦、網路進行實際測試。</p><p>令人遺憾的是，即使選擇最接近台灣的新加坡機房，我測試的 ping 值也達到 400 毫秒。</p><p>雖然比歐洲機房的 600-800 毫秒快，但相比 DigitalOcean 新加坡機房僅 130 毫秒，仍屬太慢。</p><p>而且價格是歐洲機房的 2 倍左右，個人是覺得不太划算啦！</p><h3 id="歐洲優先"><a href="#歐洲優先" class="headerlink" title="歐洲優先"></a>歐洲優先</h3><p>所以強烈建議，如果對延遲速度有要求，還是不要選它們家的 VM。</p><p>如果可以接受延遲，那選擇歐洲機房與 ARM 處理器，就是最高 CP 值的組合！</p><p><img src="https://img.kyomind.tw/20250727-231130-hz3-min.png" alt="我選擇 CAX21 機型"><span class="cap">我選擇 CAX21 機型</span>  </p><p>以上都是以 Shared vCPU 為準。</p><p>ARM CPU 的 VM，CP 值都極高！此外，以上價格不含稅——還有 5% 的營業稅。</p><h2 id="二、SSH-連線設定"><a href="#二、SSH-連線設定" class="headerlink" title="二、SSH 連線設定"></a>二、SSH 連線設定</h2><p>我們在〈<a href="/vm-ssh-setup/">為 e2-micro VM 建立 SSH 連線：本機與 GitHub</a>〉提過，新 VM 設定 SSH 連線的方式不外乎這兩種：</p><ol><li>Web Console 登入後自行設定。</li><li>建立 VM 時直接上傳公鑰。</li></ol><p>Hetzner 屬於第二種，上傳一組後，可以設為「預設」，讓全專案都可以使用。這樣一來，開第 2 台、第 3 台時就不必再重新上傳了。</p><p>所以，請先準備好你的公鑰。指令可參考「<a href="/vm-ssh-setup/#%E6%9C%AC%E6%A9%9F%E5%BB%BA%E7%AB%8B-SSH-%E9%87%91%E9%91%B0">本機建立 SSH 金鑰</a>」。</p><p>建立完成後，用 terminal 測試 SSH 連線：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@&lt;你的 VM IP&gt;</span><br></pre></td></tr></table></figure><h3 id="SSH-補充建議"><a href="#SSH-補充建議" class="headerlink" title="SSH 補充建議"></a>SSH 補充建議</h3><ol><li>使用 config 檔管理 SSH 連線。</li><li>在<code>root</code>帳號登入後，建立一個普通使用者與獨立的 SSH 連線，並加入 sudo 群組。然後沒事不要再用<code>root</code>登入XD</li></ol><p>保持好習慣，可以省去不必要的麻煩。</p><h2 id="三、防火牆"><a href="#三、防火牆" class="headerlink" title="三、防火牆"></a>三、防火牆</h2><p>Hetzner 的設計是：</p><ul><li>防火牆綁在「專案」層級</li><li>VM 建立時，從現有的防火牆中選擇套用</li></ul><p>如果你尚未建立防火牆，系統會提示你先設定一個，然後再繼續 VM 建立流程。</p><h3 id="Port-開放原則"><a href="#Port-開放原則" class="headerlink" title="Port 開放原則"></a>Port 開放原則</h3><p>建議只開放 22（SSH）、80（HTTP）、443（HTTPS），其餘一律不開。</p><p>其實就是預設值啦！具體設定如下：</p><p><img src="https://img.kyomind.tw/20250727-231422-hz4-min.png" alt="基本防火牆設定"><span class="cap">基本防火牆設定</span>  </p><p>你可以針對不同用途建立多個防火牆設定檔，或直接共用同一個即可。</p><h2 id="四、雜項"><a href="#四、雜項" class="headerlink" title="四、雜項"></a>四、雜項</h2><p>以下是建立 VM 流程中，我對於雜項的選擇：</p><ol><li>作業系統：當然是 <a href="https://ubuntu.com/blog/tag/ubuntu-24-04-lts">Ubuntu 24.04 LTS</a>。（純個人偏好）</li><li>網路：IPv4（需要一點點費用：€0.0008&#x2F;h）、IPv6（免費）勾選。</li><li>Volumes：預設的 80 GB，很夠用，先不選，真的不夠再加。</li><li>Backups：看需求，我沒選。</li></ol><hr><h2 id="結語：Hetzner-就是香！"><a href="#結語：Hetzner-就是香！" class="headerlink" title="結語：Hetzner 就是香！"></a>結語：Hetzner 就是香！</h2><p>不同需求有不同的選擇，不過在多數情況下，Hetzner 提供的產品服務，對我而言就是絕佳選擇！</p><p>我目前已經在上面部署了（皆以 Docker 容器部署）：</p><ol><li>2 個 <a href="/memos/">memos</a> 服務。</li><li>1 個 <a href="/weekly-review-21/">Umami</a> 服務（GA4 替代品）。</li><li>Nginx、Certbot、<a href="https://www.portainer.io/">Portainer</a> 等等。</li><li>我自己的 <a href="https://github.com/kyomind/WeaMind">side project</a>。</li></ol><p>未來還有很大空間可以發擇，預計還要再部署 <a href="https://n8n.io/">n8n</a>。</p><p>這樣的彈性與餘裕，一個月竟然只要 6.5 歐元，真是非常美妙☺️</p><p>這也是為什麼我願意為 Hetzner 寫下兩篇文章介紹並推廣。</p><hr><h2 id="使用我的推薦連結，享受-20-歐元免費額度"><a href="#使用我的推薦連結，享受-20-歐元免費額度" class="headerlink" title="使用我的推薦連結，享受 20 歐元免費額度"></a>使用我的推薦連結，享受 20 歐元免費額度</h2><p>最後，如果你想試試 Hetzner，歡迎使用<a href="https://hetzner.cloud/?ref=gD26JqrE8c9t"><strong>我的推薦連結</strong></a>註冊，你可以直接獲得 <strong>20 歐元的使用額度</strong>。</p><p>而我在<strong>一定條件</strong>下（用戶使用連結註冊並付費達 10 歐元），可以獲得 10 歐元的回饋。<strong>這是贊助本站最有效的方式。</strong></p><p>希望這篇分享能幫助你，在選擇 VPS 的路上，多一個可靠的選擇。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GhElIMy.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;/hetzner/&quot;&gt;Hetzner VPS 實測：比 DigitalOcean 更划算的選擇？&lt;/a&gt;〉介紹了 Hetzner 這個來自德國的 VPS 供應商，該篇文章在 VM 價格與規格上，與 DigitalOcean 進行比較。&lt;/p&gt;
&lt;p&gt;使用下來已超過 3 個月，除了台灣連歐洲的延遲較高，以這樣的價格，整體表現仍讓我十分滿意。&lt;/p&gt;
&lt;p&gt;我之後絕大部分的服務，都會部署在目前租用的 Hetzner VM 上。&lt;/p&gt;
&lt;p&gt;上一篇是介紹與推廣，本篇則是進一步教你怎麼在 Hetzner 平台上建立新 VM，簡單實用。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/GhElIMy.jpeg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>uv 容器化實作：使用官方 image 建立 Dockerfile</title>
    <link href="https://blog.kyomind.tw/uv-dockerfile/"/>
    <id>https://blog.kyomind.tw/uv-dockerfile/</id>
    <published>2025-07-19T07:15:27.000Z</published>
    <updated>2025-10-02T07:45:13.465Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/introducing-uv-min.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><blockquote><p>📌 這是 <a href="https://github.com/kyomind/WeaMind/blob/main/blogs/README.md">WeaMind 系列</a> 的第 3 篇。<br>本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。</p></blockquote><p><a href="https://docs.astral.sh/uv/">uv</a> 是近年來快速竄起的 Python 套件管理器，憑藉其最關鍵的核心特性——快😎，在 Python 開發圈吸引了不少關注與採用。</p><p>之前我已寫過〈<a href="/introducing-uv/">Python 套件管理器 uv 介紹——與 Poetry 比較</a>〉介紹。有興趣的讀者歡迎參考。</p><p>本文是 uv 系列的第二篇，<strong>聚焦於 Dockerfile</strong>。</p><p>當我要將「使用 uv 的 Python 專案」容器化時，我發現相關的討論與介紹較少，所以花了一些時間摸索。</p><p>本文目標是<strong>大幅減少你的試錯時間</strong>，並提出我的實踐與看法。</p><span id="more"></span><h3 id="系列：Python-後端專案容器化"><a href="#系列：Python-後端專案容器化" class="headerlink" title="系列：Python 後端專案容器化"></a>系列：Python 後端專案容器化</h3><ul><li><a href="/series/#Python-%E5%BE%8C%E7%AB%AF%E5%B0%88%E6%A1%88%E5%AE%B9%E5%99%A8%E5%8C%96">文章清單（連載中）</a></li></ul><h3 id="系列：Python-套件管理——使用-uv"><a href="#系列：Python-套件管理——使用-uv" class="headerlink" title="系列：Python 套件管理——使用 uv"></a>系列：Python 套件管理——使用 uv</h3><ul><li><a href="/series/#Python-%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8-uv">文章清單（連載中）</a></li></ul><hr><h2 id="從-Poetry-到-uv：Dockerfile-寫法大不同"><a href="#從-Poetry-到-uv：Dockerfile-寫法大不同" class="headerlink" title="從 Poetry 到 uv：Dockerfile 寫法大不同"></a>從 Poetry 到 uv：Dockerfile 寫法大不同</h2><p>不久前，我才寫下了〈<a href="https://blog.kyomind.tw/poetry-multi-stage-build/">Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</a>〉，講述如何在 Docker 中，使用 Poetry 建立容器內的 Python 執行環境。</p><p>本文算是該篇文章的「<strong>uv 姐妹作</strong>」，但是，做法非常不同！</p><p>我本以為，只要簡單模仿 Poetry 的 multi-stage build 方式就好，但實際操作後才發現問題多多。</p><p>畢竟兩者的指令不同，尤其對於「全域安裝套件」有著截然不同的做法。</p><p>這裡就不仔細比較差異了，經過一番探索，我們已經得到了最佳解😇</p><p>那就是<strong>使用 uv 團隊推出的官方 Docker image！</strong></p><hr><h2 id="使用-uv-官方-image"><a href="#使用-uv-官方-image" class="headerlink" title="使用 uv 官方 image"></a>使用 uv 官方 image</h2><p>關於 uv 容器化議題，uv 開發團隊直接推出了專用的<a href="https://github.com/astral-sh/uv/pkgs/container/uv">官方 image</a>。</p><p>該 image 已內建 uv，且在體積上進行了最佳化，大概只有 60 MB。（指的是使用 slim 版本的 Linux 基底）</p><p>透過它，你可以省去繁瑣的安裝設定，並且在安全性上更有保障。</p><p>如果習慣從 Docker hub 拉取，則可參考<a href="https://hub.docker.com/r/astral/uv/tags">這裡</a>。</p><p>一般而言，仍建議你使用 GitHub 托管的版本——也就是<code>ghcr.io/</code>開頭的版本。因為它才是「第一手」。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghcr.io/astral-sh/uv:python3.12-bookworm-slim</span><br></pre></td></tr></table></figure><p>建議用它作為 Dockerfile 的基底 image。</p><h2 id="如何使用官方-image-撰寫-Dockerfile"><a href="#如何使用官方-image-撰寫-Dockerfile" class="headerlink" title="如何使用官方 image 撰寫 Dockerfile"></a>如何使用官方 image 撰寫 Dockerfile</h2><p>有了 image，那我們要怎麼撰寫 Dockerfile 呢？</p><p>對此，我們也不需要自己苦苦思考了，大部分挑戰都已經有了答案——請直接參考這個<a href="https://github.com/astral-sh/uv-docker-example">官方倉庫</a>中的 <a href="https://github.com/astral-sh/uv-docker-example/blob/main/Dockerfile">Dockerfile</a> 寫法！</p><p><strong>強烈建議你，如果沒有特殊需求，就 follow 它的寫法</strong>，因為 uv 的操作有很多繁瑣的細節，考驗著你對該工具的了解，尤其在 Docker 容器化的場景更是如此。</p><p>官方的 Dockerfile 也非常細心，在多個指令都加上了簡要的註解，讓你知其然又知其所以然。</p><p>其實看過其中一些指令內容就知道，要自己寫肯定很難寫得這麼好。</p><p>所以我們還是盡可能參考甚至遵照這份 Dockerfile 的寫法。</p><p>可以少走很多彎路。</p><hr><h2 id="為什麼不需要-Multi-stage-build？"><a href="#為什麼不需要-Multi-stage-build？" class="headerlink" title="為什麼不需要 Multi-stage build？"></a>為什麼不需要 Multi-stage build？</h2><p>前述〈<a href="https://blog.kyomind.tw/poetry-multi-stage-build/">Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</a>〉教你如何用 multi-stage build 建立 Poetry 虛擬環境。</p><p>因為 Poetry 和 uv 這類工具有<strong>各自需要的執行環境與依賴套件</strong>，不那麼適合在 Docker 建構過程中直接安裝並封裝成 image，這會造成<strong>一定程度的空間浪費與冗餘</strong>。</p><p>所以我們選擇用 multi-stage build 來建立 image。省去不必要的依賴，有效減少最終 image 的體積。</p><p>那為什麼這裡就<strong>沒有這麼做</strong>呢？</p><p>原因很簡單，<strong>官方已經提供這份簡單、乾淨的 image，讓你直接開箱即用</strong>。雖然最終的 image 中仍會有 uv，但它的體積佔用已然經過最佳化。</p><p>此時自己再搞個 multi-stage build，也省不了多少空間，還徒增 Dockerfile 的複雜度與出錯可能。</p><h3 id="MCP-時代需要-uv"><a href="#MCP-時代需要-uv" class="headerlink" title="MCP 時代需要 uv"></a>MCP 時代需要 uv</h3><p>附帶一提，在這個 MCP（模型上下文協定，<a href="https://modelcontextprotocol.io/introduction">Model Context Protocol</a>）盛行的時代，我們可以看到 MCP Server 的開發，主要由兩種語言佔多數：</p><ol><li>TypeScript（JavaScript）</li><li>Python</li></ol><p>如果你想用 Python 來開發 MCP 服務，並希望讓使用者執行<code>uv run &lt;你定義的指令&gt;</code>來啟動 MCP Server（這是目前主流做法），那 uv 就需要存在你的最終 image 中。</p><blockquote><p>延伸閱讀（外部）：</p><ul><li><a href="https://blog.miniasp.com/post/2025/04/01/Write-your-own-MCP-server-using-uv-and-Python">使用 uv 輔助開發 MCP 伺服器並安裝到 Claude Desktop 與 VS Code</a></li><li><a href="https://oalieno.tw/posts/mcp">MCP 開發實戰手冊：SSE、STDIO、Tool、Resource 一次搞懂</a>（尤其是「<strong>MCP Server 開發語言與執行方式</strong>」部分）</li></ul></blockquote><p>如此一來，自然也不需要透過 multi-stage build 來移除 uv 了。</p><h3 id="我就是要-Multi-stage-build！"><a href="#我就是要-Multi-stage-build！" class="headerlink" title="我就是要 Multi-stage build！"></a>我就是要 Multi-stage build！</h3><p>不同專案有不同需求，如果你真的需要 multi-stage build 以進一步節省空間的話，同一個倉庫中有<a href="https://github.com/astral-sh/uv-docker-example/blob/main/multistage.Dockerfile">另一個 Dockerfile</a> 可供參考。</p><hr><h2 id="uv-與-pip-requirements-txt-混搭法"><a href="#uv-與-pip-requirements-txt-混搭法" class="headerlink" title="uv 與 pip &#x2F; requirements.txt 混搭法"></a>uv 與 pip &#x2F; requirements.txt 混搭法</h2><p>其實，uv 對 pip 的相容性相當不錯——畢竟它有子命令<code>uv pip</code>。</p><p>因此，你也可以不用官方的 uv image，而是使用一般 Python image，再直接搭配<code>requirements.txt</code>安裝容器中的 Python 虛擬環境就好。</p><p>好處是延續了既有的 pip 開發習慣，降低認知負擔。</p><p>重點是，官方還非常貼心地準備了 <a href="https://docs.astral.sh/uv/guides/integration/pre-commit/">pre-commit hook</a>，來協助你輕鬆同步<code>uv.lock</code>與<code>requirements.txt</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">&lt;https://github.com/astral-sh/uv-pre-commit&gt;</span></span><br><span class="line">    <span class="comment"># uv version.</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">0.8</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">uv-export</span></span><br></pre></td></tr></table></figure><p>如此一來，就不會再發生<a href="/poetry-multi-stage-build/#%E8%88%8A%E6%9C%89%E5%81%9A%E6%B3%95%EF%BC%9Arequirements-txt-%E5%8F%8A%E5%85%B6%E9%99%90%E5%88%B6">前文</a>中提到的「在更新<code>poetry.lock</code>時，常常會忘記同步到<code>requirements.txt</code>」這類問題。</p><blockquote><p>相關文章：<a href="/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><p>此外，你也可以使用官方 image 但保留<code>requirements.txt</code>作為安裝依據，Dockerfile 寫法同樣簡單。</p><p>以上這兩種混搭方式的具體實作，可以參考 <a href="https://jumping-code.com/about-me/">JumpingCode 資料科學手記</a>的這篇〈<a href="https://jumping-code.com/2024/08/23/uv-pip-docker-image/#dockerfile-using-uv">如何使用 Python 套件管理工具「uv」取代 pip 來加速 Docker Image 的建立</a>〉。</p><p>其中的「<a href="https://jumping-code.com/2024/08/23/uv-pip-docker-image/#%E5%AF%A6%E6%B8%AC%E6%AA%94%E6%A1%88">實測檔案</a>」一節就提供了完整的 Dockerfile 範例。</p><hr><h2 id="我的-Dockerfile"><a href="#我的-Dockerfile" class="headerlink" title="我的 Dockerfile"></a>我的 Dockerfile</h2><p>最後附上 WeaMind 專案中，我目前使用的 <a href="https://github.com/kyomind/WeaMind/blob/blog/uv-dockerfile-v1-20250719/Dockerfile">Dockerfile</a>。</p><p>我對官方寫法做了一定的<strong>刪減</strong>，主要是移除專案作為第三方套件的相關設定，並簡化 Dockerfile 的快取策略。</p><p>如果你沒有把握，建議和 AI 討論或者直接 follow 官方的寫法就好。</p><p>此外，我還加上了一些註解，供讀者參考。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ghcr.io/astral-sh/uv:python3.<span class="number">12</span>-bookworm-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use &#x27;code&#x27; to avoid confusion with the &#x27;app&#x27; directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile bytecode and avoid symlinks</span></span><br><span class="line"><span class="keyword">ENV</span> UV_COMPILE_BYTECODE=<span class="number">1</span></span><br><span class="line"><span class="keyword">ENV</span> UV_LINK_MODE=<span class="keyword">copy</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="comment"># ---------- layer 1: heavy dependencies ----------</span></span><br><span class="line"><span class="comment"># Cache only invalidates when these two files change</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pyproject.toml uv.lock ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/root/.cache/uv \</span></span><br><span class="line"><span class="language-bash">    uv <span class="built_in">sync</span> --locked --no-dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- layer 2: application code ----------</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the venv at the beginning of PATH</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/code/.venv/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not use uv as the entrypoint</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> []</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>如果這篇文章對你有幫助，歡迎到 <a href="https://github.com/kyomind/WeaMind">WeaMind GitHub 首頁</a> 給我一個星星</strong><br>想試用 WeaMind，可掃描下方 QR Code 或搜尋 LINE ID <code>@370ndhmf</code> 加入好友<br>你的支持是我持續分享的動力</p></blockquote><p><img src="https://img.kyomind.tw/wea-qrcode-min-20250929-223022.png" alt="WeaMind QR Code"><span class="cap">WeaMind QR Code</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/introducing-uv-min.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 這是 &lt;a href=&quot;https://github.com/kyomind/WeaMind/blob/main/blogs/README.md&quot;&gt;WeaMind 系列&lt;/a&gt; 的第 3 篇。&lt;br&gt;本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.astral.sh/uv/&quot;&gt;uv&lt;/a&gt; 是近年來快速竄起的 Python 套件管理器，憑藉其最關鍵的核心特性——快😎，在 Python 開發圈吸引了不少關注與採用。&lt;/p&gt;
&lt;p&gt;之前我已寫過〈&lt;a href=&quot;/introducing-uv/&quot;&gt;Python 套件管理器 uv 介紹——與 Poetry 比較&lt;/a&gt;〉介紹。有興趣的讀者歡迎參考。&lt;/p&gt;
&lt;p&gt;本文是 uv 系列的第二篇，&lt;strong&gt;聚焦於 Dockerfile&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;當我要將「使用 uv 的 Python 專案」容器化時，我發現相關的討論與介紹較少，所以花了一些時間摸索。&lt;/p&gt;
&lt;p&gt;本文目標是&lt;strong&gt;大幅減少你的試錯時間&lt;/strong&gt;，並提出我的實踐與看法。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/introducing-uv-min.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
    <category term="WeaMind" scheme="https://blog.kyomind.tw/tags/WeaMind/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
    <category term="uv" scheme="https://blog.kyomind.tw/tags/uv/"/>
    
  </entry>
  
  <entry>
    <title>Vibe Coding 與人類的時代</title>
    <link href="https://blog.kyomind.tw/vibe-coding/"/>
    <id>https://blog.kyomind.tw/vibe-coding/</id>
    <published>2025-07-10T14:22:29.000Z</published>
    <updated>2025-08-26T14:19:18.739Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><blockquote><p>任何人類都能使用魔法的時代要到來了——《葬送的芙莉蓮》漫畫第 53 話 | 人類的時代</p></blockquote><p>有了強大的 AI 輔助 ，寫程式再也不是軟體工程師的專屬。</p><p>如此的時代巨變，首先讓我聯想到的，就是「芙莉蓮」中的這段劇情。</p><p>不過把這個比喻與感受表達得最好的，當屬財經作家王伯達的這篇<a href="https://www.facebook.com/share/p/173juCsKre/">臉書文</a>。</p><p>他寫道：</p><blockquote><p>AI 讓更多人，用更容易的方式使用程式語言與複雜軟體。</p><p>這讓我想到芙莉蓮的老師，弗蘭梅。</p><p>她說服了人類的皇帝，讓人類得以開始研究魔法，魔法不再是個禁忌，開啟了人人有魔法可以練的年代。</p></blockquote><p>顯然，在我這個軟體工程師眼中，AI 就像芙蘭梅，把原本高門檻的知識、技術變成大眾能輕易接觸的工具，<strong>讓所有人都有機會參與創造</strong>。</p><p>本文聊聊我作為一個軟體工程師，如何看待這個 AI 普及後的「魔法時代」。</p><span id="more"></span><hr><h2 id="工程師的傲慢：自詡為魔法的守門人"><a href="#工程師的傲慢：自詡為魔法的守門人" class="headerlink" title="工程師的傲慢：自詡為魔法的守門人"></a>工程師的傲慢：自詡為魔法的守門人</h2><p>曾幾何時，軟體工程師就像這個世界的魔法使，掌握著一種魔法般的語言——程式碼。</p><p>我們用它來創造服務、建立平台、構築起一個個廣袤無垠的數位世界。</p><p>然而，AI 的出現，讓一切開始改變。</p><p>ChatGPT 問世後，所有的「文本生成」變得簡單起來——包括程式碼。</p><p>隨著 AI 持續演進、AI Agent 工具日漸成熟，你越來越常聽到這樣的說法：</p><blockquote><p>我不懂程式語言，但我能用 AI 寫程式。</p></blockquote><p>剛開始聽到這類言論時，老實說，我的內心充滿了鄙夷之情😅</p><p>就像師祖賽莉耶說的：「<strong>魔法就應該是特別的。</strong>」</p><p>而我也覺得，程式就應該是「<strong>特別</strong>」的，不是誰都能隨口說自己「會寫程式」。</p><h2 id="因為稀缺，所以傲慢"><a href="#因為稀缺，所以傲慢" class="headerlink" title="因為稀缺，所以傲慢"></a>因為稀缺，所以傲慢</h2><p>這種想法有道理嗎？也許這是人性的一部分。</p><p>作家朱宥勳在《<a href="https://www.books.com.tw/products/0010867642">文壇生態導覽——作家新手村 2 心法篇</a>》一書中提到，如果一位文人既會寫散文又會寫詩，他會希望人們稱他為「詩人」。</p><p>如果既會寫散文又會寫小說呢？當然是小說家！</p><blockquote><p><strong>所以楊牧是詩人，陳映真是小說家——儘管他們散文都寫得很好</strong>。</p></blockquote><p>看起來，身為詩人、小說家，<strong>似乎比身為散文作家更讓人有一種「特別」的感覺</strong>。</p><p>為什麼？或許是因為——散文的門檻比較低吧。</p><p>任何人，只要識字、能表達，都能自稱「<strong>會寫</strong>」散文（文采如何可以另當別論）。</p><p>而寫詩、寫小說這種「<a href="https://dict.idioms.moe.edu.tw/idiomView.jsp?ID=1150&webMd=2&la=0">陽春白雪</a>」，對我等普羅大眾來說，<strong>簡直連想都不敢想</strong>！——就像寫程式一樣。</p><hr><h2 id="心態的轉變"><a href="#心態的轉變" class="headerlink" title="心態的轉變"></a>心態的轉變</h2><p>懷抱著上述的想法（儘管我不是程式界的楊牧），我一直希望自己是特別的。</p><p>直到今年 2 月，當 <a href="https://zh.wikipedia.org/zh-tw/%E5%AE%89%E5%BE%B7%E7%83%88%C2%B7%E5%8D%A1%E5%B8%95%E6%96%AF">Andrej Karpathy</a> 提出 Vibe Coding 一詞時，我心中的這份傲慢被敲響了喪鐘。</p><p>我心想：如果連這種大神級的軟體工程師，都提出並嘗試了這樣有趣的軟體開發方式，那一般人用這種方式來開發自己需要的工具或服務，完全說得通啊！</p><p>加上 <a href="https://www.facebook.com/will.fans/?locale=zh_TW">Will 保哥</a>的各種鼓吹，我對 Vibe Coding 的接納度迅速上升。</p><h2 id="什麼是-Vibe-Coding"><a href="#什麼是-Vibe-Coding" class="headerlink" title="什麼是 Vibe Coding"></a>什麼是 Vibe Coding</h2><p>Vibe Coding 這個新鮮的詞彙已經有了自己的<a href="https://zh.wikipedia.org/zh-tw/Vibe_coding">維基百科條目</a>。</p><p>我簡要摘錄如下（定義來自英文頁面）：</p><blockquote><p>Vibe coding is an artificial intelligence-assisted software development style popularized by Andrej Karpathy in early 2025. It describes a fast, improvisational, collaborative approach to creating software where the developer and a large language model (LLM) tuned for coding is acting rather like pair programmers in a conversational loop.</p></blockquote><p>簡單講，就是開發者透過自然語言與 AI 對話，反覆修正，一步步建立並完善軟體。</p><p>作為一個 Vibe Coder，你不需了解各種開發細節，甚至不用懂程式語言，而是專注於想要達成的目標和功能需求。</p><p>AI 成為了翻譯者，把我們的意圖轉化為可執行的程式碼。</p><hr><p>心態的改變，讓我開始重新看待「寫程式」的價值本身。</p><h2 id="軟體只是手段"><a href="#軟體只是手段" class="headerlink" title="軟體只是手段"></a>軟體只是手段</h2><p>越來越多人開始用 AI 寫程式，解決各種日常問題。</p><p>近期讓我最有感的是〈<a href="https://www.inside.com.tw/feature/2025-generative-ai/38545-ai-coding-ngoer">【Generative AI 年會】人力少但服務不打折！Peggy Lo：AI Coding 是 NGO 工作者最強大靠山</a>〉。</p><p>報導中，Peggy Lo 分享了她在僅有四人編制的基金會秘書處，如何運用 AI Coding 應對龐大的行政庶務與人力緊縮。</p><p>透過 AI，她不僅大幅提升了工作效率，還能讓服務變得更細緻、更深入。</p><p>這豈不是 Vibe Coding 的最佳典範？</p><p>我知道，程式從來只是手段。重要的不是「會不會寫」，而是「能不能用來解決真正的問題」。</p><p>一方面覺得自己的傲慢有些可笑，一方面也<strong>鬆了口氣</strong>。</p><p>我想，我更該在乎的，不是透過 AI 開發到底算不算「會寫程式」。</p><p>而是作為一個軟體工程師，<strong>我能解決什麼樣的問題</strong>。</p><hr><h2 id="「一般人」的優勢"><a href="#「一般人」的優勢" class="headerlink" title="「一般人」的優勢"></a>「一般人」的優勢</h2><p>而且話說回來，我不禁在想，不會程式的人用 AI 來開發，反而有自己的獨特優勢！</p><p>工程師多少知道某些技術的困難度，這反而會成為心理負擔，限制想像——覺得 AI 應該辦不到。</p><p>事實證明，AI 往往超乎人們的想像——在厲害與不厲害兩個方面都是XD</p><p>不懂程式的人沒這層包袱，做事的方式就很簡單：提出要求，請 AI 想辦法實現。</p><blockquote><p>魔法是想像的世界，在魔法世界中，無法想像的事情就無法實現</p></blockquote><p>沒有限制，反而更能天馬行空，專注於達成目標。</p><p>雖然未必每次都這麼順利，但少了這些束縛，有時候我認為是一個巨大的優勢。</p><p>唉，我就是缺乏想像力。</p><hr><h2 id="工程師也要會-Vibe-Coding"><a href="#工程師也要會-Vibe-Coding" class="headerlink" title="工程師也要會 Vibe Coding"></a>工程師也要會 Vibe Coding</h2><p>當然，這不代表工程師就該束手就擒。</p><p>相反地，我們更需要進化。</p><p>直白地說，我認為軟體工程師比一般人更需要學會 Vibe Coding。</p><p>像我這樣一個只熟悉後端的 Python 工程師，面對不熟的技術領域（例如前端），也需要發揮 Vibe Coding 的精神與實踐能力。</p><p>善於與 AI 協作的工程師（再加上一點想像力😎），可能是這個時代最有力的創造者。</p><h3 id="一般人打造工具，工程師打造系統"><a href="#一般人打造工具，工程師打造系統" class="headerlink" title="一般人打造工具，工程師打造系統"></a>一般人打造工具，工程師打造系統</h3><p>我覺得工程師應用 AI 放大軟體開發的能力，理應遠超過一般人。</p><p>這讓人充滿期待。</p><p>有人說，AI 讓工程師從作者變成了編輯者，<a href="https://www.managertoday.com.tw/articles/view/70451">讓寫程式像審稿</a>。好像自降了格調一般。</p><p>我認為這沒錯啊！重點是——<strong>審稿本身就是門技術活</strong>！</p><p>就像我在〈<a href="https://blog.kyomind.tw/myth-of-ai-writing-efficiency/">AI 讓寫作變輕鬆了？我可不這麼認為</a>〉提到的，AI 對我寫作的影響：</p><blockquote><p>為了善用 AI 的力量，我發現自己<strong>變成了 5 分作者、5 分編輯</strong>，而且<strong>經常在兩種身分間游移互換</strong>：一下子自己寫，讓 AI 看；一下子要 AI 寫、我來看。</p></blockquote><blockquote><p>AI 的普及，讓我們不僅僅是創作者，也成了編輯，甚至是策劃者。<strong>這種角色的轉換增加了工作量和難度，但也讓我們對內容的掌控更為精細。</strong></p></blockquote><p>沒有足夠的經驗，不可能成為優秀的編輯。</p><hr><p>總之，我覺得，工程師也好，非工程師也罷，在 AI 面前，我們都是人類，都需要藉由 AI 的輔助，不斷擴展自己的邊界。</p><p>這是個令人興奮的時代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何人類都能使用魔法的時代要到來了——《葬送的芙莉蓮》漫畫第 53 話 | 人類的時代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了強大的 AI 輔助 ，寫程式再也不是軟體工程師的專屬。&lt;/p&gt;
&lt;p&gt;如此的時代巨變，首先讓我聯想到的，就是「芙莉蓮」中的這段劇情。&lt;/p&gt;
&lt;p&gt;不過把這個比喻與感受表達得最好的，當屬財經作家王伯達的這篇&lt;a href=&quot;https://www.facebook.com/share/p/173juCsKre/&quot;&gt;臉書文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;他寫道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI 讓更多人，用更容易的方式使用程式語言與複雜軟體。&lt;/p&gt;
&lt;p&gt;這讓我想到芙莉蓮的老師，弗蘭梅。&lt;/p&gt;
&lt;p&gt;她說服了人類的皇帝，讓人類得以開始研究魔法，魔法不再是個禁忌，開啟了人人有魔法可以練的年代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顯然，在我這個軟體工程師眼中，AI 就像芙蘭梅，把原本高門檻的知識、技術變成大眾能輕易接觸的工具，&lt;strong&gt;讓所有人都有機會參與創造&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文聊聊我作為一個軟體工程師，如何看待這個 AI 普及後的「魔法時代」。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Vibe Coding" scheme="https://blog.kyomind.tw/tags/Vibe-Coding/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 入門：自動化 Lint、Format 與 Type Check</title>
    <link href="https://blog.kyomind.tw/github-actions/"/>
    <id>https://blog.kyomind.tw/github-actions/</id>
    <published>2025-07-06T02:31:27.000Z</published>
    <updated>2025-10-02T07:45:13.462Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/code-and-me.png"></p><blockquote><p>📌 這是 <a href="https://github.com/kyomind/WeaMind/blob/main/blogs/README.md">WeaMind 系列</a> 的第 2 篇。<br>本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。</p></blockquote><p>從這篇文章開始，我將啟動一個新的系列。</p><p>搭配我正在實作中的 Side Project——<a href="https://github.com/kyomind/WeaMind">WeaMind</a>，寫下一篇又一篇的技術實作心得。</p><p>讓我們一起在專案中成長，並獲得更多的開發樂趣。</p><p>如標題所示，本文主要介紹 <a href="https://github.com/features/actions">GitHub Actions</a>。不過在此之前，我們得先對 CI 有初步的了解。</p><hr><h2 id="什麼是-CI？為什麼需要-CI？"><a href="#什麼是-CI？為什麼需要-CI？" class="headerlink" title="什麼是 CI？為什麼需要 CI？"></a>什麼是 CI？為什麼需要 CI？</h2><p>CI 是「<a href="https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">Continuous Integration</a>」的縮寫，中文是「持續整合」。</p><p>它的核心概念是：<strong>當開發人員提交程式碼時，系統可以「自動執行一系列預先定義的檢查流程」</strong>，例如檢查程式碼是否與現有程式相容、是否能正常運作。</p><p>在軟體開發流程中，我們常常要處理很多<strong>重複但又不可忽略</strong>的工作：檢查程式碼格式、執行靜態分析、跑單元測試，甚至產生 API 文件等。</p><p>如果每次提交都要手動跑一輪，既麻煩又易忘。</p><p>這時 CI 就派上用場了。它能在每次 push 或開 PR 時（或其它事件），自動幫我們做這些事，讓問題提早浮現，使得開發流程更加穩健，也能節省大量重複性勞動。</p><span id="more"></span><h2 id="常見的-CI-工具有哪些？"><a href="#常見的-CI-工具有哪些？" class="headerlink" title="常見的 CI 工具有哪些？"></a>常見的 CI 工具有哪些？</h2><p>市面上已有不少 CI 工具可以選擇，例如：</p><ul><li><strong>Travis CI</strong>：老牌工具，但在開源社群中的使用率逐漸下降。</li><li><strong>CircleCI</strong>：主打高彈性與高度客製化的流程控制。</li><li><strong>GitHub Actions</strong>：GitHub 官方推出、與 GitHub 無縫整合的 CI&#x2F;CD 解決方案。</li></ul><p>這次我們選擇的是 GitHub Actions，理由很簡單：<strong>直接內建於 GitHub、好上手、不用額外註冊帳號</strong>。</p><p>而且對於「公開倉庫」，GitHub 給的 CI 運行時間額度是——無上限！</p><p>即使是私人倉庫，免費用戶也有每月 2000 分鐘，通常很夠用了。</p><hr><h2 id="認識-GitHub-Actions"><a href="#認識-GitHub-Actions" class="headerlink" title="認識 GitHub Actions"></a>認識 GitHub Actions</h2><p><a href="https://github.com/features/actions">GitHub Actions</a> 是 GitHub 提供的 CI&#x2F;CD 解決方案。</p><p>相較於上述提到的其它工具，它誕生的時間算是晚得多。</p><p>雖然推出較晚（2019 年才正式上線），但 GitHub Actions 從一開始就內建於 GitHub 平台，整合度高是它的一大優勢。</p><p>開發者不需額外設定外部服務，就能快速啟用 CI&#x2F;CD 流程，<strong>對個人開發者或小型專案尤其友善。</strong></p><p>你可以透過撰寫一份<code>yaml</code>設定檔，定義「<strong>什麼時候要觸發什麼流程</strong>」，像是：</p><ul><li>每次 push 時跑 Lint</li><li>每次 Pull Request 開啟時跑測試</li></ul><p>它支援容器、多種語言與工具，而且有非常多現成的 actions 可以直接引用。</p><p>這些功能，此刻我們還不需要了解，先著眼於當前的目標即可。</p><hr><h2 id="學習-CI-工具最好的方式：從需求開始"><a href="#學習-CI-工具最好的方式：從需求開始" class="headerlink" title="學習 CI 工具最好的方式：從需求開始"></a>學習 CI 工具最好的方式：從需求開始</h2><p>必須強調，相比於程式語言、後端框架等工具，CI&#x2F;CD 服務是<strong>更加「工具化」的工具</strong>。</p><p>意思是說，雖然有使用上的規則，但其中<strong>並沒有太多的「道理」可言</strong>！</p><p>單純就是看各家廠商怎麼制定與規範、設定檔怎麼寫等等。</p><p>所以，我認為，學習這類工具，最好的方式就是「直接用用看」！</p><p>你不需要一開始就設計一套完整的 CI 流程，只要從<strong>最簡單的需求</strong>開始，例如：</p><ul><li>跑 Lint、跑 Formatter</li><li>檢查型別（Python type check）</li></ul><p>這正是本文的出發點——用 GitHub Actions 設定一個最小可用的 CI 流程，整合 Lint、Format 與 Type Check。</p><h2 id="沒有需求怎麼辦？"><a href="#沒有需求怎麼辦？" class="headerlink" title="沒有需求怎麼辦？"></a>沒有需求怎麼辦？</h2><p>前面強調了需求的重要性，絕非隨便說說。</p><p>為了學習 GitHub Actions，我也看過不少課程，但沒有真實需求，學完很快就忘了。因為它的各種功能對我來說，都<strong>無法產生「具體的連結」。</strong></p><p>所以，如果你沒有實際的需求，我有兩個建議：</p><ol><li>自己創造需求！就像我們這裡的 side project，這不就有需求了嗎😇</li><li>先別學了！事半功倍鵝🪿</li></ol><p>第二點不是開玩笑XD，真的，沒需求就先別學了——晚點再說。軟體開發還有無數的領域等著你探索與投入。</p><hr><p>回到正題，直接來看專案中如何實作 GitHub Actions CI。</p><h2 id="GitHub-Actions-實作"><a href="#GitHub-Actions-實作" class="headerlink" title="GitHub Actions 實作"></a>GitHub Actions 實作</h2><p>我們的小目標是：</p><p>一、只要有人 push 到<code>main</code>分支，或開 PR 要合併到<code>main</code>，就自動檢查程式碼品質——這是<strong>最常見的 CI 觸發時機</strong>。</p><p>二、使用以下工具檢查專案程式碼：</p><ul><li><strong>Ruff</strong>：作為 Linter 與 Formatter。參考〈<a href="/ruff/">Python 開發：RuffLinter、Formatter 介紹 + 設定教學</a>〉</li><li><strong>Pyright</strong>：執行<strong>靜態型別檢查</strong>。參考〈<a href="/pyright/">Pyright 上手指南：Python 型別檢查的新選擇</a>〉</li></ul><p>這些都是我平常在本機開發會執行的操作——無論是透過 VS Code 還是 pre-commit，現在只是搬到 CI 中再執行一次。</p><blockquote><p>相關文章：<a href="/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><hr><h2 id="GitHub-Action-YAML-設定"><a href="#GitHub-Action-YAML-設定" class="headerlink" title="GitHub Action YAML 設定"></a>GitHub Action YAML 設定</h2><p>以下是<a href="https://github.com/kyomind/WeaMind/blob/blog/github-actions-v1-20250706/.github/workflows/ci.yml">實際的設定檔內容</a>，放在專案目錄底下的 <code>.github/workflows/ci.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Continuous</span> <span class="string">Integration</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">quality-check:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Lint,</span> <span class="string">Format,</span> <span class="string">Type</span> <span class="string">Check,</span> <span class="string">Test</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ghcr.io/astral-sh/uv:python3.12-bookworm-slim</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">sync</span> <span class="string">--locked</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Lint</span> <span class="string">(ruff)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">ruff</span> <span class="string">check</span> <span class="string">.</span> <span class="string">--fix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Format</span> <span class="string">(ruff</span> <span class="string">format)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">ruff</span> <span class="string">format</span> <span class="string">.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Type</span> <span class="string">check</span> <span class="string">(pyright)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">pyright</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">unit</span> <span class="string">tests</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">pytest</span></span><br></pre></td></tr></table></figure><p>可以看出，它還跑了單元測試！</p><p>我們可以暫時無視這部分，因為測試的相關設定細節更多，之後再另篇討論。</p><p>其餘細節也都先略過，只看最後的<code>steps</code>部分。</p><p>每個<code>run:</code>就是執行一個 CLI 指令，只不過是在 GitHub 的遠端 runner 上執行而已。</p><p>這個流程透露了 CI 的本質：<strong>開另一台機器，做一連串你「事先預定」的事情！</strong></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p>寫好 yaml 設定檔後，只要你 commit 並 push，GitHub 就會開始跑 CI workflow 了！（每一個設定檔都是一個 workflow）</p><p>無論成功或失敗，結果都會顯示在專案的「<a href="https://github.com/kyomind/WeaMind/actions">Actions</a>」分頁：</p><p><img src="https://img.kyomind.tw/20250706-112153-action-min.png" alt="GitHub Actions 執行結果"><span class="cap">GitHub Actions 執行結果</span></p><p>這裡是成功的，如果失敗了，GitHub 還會寄信給你——這很重要。</p><hr><h2 id="結語：最關鍵的第一步"><a href="#結語：最關鍵的第一步" class="headerlink" title="結語：最關鍵的第一步"></a>結語：最關鍵的第一步</h2><p>本文僅對 CI 跟 GitHub Actions 做了基本的介紹，並展示一下我的設定檔。</p><p>因為篇幅有限，沒有對所有細節進行完整說明——或許以後！</p><p>但這並不妨礙你立刻開始動手。</p><p>我認為，在 AI 能夠很好地輔助軟體開發的時代，設定檔的內容大部分都可以由 AI 代勞——當然我們不能對此一無所知😅</p><p>最重要的還是：<strong>你開始使用這些工具，將它們融入到開發流程中</strong>。</p><p>我想這才是最關鍵的第一步。</p><hr><blockquote><p><strong>如果這篇文章對你有幫助，歡迎到 <a href="https://github.com/kyomind/WeaMind">WeaMind GitHub 首頁</a> 給我一個星星</strong><br>想試用 WeaMind，可掃描下方 QR Code 或搜尋 LINE ID <code>@370ndhmf</code> 加入好友<br>你的支持是我持續分享的動力</p></blockquote><p><img src="https://img.kyomind.tw/wea-qrcode-min-20250929-223022.png" alt="WeaMind QR Code"><span class="cap">WeaMind QR Code</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/code-and-me.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 這是 &lt;a href=&quot;https://github.com/kyomind/WeaMind/blob/main/blogs/README.md&quot;&gt;WeaMind 系列&lt;/a&gt; 的第 2 篇。&lt;br&gt;本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;從這篇文章開始，我將啟動一個新的系列。&lt;/p&gt;
&lt;p&gt;搭配我正在實作中的 Side Project——&lt;a href=&quot;https://github.com/kyomind/WeaMind&quot;&gt;WeaMind&lt;/a&gt;，寫下一篇又一篇的技術實作心得。&lt;/p&gt;
&lt;p&gt;讓我們一起在專案中成長，並獲得更多的開發樂趣。&lt;/p&gt;
&lt;p&gt;如標題所示，本文主要介紹 &lt;a href=&quot;https://github.com/features/actions&quot;&gt;GitHub Actions&lt;/a&gt;。不過在此之前，我們得先對 CI 有初步的了解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什麼是-CI？為什麼需要-CI？&quot;&gt;&lt;a href=&quot;#什麼是-CI？為什麼需要-CI？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 CI？為什麼需要 CI？&quot;&gt;&lt;/a&gt;什麼是 CI？為什麼需要 CI？&lt;/h2&gt;&lt;p&gt;CI 是「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88&quot;&gt;Continuous Integration&lt;/a&gt;」的縮寫，中文是「持續整合」。&lt;/p&gt;
&lt;p&gt;它的核心概念是：&lt;strong&gt;當開發人員提交程式碼時，系統可以「自動執行一系列預先定義的檢查流程」&lt;/strong&gt;，例如檢查程式碼是否與現有程式相容、是否能正常運作。&lt;/p&gt;
&lt;p&gt;在軟體開發流程中，我們常常要處理很多&lt;strong&gt;重複但又不可忽略&lt;/strong&gt;的工作：檢查程式碼格式、執行靜態分析、跑單元測試，甚至產生 API 文件等。&lt;/p&gt;
&lt;p&gt;如果每次提交都要手動跑一輪，既麻煩又易忘。&lt;/p&gt;
&lt;p&gt;這時 CI 就派上用場了。它能在每次 push 或開 PR 時（或其它事件），自動幫我們做這些事，讓問題提早浮現，使得開發流程更加穩健，也能節省大量重複性勞動。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="GitHub Actions" scheme="https://blog.kyomind.tw/tags/GitHub-Actions/"/>
    
    <category term="WeaMind" scheme="https://blog.kyomind.tw/tags/WeaMind/"/>
    
  </entry>
  
  <entry>
    <title>yadm 教學：實作 macOS 與 Linux 的 dotfiles 跨平台同步</title>
    <link href="https://blog.kyomind.tw/yadm-cross-platform/"/>
    <id>https://blog.kyomind.tw/yadm-cross-platform/</id>
    <published>2025-06-28T15:01:29.000Z</published>
    <updated>2025-06-29T02:30:43.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><p>兩年多前，我寫了這篇〈<a href="https://blog.kyomind.tw/yadm/">是時候同步你的 dotfiles 了——我選擇 yadm</a>〉，當時的主要動機是想要在多個 Linux VM 之間同步設定檔。</p><p>該文章介紹了「何謂 dotfiles」（後端工程師應該都很熟悉），以及我認為的「dotfiles 同步工具」的兩大流派：</p><ol><li>Symbolic Link。</li><li>Bare Git。</li></ol><p>然而，兩年之間，我幾乎很少在文中提起它。</p><p>事實上，我這段期間使用的 yadm 的頻率<strong>確實不高</strong>！</p><p>但這並不代表我沒有同步 dotfiles 的需求，只是真正的核心需求在於<strong>跨平台</strong>，尤其是 macOS 與 Linux 之間。</p><p>若僅是在不同 Linux VM 之間同步，就顯得有點小打小鬧，<strong>實用性不足</strong>。</p><hr><p>我日常開發主要都在 Mac 上，而 Mac 與 Linux 的設定落差雖不大，但<strong>絕不會完全相同</strong>——這讓單一套設定難以通用。</p><p>比如我的 Mac 上有一些 Homebrew 的環境變數，在 Linux 上無用武之地不說，還可能造成執行錯誤。</p><p>總之，<strong>若不解決跨平台問題，那 yadm 的價值將發揮不到一半。</strong></p><p>上個月我終於鐵了心，<strong>把這件事搞定了！</strong></p><p>做完只覺得，我實在太晚開始，跨平台同步的<strong>價值非常巨大且實用</strong>。</p><p>因此，儘管使用這類工具的人並不多，我也要寫下這篇文章，供有志之士參考！</p><span id="more"></span><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文重點在於介紹 yadm 的跨平台<strong>設定檔、關聯機制</strong>，還有基本操作。</p><p>所以我會假設你已經用過了 yadm——其實沒用過也無妨，因為常見的操作並不複雜。你可以等看了效果後再決定是否學習 yadm。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>不可否認，本文的目標讀者是軟體工程師，尤其是後端開發者。</p><p>非技術出身的讀者，可能連 dotfiles 的作用都不容易理解——這很正常。</p><p>總之，對於一個熱衷於「客製化工具設定」的開發者，我相信 dotfiles 的同步是肯定要學的。</p><p>太實用了！</p><hr><h2 id="Alternate-Files-介紹"><a href="#Alternate-Files-介紹" class="headerlink" title="Alternate Files 介紹"></a>Alternate Files 介紹</h2><p>yadm 最強大的能力之一，就是透過「<a href="https://yadm.io/docs/alternates">Alternate Files</a>」（下稱 alt files）來實現跨平台同步，<strong>它能依據作業系統、主機名稱等條件，自動尋找對應的設定檔</strong>。</p><p>這是實現跨平台 dotfiles 管理的核心關鍵。</p><h3 id="實際範例：我的-dotfiles-結構"><a href="#實際範例：我的-dotfiles-結構" class="headerlink" title="實際範例：我的 dotfiles 結構"></a>實際範例：我的 dotfiles 結構</h3><p>這是我的 dotfiles repo 現況，我們只要關注這些「檔名」即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .aliases<span class="comment">##default</span></span><br><span class="line">├── .aliases<span class="comment">##os.Darwin</span></span><br><span class="line">├── .aliases<span class="comment">##os.Linux</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Darwin</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Linux</span></span><br><span class="line">├── .zprofile<span class="comment">##default</span></span><br><span class="line">├── .zprofile<span class="comment">##os.Darwin</span></span><br><span class="line">├── .zshrc<span class="comment">##default</span></span><br><span class="line">├── .zshrc<span class="comment">##os.Darwin</span></span><br><span class="line">└── .zshrc<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><p>可以大概看出，我僅僅同步了 4 個主要設定檔，雖然加上 alt files 後，實際上總共有 10 個檔案。</p><p>這個命名結構反映出<strong>兩種</strong>主要形式——共用檔與變體檔：</p><ul><li><code>##default</code>：所有平台共通的預設設定（<strong>共用檔</strong>）</li><li><code>##os.Darwin</code>&#x2F;<code>os.Darwin</code>：依作業系統不同而變化的設定（<strong>變體檔</strong>）</li></ul><p>這種設計的重點是「<strong>分層與組合</strong>」。</p><p>yadm 在處理 alt files 時，會<strong>優先使用符合條件的變體</strong>（如 Darwin），若該變體不存在，則退回（fallback）至 default 檔案。</p><p>如此一來，我們就能<strong>針對特定平台進行客製設定，同時保有共用邏輯</strong>。</p><hr><h2 id="yadm-Alt-Files-的三大重點"><a href="#yadm-Alt-Files-的三大重點" class="headerlink" title="yadm Alt Files 的三大重點"></a>yadm Alt Files 的三大重點</h2><p>我知道，光這樣講並不容易理解。</p><p>簡單來說，我覺得這些 alt files 有三個學習重點。</p><h3 id="一、「後綴」命名格式與樣式"><a href="#一、「後綴」命名格式與樣式" class="headerlink" title="一、「後綴」命名格式與樣式"></a>一、「後綴」命名格式與樣式</h3><p>在特殊標記<code>##</code>之後的「<strong>os 層級</strong>」命名格式是固定的！</p><p>換言之，<code>os.Darwin</code>、<code>os.Darwin</code>這些「後綴」名稱<strong>不可自訂</strong>，千萬不要打錯了。</p><p>事實上這類後綴可以有<strong>非常多樣</strong>的寫法，有些確實需要自定義，比如文件中的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##class.Work</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##class.Work,~os.Darwin</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host1</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host2</span></span><br></pre></td></tr></table></figure><p>這允許你即使在同一種平台，也能讓不同主機，甚至不同使用者之間產生一定的差異與客製。</p><p>不過我覺得，<strong>區分 macOS 和 Linux 就已經非常實用</strong>。</p><p><strong>我建議你也這樣做就好</strong>，因為我認為 yadm <strong>已然不算很平易近人的工具XD</strong>，如果還要了解這些複雜的後綴規則與用法，恐怕讓人退避三舍。</p><h3 id="二、路徑的尋找規則"><a href="#二、路徑的尋找規則" class="headerlink" title="二、路徑的尋找規則"></a>二、路徑的尋找規則</h3><p>在<strong>相同前綴不同後綴</strong>的一系列的檔名中，yadm 只會依照「尋找規則」，選取其中一個建立 Symbolic Link，讓它指向<strong>系統真正會讀取的檔案</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── .zshrc<span class="comment">##default</span></span><br><span class="line">├── .zshrc<span class="comment">##os.Darwin</span></span><br><span class="line">└── .zshrc<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><p>以<code>.zshrc</code>為例，在 macOS 上，它會找到<code>.zshrc##os.Darwin</code>。</p><p>而在 Linux 上則是<code>.zshrc##os.Linux</code>。</p><p>透過這套尋找規則，yadm 就能在不同作業系統提供<strong>設定檔的差異化</strong>。</p><h3 id="三、共用檔的角色"><a href="#三、共用檔的角色" class="headerlink" title="三、共用檔的角色"></a>三、共用檔的角色</h3><p>承上，熟悉 dotfiles 的你應該不難猜到，<code>.zshrc##default</code>要放的內容，就是兩邊都會「共用」的部分。</p><p>然後，在「變體」檔的開頭，要去<code>source</code>共用檔的內容！</p><p>以我的<code>.zshrc##os.Darwin</code>為例，開頭內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macOS 專屬 zsh 設定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先載入共用設定</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;<span class="variable">$HOME</span>/.zshrc##default&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Homebrew node@18 路徑（macOS 專屬）</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/opt/homebrew/opt/node@18/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果沒有共用檔，自然就不需要開頭的<code>source</code>。</p><p>像<code>p10k.zsh</code>因為設定複雜，我直接區分兩種版本，根本沒有共用部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── .p10k.zsh<span class="comment">##os.Darwin</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><hr><h2 id="Link-操作：yadm-alt"><a href="#Link-操作：yadm-alt" class="headerlink" title="Link 操作：yadm alt"></a>Link 操作：yadm alt</h2><p>當你完成上述的檔案設計並同步 dotfiles 後，只需執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm alt</span><br></pre></td></tr></table></figure><p>yadm 會<strong>尋找並關聯</strong>該主機上對應的檔案。</p><p>注意，這個步驟<strong>必不可少</strong>！不然你會發現，雖然所有 dotfiles 都已同步到本機，但這些檔案並沒有被實際使用。</p><p>而所謂的「<strong>關聯</strong>」，如前所述，就是建立 Symbolic Link。</p><p>在 Mac 上執行結果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ yadm alt</span><br><span class="line">Linking /Users/kyo/.aliases<span class="comment">##os.Darwin to /Users/kyo/.aliases</span></span><br><span class="line">Linking /Users/kyo/.p10k.zsh<span class="comment">##os.Darwin to /Users/kyo/.p10k.zsh</span></span><br><span class="line">Linking /Users/kyo/.zprofile<span class="comment">##os.Darwin to /Users/kyo/.zprofile</span></span><br><span class="line">Linking /Users/kyo/.zshrc<span class="comment">##os.Darwin to /Users/kyo/.zshrc</span></span><br></pre></td></tr></table></figure><p>而 Linux 則是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ yadm alt</span><br><span class="line">Linking /home/kyo/.aliases<span class="comment">##os.Linux to /home/kyo/.aliases</span></span><br><span class="line">Linking /home/kyo/.p10k.zsh<span class="comment">##os.Linux to /home/kyo/.p10k.zsh</span></span><br><span class="line">Linking /home/kyo/.zprofile<span class="comment">##default to /home/kyo/.zprofile</span></span><br><span class="line">Linking /home/kyo/.zshrc<span class="comment">##os.Linux to /home/kyo/.zshrc</span></span><br></pre></td></tr></table></figure><p>Beautiful！</p><hr><h2 id="yadm-使用忠告"><a href="#yadm-使用忠告" class="headerlink" title="yadm 使用忠告"></a>yadm 使用忠告</h2><p>yadm 是 Git 的 wrapper，操作它等於在<strong>操作一個裸露的 Git repo</strong>——而且這個 repo 還是<strong>你的 Home 目錄</strong>😱</p><p>這意味著，yadm 的操作<strong>會直接影響到你的系統設定檔</strong>。</p><p>如果你太隨意下達像是<code>yadm reset</code>、<code>yadm add .</code>等指令，有可能會讓你的系統檔案直接損毀XD</p><p>我就曾因為情急不慎操作，導致某台 VM 的設定變得半殘XD，只能砍掉重練。</p><h3 id="安全使用法則"><a href="#安全使用法則" class="headerlink" title="安全使用法則"></a>安全使用法則</h3><p>因此，我歸納了一個更安全的使用之道：</p><ul><li>所有設定修改，都集中在本機上的 dotfiles repo 中，<strong>透過 VS Code 進行編輯</strong>。</li><li>其他機器（包括本機）<strong>僅透過</strong><code>yadm pull</code><strong>同步修改後的結果</strong>，不進行任何<code>yadm commit</code>、<code>yadm push</code>等動作。</li></ul><p>這樣的模式確保你的設定變動<strong>只從單一來源發出</strong>，降低毀損風險，也讓同步過程更安全可控。</p><p>此外，如果我要做<code>yadm pull</code>、<code>yadm list</code>、<code>yadm status</code>三個指令（後兩者並不會改變檔案狀態，所以是安全的）<strong>以外</strong>的操作，<strong>我一定會先問 AI！</strong></p><p>因為這工具看似簡單，但威力絕不容小覷。</p><hr><h2 id="結語：同步-dotfiles-真的非常愉快"><a href="#結語：同步-dotfiles-真的非常愉快" class="headerlink" title="結語：同步 dotfiles 真的非常愉快"></a>結語：同步 dotfiles 真的非常愉快</h2><p>不誇張，自從設好跨平台同步後，<strong>開發幸福感大幅提升</strong>！</p><p>我以前太小看 yadm 了，可以跨平台之後，我變得更常改動 dotfiles、加入新的 alias，絲毫不用擔心同步問題。</p><p>我知道這篇文章不會有太多受眾，怕哪是軟體工程師，也不是人人都熱衷此道。</p><p>但如果你想在多台 Mac 和多台 Linux VM（我目前有 3 台 Mac 與兩台 Linux VM）同步設定檔，卻仍在猶豫要選用哪一款工具的話。</p><p><strong>不用想了，就選 yadm 吧！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;p&gt;兩年多前，我寫了這篇〈&lt;a href=&quot;https://blog.kyomind.tw/yadm/&quot;&gt;是時候同步你的 dotfiles 了——我選擇 yadm&lt;/a&gt;〉，當時的主要動機是想要在多個 Linux VM 之間同步設定檔。&lt;/p&gt;
&lt;p&gt;該文章介紹了「何謂 dotfiles」（後端工程師應該都很熟悉），以及我認為的「dotfiles 同步工具」的兩大流派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symbolic Link。&lt;/li&gt;
&lt;li&gt;Bare Git。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，兩年之間，我幾乎很少在文中提起它。&lt;/p&gt;
&lt;p&gt;事實上，我這段期間使用的 yadm 的頻率&lt;strong&gt;確實不高&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;但這並不代表我沒有同步 dotfiles 的需求，只是真正的核心需求在於&lt;strong&gt;跨平台&lt;/strong&gt;，尤其是 macOS 與 Linux 之間。&lt;/p&gt;
&lt;p&gt;若僅是在不同 Linux VM 之間同步，就顯得有點小打小鬧，&lt;strong&gt;實用性不足&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我日常開發主要都在 Mac 上，而 Mac 與 Linux 的設定落差雖不大，但&lt;strong&gt;絕不會完全相同&lt;/strong&gt;——這讓單一套設定難以通用。&lt;/p&gt;
&lt;p&gt;比如我的 Mac 上有一些 Homebrew 的環境變數，在 Linux 上無用武之地不說，還可能造成執行錯誤。&lt;/p&gt;
&lt;p&gt;總之，&lt;strong&gt;若不解決跨平台問題，那 yadm 的價值將發揮不到一半。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上個月我終於鐵了心，&lt;strong&gt;把這件事搞定了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做完只覺得，我實在太晚開始，跨平台同步的&lt;strong&gt;價值非常巨大且實用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，儘管使用這類工具的人並不多，我也要寫下這篇文章，供有志之士參考！&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>將域名註冊移轉至 Dynadot</title>
    <link href="https://blog.kyomind.tw/weekly-review-44/"/>
    <id>https://blog.kyomind.tw/weekly-review-44/</id>
    <published>2025-06-21T08:45:35.000Z</published>
    <updated>2025-12-20T13:29:06.597Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/weekly-review.png"></p><p>我從 2018 年開始租用<code>kyomind.tw</code>這個域名，至今已 7 年。</p><p>每年 9&#x2F;1 是它的續約時間。過去多年來，價格大致穩定，折合新台幣大概 700 多元。</p><p>直到去年續約，我被信用卡帳單上的金額嚇了一跳：<strong>1260 元</strong>。</p><p>這是什麼情況？</p><p>一度以為是哪裡被誤收，或是信用卡出了問題。但查了帳單、比對後台紀錄，確認那筆款項的確是域名供應商 <a href="https://www.gandi.net/zh-Hant">Gandi</a> 對我的 .tw 域名的續約費用。</p><p>當下覺得很不對勁——域名費用可以這樣說漲就漲嗎？而且幅度也太誇張了！</p><hr><p>就這樣過了半年多，想想幾個月後又要續約了，1260 實在有點讓人卻步。</p><p>我們知道，域名在不同供應商之間，價格並不同。</p><p>而且！<strong>域名是可以移轉的</strong>。</p><p>所以我決定查查，目前 .tw 便宜的地方有哪些——發現了 <a href="https://www.dynadot.com/">Dynadot</a> 只要 18 美元！</p><p>而且，其他域名供應商，大概也只要二十幾美元左右啊，怎麼 Gandi 會特別貴？</p><p>於是我決定進一步弄清楚這到底是怎麼回事，這才發現，其實此時此刻，Gandi 的續約價格也只是台幣 700 多。</p><p>這讓我更加惱火了……</p><span id="more"></span><h2 id="發生了什麼事？"><a href="#發生了什麼事？" class="headerlink" title="發生了什麼事？"></a>發生了什麼事？</h2><p>用 ChatGPT 的 o3 模型幫我一探究竟。</p><p>以下匯率會依時間變動，看美元計價即可。</p><table><thead><tr><th>時點</th><th>Gandi 的 .tw 域名價格</th><th>實際反應</th></tr></thead><tbody><tr><td>2022-05-27</td><td>由 US$23.26 漲到 US$25（≈NT$710）</td><td>官方公告「.tw 調價」</td></tr><tr><td>2023-03</td><td>法國 Gandi SAS 與荷蘭的 Total Webhosting Solutions（TWS）正式合併，成立新的歐洲線上服務平台 <strong>Your.Online</strong>（官方<a href="https://news.gandi.net/en/2023/03/your-online-gandi-continues-its-development/">新聞稿</a>）</td><td>合併（<strong>實際上是 Gandi 被收購</strong>）完成後，<a href="http://gandi.net/">Gandi.net</a> 保持自治與原有品牌運營。但經營策略明顯轉變，為後續價格變動埋下伏筆</td></tr><tr><td>2024-08-29</td><td>突然暴漲到 US$39.98（≈NT$1,260）</td><td>客戶收到 30 天預告信，8&#x2F;29 價目表 PDF 生效；我的 9&#x2F;1 續約正好被擊中</td></tr><tr><td>2025-Q1 (未公告)</td><td>悄悄下修到 US$24（≈NT$744）</td><td>現在官網 .tw 頁面顯示的價格</td></tr></tbody></table><p>換句話說：我被收的 1260 元，的確是當時<strong>正式定價</strong>——而且才調漲沒幾天🤬</p><p>但之後 Gandi 又自己把價錢降了回來，整段過程沒有發新聞稿、沒有發聲明，就像整件事從來沒發生過一樣。</p><h2 id="為什麼會「漲了又降」？"><a href="#為什麼會「漲了又降」？" class="headerlink" title="為什麼會「漲了又降」？"></a>為什麼會「漲了又降」？</h2><p>漲價的不只有 .tw 域名，許多常見的域名都有漲，而且漲幅都很驚人。</p><p>雖然沒說明為何漲了又降，但從<a href="https://www.reddit.com/r/Domains/comments/1f4r7nl/the_cost_of_renewing_my_com_domain_is_coming_in/">社群反應</a>與價目表變化來看，極有可能是因為 2024 年暴漲後引發大量客戶流失。</p><p>就像前面說的，域名並非獨家提供的東西，<strong>用戶隨時可以選擇移轉到其他供應商</strong>。</p><p>Gandi 為了止血，在 2025 年初悄悄調以前的合理價格，卻選擇不對外說明。</p><p>畢竟如果有一個正式公告，那就相當於宣布自己做錯了事——確實是大錯特錯。</p><p>最後也只能摸摸鼻子，把價格調回來。</p><hr><h2 id="我還是決定移轉"><a href="#我還是決定移轉" class="headerlink" title="我還是決定移轉"></a>我還是決定移轉</h2><p>說真的，如果沒有去年的事件，就算我發現 Dynadot 上面的 TW 域名只要 18 美元，我基本上還是不會想移轉。</p><p>畢竟一年 6 美元的差距，沒有大到「讓我感到可惜」的地步。</p><p>服務用久了，還是會有感情的。</p><p>可是，想到去年發生的事，加上現在域名已經託管給 Cloudflare 了，註冊商的重要性大幅降低。才讓我有幾分心動。</p><p>在跟 AI 反覆討論之後，他還是力勸我離開，不要吃這種虧。</p><p>幾經考慮，決定移轉！</p><h2 id="域名轉出"><a href="#域名轉出" class="headerlink" title="域名轉出"></a>域名轉出</h2><p>操作不複雜。轉移流程如下：</p><ol><li>從 Gandi 後台解鎖域名，取得 EPP Code。</li><li>在 Dynadot 下單轉入，後續依照指示輸入該 code。</li><li>DNS Server 維持指向原本的 Cloudflare，不用做什麼。轉移期間 0 停機。</li><li>通常 24–48 小時就會完成。<strong>我實際操作只花了 1-2 小時。</strong></li></ol><h3 id="轉出心得"><a href="#轉出心得" class="headerlink" title="轉出心得"></a>轉出心得</h3><p>說真的，我覺得 Gandi 的後台比 Dynadot 更清楚、簡潔。</p><p>但如前所述，因為域名已托管給 Cloudflare，這一點其實已經不重要了。</p><p>所有的域名操作都是在 Cloudflare 上，除了每年（或每幾年）續約一次，平時根本不需要再登入註冊商後台。</p><p>在這種使用情境下，「價格」（或供應商的可靠度）幾乎成了唯一考量。</p><blockquote><p>有興趣在 Dynadot 購買域名的朋友，可以考慮透過我的<a href="http://www.dynadot.com/?s8WF6Q818Y8s748P">邀請連結</a>註冊。</p></blockquote><p>新戶透過這個連結註冊，並購買域名滿 9.99 美元時，雙方可各獲得 5 美元的優惠。</p><hr><h2 id="哪裡買域名最划算？Cloudflare-是首選"><a href="#哪裡買域名最划算？Cloudflare-是首選" class="headerlink" title="哪裡買域名最划算？Cloudflare 是首選"></a>哪裡買域名最划算？Cloudflare 是首選</h2><p>無論是購買新的域名，或是移轉既有的域名，我都建議<strong>優先查看 <a href="https://www.cloudflare.com/zh-tw/products/registrar/">Cloudflare Registrar</a></strong> 提供的價格與支援範圍。</p><p>只要 Cloudflare 支援該 <a href="https://zh.wikipedia.org/zh-tw/%E9%A0%82%E7%B4%9A%E5%9F%9F">TLD</a>，它幾乎都提供「<strong>接近成本價</strong>」的續費方案，而且整合自家 DNS，操作與安全性也更有保障。</p><blockquote><p><strong>頂級域名</strong>（英語：Top-level Domain, TLD）是<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">網際網路</a><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系統</a>的等級中，位於根域名空間的最高級域名，例如<code>com</code>是網址<code>example.com</code>的頂級域名。</p></blockquote><p>若 Cloudflare 沒有你需要的 TLD（很可惜它就不支援 .tw 域名），再去像 Dynadot、Namecheap 等註冊商比價會更有效率。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>從 Gandi 被收購後接連出現的價格波動與溝通失誤，可以看出一件事：當一家註冊商不再把用戶信任當作優先考量，無論它過去再穩，都可能在一夜之間變得不可靠。</p><p>這不是單一價格調漲的問題，而是<strong>整體經營思維轉變</strong>的結果。</p><p>這種「<strong>恣意妄為</strong>」的態度，讓我對 Gandi 的信任度大幅下降。既然有了更好的選擇，為什麼不換呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/weekly-review.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我從 2018 年開始租用&lt;code&gt;kyomind.tw&lt;/code&gt;這個域名，至今已 7 年。&lt;/p&gt;
&lt;p&gt;每年 9&amp;#x2F;1 是它的續約時間。過去多年來，價格大致穩定，折合新台幣大概 700 多元。&lt;/p&gt;
&lt;p&gt;直到去年續約，我被信用卡帳單上的金額嚇了一跳：&lt;strong&gt;1260 元&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是什麼情況？&lt;/p&gt;
&lt;p&gt;一度以為是哪裡被誤收，或是信用卡出了問題。但查了帳單、比對後台紀錄，確認那筆款項的確是域名供應商 &lt;a href=&quot;https://www.gandi.net/zh-Hant&quot;&gt;Gandi&lt;/a&gt; 對我的 .tw 域名的續約費用。&lt;/p&gt;
&lt;p&gt;當下覺得很不對勁——域名費用可以這樣說漲就漲嗎？而且幅度也太誇張了！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;就這樣過了半年多，想想幾個月後又要續約了，1260 實在有點讓人卻步。&lt;/p&gt;
&lt;p&gt;我們知道，域名在不同供應商之間，價格並不同。&lt;/p&gt;
&lt;p&gt;而且！&lt;strong&gt;域名是可以移轉的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以我決定查查，目前 .tw 便宜的地方有哪些——發現了 &lt;a href=&quot;https://www.dynadot.com/&quot;&gt;Dynadot&lt;/a&gt; 只要 18 美元！&lt;/p&gt;
&lt;p&gt;而且，其他域名供應商，大概也只要二十幾美元左右啊，怎麼 Gandi 會特別貴？&lt;/p&gt;
&lt;p&gt;於是我決定進一步弄清楚這到底是怎麼回事，這才發現，其實此時此刻，Gandi 的續約價格也只是台幣 700 多。&lt;/p&gt;
&lt;p&gt;這讓我更加惱火了……&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/weekly-review.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
  </entry>
  
  <entry>
    <title>為 e2-micro VM 建立 SSH 連線：本機與 GitHub</title>
    <link href="https://blog.kyomind.tw/vm-ssh-setup/"/>
    <id>https://blog.kyomind.tw/vm-ssh-setup/</id>
    <published>2025-06-14T02:59:31.000Z</published>
    <updated>2025-06-22T03:15:46.519Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/code-and-me.png"></p><p>不久前，我看完了朋友<a href="https://kucw.io/about/">古古</a>的電子報〈<a href="https://kucw.io/blog/gcp-free-tier/">終身免費的 VM 服務！Google Cloud 免費方案分享</a>〉，介紹 GCP 的 E2 Micro（產品代號：e2-micro）免費 VM。</p><p>簡言之，我們可以在<strong>一定資源額度與條件範圍內</strong>，免費使用 Google Cloud Platform 上的 Compute Engine 虛擬機器。</p><p>我對此深感興趣，因為它的規格比之前的 F1 Micro 好上一截。</p><p>F1 時代的 RAM 大約只有 0.6 GiB（約 600MB），有開發經驗的都知道，這在某些情況下，用起來會有點捉襟見肘😂</p><p>於是，我也跟著教學開了一台！免費的午餐怎麼能不拿呢？</p><p>附帶一提，對 GCP 不熟的人——比如我，<strong>請一定要照著教學來建立 VM</strong>，以免設定時有所遺漏，一不小心就被收費。</p><h2 id="最後一塊拼圖"><a href="#最後一塊拼圖" class="headerlink" title="最後一塊拼圖"></a>最後一塊拼圖</h2><p>不過原來的教學只寫到 VM 建立完成為止，對於我們這些後端工程師而言，顯然還有一個很重要的基礎設定沒做——SSH 連線。 </p><p>因此，我想補齊這剩下的部分，包含：</p><ol><li>建立自己的 Linux 帳號。</li><li>建立本機與 VM 的 SSH 連線金鑰，並完成連線。</li><li>建立 VM 與 GitHub 的 SSH 連線，且能正常 clone Github 專案。</li></ol><p>剛好我在之前文章〈<a href="/linux-dev-setup/">Linux 上的 Python 開發環境設定</a>〉中，略過了「<a href="/linux-dev-setup/#%E4%B8%80%E3%80%81%E8%A8%AD%E5%AE%9A-SSH-%E9%80%A3%E7%B7%9A">設定 SSH 連線</a>」環節——老實說只是因為我懶得寫XD</p><p>但仔細想想，這個流程我自己做了很多次，不如直接寫在文章裡，方便大家回顧。</p><p>雖說是寫給 e2-micro，不過，這些內容適用於任何 Linux VM。</p><p>本文就來補完這些步驟，並講述我對於這個免費 VM 的看法。</p><span id="more"></span><hr><h2 id="為什麼你值得一台-E2-Micro？"><a href="#為什麼你值得一台-E2-Micro？" class="headerlink" title="為什麼你值得一台 E2 Micro？"></a>為什麼你值得一台 E2 Micro？</h2><p>因為免費囉！但不止如此。</p><p>〈<a href="/hetzner/">從 DigitalOcean 到 Hetzner：我為何轉向這家德國 VPS 供應商</a>〉一文中，有讀者<a href="https://github.com/kyomind/blog-reply/issues/70#issuecomment-2875240486">留言</a>問道：</p><blockquote><p>想問問不選擇 <a href="https://fly.io/">Fly.io</a> 或 <a href="https://render.com/">render</a> 來部署的原因，他們看起來有免費額度可以部署。</p></blockquote><p>我則回應：</p><blockquote><p>這類帶有免費額度的服務，主要是為了吸引不想花錢的用戶，條款常有變更的可能，比較適合短期或實驗性質（雖然 memos 備份挺容易的），長期部署我比較不會考慮</p></blockquote><p>退一步來說，如果你真的需要一台免費的 VM 來部署 memos 這類的小服務，那麼與其選擇 <a href="https://fly.io/">Fly.io</a> 或 <a href="https://render.com/">render</a>，還不如先開一台 E2 免費 VM！</p><p>等到不堪負荷了（但仍不想付錢XD），再考慮像 Fly.io 或 render 這些供應商也不遲。</p><p>畢竟 GCP 這樣的大廠，福利政策突然變更、收回的機率，通常比上述公司小得多。</p><p>除此之外，還有兩個關鍵理由。 </p><h3 id="一、延遲優勢"><a href="#一、延遲優勢" class="headerlink" title="一、延遲優勢"></a>一、延遲優勢</h3><p>我覺得，這台免費 VM 的最大亮點，是「<strong>延遲低</strong>」。</p><p>GCP 雖然只開放美國三個地區的資料中心供免費機器使用，但實際測試從台灣連線，<strong>延遲還可以</strong>！</p><p>請優先選擇<code>us-west1</code>（美國西部）地區，因為這個地區的延遲最低。</p><p>經實測比我在 Hetzner（德國）上的機器表現好非常多。與 DigitalOcean（新加坡）的延遲相當。</p><p>我自己的 <a href="https://www.cloudpingtest.com/">Cloud Ping Test</a> 網站測試結果如下：</p><ul><li>GCP（us-west1）：130-150 ms</li><li>Hetzner（德國）：600-800 ms</li><li>DigitalOcean（新加坡）：120-150 ms</li></ul><p>雖然比不上 GCP 台灣機房動輒 10-30 ms 的延遲，但對於大多數應用來說，130-150 ms 的延遲應屬「<strong>可接受</strong>」。</p><h3 id="二、免費額度堪稱大方"><a href="#二、免費額度堪稱大方" class="headerlink" title="二、免費額度堪稱大方"></a>二、免費額度堪稱大方</h3><p>免費機器的內容如下：</p><ul><li>0.25 至 2 個 vCPU（1 個共用核心，動態分配資源）</li><li>1 GB RAM</li><li>30 GB 標準磁碟（傳統 HDD）</li><li>每月 1 GB 出站流量</li></ul><p>這些規格看似陽春，但其實已能支撐許多日常小 app。若對照 DigitalOcean，類似的 VM 要價在每個月 5 美元以上。</p><p><img src="https://img.kyomind.tw/20250614-110147-vm-ssh-setup.png">  </p><p>所以，這樣的 VM 竟然可以免費使用，我覺得已經很大方。</p><h2 id="小提醒：對外流量限制"><a href="#小提醒：對外流量限制" class="headerlink" title="小提醒：對外流量限制"></a>小提醒：對外流量限制</h2><p>雖然一直強調它的優點，但是 1GB 的「對外流量」如果要拿來做公開服務，很可能會不夠用。</p><p>你看上圖 DigitalOcean 的價格，6 美元的 VM 每月有著 1000 GiB 的流量。</p><p>E2 Micro <strong>強烈建議只拿來部署自用服務</strong>。</p><hr><p>介紹完我認為的 E2 Micro 優點，接下來進入正題。</p><h2 id="設定-SSH-連線"><a href="#設定-SSH-連線" class="headerlink" title="設定 SSH 連線"></a>設定 SSH 連線</h2><p>在使用雲端平台或 VPS 服務建立 VM 後，通常有<strong>兩種</strong>主要的<strong>初次登入方式</strong>：</p><ol><li><strong>Web 界面提供內建 SSH 終端機</strong>：使用者可從平台介面直接開啟瀏覽器終端登入虛擬機器，無需事先設定金鑰。</li><li><strong>建立 VM 時預先設定 SSH 金鑰</strong>：在建立過程中指定公鑰，平台會在 VM 建立時將其寫入<code>authorized_keys</code>，讓你能用該金鑰從本機連入。（通常是用 root 帳號）</li></ol><p>這兩種方式大多數平台都支援，在原文的教學中，採用的是第一種方式，也就是透過 Web SSH 登入 VM。</p><p>登入之後，我們就可以開始設定<strong>真正屬於自己</strong>的登入方式。</p><h3 id="建立-Linux-帳號"><a href="#建立-Linux-帳號" class="headerlink" title="建立 Linux 帳號"></a>建立 Linux 帳號</h3><p>不管是 root 帳號還是 GCP 給你的帳號，都不是我們自己建立的帳號。</p><p>開發時，通常不會直接使用這些帳號來進行日常操作，尤其 root 帳號權限過大，存在一定的安全風險。</p><p>所以我們習慣先建立自己的 Linux 帳號，然後再設定 SSH 連線。</p><p>建立新帳號，並加入管理者群組：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser kyo</span><br><span class="line">sudo usermod -aG sudo kyo</span><br></pre></td></tr></table></figure><p>這裡直接用<code>kyo</code>舉例，實際操作時，請自行替換帳號名稱。</p><p>為<code>kyo</code>建立<code>.ssh</code>目錄，設定並權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /home/kyo/.ssh</span><br><span class="line">sudo <span class="built_in">chown</span> kyo:kyo /home/kyo/.ssh</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 /home/kyo/.ssh</span><br></pre></td></tr></table></figure><h3 id="本機建立-SSH-金鑰"><a href="#本機建立-SSH-金鑰" class="headerlink" title="本機建立 SSH 金鑰"></a>本機建立 SSH 金鑰</h3><p>接下來，我們在<strong>本機電腦</strong>產出 SSH 金鑰，建議使用 <a href="https://zh.wikipedia.org/zh-tw/EdDSA#Ed25519">Ed25519</a> 演算法，它更加現代，而且更重要的是——<strong>公鑰很短</strong>！（方便複製）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;odinxp@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>採用預設選項一路按<code>Enter</code>的話，會產生下面兩個檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.ssh/</span></span><br><span class="line">id_ed25519</span><br><span class="line">id_ed25519.pub</span><br></pre></td></tr></table></figure><p>通常我會先產出，再自行改名。比如把檔名改成<code>gcp</code>、<code>gcp.pub</code>，方便辨識。</p><p>將產生的公鑰內容複製，並貼到 VM 上<code>kyo</code>帳戶下的<code>authorized_keys</code>中，此時因為是透過 Web SSH 登入的管理者帳號來操作自非身帳號，指令要加上<code>sudo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/gcp.pub</span><br><span class="line"><span class="comment"># 複製內容後在 VM 上操作</span></span><br><span class="line">sudo nano /home/kyo/.ssh/authorized_keys <span class="comment"># 貼上內容後存檔</span></span><br><span class="line">sudo <span class="built_in">chown</span> kyo:kyo /home/kyo/.ssh/authorized_keys</span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /home/kyo/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>在本機建立 <a href="https://chusiang.gitbooks.io/working-on-gnu-linux/content/20.ssh_config.html">SSH config</a> 來簡化連線設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.ssh/config</span><br></pre></td></tr></table></figure><p>然後編輯<code>~/.ssh/config</code>，加入以下內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host gcp</span><br><span class="line">    HostName &lt;VM 的實際 ip&gt;</span><br><span class="line">    User kyo</span><br><span class="line">    IdentityFile ~/.ssh/gcp</span><br></pre></td></tr></table></figure><p>本機測試使用新帳號連線 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh kyo@gcp</span><br></pre></td></tr></table></figure><p>這樣基本就完成了！</p><hr><h2 id="Github-SSH-設定"><a href="#Github-SSH-設定" class="headerlink" title="Github SSH 設定"></a>Github SSH 設定</h2><p>設定完本機連線，我通常會緊接著設定 GitHub 連線。</p><p>注意，<strong>本機連線</strong>指的是「<strong>本機和 VM 之間</strong>」；而 <strong>GitHub 連線</strong>在本文的語境下，則是指「<strong>VM 和 GitHub 之間</strong>」。</p><p>所以這部分的主要操作都是<strong>在 VM 上進行</strong>。</p><p>一樣，先在 VM 上產生新的 SSH 金鑰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;odinxp@gmail.com&quot;</span> -f ~/.ssh/github</span><br></pre></td></tr></table></figure><p>加上<code>-f ~/.ssh/github</code>後，可以省去手動更名的麻煩，不過要注意，它同時也會<strong>覆蓋</strong>原有的檔案！（如果有的話）</p><p>複製公鑰內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/github.pub</span><br></pre></td></tr></table></figure><p>前往 <a href="https://github.com/settings/ssh/new">Github SSH 設定頁</a>，貼上金鑰。</p><p>新增、編輯<code>~/.ssh/config</code>加入 Github 設定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/github</span><br></pre></td></tr></table></figure><p>測試是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com -i ~/.ssh/github</span><br><span class="line">Hi kyomind! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>直接 clone 一個自己的 repo 確認沒問題：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:kyomind/WeaMind.git</span><br><span class="line">Cloning into <span class="string">&#x27;WeaMind&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 193, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (193/193), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (121/121), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 193 (delta 87), reused 161 (delta 58), pack-reused 0 (from 0)</span><br><span class="line">Receiving objects: 100% (193/193), 63.91 KiB | 661.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (87/87), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>大功告成，讚！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/code-and-me.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;不久前，我看完了朋友&lt;a href=&quot;https://kucw.io/about/&quot;&gt;古古&lt;/a&gt;的電子報〈&lt;a href=&quot;https://kucw.io/blog/gcp-free-tier/&quot;&gt;終身免費的 VM 服務！Google Cloud 免費方案分享&lt;/a&gt;〉，介紹 GCP 的 E2 Micro（產品代號：e2-micro）免費 VM。&lt;/p&gt;
&lt;p&gt;簡言之，我們可以在&lt;strong&gt;一定資源額度與條件範圍內&lt;/strong&gt;，免費使用 Google Cloud Platform 上的 Compute Engine 虛擬機器。&lt;/p&gt;
&lt;p&gt;我對此深感興趣，因為它的規格比之前的 F1 Micro 好上一截。&lt;/p&gt;
&lt;p&gt;F1 時代的 RAM 大約只有 0.6 GiB（約 600MB），有開發經驗的都知道，這在某些情況下，用起來會有點捉襟見肘😂&lt;/p&gt;
&lt;p&gt;於是，我也跟著教學開了一台！免費的午餐怎麼能不拿呢？&lt;/p&gt;
&lt;p&gt;附帶一提，對 GCP 不熟的人——比如我，&lt;strong&gt;請一定要照著教學來建立 VM&lt;/strong&gt;，以免設定時有所遺漏，一不小心就被收費。&lt;/p&gt;
&lt;h2 id=&quot;最後一塊拼圖&quot;&gt;&lt;a href=&quot;#最後一塊拼圖&quot; class=&quot;headerlink&quot; title=&quot;最後一塊拼圖&quot;&gt;&lt;/a&gt;最後一塊拼圖&lt;/h2&gt;&lt;p&gt;不過原來的教學只寫到 VM 建立完成為止，對於我們這些後端工程師而言，顯然還有一個很重要的基礎設定沒做——SSH 連線。 &lt;/p&gt;
&lt;p&gt;因此，我想補齊這剩下的部分，包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立自己的 Linux 帳號。&lt;/li&gt;
&lt;li&gt;建立本機與 VM 的 SSH 連線金鑰，並完成連線。&lt;/li&gt;
&lt;li&gt;建立 VM 與 GitHub 的 SSH 連線，且能正常 clone Github 專案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;剛好我在之前文章〈&lt;a href=&quot;/linux-dev-setup/&quot;&gt;Linux 上的 Python 開發環境設定&lt;/a&gt;〉中，略過了「&lt;a href=&quot;/linux-dev-setup/#%E4%B8%80%E3%80%81%E8%A8%AD%E5%AE%9A-SSH-%E9%80%A3%E7%B7%9A&quot;&gt;設定 SSH 連線&lt;/a&gt;」環節——老實說只是因為我懶得寫XD&lt;/p&gt;
&lt;p&gt;但仔細想想，這個流程我自己做了很多次，不如直接寫在文章裡，方便大家回顧。&lt;/p&gt;
&lt;p&gt;雖說是寫給 e2-micro，不過，這些內容適用於任何 Linux VM。&lt;/p&gt;
&lt;p&gt;本文就來補完這些步驟，並講述我對於這個免費 VM 的看法。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
  </entry>
  
</feed>
