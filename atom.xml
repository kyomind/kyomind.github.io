<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/favicon-32x32.png</icon>
  <subtitle>Kyo 的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2025-07-27T15:42:50.349Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Hetzner 開新 VM 指南：選機房、SSH 連線、設定防火牆</title>
    <link href="https://blog.kyomind.tw/hetzner-vm/"/>
    <id>https://blog.kyomind.tw/hetzner-vm/</id>
    <published>2025-07-27T15:03:31.000Z</published>
    <updated>2025-07-27T15:42:50.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/GhElIMy.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><p>〈<a href="/hetzner/">Hetzner VPS 實測：比 DigitalOcean 更划算的選擇？</a>〉介紹了 Hetzner 這個來自德國的 VPS 供應商，該篇文章在 VM 價格與規格上，與 DigitalOcean 進行比較。</p><p>使用下來已超過 3 個月，除了台灣連歐洲的延遲較高，以這樣的價格，整體表現仍讓我十分滿意。</p><p>我之後絕大部分的服務，都會部署在目前租用的 Hetzner VM 上。</p><p>上一篇是介紹與推廣，本篇則是進一步教你怎麼在 Hetzner 平台上建立新 VM，簡單實用。</p><p>話不多說，直接開始。</p><span id="more"></span><hr><p>登入後，先打開 Hetzner 的 <a href="https://console.hetzner.com/">Console 頁面</a>。</p><p><img src="https://img.kyomind.tw/20250727-230712-hz1-min.png" alt="Hetzner Console"><span class="cap">Hetzner Console</span>  </p><p>新增專案並點擊「Create Server」後，我們會在該頁面完成全部流程。</p><p>大部分步驟都不難理解，以下只針對其中幾步進行重點解說。</p><hr><h2 id="一、資料中心選擇"><a href="#一、資料中心選擇" class="headerlink" title="一、資料中心選擇"></a>一、資料中心選擇</h2><p>如圖，全世界有 6 處資料中心可供選擇，3 個在歐洲，2 個在美國，1 個在新加坡。</p><p><img src="https://img.kyomind.tw/20250727-230936-hz2-min.png" alt="機房選擇"><span class="cap">機房選擇</span>  </p><p>但如果你和我一樣選 ARM 版的 CPU，那就只剩下歐洲的 3 個可選。</p><p>這部分請參考上一篇的「<a href="/hetzner/#%E5%AF%A6%E9%9A%9B%E6%B8%AC%E8%A9%A6%EF%BC%9ALatency-%E6%AF%94%E8%BC%83">實際測試：Latency 比較</a>」（包含我的測試結果），並用你的電腦、網路進行實際測試。</p><p>令人遺憾的是，即使選擇最接近台灣的新加坡機房，我測試的 ping 值也達到 400 毫秒。</p><p>雖然比歐洲機房的 600-800 毫秒快，但相比 DigitalOcean 新加坡機房僅 130 毫秒，仍屬太慢。</p><p>而且價格是歐洲機房的 2 倍左右，個人是覺得不太划算啦！</p><h3 id="歐洲優先"><a href="#歐洲優先" class="headerlink" title="歐洲優先"></a>歐洲優先</h3><p>所以強烈建議，如果對延遲速度有要求，還是不要選它們家的 VM。</p><p>如果可以接受延遲，那選擇歐洲機房與 ARM 處理器，就是最高 CP 值的組合！</p><p><img src="https://img.kyomind.tw/20250727-231130-hz3-min.png" alt="我選擇 CAX21 機型"><span class="cap">我選擇 CAX21 機型</span>  </p><p>以上都是以 Shared vCPU 為準。</p><p>ARM CPU 的 VM，CP 值都極高！此外，以上價格不含稅——還有 5% 的營業稅。</p><h2 id="二、SSH-連線設定"><a href="#二、SSH-連線設定" class="headerlink" title="二、SSH 連線設定"></a>二、SSH 連線設定</h2><p>我們在〈<a href="/vm-ssh-setup/">為 e2-micro VM 建立 SSH 連線：本機與 GitHub</a>〉提過，新 VM 設定 SSH 連線的方式不外乎這兩種：</p><ol><li>Web Console 登入後自行設定。</li><li>建立 VM 時直接上傳公鑰。</li></ol><p>Hetzner 屬於第二種，上傳一組後，可以設為「預設」，讓全專案都可以使用。這樣一來，開第 2 台、第 3 台時就不必再重新上傳了。</p><p>所以，請先準備好你的公鑰。指令可參考「<a href="/vm-ssh-setup/#%E6%9C%AC%E6%A9%9F%E5%BB%BA%E7%AB%8B-SSH-%E9%87%91%E9%91%B0">本機建立 SSH 金鑰</a>」。</p><p>建立完成後，用 terminal 測試 SSH 連線：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@&lt;你的 VM IP&gt;</span><br></pre></td></tr></table></figure><h3 id="SSH-補充建議"><a href="#SSH-補充建議" class="headerlink" title="SSH 補充建議"></a>SSH 補充建議</h3><ol><li>使用 config 檔管理 SSH 連線。</li><li>在<code>root</code>帳號登入後，建立一個普通使用者與獨立的 SSH 連線，並加入 sudo 群組。然後沒事不要再用<code>root</code>登入XD</li></ol><p>保持好習慣，可以省去不必要的麻煩。</p><h2 id="三、防火牆"><a href="#三、防火牆" class="headerlink" title="三、防火牆"></a>三、防火牆</h2><p>Hetzner 的設計是：</p><ul><li>防火牆綁在「專案」層級</li><li>VM 建立時，從現有的防火牆中選擇套用</li></ul><p>如果你尚未建立防火牆，系統會提示你先設定一個，然後再繼續 VM 建立流程。</p><h3 id="Port-開放原則"><a href="#Port-開放原則" class="headerlink" title="Port 開放原則"></a>Port 開放原則</h3><p>建議只開放 22（SSH）、80（HTTP）、443（HTTPS），其餘一律不開。</p><p>其實就是預設值啦！具體設定如下：</p><p><img src="https://img.kyomind.tw/20250727-231422-hz4-min.png" alt="基本防火牆設定"><span class="cap">基本防火牆設定</span>  </p><p>你可以針對不同用途建立多個防火牆設定檔，或直接共用同一個即可。</p><h2 id="四、雜項"><a href="#四、雜項" class="headerlink" title="四、雜項"></a>四、雜項</h2><p>以下是建立 VM 流程中，我對於雜項的選擇：</p><ol><li>作業系統：當然是 <a href="https://ubuntu.com/blog/tag/ubuntu-24-04-lts">Ubuntu 24.04 LTS</a>。（純個人偏好）</li><li>網路：IPv4（需要一點點費用：€0.0008&#x2F;h）、IPv6（免費）勾選。</li><li>Volumes：預設的 80 GB，很夠用，先不選，真的不夠再加。</li><li>Backups：看需求，我沒選。</li></ol><hr><h2 id="結語：Hetzner-就是香！"><a href="#結語：Hetzner-就是香！" class="headerlink" title="結語：Hetzner 就是香！"></a>結語：Hetzner 就是香！</h2><p>不同需求有不同的選擇，不過在多數情況下，Hetzner 提供的產品服務，對我而言就是絕佳選擇！</p><p>我目前已經在上面部署了（皆以 Docker 容器部署）：</p><ol><li>2 個 <a href="/memos/">memos</a> 服務。</li><li>1 個 <a href="/weekly-review-21/">Umami</a> 服務（GA4 替代品）。</li><li>Nginx、Certbot、<a href="https://www.portainer.io/">Portainer</a> 等等。</li><li>我自己的 <a href="https://github.com/kyomind/WeaMind">side project</a>。</li></ol><p>未來還有很大空間可以發擇，預計還要再部署 <a href="https://n8n.io/">n8n</a>。</p><p>這樣的彈性與餘裕，一個月竟然只要 6.5 歐元，真是非常美妙☺️</p><p>這也是為什麼我願意為 Hetzner 寫下兩篇文章介紹並推廣。</p><hr><h2 id="使用我的推薦連結，享受-20-歐元免費額度"><a href="#使用我的推薦連結，享受-20-歐元免費額度" class="headerlink" title="使用我的推薦連結，享受 20 歐元免費額度"></a>使用我的推薦連結，享受 20 歐元免費額度</h2><p>最後，如果你想試試 Hetzner，歡迎使用<a href="https://hetzner.cloud/?ref=gD26JqrE8c9t"><strong>我的推薦連結</strong></a>註冊，你可以直接獲得 <strong>20 歐元的使用額度</strong>。</p><p>而我在<strong>一定條件</strong>下（用戶使用連結註冊並付費達 10 歐元），可以獲得 10 歐元的回饋。<strong>這是贊助本站最有效的方式。</strong></p><p>希望這篇分享能幫助你，在選擇 VPS 的路上，多一個可靠的選擇。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GhElIMy.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;/hetzner/&quot;&gt;Hetzner VPS 實測：比 DigitalOcean 更划算的選擇？&lt;/a&gt;〉介紹了 Hetzner 這個來自德國的 VPS 供應商，該篇文章在 VM 價格與規格上，與 DigitalOcean 進行比較。&lt;/p&gt;
&lt;p&gt;使用下來已超過 3 個月，除了台灣連歐洲的延遲較高，以這樣的價格，整體表現仍讓我十分滿意。&lt;/p&gt;
&lt;p&gt;我之後絕大部分的服務，都會部署在目前租用的 Hetzner VM 上。&lt;/p&gt;
&lt;p&gt;上一篇是介紹與推廣，本篇則是進一步教你怎麼在 Hetzner 平台上建立新 VM，簡單實用。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/GhElIMy.jpeg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>uv 容器化實作：使用官方 image 建立 Dockerfile</title>
    <link href="https://blog.kyomind.tw/uv-dockerfile/"/>
    <id>https://blog.kyomind.tw/uv-dockerfile/</id>
    <published>2025-07-19T07:15:27.000Z</published>
    <updated>2025-08-07T09:45:15.126Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/introducing-uv-min.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><blockquote><p>📌 這是 <a href="https://github.com/kyomind/WeaMind/blob/main/blogs/README.md">WeaMind 系列</a> 的第 3 篇。<br>本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。</p></blockquote><p><a href="https://docs.astral.sh/uv/">uv</a> 是近年來快速竄起的 Python 套件管理器，憑藉其最關鍵的核心特性——快😎，在 Python 開發圈吸引了不少關注與採用。</p><p>之前我已寫過〈<a href="/introducing-uv/">Python 套件管理器 uv 介紹——與 Poetry 比較</a>〉介紹。有興趣的讀者歡迎參考。</p><p>本文是 uv 系列的第二篇，<strong>聚焦於 Dockerfile</strong>。</p><p>當我要將「使用 uv 的 Python 專案」容器化時，我發現相關的討論與介紹較少，所以花了一些時間摸索。</p><p>本文目標是<strong>大幅減少你的試錯時間</strong>，並提出我的實踐與看法。</p><span id="more"></span><h3 id="系列：Python-後端專案容器化"><a href="#系列：Python-後端專案容器化" class="headerlink" title="系列：Python 後端專案容器化"></a>系列：Python 後端專案容器化</h3><ul><li><a href="/series/#Python-%E5%BE%8C%E7%AB%AF%E5%B0%88%E6%A1%88%E5%AE%B9%E5%99%A8%E5%8C%96">文章清單（連載中）</a></li></ul><h3 id="系列：Python-套件管理——使用-uv"><a href="#系列：Python-套件管理——使用-uv" class="headerlink" title="系列：Python 套件管理——使用 uv"></a>系列：Python 套件管理——使用 uv</h3><ul><li><a href="/series/#Python-%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8-uv">文章清單（連載中）</a></li></ul><hr><h2 id="從-Poetry-到-uv：Dockerfile-寫法大不同"><a href="#從-Poetry-到-uv：Dockerfile-寫法大不同" class="headerlink" title="從 Poetry 到 uv：Dockerfile 寫法大不同"></a>從 Poetry 到 uv：Dockerfile 寫法大不同</h2><p>不久前，我才寫下了〈<a href="https://blog.kyomind.tw/poetry-multi-stage-build/">Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</a>〉，講述如何在 Docker 中，使用 Poetry 建立容器內的 Python 執行環境。</p><p>本文算是該篇文章的「<strong>uv 姐妹作</strong>」，但是，做法非常不同！</p><p>我本以為，只要簡單模仿 Poetry 的 multi-stage build 方式就好，但實際操作後才發現問題多多。</p><p>畢竟兩者的指令不同，尤其對於「全域安裝套件」有著截然不同的做法。</p><p>這裡就不仔細比較差異了，經過一番探索，我們已經得到了最佳解😇</p><p>那就是<strong>使用 uv 團隊推出的官方 Docker image！</strong></p><hr><h2 id="使用-uv-官方-image"><a href="#使用-uv-官方-image" class="headerlink" title="使用 uv 官方 image"></a>使用 uv 官方 image</h2><p>關於 uv 容器化議題，uv 開發團隊直接推出了專用的<a href="https://github.com/astral-sh/uv/pkgs/container/uv">官方 image</a>。</p><p>該 image 已內建 uv，且在體積上進行了最佳化，大概只有 60 MB。（指的是使用 slim 版本的 Linux 基底）</p><p>透過它，你可以省去繁瑣的安裝設定，並且在安全性上更有保障。</p><p>如果習慣從 Docker hub 拉取，則可參考<a href="https://hub.docker.com/r/astral/uv/tags">這裡</a>。</p><p>一般而言，仍建議你使用 GitHub 托管的版本——也就是<code>ghcr.io/</code>開頭的版本。因為它才是「第一手」。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghcr.io/astral-sh/uv:python3.12-bookworm-slim</span><br></pre></td></tr></table></figure><p>建議用它作為 Dockerfile 的基底 image。</p><h2 id="如何使用官方-image-撰寫-Dockerfile"><a href="#如何使用官方-image-撰寫-Dockerfile" class="headerlink" title="如何使用官方 image 撰寫 Dockerfile"></a>如何使用官方 image 撰寫 Dockerfile</h2><p>有了 image，那我們要怎麼撰寫 Dockerfile 呢？</p><p>對此，我們也不需要自己苦苦思考了，大部分挑戰都已經有了答案——請直接參考這個<a href="https://github.com/astral-sh/uv-docker-example">官方倉庫</a>中的 <a href="https://github.com/astral-sh/uv-docker-example/blob/main/Dockerfile">Dockerfile</a> 寫法！</p><p><strong>強烈建議你，如果沒有特殊需求，就 follow 它的寫法</strong>，因為 uv 的操作有很多繁瑣的細節，考驗著你對該工具的了解，尤其在 Docker 容器化的場景更是如此。</p><p>官方的 Dockerfile 也非常細心，在多個指令都加上了簡要的註解，讓你知其然又知其所以然。</p><p>其實看過其中一些指令內容就知道，要自己寫肯定很難寫得這麼好。</p><p>所以我們還是盡可能參考甚至遵照這份 Dockerfile 的寫法。</p><p>可以少走很多彎路。</p><hr><h2 id="為什麼不需要-Multi-stage-build？"><a href="#為什麼不需要-Multi-stage-build？" class="headerlink" title="為什麼不需要 Multi-stage build？"></a>為什麼不需要 Multi-stage build？</h2><p>前述〈<a href="https://blog.kyomind.tw/poetry-multi-stage-build/">Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</a>〉教你如何用 multi-stage build 建立 Poetry 虛擬環境。</p><p>因為 Poetry 和 uv 這類工具有<strong>各自需要的執行環境與依賴套件</strong>，不那麼適合在 Docker 建構過程中直接安裝並封裝成 image，這會造成<strong>一定程度的空間浪費與冗餘</strong>。</p><p>所以我們選擇用 multi-stage build 來建立 image。省去不必要的依賴，有效減少最終 image 的體積。</p><p>那為什麼這裡就<strong>沒有這麼做</strong>呢？ </p><p>原因很簡單，<strong>官方已經提供這份簡單、乾淨的 image，讓你直接開箱即用</strong>。雖然最終的 image 中仍會有 uv，但它的體積佔用已然經過最佳化。</p><p>此時自己再搞個 multi-stage build，也省不了多少空間，還徒增 Dockerfile 的複雜度與出錯可能。</p><h3 id="MCP-時代需要-uv"><a href="#MCP-時代需要-uv" class="headerlink" title="MCP 時代需要 uv"></a>MCP 時代需要 uv</h3><p>附帶一提，在這個 MCP（模型上下文協定，<a href="https://modelcontextprotocol.io/introduction">Model Context Protocol</a>）盛行的時代，我們可以看到 MCP Server 的開發，主要由兩種語言佔多數：</p><ol><li>TypeScript（JavaScript）</li><li>Python</li></ol><p>如果你想用 Python 來開發 MCP 服務，並希望讓使用者執行<code>uv run &lt;你定義的指令&gt;</code>來啟動 MCP Server（這是目前主流做法），那 uv 就需要存在你的最終 image 中。</p><blockquote><p>延伸閱讀（外部）：</p><ul><li><a href="https://blog.miniasp.com/post/2025/04/01/Write-your-own-MCP-server-using-uv-and-Python">使用 uv 輔助開發 MCP 伺服器並安裝到 Claude Desktop 與 VS Code</a></li><li><a href="https://oalieno.tw/posts/mcp">MCP 開發實戰手冊：SSE、STDIO、Tool、Resource 一次搞懂</a>（尤其是「<strong>MCP Server 開發語言與執行方式</strong>」部分）</li></ul></blockquote><p>如此一來，自然也不需要透過 multi-stage build 來移除 uv 了。</p><h3 id="我就是要-Multi-stage-build！"><a href="#我就是要-Multi-stage-build！" class="headerlink" title="我就是要 Multi-stage build！"></a>我就是要 Multi-stage build！</h3><p>不同專案有不同需求，如果你真的需要 multi-stage build 以進一步節省空間的話，同一個倉庫中有<a href="https://github.com/astral-sh/uv-docker-example/blob/main/multistage.Dockerfile">另一個 Dockerfile</a> 可供參考。</p><hr><h2 id="uv-與-pip-requirements-txt-混搭法"><a href="#uv-與-pip-requirements-txt-混搭法" class="headerlink" title="uv 與 pip &#x2F; requirements.txt 混搭法"></a>uv 與 pip &#x2F; requirements.txt 混搭法</h2><p>其實，uv 對 pip 的相容性相當不錯——畢竟它有子命令<code>uv pip</code>。</p><p>因此，你也可以不用官方的 uv image，而是使用一般 Python image，再直接搭配<code>requirements.txt</code>安裝容器中的 Python 虛擬環境就好。</p><p>好處是延續了既有的 pip 開發習慣，降低認知負擔。</p><p>重點是，官方還非常貼心地準備了 <a href="https://docs.astral.sh/uv/guides/integration/pre-commit/">pre-commit hook</a>，來協助你輕鬆同步<code>uv.lock</code>與<code>requirements.txt</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">&lt;https://github.com/astral-sh/uv-pre-commit&gt;</span></span><br><span class="line">    <span class="comment"># uv version.</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">0.8</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">uv-export</span></span><br></pre></td></tr></table></figure><p>如此一來，就不會再發生<a href="/poetry-multi-stage-build/#%E8%88%8A%E6%9C%89%E5%81%9A%E6%B3%95%EF%BC%9Arequirements-txt-%E5%8F%8A%E5%85%B6%E9%99%90%E5%88%B6">前文</a>中提到的「在更新<code>poetry.lock</code>時，常常會忘記同步到<code>requirements.txt</code>」這類問題。</p><blockquote><p>相關文章：<a href="/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><p>此外，你也可以使用官方 image 但保留<code>requirements.txt</code>作為安裝依據，Dockerfile 寫法同樣簡單。</p><p>以上這兩種混搭方式的具體實作，可以參考 <a href="https://jumping-code.com/about-me/">JumpingCode 資料科學手記</a>的這篇〈<a href="https://jumping-code.com/2024/08/23/uv-pip-docker-image/#dockerfile-using-uv">如何使用 Python 套件管理工具「uv」取代 pip 來加速 Docker Image 的建立</a>〉。</p><p>其中的「<a href="https://jumping-code.com/2024/08/23/uv-pip-docker-image/#%E5%AF%A6%E6%B8%AC%E6%AA%94%E6%A1%88">實測檔案</a>」一節就提供了完整的 Dockerfile 範例。</p><hr><h2 id="我的-Dockerfile"><a href="#我的-Dockerfile" class="headerlink" title="我的 Dockerfile"></a>我的 Dockerfile</h2><p>最後附上 WeaMind 專案中，我目前使用的 <a href="https://github.com/kyomind/WeaMind/blob/blog/uv-dockerfile-v1-20250719/Dockerfile">Dockerfile</a>。</p><p>我對官方寫法做了一定的<strong>刪減</strong>，主要是移除專案作為第三方套件的相關設定，並簡化 Dockerfile 的快取策略。</p><p>如果你沒有把握，建議和 AI 討論或者直接 follow 官方的寫法就好。</p><p>此外，我還加上了一些註解，供讀者參考。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ghcr.io/astral-sh/uv:python3.<span class="number">12</span>-bookworm-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use &#x27;code&#x27; to avoid confusion with the &#x27;app&#x27; directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile bytecode and avoid symlinks</span></span><br><span class="line"><span class="keyword">ENV</span> UV_COMPILE_BYTECODE=<span class="number">1</span></span><br><span class="line"><span class="keyword">ENV</span> UV_LINK_MODE=<span class="keyword">copy</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="comment"># ---------- layer 1: heavy dependencies ----------</span></span><br><span class="line"><span class="comment"># Cache only invalidates when these two files change</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pyproject.toml uv.lock ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/root/.cache/uv \</span></span><br><span class="line"><span class="language-bash">    uv <span class="built_in">sync</span> --locked --no-dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- layer 2: application code ----------</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the venv at the beginning of PATH</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/code/.venv/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not use uv as the entrypoint</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> []</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/introducing-uv-min.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 這是 &lt;a href=&quot;https://github.com/kyomind/WeaMind/blob/main/blogs/README.md&quot;&gt;WeaMind 系列&lt;/a&gt; 的第 3 篇。&lt;br&gt;本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.astral.sh/uv/&quot;&gt;uv&lt;/a&gt; 是近年來快速竄起的 Python 套件管理器，憑藉其最關鍵的核心特性——快😎，在 Python 開發圈吸引了不少關注與採用。&lt;/p&gt;
&lt;p&gt;之前我已寫過〈&lt;a href=&quot;/introducing-uv/&quot;&gt;Python 套件管理器 uv 介紹——與 Poetry 比較&lt;/a&gt;〉介紹。有興趣的讀者歡迎參考。&lt;/p&gt;
&lt;p&gt;本文是 uv 系列的第二篇，&lt;strong&gt;聚焦於 Dockerfile&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;當我要將「使用 uv 的 Python 專案」容器化時，我發現相關的討論與介紹較少，所以花了一些時間摸索。&lt;/p&gt;
&lt;p&gt;本文目標是&lt;strong&gt;大幅減少你的試錯時間&lt;/strong&gt;，並提出我的實踐與看法。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/introducing-uv-min.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
    <category term="uv" scheme="https://blog.kyomind.tw/tags/uv/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
  </entry>
  
  <entry>
    <title>Vibe Coding 與人類的時代</title>
    <link href="https://blog.kyomind.tw/vibe-coding/"/>
    <id>https://blog.kyomind.tw/vibe-coding/</id>
    <published>2025-07-10T14:22:29.000Z</published>
    <updated>2025-08-26T14:19:18.739Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><blockquote><p>任何人類都能使用魔法的時代要到來了——《葬送的芙莉蓮》漫畫第 53 話 | 人類的時代</p></blockquote><p>有了強大的 AI 輔助 ，寫程式再也不是軟體工程師的專屬。</p><p>如此的時代巨變，首先讓我聯想到的，就是「芙莉蓮」中的這段劇情。</p><p>不過把這個比喻與感受表達得最好的，當屬財經作家王伯達的這篇<a href="https://www.facebook.com/share/p/173juCsKre/">臉書文</a>。</p><p>他寫道：</p><blockquote><p>AI 讓更多人，用更容易的方式使用程式語言與複雜軟體。</p><p>這讓我想到芙莉蓮的老師，弗蘭梅。</p><p>她說服了人類的皇帝，讓人類得以開始研究魔法，魔法不再是個禁忌，開啟了人人有魔法可以練的年代。</p></blockquote><p>顯然，在我這個軟體工程師眼中，AI 就像芙蘭梅，把原本高門檻的知識、技術變成大眾能輕易接觸的工具，<strong>讓所有人都有機會參與創造</strong>。</p><p>本文聊聊我作為一個軟體工程師，如何看待這個 AI 普及後的「魔法時代」。</p><span id="more"></span><hr><h2 id="工程師的傲慢：自詡為魔法的守門人"><a href="#工程師的傲慢：自詡為魔法的守門人" class="headerlink" title="工程師的傲慢：自詡為魔法的守門人"></a>工程師的傲慢：自詡為魔法的守門人</h2><p>曾幾何時，軟體工程師就像這個世界的魔法使，掌握著一種魔法般的語言——程式碼。</p><p>我們用它來創造服務、建立平台、構築起一個個廣袤無垠的數位世界。</p><p>然而，AI 的出現，讓一切開始改變。</p><p>ChatGPT 問世後，所有的「文本生成」變得簡單起來——包括程式碼。</p><p>隨著 AI 持續演進、AI Agent 工具日漸成熟，你越來越常聽到這樣的說法：</p><blockquote><p>我不懂程式語言，但我能用 AI 寫程式。</p></blockquote><p>剛開始聽到這類言論時，老實說，我的內心充滿了鄙夷之情😅</p><p>就像師祖賽莉耶說的：「<strong>魔法就應該是特別的。</strong>」</p><p>而我也覺得，程式就應該是「<strong>特別</strong>」的，不是誰都能隨口說自己「會寫程式」。</p><h2 id="因為稀缺，所以傲慢"><a href="#因為稀缺，所以傲慢" class="headerlink" title="因為稀缺，所以傲慢"></a>因為稀缺，所以傲慢</h2><p>這種想法有道理嗎？也許這是人性的一部分。</p><p>作家朱宥勳在《<a href="https://www.books.com.tw/products/0010867642">文壇生態導覽——作家新手村 2 心法篇</a>》一書中提到，如果一位文人既會寫散文又會寫詩，他會希望人們稱他為「詩人」。</p><p>如果既會寫散文又會寫小說呢？當然是小說家！</p><blockquote><p><strong>所以楊牧是詩人，陳映真是小說家——儘管他們散文都寫得很好</strong>。</p></blockquote><p>看起來，身為詩人、小說家，<strong>似乎比身為散文作家更讓人有一種「特別」的感覺</strong>。</p><p>為什麼？或許是因為——散文的門檻比較低吧。</p><p>任何人，只要識字、能表達，都能自稱「<strong>會寫</strong>」散文（文采如何可以另當別論）。</p><p>而寫詩、寫小說這種「<a href="https://dict.idioms.moe.edu.tw/idiomView.jsp?ID=1150&webMd=2&la=0">陽春白雪</a>」，對我等普羅大眾來說，<strong>簡直連想都不敢想</strong>！——就像寫程式一樣。</p><hr><h2 id="心態的轉變"><a href="#心態的轉變" class="headerlink" title="心態的轉變"></a>心態的轉變</h2><p>懷抱著上述的想法（儘管我不是程式界的楊牧），我一直希望自己是特別的。</p><p>直到今年 2 月，當 <a href="https://zh.wikipedia.org/zh-tw/%E5%AE%89%E5%BE%B7%E7%83%88%C2%B7%E5%8D%A1%E5%B8%95%E6%96%AF">Andrej Karpathy</a> 提出 Vibe Coding 一詞時，我心中的這份傲慢被敲響了喪鐘。</p><p>我心想：如果連這種大神級的軟體工程師，都提出並嘗試了這樣有趣的軟體開發方式，那一般人用這種方式來開發自己需要的工具或服務，完全說得通啊！</p><p>加上 <a href="https://www.facebook.com/will.fans/?locale=zh_TW">Will 保哥</a>的各種鼓吹，我對 Vibe Coding 的接納度迅速上升。</p><h2 id="什麼是-Vibe-Coding"><a href="#什麼是-Vibe-Coding" class="headerlink" title="什麼是 Vibe Coding"></a>什麼是 Vibe Coding</h2><p>Vibe Coding 這個新鮮的詞彙已經有了自己的<a href="https://zh.wikipedia.org/zh-tw/Vibe_coding">維基百科條目</a>。</p><p>我簡要摘錄如下（定義來自英文頁面）：</p><blockquote><p>Vibe coding is an artificial intelligence-assisted software development style popularized by Andrej Karpathy in early 2025. It describes a fast, improvisational, collaborative approach to creating software where the developer and a large language model (LLM) tuned for coding is acting rather like pair programmers in a conversational loop.</p></blockquote><p>簡單講，就是開發者透過自然語言與 AI 對話，反覆修正，一步步建立並完善軟體。</p><p>作為一個 Vibe Coder，你不需了解各種開發細節，甚至不用懂程式語言，而是專注於想要達成的目標和功能需求。</p><p>AI 成為了翻譯者，把我們的意圖轉化為可執行的程式碼。</p><hr><p>心態的改變，讓我開始重新看待「寫程式」的價值本身。</p><h2 id="軟體只是手段"><a href="#軟體只是手段" class="headerlink" title="軟體只是手段"></a>軟體只是手段</h2><p>越來越多人開始用 AI 寫程式，解決各種日常問題。</p><p>近期讓我最有感的是〈<a href="https://www.inside.com.tw/feature/2025-generative-ai/38545-ai-coding-ngoer">【Generative AI 年會】人力少但服務不打折！Peggy Lo：AI Coding 是 NGO 工作者最強大靠山</a>〉。</p><p>報導中，Peggy Lo 分享了她在僅有四人編制的基金會秘書處，如何運用 AI Coding 應對龐大的行政庶務與人力緊縮。</p><p>透過 AI，她不僅大幅提升了工作效率，還能讓服務變得更細緻、更深入。</p><p>這豈不是 Vibe Coding 的最佳典範？</p><p>我知道，程式從來只是手段。重要的不是「會不會寫」，而是「能不能用來解決真正的問題」。</p><p>一方面覺得自己的傲慢有些可笑，一方面也<strong>鬆了口氣</strong>。</p><p>我想，我更該在乎的，不是透過 AI 開發到底算不算「會寫程式」。</p><p>而是作為一個軟體工程師，<strong>我能解決什麼樣的問題</strong>。</p><hr><h2 id="「一般人」的優勢"><a href="#「一般人」的優勢" class="headerlink" title="「一般人」的優勢"></a>「一般人」的優勢</h2><p>而且話說回來，我不禁在想，不會程式的人用 AI 來開發，反而有自己的獨特優勢！</p><p>工程師多少知道某些技術的困難度，這反而會成為心理負擔，限制想像——覺得 AI 應該辦不到。</p><p>事實證明，AI 往往超乎人們的想像——在厲害與不厲害兩個方面都是XD</p><p>不懂程式的人沒這層包袱，做事的方式就很簡單：提出要求，請 AI 想辦法實現。</p><blockquote><p>魔法是想像的世界，在魔法世界中，無法想像的事情就無法實現</p></blockquote><p>沒有限制，反而更能天馬行空，專注於達成目標。</p><p>雖然未必每次都這麼順利，但少了這些束縛，有時候我認為是一個巨大的優勢。</p><p>唉，我就是缺乏想像力。</p><hr><h2 id="工程師也要會-Vibe-Coding"><a href="#工程師也要會-Vibe-Coding" class="headerlink" title="工程師也要會 Vibe Coding"></a>工程師也要會 Vibe Coding</h2><p>當然，這不代表工程師就該束手就擒。</p><p>相反地，我們更需要進化。</p><p>直白地說，我認為軟體工程師比一般人更需要學會 Vibe Coding。</p><p>像我這樣一個只熟悉後端的 Python 工程師，面對不熟的技術領域（例如前端），也需要發揮 Vibe Coding 的精神與實踐能力。</p><p>善於與 AI 協作的工程師（再加上一點想像力😎），可能是這個時代最有力的創造者。</p><h3 id="一般人打造工具，工程師打造系統"><a href="#一般人打造工具，工程師打造系統" class="headerlink" title="一般人打造工具，工程師打造系統"></a>一般人打造工具，工程師打造系統</h3><p>我覺得工程師應用 AI 放大軟體開發的能力，理應遠超過一般人。</p><p>這讓人充滿期待。</p><p>有人說，AI 讓工程師從作者變成了編輯者，<a href="https://www.managertoday.com.tw/articles/view/70451">讓寫程式像審稿</a>。好像自降了格調一般。</p><p>我認為這沒錯啊！重點是——<strong>審稿本身就是門技術活</strong>！</p><p>就像我在〈<a href="https://blog.kyomind.tw/myth-of-ai-writing-efficiency/">AI 讓寫作變輕鬆了？我可不這麼認為</a>〉提到的，AI 對我寫作的影響：</p><blockquote><p>為了善用 AI 的力量，我發現自己<strong>變成了 5 分作者、5 分編輯</strong>，而且<strong>經常在兩種身分間游移互換</strong>：一下子自己寫，讓 AI 看；一下子要 AI 寫、我來看。</p></blockquote><blockquote><p>AI 的普及，讓我們不僅僅是創作者，也成了編輯，甚至是策劃者。<strong>這種角色的轉換增加了工作量和難度，但也讓我們對內容的掌控更為精細。</strong></p></blockquote><p>沒有足夠的經驗，不可能成為優秀的編輯。</p><hr><p>總之，我覺得，工程師也好，非工程師也罷，在 AI 面前，我們都是人類，都需要藉由 AI 的輔助，不斷擴展自己的邊界。</p><p>這是個令人興奮的時代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何人類都能使用魔法的時代要到來了——《葬送的芙莉蓮》漫畫第 53 話 | 人類的時代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了強大的 AI 輔助 ，寫程式再也不是軟體工程師的專屬。&lt;/p&gt;
&lt;p&gt;如此的時代巨變，首先讓我聯想到的，就是「芙莉蓮」中的這段劇情。&lt;/p&gt;
&lt;p&gt;不過把這個比喻與感受表達得最好的，當屬財經作家王伯達的這篇&lt;a href=&quot;https://www.facebook.com/share/p/173juCsKre/&quot;&gt;臉書文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;他寫道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI 讓更多人，用更容易的方式使用程式語言與複雜軟體。&lt;/p&gt;
&lt;p&gt;這讓我想到芙莉蓮的老師，弗蘭梅。&lt;/p&gt;
&lt;p&gt;她說服了人類的皇帝，讓人類得以開始研究魔法，魔法不再是個禁忌，開啟了人人有魔法可以練的年代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顯然，在我這個軟體工程師眼中，AI 就像芙蘭梅，把原本高門檻的知識、技術變成大眾能輕易接觸的工具，&lt;strong&gt;讓所有人都有機會參與創造&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文聊聊我作為一個軟體工程師，如何看待這個 AI 普及後的「魔法時代」。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Vibe Coding" scheme="https://blog.kyomind.tw/tags/Vibe-Coding/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 入門：自動化 Lint、Format 與 Type Check</title>
    <link href="https://blog.kyomind.tw/github-actions/"/>
    <id>https://blog.kyomind.tw/github-actions/</id>
    <published>2025-07-06T02:31:27.000Z</published>
    <updated>2025-07-27T01:25:12.898Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/code-and-me.png"></p><blockquote><p>📌 這是 <a href="https://github.com/kyomind/WeaMind/blob/main/blogs/README.md">WeaMind 系列</a> 的第 2 篇。<br>本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。</p></blockquote><p>從這篇文章開始，我將啟動一個新的系列。</p><p>搭配我正在實作中的 Side Project——<a href="https://github.com/kyomind/WeaMind">WeaMind</a>，寫下一篇又一篇的技術實作心得。</p><p>讓我們一起在專案中成長，並獲得更多的開發樂趣。</p><p>如標題所示，本文主要介紹 <a href="https://github.com/features/actions">GitHub Actions</a>。不過在此之前，我們得先對 CI 有初步的了解。</p><hr><h2 id="什麼是-CI？為什麼需要-CI？"><a href="#什麼是-CI？為什麼需要-CI？" class="headerlink" title="什麼是 CI？為什麼需要 CI？"></a>什麼是 CI？為什麼需要 CI？</h2><p>CI 是「<a href="https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">Continuous Integration</a>」的縮寫，中文是「持續整合」。</p><p>它的核心概念是：<strong>當開發人員提交程式碼時，系統可以「自動執行一系列預先定義的檢查流程」</strong>，例如檢查程式碼是否與現有程式相容、是否能正常運作。</p><p>在軟體開發流程中，我們常常要處理很多<strong>重複但又不可忽略</strong>的工作：檢查程式碼格式、執行靜態分析、跑單元測試，甚至產生 API 文件等。</p><p>如果每次提交都要手動跑一輪，既麻煩又易忘。</p><p>這時 CI 就派上用場了。它能在每次 push 或開 PR 時（或其它事件），自動幫我們做這些事，讓問題提早浮現，使得開發流程更加穩健，也能節省大量重複性勞動。</p><span id="more"></span><h2 id="常見的-CI-工具有哪些？"><a href="#常見的-CI-工具有哪些？" class="headerlink" title="常見的 CI 工具有哪些？"></a>常見的 CI 工具有哪些？</h2><p>市面上已有不少 CI 工具可以選擇，例如：</p><ul><li><strong>Travis CI</strong>：老牌工具，但在開源社群中的使用率逐漸下降。</li><li><strong>CircleCI</strong>：主打高彈性與高度客製化的流程控制。</li><li><strong>GitHub Actions</strong>：GitHub 官方推出、與 GitHub 無縫整合的 CI&#x2F;CD 解決方案。</li></ul><p>這次我們選擇的是 GitHub Actions，理由很簡單：<strong>直接內建於 GitHub、好上手、不用額外註冊帳號</strong>。</p><p>而且對於「公開倉庫」，GitHub 給的 CI 運行時間額度是——無上限！</p><p>即使是私人倉庫，免費用戶也有每月 2000 分鐘，通常很夠用了。</p><hr><h2 id="認識-GitHub-Actions"><a href="#認識-GitHub-Actions" class="headerlink" title="認識 GitHub Actions"></a>認識 GitHub Actions</h2><p><a href="https://github.com/features/actions">GitHub Actions</a> 是 GitHub 提供的 CI&#x2F;CD 解決方案。</p><p>相較於上述提到的其它工具，它誕生的時間算是晚得多。</p><p>雖然推出較晚（2019 年才正式上線），但 GitHub Actions 從一開始就內建於 GitHub 平台，整合度高是它的一大優勢。</p><p>開發者不需額外設定外部服務，就能快速啟用 CI&#x2F;CD 流程，<strong>對個人開發者或小型專案尤其友善。</strong></p><p>你可以透過撰寫一份<code>yaml</code>設定檔，定義「<strong>什麼時候要觸發什麼流程</strong>」，像是：</p><ul><li>每次 push 時跑 Lint</li><li>每次 Pull Request 開啟時跑測試</li></ul><p>它支援容器、多種語言與工具，而且有非常多現成的 actions 可以直接引用。</p><p>這些功能，此刻我們還不需要了解，先著眼於當前的目標即可。</p><hr><h2 id="學習-CI-工具最好的方式：從需求開始"><a href="#學習-CI-工具最好的方式：從需求開始" class="headerlink" title="學習 CI 工具最好的方式：從需求開始"></a>學習 CI 工具最好的方式：從需求開始</h2><p>必須強調，相比於程式語言、後端框架等工具，CI&#x2F;CD 服務是<strong>更加「工具化」的工具</strong>。</p><p>意思是說，雖然有使用上的規則，但其中<strong>並沒有太多的「道理」可言</strong>！</p><p>單純就是看各家廠商怎麼制定與規範、設定檔怎麼寫等等。</p><p>所以，我認為，學習這類工具，最好的方式就是「直接用用看」！</p><p>你不需要一開始就設計一套完整的 CI 流程，只要從<strong>最簡單的需求</strong>開始，例如：</p><ul><li>跑 Lint、跑 Formatter</li><li>檢查型別（Python type check）</li></ul><p>這正是本文的出發點——用 GitHub Actions 設定一個最小可用的 CI 流程，整合 Lint、Format 與 Type Check。</p><h2 id="沒有需求怎麼辦？"><a href="#沒有需求怎麼辦？" class="headerlink" title="沒有需求怎麼辦？"></a>沒有需求怎麼辦？</h2><p>前面強調了需求的重要性，絕非隨便說說。</p><p>為了學習 GitHub Actions，我也看過不少課程，但沒有真實需求，學完很快就忘了。因為它的各種功能對我來說，都<strong>無法產生「具體的連結」。</strong></p><p>所以，如果你沒有實際的需求，我有兩個建議：</p><ol><li>自己創造需求！就像我們這裡的 side project，這不就有需求了嗎😇</li><li>先別學了！事半功倍鵝🪿</li></ol><p>第二點不是開玩笑XD，真的，沒需求就先別學了——晚點再說。軟體開發還有無數的領域等著你探索與投入。</p><hr><p>回到正題，直接來看專案中如何實作 GitHub Actions CI。</p><h2 id="GitHub-Actions-實作"><a href="#GitHub-Actions-實作" class="headerlink" title="GitHub Actions 實作"></a>GitHub Actions 實作</h2><p>我們的小目標是：</p><p>一、只要有人 push 到<code>main</code>分支，或開 PR 要合併到<code>main</code>，就自動檢查程式碼品質——這是<strong>最常見的 CI 觸發時機</strong>。</p><p>二、使用以下工具檢查專案程式碼：</p><ul><li><strong>Ruff</strong>：作為 Linter 與 Formatter。參考〈<a href="/ruff/">Python 開發：RuffLinter、Formatter 介紹 + 設定教學</a>〉</li><li><strong>Pyright</strong>：執行<strong>靜態型別檢查</strong>。參考〈<a href="/pyright/">Pyright 上手指南：Python 型別檢查的新選擇</a>〉</li></ul><p>這些都是我平常在本機開發會執行的操作——無論是透過 VS Code 還是 pre-commit，現在只是搬到 CI 中再執行一次。</p><blockquote><p>相關文章：<a href="/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><hr><h2 id="GitHub-Action-YAML-設定"><a href="#GitHub-Action-YAML-設定" class="headerlink" title="GitHub Action YAML 設定"></a>GitHub Action YAML 設定</h2><p>以下是<a href="https://github.com/kyomind/WeaMind/blob/blog/github-actions-v1-20250706/.github/workflows/ci.yml">實際的設定檔內容</a>，放在專案目錄底下的 <code>.github/workflows/ci.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Continuous</span> <span class="string">Integration</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">quality-check:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Lint,</span> <span class="string">Format,</span> <span class="string">Type</span> <span class="string">Check,</span> <span class="string">Test</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ghcr.io/astral-sh/uv:python3.12-bookworm-slim</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">sync</span> <span class="string">--locked</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Lint</span> <span class="string">(ruff)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">ruff</span> <span class="string">check</span> <span class="string">.</span> <span class="string">--fix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Format</span> <span class="string">(ruff</span> <span class="string">format)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">ruff</span> <span class="string">format</span> <span class="string">.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Type</span> <span class="string">check</span> <span class="string">(pyright)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">pyright</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">unit</span> <span class="string">tests</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">pytest</span></span><br></pre></td></tr></table></figure><p>可以看出，它還跑了單元測試！</p><p>我們可以暫時無視這部分，因為測試的相關設定細節更多，之後再另篇討論。</p><p>其餘細節也都先略過，只看最後的<code>steps</code>部分。</p><p>每個<code>run:</code>就是執行一個 CLI 指令，只不過是在 GitHub 的遠端 runner 上執行而已。</p><p>這個流程透露了 CI 的本質：<strong>開另一台機器，做一連串你「事先預定」的事情！</strong></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p>寫好 yaml 設定檔後，只要你 commit 並 push，GitHub 就會開始跑 CI workflow 了！（每一個設定檔都是一個 workflow）</p><p>無論成功或失敗，結果都會顯示在專案的「<a href="https://github.com/kyomind/WeaMind/actions">Actions</a>」分頁：</p><p><img src="https://img.kyomind.tw/20250706-112153-action-min.png" alt="GitHub Actions 執行結果"><span class="cap">GitHub Actions 執行結果</span></p><p>這裡是成功的，如果失敗了，GitHub 還會寄信給你——這很重要。</p><hr><h2 id="結語：最關鍵的第一步"><a href="#結語：最關鍵的第一步" class="headerlink" title="結語：最關鍵的第一步"></a>結語：最關鍵的第一步</h2><p>本文僅對 CI 跟 GitHub Actions 做了基本的介紹，並展示一下我的設定檔。</p><p>因為篇幅有限，沒有對所有細節進行完整說明——或許以後！</p><p>但這並不妨礙你立刻開始動手。</p><p>我認為，在 AI 能夠很好地輔助軟體開發的時代，設定檔的內容大部分都可以由 AI 代勞——當然我們不能對此一無所知😅</p><p>最重要的還是：<strong>你開始使用這些工具，將它們融入到開發流程中</strong>。</p><p>我想這才是最關鍵的第一步。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/code-and-me.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 這是 &lt;a href=&quot;https://github.com/kyomind/WeaMind/blob/main/blogs/README.md&quot;&gt;WeaMind 系列&lt;/a&gt; 的第 2 篇。&lt;br&gt;本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;從這篇文章開始，我將啟動一個新的系列。&lt;/p&gt;
&lt;p&gt;搭配我正在實作中的 Side Project——&lt;a href=&quot;https://github.com/kyomind/WeaMind&quot;&gt;WeaMind&lt;/a&gt;，寫下一篇又一篇的技術實作心得。&lt;/p&gt;
&lt;p&gt;讓我們一起在專案中成長，並獲得更多的開發樂趣。&lt;/p&gt;
&lt;p&gt;如標題所示，本文主要介紹 &lt;a href=&quot;https://github.com/features/actions&quot;&gt;GitHub Actions&lt;/a&gt;。不過在此之前，我們得先對 CI 有初步的了解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什麼是-CI？為什麼需要-CI？&quot;&gt;&lt;a href=&quot;#什麼是-CI？為什麼需要-CI？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 CI？為什麼需要 CI？&quot;&gt;&lt;/a&gt;什麼是 CI？為什麼需要 CI？&lt;/h2&gt;&lt;p&gt;CI 是「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88&quot;&gt;Continuous Integration&lt;/a&gt;」的縮寫，中文是「持續整合」。&lt;/p&gt;
&lt;p&gt;它的核心概念是：&lt;strong&gt;當開發人員提交程式碼時，系統可以「自動執行一系列預先定義的檢查流程」&lt;/strong&gt;，例如檢查程式碼是否與現有程式相容、是否能正常運作。&lt;/p&gt;
&lt;p&gt;在軟體開發流程中，我們常常要處理很多&lt;strong&gt;重複但又不可忽略&lt;/strong&gt;的工作：檢查程式碼格式、執行靜態分析、跑單元測試，甚至產生 API 文件等。&lt;/p&gt;
&lt;p&gt;如果每次提交都要手動跑一輪，既麻煩又易忘。&lt;/p&gt;
&lt;p&gt;這時 CI 就派上用場了。它能在每次 push 或開 PR 時（或其它事件），自動幫我們做這些事，讓問題提早浮現，使得開發流程更加穩健，也能節省大量重複性勞動。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="GitHub Actions" scheme="https://blog.kyomind.tw/tags/GitHub-Actions/"/>
    
    <category term="WeaMind" scheme="https://blog.kyomind.tw/tags/WeaMind/"/>
    
  </entry>
  
  <entry>
    <title>yadm 教學：實作 macOS 與 Linux 的 dotfiles 跨平台同步</title>
    <link href="https://blog.kyomind.tw/yadm-cross-platform/"/>
    <id>https://blog.kyomind.tw/yadm-cross-platform/</id>
    <published>2025-06-28T15:01:29.000Z</published>
    <updated>2025-06-29T02:30:43.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><p>兩年多前，我寫了這篇〈<a href="https://blog.kyomind.tw/yadm/">是時候同步你的 dotfiles 了——我選擇 yadm</a>〉，當時的主要動機是想要在多個 Linux VM 之間同步設定檔。</p><p>該文章介紹了「何謂 dotfiles」（後端工程師應該都很熟悉），以及我認為的「dotfiles 同步工具」的兩大流派：</p><ol><li>Symbolic Link。</li><li>Bare Git。</li></ol><p>然而，兩年之間，我幾乎很少在文中提起它。</p><p>事實上，我這段期間使用的 yadm 的頻率<strong>確實不高</strong>！</p><p>但這並不代表我沒有同步 dotfiles 的需求，只是真正的核心需求在於<strong>跨平台</strong>，尤其是 macOS 與 Linux 之間。</p><p>若僅是在不同 Linux VM 之間同步，就顯得有點小打小鬧，<strong>實用性不足</strong>。</p><hr><p>我日常開發主要都在 Mac 上，而 Mac 與 Linux 的設定落差雖不大，但<strong>絕不會完全相同</strong>——這讓單一套設定難以通用。</p><p>比如我的 Mac 上有一些 Homebrew 的環境變數，在 Linux 上無用武之地不說，還可能造成執行錯誤。</p><p>總之，<strong>若不解決跨平台問題，那 yadm 的價值將發揮不到一半。</strong></p><p>上個月我終於鐵了心，<strong>把這件事搞定了！</strong></p><p>做完只覺得，我實在太晚開始，跨平台同步的<strong>價值非常巨大且實用</strong>。</p><p>因此，儘管使用這類工具的人並不多，我也要寫下這篇文章，供有志之士參考！</p><span id="more"></span><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文重點在於介紹 yadm 的跨平台<strong>設定檔、關聯機制</strong>，還有基本操作。</p><p>所以我會假設你已經用過了 yadm——其實沒用過也無妨，因為常見的操作並不複雜。你可以等看了效果後再決定是否學習 yadm。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>不可否認，本文的目標讀者是軟體工程師，尤其是後端開發者。</p><p>非技術出身的讀者，可能連 dotfiles 的作用都不容易理解——這很正常。</p><p>總之，對於一個熱衷於「客製化工具設定」的開發者，我相信 dotfiles 的同步是肯定要學的。</p><p>太實用了！</p><hr><h2 id="Alternate-Files-介紹"><a href="#Alternate-Files-介紹" class="headerlink" title="Alternate Files 介紹"></a>Alternate Files 介紹</h2><p>yadm 最強大的能力之一，就是透過「<a href="https://yadm.io/docs/alternates">Alternate Files</a>」（下稱 alt files）來實現跨平台同步，<strong>它能依據作業系統、主機名稱等條件，自動尋找對應的設定檔</strong>。</p><p>這是實現跨平台 dotfiles 管理的核心關鍵。</p><h3 id="實際範例：我的-dotfiles-結構"><a href="#實際範例：我的-dotfiles-結構" class="headerlink" title="實際範例：我的 dotfiles 結構"></a>實際範例：我的 dotfiles 結構</h3><p>這是我的 dotfiles repo 現況，我們只要關注這些「檔名」即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .aliases<span class="comment">##default</span></span><br><span class="line">├── .aliases<span class="comment">##os.Darwin</span></span><br><span class="line">├── .aliases<span class="comment">##os.Linux</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Darwin</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Linux</span></span><br><span class="line">├── .zprofile<span class="comment">##default</span></span><br><span class="line">├── .zprofile<span class="comment">##os.Darwin</span></span><br><span class="line">├── .zshrc<span class="comment">##default</span></span><br><span class="line">├── .zshrc<span class="comment">##os.Darwin</span></span><br><span class="line">└── .zshrc<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><p>可以大概看出，我僅僅同步了 4 個主要設定檔，雖然加上 alt files 後，實際上總共有 10 個檔案。</p><p>這個命名結構反映出<strong>兩種</strong>主要形式——共用檔與變體檔：</p><ul><li><code>##default</code>：所有平台共通的預設設定（<strong>共用檔</strong>）</li><li><code>##os.Darwin</code>&#x2F;<code>os.Darwin</code>：依作業系統不同而變化的設定（<strong>變體檔</strong>）</li></ul><p>這種設計的重點是「<strong>分層與組合</strong>」。</p><p>yadm 在處理 alt files 時，會<strong>優先使用符合條件的變體</strong>（如 Darwin），若該變體不存在，則退回（fallback）至 default 檔案。</p><p>如此一來，我們就能<strong>針對特定平台進行客製設定，同時保有共用邏輯</strong>。</p><hr><h2 id="yadm-Alt-Files-的三大重點"><a href="#yadm-Alt-Files-的三大重點" class="headerlink" title="yadm Alt Files 的三大重點"></a>yadm Alt Files 的三大重點</h2><p>我知道，光這樣講並不容易理解。</p><p>簡單來說，我覺得這些 alt files 有三個學習重點。</p><h3 id="一、「後綴」命名格式與樣式"><a href="#一、「後綴」命名格式與樣式" class="headerlink" title="一、「後綴」命名格式與樣式"></a>一、「後綴」命名格式與樣式</h3><p>在特殊標記<code>##</code>之後的「<strong>os 層級</strong>」命名格式是固定的！</p><p>換言之，<code>os.Darwin</code>、<code>os.Darwin</code>這些「後綴」名稱<strong>不可自訂</strong>，千萬不要打錯了。</p><p>事實上這類後綴可以有<strong>非常多樣</strong>的寫法，有些確實需要自定義，比如文件中的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##class.Work</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##class.Work,~os.Darwin</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host1</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host2</span></span><br></pre></td></tr></table></figure><p>這允許你即使在同一種平台，也能讓不同主機，甚至不同使用者之間產生一定的差異與客製。</p><p>不過我覺得，<strong>區分 macOS 和 Linux 就已經非常實用</strong>。</p><p><strong>我建議你也這樣做就好</strong>，因為我認為 yadm <strong>已然不算很平易近人的工具XD</strong>，如果還要了解這些複雜的後綴規則與用法，恐怕讓人退避三舍。</p><h3 id="二、路徑的尋找規則"><a href="#二、路徑的尋找規則" class="headerlink" title="二、路徑的尋找規則"></a>二、路徑的尋找規則</h3><p>在<strong>相同前綴不同後綴</strong>的一系列的檔名中，yadm 只會依照「尋找規則」，選取其中一個建立 Symbolic Link，讓它指向<strong>系統真正會讀取的檔案</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── .zshrc<span class="comment">##default</span></span><br><span class="line">├── .zshrc<span class="comment">##os.Darwin</span></span><br><span class="line">└── .zshrc<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><p>以<code>.zshrc</code>為例，在 macOS 上，它會找到<code>.zshrc##os.Darwin</code>。</p><p>而在 Linux 上則是<code>.zshrc##os.Linux</code>。</p><p>透過這套尋找規則，yadm 就能在不同作業系統提供<strong>設定檔的差異化</strong>。</p><h3 id="三、共用檔的角色"><a href="#三、共用檔的角色" class="headerlink" title="三、共用檔的角色"></a>三、共用檔的角色</h3><p>承上，熟悉 dotfiles 的你應該不難猜到，<code>.zshrc##default</code>要放的內容，就是兩邊都會「共用」的部分。</p><p>然後，在「變體」檔的開頭，要去<code>source</code>共用檔的內容！</p><p>以我的<code>.zshrc##os.Darwin</code>為例，開頭內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macOS 專屬 zsh 設定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先載入共用設定</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;<span class="variable">$HOME</span>/.zshrc##default&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Homebrew node@18 路徑（macOS 專屬）</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/opt/homebrew/opt/node@18/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果沒有共用檔，自然就不需要開頭的<code>source</code>。</p><p>像<code>p10k.zsh</code>因為設定複雜，我直接區分兩種版本，根本沒有共用部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── .p10k.zsh<span class="comment">##os.Darwin</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><hr><h2 id="Link-操作：yadm-alt"><a href="#Link-操作：yadm-alt" class="headerlink" title="Link 操作：yadm alt"></a>Link 操作：yadm alt</h2><p>當你完成上述的檔案設計並同步 dotfiles 後，只需執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm alt</span><br></pre></td></tr></table></figure><p>yadm 會<strong>尋找並關聯</strong>該主機上對應的檔案。</p><p>注意，這個步驟<strong>必不可少</strong>！不然你會發現，雖然所有 dotfiles 都已同步到本機，但這些檔案並沒有被實際使用。</p><p>而所謂的「<strong>關聯</strong>」，如前所述，就是建立 Symbolic Link。</p><p>在 Mac 上執行結果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ yadm alt</span><br><span class="line">Linking /Users/kyo/.aliases<span class="comment">##os.Darwin to /Users/kyo/.aliases</span></span><br><span class="line">Linking /Users/kyo/.p10k.zsh<span class="comment">##os.Darwin to /Users/kyo/.p10k.zsh</span></span><br><span class="line">Linking /Users/kyo/.zprofile<span class="comment">##os.Darwin to /Users/kyo/.zprofile</span></span><br><span class="line">Linking /Users/kyo/.zshrc<span class="comment">##os.Darwin to /Users/kyo/.zshrc</span></span><br></pre></td></tr></table></figure><p>而 Linux 則是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ yadm alt</span><br><span class="line">Linking /home/kyo/.aliases<span class="comment">##os.Linux to /home/kyo/.aliases</span></span><br><span class="line">Linking /home/kyo/.p10k.zsh<span class="comment">##os.Linux to /home/kyo/.p10k.zsh</span></span><br><span class="line">Linking /home/kyo/.zprofile<span class="comment">##default to /home/kyo/.zprofile</span></span><br><span class="line">Linking /home/kyo/.zshrc<span class="comment">##os.Linux to /home/kyo/.zshrc</span></span><br></pre></td></tr></table></figure><p>Beautiful！</p><hr><h2 id="yadm-使用忠告"><a href="#yadm-使用忠告" class="headerlink" title="yadm 使用忠告"></a>yadm 使用忠告</h2><p>yadm 是 Git 的 wrapper，操作它等於在<strong>操作一個裸露的 Git repo</strong>——而且這個 repo 還是<strong>你的 Home 目錄</strong>😱</p><p>這意味著，yadm 的操作<strong>會直接影響到你的系統設定檔</strong>。</p><p>如果你太隨意下達像是<code>yadm reset</code>、<code>yadm add .</code>等指令，有可能會讓你的系統檔案直接損毀XD</p><p>我就曾因為情急不慎操作，導致某台 VM 的設定變得半殘XD，只能砍掉重練。</p><h3 id="安全使用法則"><a href="#安全使用法則" class="headerlink" title="安全使用法則"></a>安全使用法則</h3><p>因此，我歸納了一個更安全的使用之道：</p><ul><li>所有設定修改，都集中在本機上的 dotfiles repo 中，<strong>透過 VS Code 進行編輯</strong>。</li><li>其他機器（包括本機）<strong>僅透過</strong><code>yadm pull</code><strong>同步修改後的結果</strong>，不進行任何<code>yadm commit</code>、<code>yadm push</code>等動作。</li></ul><p>這樣的模式確保你的設定變動<strong>只從單一來源發出</strong>，降低毀損風險，也讓同步過程更安全可控。</p><p>此外，如果我要做<code>yadm pull</code>、<code>yadm list</code>、<code>yadm status</code>三個指令（後兩者並不會改變檔案狀態，所以是安全的）<strong>以外</strong>的操作，<strong>我一定會先問 AI！</strong></p><p>因為這工具看似簡單，但威力絕不容小覷。</p><hr><h2 id="結語：同步-dotfiles-真的非常愉快"><a href="#結語：同步-dotfiles-真的非常愉快" class="headerlink" title="結語：同步 dotfiles 真的非常愉快"></a>結語：同步 dotfiles 真的非常愉快</h2><p>不誇張，自從設好跨平台同步後，<strong>開發幸福感大幅提升</strong>！</p><p>我以前太小看 yadm 了，可以跨平台之後，我變得更常改動 dotfiles、加入新的 alias，絲毫不用擔心同步問題。</p><p>我知道這篇文章不會有太多受眾，怕哪是軟體工程師，也不是人人都熱衷此道。</p><p>但如果你想在多台 Mac 和多台 Linux VM（我目前有 3 台 Mac 與兩台 Linux VM）同步設定檔，卻仍在猶豫要選用哪一款工具的話。</p><p><strong>不用想了，就選 yadm 吧！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;p&gt;兩年多前，我寫了這篇〈&lt;a href=&quot;https://blog.kyomind.tw/yadm/&quot;&gt;是時候同步你的 dotfiles 了——我選擇 yadm&lt;/a&gt;〉，當時的主要動機是想要在多個 Linux VM 之間同步設定檔。&lt;/p&gt;
&lt;p&gt;該文章介紹了「何謂 dotfiles」（後端工程師應該都很熟悉），以及我認為的「dotfiles 同步工具」的兩大流派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symbolic Link。&lt;/li&gt;
&lt;li&gt;Bare Git。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，兩年之間，我幾乎很少在文中提起它。&lt;/p&gt;
&lt;p&gt;事實上，我這段期間使用的 yadm 的頻率&lt;strong&gt;確實不高&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;但這並不代表我沒有同步 dotfiles 的需求，只是真正的核心需求在於&lt;strong&gt;跨平台&lt;/strong&gt;，尤其是 macOS 與 Linux 之間。&lt;/p&gt;
&lt;p&gt;若僅是在不同 Linux VM 之間同步，就顯得有點小打小鬧，&lt;strong&gt;實用性不足&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我日常開發主要都在 Mac 上，而 Mac 與 Linux 的設定落差雖不大，但&lt;strong&gt;絕不會完全相同&lt;/strong&gt;——這讓單一套設定難以通用。&lt;/p&gt;
&lt;p&gt;比如我的 Mac 上有一些 Homebrew 的環境變數，在 Linux 上無用武之地不說，還可能造成執行錯誤。&lt;/p&gt;
&lt;p&gt;總之，&lt;strong&gt;若不解決跨平台問題，那 yadm 的價值將發揮不到一半。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上個月我終於鐵了心，&lt;strong&gt;把這件事搞定了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做完只覺得，我實在太晚開始，跨平台同步的&lt;strong&gt;價值非常巨大且實用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，儘管使用這類工具的人並不多，我也要寫下這篇文章，供有志之士參考！&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Gandi 惹惱了我😡——怒將域名轉至 Dynadot</title>
    <link href="https://blog.kyomind.tw/weekly-review-44/"/>
    <id>https://blog.kyomind.tw/weekly-review-44/</id>
    <published>2025-06-21T08:45:35.000Z</published>
    <updated>2025-08-11T15:34:59.424Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/weekly-review.png"> </p><p>我從 2018 年開始租用<code>kyomind.tw</code>這個域名，至今已 7 年。</p><p>每年 9&#x2F;1 是它的續約時間。過去多年來，價格大致穩定，折合新台幣大概 700 多元。</p><p>直到去年續約，我被信用卡帳單上的金額嚇了一跳：<strong>1260 元</strong>。</p><p>這是什麼情況？</p><p>一度以為是哪裡被誤收，或是信用卡出了問題。但查了帳單、比對後台紀錄，確認那筆款項的確是域名供應商 <a href="https://www.gandi.net/zh-Hant">Gandi</a> 對我的 .tw 域名的續約費用。</p><p>當下覺得很不對勁——域名費用可以這樣說漲就漲嗎？而且幅度也太誇張了！</p><hr><p>就這樣過了半年多，想想幾個月後又要續約了，1260 實在有點讓人卻步。</p><p>我們知道，域名在不同供應商之間，價格並不同。</p><p>而且！<strong>域名是可以移轉的</strong>。</p><p>所以我決定查查，目前 .tw 便宜的地方有哪些——發現了 <a href="https://www.dynadot.com/">Dynadot</a> 只要 18 美元！</p><p>而且，其他域名供應商，大概也只要二十幾美元左右啊，怎麼 Gandi 會特別貴？</p><p>於是我決定進一步弄清楚這到底是怎麼回事，這才發現，其實此時此刻，Gandi 的續約價格也只是台幣 700 多。</p><p>這讓我更加惱火了……</p><span id="more"></span><h2 id="發生了什麼事？"><a href="#發生了什麼事？" class="headerlink" title="發生了什麼事？"></a>發生了什麼事？</h2><p>用 ChatGPT 的 o3 模型幫我一探究竟。</p><p>以下匯率會依時間變動，看美元計價即可。</p><table><thead><tr><th>時點</th><th>Gandi 的 .tw 域名價格</th><th>實際反應</th></tr></thead><tbody><tr><td>2022-05-27</td><td>由 US$23.26 漲到 US$25（≈NT$710）</td><td>官方公告「.tw 調價」</td></tr><tr><td>2023-03</td><td>法國 Gandi SAS 與荷蘭的 Total Webhosting Solutions（TWS）正式合併，成立新的歐洲線上服務平台 <strong>Your.Online</strong>（官方<a href="https://news.gandi.net/en/2023/03/your-online-gandi-continues-its-development/">新聞稿</a>）</td><td>合併（<strong>實際上是 Gandi 被收購</strong>）完成後，<a href="http://gandi.net/">Gandi.net</a> 保持自治與原有品牌運營。但經營策略明顯轉變，為後續價格變動埋下伏筆</td></tr><tr><td>2024-08-29</td><td>突然暴漲到 US$39.98（≈NT$1,260）</td><td>客戶收到 30 天預告信，8&#x2F;29 價目表 PDF 生效；我的 9&#x2F;1 續約正好被擊中</td></tr><tr><td>2025-Q1 (未公告)</td><td>悄悄下修到 US$24（≈NT$744）</td><td>現在官網 .tw 頁面顯示的價格</td></tr></tbody></table><p>換句話說：我被收的 1260 元，的確是當時<strong>正式定價</strong>——而且才調漲沒幾天🤬</p><p>但之後 Gandi 又自己把價錢降了回來，整段過程沒有發新聞稿、沒有發聲明，就像整件事從來沒發生過一樣。</p><h2 id="為什麼會「漲了又降」？"><a href="#為什麼會「漲了又降」？" class="headerlink" title="為什麼會「漲了又降」？"></a>為什麼會「漲了又降」？</h2><p>漲價的不只有 .tw 域名，許多常見的域名都有漲，而且漲幅都很驚人。</p><p>雖然沒說明為何漲了又降，但從<a href="https://www.reddit.com/r/Domains/comments/1f4r7nl/the_cost_of_renewing_my_com_domain_is_coming_in/">社群反應</a>與價目表變化來看，極有可能是因為 2024 年暴漲後引發大量客戶流失。</p><p>就像前面說的，域名並非獨家提供的東西，<strong>用戶隨時可以選擇移轉到其他供應商</strong>。</p><p>Gandi 為了止血，在 2025 年初悄悄調以前的合理價格，卻選擇不對外說明。</p><p>畢竟如果有一個正式公告，那就相當於宣布自己做錯了事——確實是大錯特錯。</p><p>最後也只能摸摸鼻子，把價格調回來。</p><hr><h2 id="我還是決定移轉"><a href="#我還是決定移轉" class="headerlink" title="我還是決定移轉"></a>我還是決定移轉</h2><p>說真的，如果沒有去年的事件，就算我發現 Dynadot 上面的 TW 域名只要 18 美元，我基本上還是不會想移轉。</p><p>畢竟一年 6 美元的差距，沒有大到「讓我感到可惜」的地步。</p><p>服務用久了，還是會有感情的。</p><p>可是，想到去年發生的事，加上現在域名已經託管給 Cloudflare 了，註冊商的重要性大幅降低。才讓我有幾分心動。</p><p>在跟 AI 反覆討論之後，他還是力勸我離開，不要吃這種虧。</p><p>幾經考慮，決定移轉！</p><h2 id="域名轉出"><a href="#域名轉出" class="headerlink" title="域名轉出"></a>域名轉出</h2><p>操作不複雜。轉移流程如下：</p><ol><li>從 Gandi 後台解鎖域名，取得 EPP Code。</li><li>在 Dynadot 下單轉入，後續依照指示輸入該 code。</li><li>DNS Server 維持指向原本的 Cloudflare，不用做什麼。轉移期間 0 停機。</li><li>通常 24–48 小時就會完成。<strong>我實際操作只花了 1-2 小時。</strong></li></ol><h3 id="轉出心得"><a href="#轉出心得" class="headerlink" title="轉出心得"></a>轉出心得</h3><p>說真的，我覺得 Gandi 的後台比 Dynadot 更清楚、簡潔。</p><p>但如前所述，因為域名已托管給 Cloudflare，這一點其實已經不重要了。</p><p>所有的域名操作都是在 Cloudflare 上，除了每年（或每幾年）續約一次，平時根本不需要再登入註冊商後台。</p><p>在這種使用情境下，「價格」（或供應商的可靠度）幾乎成了唯一考量。</p><blockquote><p>有興趣在 Dynadot 購買域名的朋友，可以考慮透過我的<a href="http://www.dynadot.com/?s8WF6Q818Y8s748P">邀請連結</a>註冊。</p></blockquote><p>新戶透過這個連結註冊，並購買域名滿 9.99 美元時，雙方可各獲得 5 美元的優惠。</p><hr><h2 id="哪裡買域名最划算？Cloudflare-是首選"><a href="#哪裡買域名最划算？Cloudflare-是首選" class="headerlink" title="哪裡買域名最划算？Cloudflare 是首選"></a>哪裡買域名最划算？Cloudflare 是首選</h2><p>無論是購買新的域名，或是移轉既有的域名，我都建議<strong>優先查看 <a href="https://www.cloudflare.com/zh-tw/products/registrar/">Cloudflare Registrar</a></strong> 提供的價格與支援範圍。</p><p>只要 Cloudflare 支援該 <a href="https://zh.wikipedia.org/zh-tw/%E9%A0%82%E7%B4%9A%E5%9F%9F">TLD</a>，它幾乎都提供「<strong>接近成本價</strong>」的續費方案，而且整合自家 DNS，操作與安全性也更有保障。</p><blockquote><p><strong>頂級域名</strong>（英語：Top-level Domain, TLD）是<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">網際網路</a><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系統</a>的等級中，位於根域名空間的最高級域名，例如<code>com</code>是網址<code>example.com</code>的頂級域名。</p></blockquote><p>若 Cloudflare 沒有你需要的 TLD（很可惜它就不支援 .tw 域名），再去像 Dynadot、Namecheap 等註冊商比價會更有效率。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>從 Gandi 被收購後接連出現的價格波動與溝通失誤，可以看出一件事：當一家註冊商不再把用戶信任當作優先考量，無論它過去再穩，都可能在一夜之間變得不可靠。</p><p>這不是單一價格調漲的問題，而是<strong>整體經營思維轉變</strong>的結果。</p><p>這種「<strong>恣意妄為</strong>」的態度，讓我對 Gandi 的信任度大幅下降。既然有了更好的選擇，為什麼不換呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/weekly-review.png&quot;&gt; &lt;/p&gt;
&lt;p&gt;我從 2018 年開始租用&lt;code&gt;kyomind.tw&lt;/code&gt;這個域名，至今已 7 年。&lt;/p&gt;
&lt;p&gt;每年 9&amp;#x2F;1 是它的續約時間。過去多年來，價格大致穩定，折合新台幣大概 700 多元。&lt;/p&gt;
&lt;p&gt;直到去年續約，我被信用卡帳單上的金額嚇了一跳：&lt;strong&gt;1260 元&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是什麼情況？&lt;/p&gt;
&lt;p&gt;一度以為是哪裡被誤收，或是信用卡出了問題。但查了帳單、比對後台紀錄，確認那筆款項的確是域名供應商 &lt;a href=&quot;https://www.gandi.net/zh-Hant&quot;&gt;Gandi&lt;/a&gt; 對我的 .tw 域名的續約費用。&lt;/p&gt;
&lt;p&gt;當下覺得很不對勁——域名費用可以這樣說漲就漲嗎？而且幅度也太誇張了！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;就這樣過了半年多，想想幾個月後又要續約了，1260 實在有點讓人卻步。&lt;/p&gt;
&lt;p&gt;我們知道，域名在不同供應商之間，價格並不同。&lt;/p&gt;
&lt;p&gt;而且！&lt;strong&gt;域名是可以移轉的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以我決定查查，目前 .tw 便宜的地方有哪些——發現了 &lt;a href=&quot;https://www.dynadot.com/&quot;&gt;Dynadot&lt;/a&gt; 只要 18 美元！&lt;/p&gt;
&lt;p&gt;而且，其他域名供應商，大概也只要二十幾美元左右啊，怎麼 Gandi 會特別貴？&lt;/p&gt;
&lt;p&gt;於是我決定進一步弄清楚這到底是怎麼回事，這才發現，其實此時此刻，Gandi 的續約價格也只是台幣 700 多。&lt;/p&gt;
&lt;p&gt;這讓我更加惱火了……&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/weekly-review.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
  </entry>
  
  <entry>
    <title>為 e2-micro VM 建立 SSH 連線：本機與 GitHub</title>
    <link href="https://blog.kyomind.tw/vm-ssh-setup/"/>
    <id>https://blog.kyomind.tw/vm-ssh-setup/</id>
    <published>2025-06-14T02:59:31.000Z</published>
    <updated>2025-06-22T03:15:46.519Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/code-and-me.png"></p><p>不久前，我看完了朋友<a href="https://kucw.io/about/">古古</a>的電子報〈<a href="https://kucw.io/blog/gcp-free-tier/">終身免費的 VM 服務！Google Cloud 免費方案分享</a>〉，介紹 GCP 的 E2 Micro（產品代號：e2-micro）免費 VM。</p><p>簡言之，我們可以在<strong>一定資源額度與條件範圍內</strong>，免費使用 Google Cloud Platform 上的 Compute Engine 虛擬機器。</p><p>我對此深感興趣，因為它的規格比之前的 F1 Micro 好上一截。</p><p>F1 時代的 RAM 大約只有 0.6 GiB（約 600MB），有開發經驗的都知道，這在某些情況下，用起來會有點捉襟見肘😂</p><p>於是，我也跟著教學開了一台！免費的午餐怎麼能不拿呢？</p><p>附帶一提，對 GCP 不熟的人——比如我，<strong>請一定要照著教學來建立 VM</strong>，以免設定時有所遺漏，一不小心就被收費。</p><h2 id="最後一塊拼圖"><a href="#最後一塊拼圖" class="headerlink" title="最後一塊拼圖"></a>最後一塊拼圖</h2><p>不過原來的教學只寫到 VM 建立完成為止，對於我們這些後端工程師而言，顯然還有一個很重要的基礎設定沒做——SSH 連線。 </p><p>因此，我想補齊這剩下的部分，包含：</p><ol><li>建立自己的 Linux 帳號。</li><li>建立本機與 VM 的 SSH 連線金鑰，並完成連線。</li><li>建立 VM 與 GitHub 的 SSH 連線，且能正常 clone Github 專案。</li></ol><p>剛好我在之前文章〈<a href="/linux-dev-setup/">Linux 上的 Python 開發環境設定</a>〉中，略過了「<a href="/linux-dev-setup/#%E4%B8%80%E3%80%81%E8%A8%AD%E5%AE%9A-SSH-%E9%80%A3%E7%B7%9A">設定 SSH 連線</a>」環節——老實說只是因為我懶得寫XD</p><p>但仔細想想，這個流程我自己做了很多次，不如直接寫在文章裡，方便大家回顧。</p><p>雖說是寫給 e2-micro，不過，這些內容適用於任何 Linux VM。</p><p>本文就來補完這些步驟，並講述我對於這個免費 VM 的看法。</p><span id="more"></span><hr><h2 id="為什麼你值得一台-E2-Micro？"><a href="#為什麼你值得一台-E2-Micro？" class="headerlink" title="為什麼你值得一台 E2 Micro？"></a>為什麼你值得一台 E2 Micro？</h2><p>因為免費囉！但不止如此。</p><p>〈<a href="/hetzner/">從 DigitalOcean 到 Hetzner：我為何轉向這家德國 VPS 供應商</a>〉一文中，有讀者<a href="https://github.com/kyomind/blog-reply/issues/70#issuecomment-2875240486">留言</a>問道：</p><blockquote><p>想問問不選擇 <a href="https://fly.io/">Fly.io</a> 或 <a href="https://render.com/">render</a> 來部署的原因，他們看起來有免費額度可以部署。</p></blockquote><p>我則回應：</p><blockquote><p>這類帶有免費額度的服務，主要是為了吸引不想花錢的用戶，條款常有變更的可能，比較適合短期或實驗性質（雖然 memos 備份挺容易的），長期部署我比較不會考慮</p></blockquote><p>退一步來說，如果你真的需要一台免費的 VM 來部署 memos 這類的小服務，那麼與其選擇 <a href="https://fly.io/">Fly.io</a> 或 <a href="https://render.com/">render</a>，還不如先開一台 E2 免費 VM！</p><p>等到不堪負荷了（但仍不想付錢XD），再考慮像 Fly.io 或 render 這些供應商也不遲。</p><p>畢竟 GCP 這樣的大廠，福利政策突然變更、收回的機率，通常比上述公司小得多。</p><p>除此之外，還有兩個關鍵理由。 </p><h3 id="一、延遲優勢"><a href="#一、延遲優勢" class="headerlink" title="一、延遲優勢"></a>一、延遲優勢</h3><p>我覺得，這台免費 VM 的最大亮點，是「<strong>延遲低</strong>」。</p><p>GCP 雖然只開放美國三個地區的資料中心供免費機器使用，但實際測試從台灣連線，<strong>延遲還可以</strong>！</p><p>請優先選擇<code>us-west1</code>（美國西部）地區，因為這個地區的延遲最低。</p><p>經實測比我在 Hetzner（德國）上的機器表現好非常多。與 DigitalOcean（新加坡）的延遲相當。</p><p>我自己的 <a href="https://www.cloudpingtest.com/">Cloud Ping Test</a> 網站測試結果如下：</p><ul><li>GCP（us-west1）：130-150 ms</li><li>Hetzner（德國）：600-800 ms</li><li>DigitalOcean（新加坡）：120-150 ms</li></ul><p>雖然比不上 GCP 台灣機房動輒 10-30 ms 的延遲，但對於大多數應用來說，130-150 ms 的延遲應屬「<strong>可接受</strong>」。</p><h3 id="二、免費額度堪稱大方"><a href="#二、免費額度堪稱大方" class="headerlink" title="二、免費額度堪稱大方"></a>二、免費額度堪稱大方</h3><p>免費機器的內容如下：</p><ul><li>0.25 至 2 個 vCPU（1 個共用核心，動態分配資源）</li><li>1 GB RAM</li><li>30 GB 標準磁碟（傳統 HDD）</li><li>每月 1 GB 出站流量</li></ul><p>這些規格看似陽春，但其實已能支撐許多日常小 app。若對照 DigitalOcean，類似的 VM 要價在每個月 5 美元以上。</p><p><img src="https://img.kyomind.tw/20250614-110147-vm-ssh-setup.png">  </p><p>所以，這樣的 VM 竟然可以免費使用，我覺得已經很大方。</p><h2 id="小提醒：對外流量限制"><a href="#小提醒：對外流量限制" class="headerlink" title="小提醒：對外流量限制"></a>小提醒：對外流量限制</h2><p>雖然一直強調它的優點，但是 1GB 的「對外流量」如果要拿來做公開服務，很可能會不夠用。</p><p>你看上圖 DigitalOcean 的價格，6 美元的 VM 每月有著 1000 GiB 的流量。</p><p>E2 Micro <strong>強烈建議只拿來部署自用服務</strong>。</p><hr><p>介紹完我認為的 E2 Micro 優點，接下來進入正題。</p><h2 id="設定-SSH-連線"><a href="#設定-SSH-連線" class="headerlink" title="設定 SSH 連線"></a>設定 SSH 連線</h2><p>在使用雲端平台或 VPS 服務建立 VM 後，通常有<strong>兩種</strong>主要的<strong>初次登入方式</strong>：</p><ol><li><strong>Web 界面提供內建 SSH 終端機</strong>：使用者可從平台介面直接開啟瀏覽器終端登入虛擬機器，無需事先設定金鑰。</li><li><strong>建立 VM 時預先設定 SSH 金鑰</strong>：在建立過程中指定公鑰，平台會在 VM 建立時將其寫入<code>authorized_keys</code>，讓你能用該金鑰從本機連入。（通常是用 root 帳號）</li></ol><p>這兩種方式大多數平台都支援，在原文的教學中，採用的是第一種方式，也就是透過 Web SSH 登入 VM。</p><p>登入之後，我們就可以開始設定<strong>真正屬於自己</strong>的登入方式。</p><h3 id="建立-Linux-帳號"><a href="#建立-Linux-帳號" class="headerlink" title="建立 Linux 帳號"></a>建立 Linux 帳號</h3><p>不管是 root 帳號還是 GCP 給你的帳號，都不是我們自己建立的帳號。</p><p>開發時，通常不會直接使用這些帳號來進行日常操作，尤其 root 帳號權限過大，存在一定的安全風險。</p><p>所以我們習慣先建立自己的 Linux 帳號，然後再設定 SSH 連線。</p><p>建立新帳號，並加入管理者群組：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser kyo</span><br><span class="line">sudo usermod -aG sudo kyo</span><br></pre></td></tr></table></figure><p>這裡直接用<code>kyo</code>舉例，實際操作時，請自行替換帳號名稱。</p><p>為<code>kyo</code>建立<code>.ssh</code>目錄，設定並權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /home/kyo/.ssh</span><br><span class="line">sudo <span class="built_in">chown</span> kyo:kyo /home/kyo/.ssh</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 /home/kyo/.ssh</span><br></pre></td></tr></table></figure><h3 id="本機建立-SSH-金鑰"><a href="#本機建立-SSH-金鑰" class="headerlink" title="本機建立 SSH 金鑰"></a>本機建立 SSH 金鑰</h3><p>接下來，我們在<strong>本機電腦</strong>產出 SSH 金鑰，建議使用 <a href="https://zh.wikipedia.org/zh-tw/EdDSA#Ed25519">Ed25519</a> 演算法，它更加現代，而且更重要的是——<strong>公鑰很短</strong>！（方便複製）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;odinxp@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>採用預設選項一路按<code>Enter</code>的話，會產生下面兩個檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.ssh/</span></span><br><span class="line">id_ed25519</span><br><span class="line">id_ed25519.pub</span><br></pre></td></tr></table></figure><p>通常我會先產出，再自行改名。比如把檔名改成<code>gcp</code>、<code>gcp.pub</code>，方便辨識。</p><p>將產生的公鑰內容複製，並貼到 VM 上<code>kyo</code>帳戶下的<code>authorized_keys</code>中，此時因為是透過 Web SSH 登入的管理者帳號來操作自非身帳號，指令要加上<code>sudo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/gcp.pub</span><br><span class="line"><span class="comment"># 複製內容後在 VM 上操作</span></span><br><span class="line">sudo nano /home/kyo/.ssh/authorized_keys <span class="comment"># 貼上內容後存檔</span></span><br><span class="line">sudo <span class="built_in">chown</span> kyo:kyo /home/kyo/.ssh/authorized_keys</span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /home/kyo/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>在本機建立 <a href="https://chusiang.gitbooks.io/working-on-gnu-linux/content/20.ssh_config.html">SSH config</a> 來簡化連線設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.ssh/config</span><br></pre></td></tr></table></figure><p>然後編輯<code>~/.ssh/config</code>，加入以下內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host gcp</span><br><span class="line">    HostName &lt;VM 的實際 ip&gt;</span><br><span class="line">    User kyo</span><br><span class="line">    IdentityFile ~/.ssh/gcp</span><br></pre></td></tr></table></figure><p>本機測試使用新帳號連線 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh kyo@gcp</span><br></pre></td></tr></table></figure><p>這樣基本就完成了！</p><hr><h2 id="Github-SSH-設定"><a href="#Github-SSH-設定" class="headerlink" title="Github SSH 設定"></a>Github SSH 設定</h2><p>設定完本機連線，我通常會緊接著設定 GitHub 連線。</p><p>注意，<strong>本機連線</strong>指的是「<strong>本機和 VM 之間</strong>」；而 <strong>GitHub 連線</strong>在本文的語境下，則是指「<strong>VM 和 GitHub 之間</strong>」。</p><p>所以這部分的主要操作都是<strong>在 VM 上進行</strong>。</p><p>一樣，先在 VM 上產生新的 SSH 金鑰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;odinxp@gmail.com&quot;</span> -f ~/.ssh/github</span><br></pre></td></tr></table></figure><p>加上<code>-f ~/.ssh/github</code>後，可以省去手動更名的麻煩，不過要注意，它同時也會<strong>覆蓋</strong>原有的檔案！（如果有的話）</p><p>複製公鑰內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/github.pub</span><br></pre></td></tr></table></figure><p>前往 <a href="https://github.com/settings/ssh/new">Github SSH 設定頁</a>，貼上金鑰。</p><p>新增、編輯<code>~/.ssh/config</code>加入 Github 設定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/github</span><br></pre></td></tr></table></figure><p>測試是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com -i ~/.ssh/github</span><br><span class="line">Hi kyomind! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>直接 clone 一個自己的 repo 確認沒問題：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:kyomind/WeaMind.git</span><br><span class="line">Cloning into <span class="string">&#x27;WeaMind&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 193, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (193/193), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (121/121), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 193 (delta 87), reused 161 (delta 58), pack-reused 0 (from 0)</span><br><span class="line">Receiving objects: 100% (193/193), 63.91 KiB | 661.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (87/87), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>大功告成，讚！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/code-and-me.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;不久前，我看完了朋友&lt;a href=&quot;https://kucw.io/about/&quot;&gt;古古&lt;/a&gt;的電子報〈&lt;a href=&quot;https://kucw.io/blog/gcp-free-tier/&quot;&gt;終身免費的 VM 服務！Google Cloud 免費方案分享&lt;/a&gt;〉，介紹 GCP 的 E2 Micro（產品代號：e2-micro）免費 VM。&lt;/p&gt;
&lt;p&gt;簡言之，我們可以在&lt;strong&gt;一定資源額度與條件範圍內&lt;/strong&gt;，免費使用 Google Cloud Platform 上的 Compute Engine 虛擬機器。&lt;/p&gt;
&lt;p&gt;我對此深感興趣，因為它的規格比之前的 F1 Micro 好上一截。&lt;/p&gt;
&lt;p&gt;F1 時代的 RAM 大約只有 0.6 GiB（約 600MB），有開發經驗的都知道，這在某些情況下，用起來會有點捉襟見肘😂&lt;/p&gt;
&lt;p&gt;於是，我也跟著教學開了一台！免費的午餐怎麼能不拿呢？&lt;/p&gt;
&lt;p&gt;附帶一提，對 GCP 不熟的人——比如我，&lt;strong&gt;請一定要照著教學來建立 VM&lt;/strong&gt;，以免設定時有所遺漏，一不小心就被收費。&lt;/p&gt;
&lt;h2 id=&quot;最後一塊拼圖&quot;&gt;&lt;a href=&quot;#最後一塊拼圖&quot; class=&quot;headerlink&quot; title=&quot;最後一塊拼圖&quot;&gt;&lt;/a&gt;最後一塊拼圖&lt;/h2&gt;&lt;p&gt;不過原來的教學只寫到 VM 建立完成為止，對於我們這些後端工程師而言，顯然還有一個很重要的基礎設定沒做——SSH 連線。 &lt;/p&gt;
&lt;p&gt;因此，我想補齊這剩下的部分，包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立自己的 Linux 帳號。&lt;/li&gt;
&lt;li&gt;建立本機與 VM 的 SSH 連線金鑰，並完成連線。&lt;/li&gt;
&lt;li&gt;建立 VM 與 GitHub 的 SSH 連線，且能正常 clone Github 專案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;剛好我在之前文章〈&lt;a href=&quot;/linux-dev-setup/&quot;&gt;Linux 上的 Python 開發環境設定&lt;/a&gt;〉中，略過了「&lt;a href=&quot;/linux-dev-setup/#%E4%B8%80%E3%80%81%E8%A8%AD%E5%AE%9A-SSH-%E9%80%A3%E7%B7%9A&quot;&gt;設定 SSH 連線&lt;/a&gt;」環節——老實說只是因為我懶得寫XD&lt;/p&gt;
&lt;p&gt;但仔細想想，這個流程我自己做了很多次，不如直接寫在文章裡，方便大家回顧。&lt;/p&gt;
&lt;p&gt;雖說是寫給 e2-micro，不過，這些內容適用於任何 Linux VM。&lt;/p&gt;
&lt;p&gt;本文就來補完這些步驟，並講述我對於這個免費 VM 的看法。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Imgur 封鎖台灣 IP，我把圖床搬到 Cloudflare R2</title>
    <link href="https://blog.kyomind.tw/weekly-review-43/"/>
    <id>https://blog.kyomind.tw/weekly-review-43/</id>
    <published>2025-06-07T03:00:10.000Z</published>
    <updated>2025-08-11T15:34:59.424Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/weekly-review.png">  </p><p>上個月中，我在寫部落格時，突然發現圖片上傳失敗，無論怎麼嘗試都無法成功。</p><p>我的寫作流程是用 VS Code 的 <a href="https://code.visualstudio.com/docs/languages/markdown">Markdown Image</a> 外掛，透過鍵盤快捷鍵，直接把圖片傳到 Imgur 上，這個流程已經持續了好幾年，非常方便、順手。</p><p>但這次踢到鐵板了。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/my-markdown-writing-flow/">Notion + VS Code：我的 Markdown 寫作工作流</a></p></blockquote><p>認真查了一下，才發現原來是 Imgur 大概從 5 月 16 日開始，<strong>無預警地封鎖</strong>了來自台灣的 IP，不再允許台灣使用者上傳圖片。（所幸已上傳的圖片還是可以看）</p><p>PTT 上也有<a href="http://ptt.cc/bbs/Gossiping/M.1747406974.A.003.html">討論</a>。</p><p>可以想見，這是多麼大的衝擊！</p><p>官方既然沒有給出任何理由，這個舉動（封鎖 IP）又顯然是<strong>蓄意</strong>的，那我們可以合理推測——短期內恐怕不會恢復正常了。</p><p>但我的部落格還是要繼續寫啊！只能乖乖尋找替代方案。</p><span id="more"></span><hr><h2 id="尋找替代方案"><a href="#尋找替代方案" class="headerlink" title="尋找替代方案"></a>尋找替代方案</h2><p>Markdown Image 這個外掛其實支援不少圖床服務，其中也包括 AWS <a href="https://aws.amazon.com/tw/s3/">S3</a> 或其他相容於 S3 API 的服務。</p><p>這讓我想到，可以用 <a href="https://www.cloudflare.com/zh-tw/developer-platform/products/r2/">Cloudflare R2</a> 來當圖床（網路上確實有很多人這麼做），畢竟它支援 S3 相容 API，而且最大的優勢是「出口流量」免費，整體成本會比 AWS S3 更低——<strong>基本上就是 0</strong>。</p><h3 id="其他考慮過的選項：GitHub-公開-Repo"><a href="#其他考慮過的選項：GitHub-公開-Repo" class="headerlink" title="其他考慮過的選項：GitHub 公開 Repo"></a>其他考慮過的選項：GitHub 公開 Repo</h3><p>除了 R2，我也考慮過其他可能性，其中一個就是直接使用 GitHub 的公開 Repository 來當圖床。</p><p>這方法在開發者社群間其實蠻流行的，只要把圖片放進一個公開 Repo，再拿原始連結當作圖床的連結使用。</p><p>而且已有許多工具可以自動化（包括上述的 Markdown Image），操作起來頗為簡便，不過畢竟不是 GitHub 官方鼓勵的用途，多少讓人有點不安心。</p><p>和 AI 討論了一下這個方案的可行性，結論是：如果 GitHub 政策哪天改了，整個圖床系統可能會瞬間失效，到時候就得從頭來過，光想就覺得頭皮發麻。</p><p>相較之下，把 Cloudflare R2 當作圖床，則是一種<strong>完全合理且可長期運作</strong>的使用情境，因此我最後還是選擇了 R2。</p><hr><h2 id="認識-Cloudflare"><a href="#認識-Cloudflare" class="headerlink" title="認識 Cloudflare"></a>認識 Cloudflare</h2><p><a href="http://zh.wikipedia.org/zh-tw/Cloudflare">Cloudflare</a> 是一家美國的網路基礎建設公司，主要提供 <a href="https://www.cloudflare.com/zh-tw/learning/cdn/what-is-a-cdn/">CDN</a>（內容傳遞網路）、網站加速、防火牆與 DDoS 防護等服務。</p><p>許多網站背後的流量處理，其實都仰賴他們的基礎設施——包括我的 blog。</p><p>後來他們推出了一系列<strong>開發者導向</strong>的服務，像是 Workers、KV、Pages、R2 等，試圖建立一整套雲端應用的堆疊。</p><p>我本來就對 Cloudflare 的服務很感興趣，常常聽聞他們家的服務如何「佛心」等等，只是一直苦無實際應用的契機。</p><p>這次 Imgur 事件，讓我終於有了理由動手玩看看 R2。</p><blockquote><p>延伸閱讀（Podcast）：<a href="https://pythonhunter.org/episodes/ep46"><strong>Ep 46. 你知道『赛博佛祖』Cloudflare 吗？</strong></a></p></blockquote><hr><h2 id="遷移的大綱與挑戰"><a href="#遷移的大綱與挑戰" class="headerlink" title="遷移的大綱與挑戰"></a>遷移的大綱與挑戰</h2><p>這個圖床遷移實際上花了我好一些功夫才完成，其中的細節頗多，無法在本文詳述。</p><p>但我們可以簡單講講，讓你有個方向。 </p><h3 id="一、域名托管"><a href="#一、域名托管" class="headerlink" title="一、域名托管"></a>一、域名托管</h3><p>我希望圖片網址是以我自己的網域開頭，而不是 Cloudflare 給的預設網址。這樣網址比較乾淨、也容易管理。</p><p>為此，我得先把 DNS 託管給 Cloudflare，接著才能用自定義網域綁定 R2 的 Bucket。</p><p>這個部分花了一點時間摸索，好在有 AI，最後順利完成。</p><p>如此一來，圖片的網址會長得像這樣：</p><blockquote><p><a href="https://img.kyomind.tw/poetry-multi-stage-build.jpg">https://img.kyomind.tw/poetry-multi-stage-build.jpg</a></p></blockquote><p>非常精美！</p><h3 id="二、Cache-Rule-設定"><a href="#二、Cache-Rule-設定" class="headerlink" title="二、Cache Rule 設定"></a>二、Cache Rule 設定</h3><p>事情還沒結束。Imgur 本身是一個專業圖床，所以他們對圖片的<a href="https://www.cloudflare.com/zh-tw/learning/cdn/what-is-caching/">快取</a>做了非常多優化。</p><p>但 Cloudflare R2 是一個<strong>通用</strong>的「<a href="https://aws.amazon.com/tw/what-is/object-storage/">物件儲存</a>」服務，可以用來存放各種資料——不限於圖片。</p><p>所以它不會主動幫你把快取設定成「最適合公開分享圖片」的模式。</p><p>我們得<strong>手動設定快取策略</strong>，透過 Cloudflare 的 <a href="http://developers.cloudflare.com/cache/how-to/cache-rules/">Cache Rules</a> 來提升圖片的載入速度。</p><p>雖然是附加工作（你不做也不影響使用），但這同時讓我更了解 Cloudflare 的服務內容與運作方式。還增進了對 CDN、瀏覽器快取與 Cookie 設定的一些了解。</p><p>感覺收獲良多耶XD！</p><h3 id="三、Markdown-Image-外掛設定"><a href="#三、Markdown-Image-外掛設定" class="headerlink" title="三、Markdown Image 外掛設定"></a>三、Markdown Image 外掛設定</h3><p>完成前兩步後，你便能透過 Cloudflare 官網的 UI 來上傳圖片並<strong>取得網址</strong>：</p><!-- ![](https://img.kyomind.tw/20250607-112306-wr43.png)   --><p><img src="https://img.kyomind.tw/20250607-131952-1312-min.png">  </p><p>但這樣做<strong>非常不方便</strong>！</p><p>所以我們還要設定 Markdown Image，讓它可以成功支援 R2 上傳。</p><p>這過程我進行得不太順利，在 Google + AI 的協作下，花了快兩個小時才成功。（明明應該是很簡單的事😅）</p><p>除了用 Markdown Image（限 VS Code），更多人則是選擇 <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 這個開源工具來上傳圖片——需要加裝 Cloudflare R2 外掛，這方面的資料就多很多！</p><p>但畢竟我是 VS Code 用戶，也用它來寫作，Markdown Image 對我而言，仍是最簡單有效的選擇。</p><hr><h2 id="結語：失之東隅，收之桑榆"><a href="#結語：失之東隅，收之桑榆" class="headerlink" title="結語：失之東隅，收之桑榆"></a>結語：失之東隅，收之桑榆</h2><p>這次的圖床搬遷，原本只是為了解決一個外部服務封鎖問題。沒想到最後竟發展成一次<strong>基礎建設升級</strong>。</p><p>從依賴 Imgur 這類圖床平台，轉為使用 Cloudflare R2 + 自定義網域，我對 blog 圖片的掌控力更高了，未來也比較不怕平台政策突變造成影響。</p><p>R2 作為我接觸 Cloudflare 服務的開端，但不會是最後一步。接下來，我要嘗試他們家的 Pages、Workers、D1 等等。</p><p>想想不禁有點小興奮！</p><p>這是一種專屬於開發者的愉悅，是<a href="https://www.youtube.com/watch?v=bFd3l8Mrhgw">知覺與快樂的螺旋</a>❤️</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/weekly-review.png&quot;&gt;  &lt;/p&gt;
&lt;p&gt;上個月中，我在寫部落格時，突然發現圖片上傳失敗，無論怎麼嘗試都無法成功。&lt;/p&gt;
&lt;p&gt;我的寫作流程是用 VS Code 的 &lt;a href=&quot;https://code.visualstudio.com/docs/languages/markdown&quot;&gt;Markdown Image&lt;/a&gt; 外掛，透過鍵盤快捷鍵，直接把圖片傳到 Imgur 上，這個流程已經持續了好幾年，非常方便、順手。&lt;/p&gt;
&lt;p&gt;但這次踢到鐵板了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/my-markdown-writing-flow/&quot;&gt;Notion + VS Code：我的 Markdown 寫作工作流&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;認真查了一下，才發現原來是 Imgur 大概從 5 月 16 日開始，&lt;strong&gt;無預警地封鎖&lt;/strong&gt;了來自台灣的 IP，不再允許台灣使用者上傳圖片。（所幸已上傳的圖片還是可以看）&lt;/p&gt;
&lt;p&gt;PTT 上也有&lt;a href=&quot;http://ptt.cc/bbs/Gossiping/M.1747406974.A.003.html&quot;&gt;討論&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;可以想見，這是多麼大的衝擊！&lt;/p&gt;
&lt;p&gt;官方既然沒有給出任何理由，這個舉動（封鎖 IP）又顯然是&lt;strong&gt;蓄意&lt;/strong&gt;的，那我們可以合理推測——短期內恐怕不會恢復正常了。&lt;/p&gt;
&lt;p&gt;但我的部落格還是要繼續寫啊！只能乖乖尋找替代方案。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/weekly-review.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Pyright 上手指南：Python 型別檢查的新選擇</title>
    <link href="https://blog.kyomind.tw/pyright/"/>
    <id>https://blog.kyomind.tw/pyright/</id>
    <published>2025-05-30T02:23:51.000Z</published>
    <updated>2025-07-21T02:45:13.186Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/pyright.jpg"></p><blockquote><p>📌 這是 <a href="https://github.com/kyomind/WeaMind/blob/main/blogs/README.md">WeaMind 系列</a> 的第 1 篇。<br>本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。</p></blockquote><p>如〈<a href="/introducing-uv/">Python 套件管理器 uv 介紹——與 Poetry 比較</a>〉一文中所述，最近我開始了一個新的 <a href="https://github.com/kyomind/WeaMind">side project</a>。</p><p>我打算好好利用這個專案，練習並實踐那些，在工作中無法盡情揮灑，或想學習但是還用不到的新技術。包括後端、AI、DevOps。</p><p>為了嘗試不同的開發體驗，從框架到工具都有所更新：</p><ul><li>因應 AI 時代，後端框架改用 FastAPI——輕量，且非同步支援佳。</li><li>套件管理器從 Poetry 換成 uv——快，就是快。</li></ul><p>而型別檢查器——本文的主角，則從 Mypy 改為 Pyright。</p><p>這不是一時興起的炫技選擇，而是一連串有意識的技術決策：選擇那些效能更好、體驗更佳，並且有長期潛力的替代方案。</p><p>Pyright，就是其中之一。</p><hr><h2 id="為什麼需要型別檢查？"><a href="#為什麼需要型別檢查？" class="headerlink" title="為什麼需要型別檢查？"></a>為什麼需要型別檢查？</h2><p>如果你對 Python 的「型別檢查」議題還不熟，歡迎參考我之前寫的「<a href="/series/#Mypy-%E4%B8%89%E9%83%A8%E6%9B%B2">Mypy 三部曲</a>」，其中對 Python type hints 與型別靜態分析工具做了深入說明。</p><p>Type hints 歷經多代 Python 發展至今，已趨於成熟。但它在實際專案中的流行程度，恐怕還不算高。</p><p>甚至直白地說，對部分 Python 開發者而言，可能：</p><ol><li>沒聽過。</li><li>知道但無感。</li></ol><p>這正是本文要努力的目標——讓更多人加入撰寫 Python type hints 的行列🔥😎</p><span id="more"></span><h3 id="型別檢查的價值"><a href="#型別檢查的價值" class="headerlink" title="型別檢查的價值"></a>型別檢查的價值</h3><p>簡言之，型別檢查不是為了「多寫幾行」程式碼，而是為了讓 IDE 幫我們多想一點、早點報錯，減少 runtime 的 trial &amp; error。</p><p>它能比單元測試讓你更早、更容易發現語法錯誤。</p><p>要做到這點——讓 Python 像「<strong>半個靜態語言</strong>」一樣可靠。我們除了需要好好寫 type hints，還要搭配「型別檢查器」（type checker）。</p><p>對我來說，type hints 與型別檢查，已經從「選配」變成「開發必需品」，就像 linter、formatter 一樣。</p><hr><p>在擁抱 type hints 成為開發習慣後，接下來就是要選擇一個好用的「型別檢查器」來幫我們把關。</p><p>除了老牌的 Mypy 之外，有沒有其它選擇呢？</p><p>答案是肯定的，這就是本文接下來要介紹的主角——Pyright。</p><h2 id="Pyright-簡介——為什麼選它？"><a href="#Pyright-簡介——為什麼選它？" class="headerlink" title="Pyright 簡介——為什麼選它？"></a>Pyright 簡介——為什麼選它？</h2><p>如〈<a href="/mypy/">Python type checker：Mypy 介紹</a>〉中所言，Mypy 誕生於 2012 年——這甚至比 Python 正式導入 type hints 還早！</p><p>作為第一個被廣泛採用的型別檢查工具，它為 Python 型別註解奠定了基礎，但同時也背負了早期設計的限制與<strong>歷史包袱</strong>。</p><p>Pyright 誕生於 2019 年，由微軟開發，設計之初即參考 TypeScript 的靜態型別系統，並針對 IDE 整合與效能優化。它更年輕、設計更現代——後發者優勢。</p><p><strong>直接擺脫漫長歲月所累積下來的歷史包袱，就是我選擇 Mypy 以外選項的主要理由。</strong></p><h2 id="Pyright-的三大優勢"><a href="#Pyright-的三大優勢" class="headerlink" title="Pyright 的三大優勢"></a>Pyright 的三大優勢</h2><p>Pyright 有以下三大賣點。</p><h3 id="1-效能極快，檢查大型專案也很輕鬆"><a href="#1-效能極快，檢查大型專案也很輕鬆" class="headerlink" title="1. 效能極快，檢查大型專案也很輕鬆"></a>1. 效能極快，檢查大型專案也很輕鬆</h3><p>Pyright 以<strong>高效能</strong>著稱。</p><blockquote><p>Pyright is a full-featured, standards-based static type checker for Python. It is designed for high performance and can be used with large Python source bases.</p></blockquote><p>使用 TypeScript 實現並運行於 Node.js 上，號稱效能比 Mypy 快 5 倍以上，特別適合大型 Python 專案。</p><h3 id="2-能進行「型別推斷」"><a href="#2-能進行「型別推斷」" class="headerlink" title="2. 能進行「型別推斷」"></a>2. 能進行「型別推斷」</h3><p>Pyright 能對「未型別註解」的程式碼進行<strong>型別推斷（type inference）</strong>，嘗試分析並提供檢查結果。</p><p>這使得它對舊有的程式碼專案（無型別註解）依然有效。</p><p>不過，Pyright 的型別檢查效果在「有明確型別註解時」會<strong>更好</strong>，且對於未註解的程式碼，檢查深度可能<strong>不如</strong>有註解的程式碼嚴謹。</p><h4 id="型別推斷的真正意義"><a href="#型別推斷的真正意義" class="headerlink" title="型別推斷的真正意義"></a>型別推斷的真正意義</h4><p>不過說真的，型別推斷和「好好寫 type hints」的核心精神是<strong>有些違背</strong>的，把它當成一個 <strong>bonus</strong> 就好。</p><p>我認為 type hints 的本質是在實踐 <a href="https://peps.python.org/pep-0020/">Zen of Python</a> 中的：</p><blockquote><p>Explicit is better than implicit</p></blockquote><p>而 Pyright 的型別推斷則是為了兼容舊有程式碼，讓你可以慢慢補上 type hints。</p><h3 id="3-與-VS-Code-的整合幾乎是零設定"><a href="#3-與-VS-Code-的整合幾乎是零設定" class="headerlink" title="3 .與 VS Code 的整合幾乎是零設定"></a>3 .與 VS Code 的整合幾乎是零設定</h3><p>直接內建於 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance">Pylance</a>！</p><p>用 VS Code 寫 Python，一定會裝 Pylance，相當於當年 Windows 綁 IE 的概念XD</p><p>只需要你在 VS Code 的 UI <strong>把型別檢查打開</strong>即可。如下圖：</p><p><img src="https://img.kyomind.tw/p4-min.png"></p><p>這樣就能享受 Pyright 的型別檢查功能，不需要額外設定。</p><hr><p>看完 Pyright 的優勢，接下來和老牌的 Mypy 比較一下。</p><h2 id="Mypy-vs-Pyright-重點比較"><a href="#Mypy-vs-Pyright-重點比較" class="headerlink" title="Mypy vs Pyright 重點比較"></a>Mypy vs Pyright 重點比較</h2><p>兩者雖然都是 Python 的靜態型別檢查工具，但設計哲學與使用體驗有所不同。</p><table><thead><tr><th>特性</th><th><strong>Mypy</strong></th><th><strong>Pyright</strong></th></tr></thead><tbody><tr><td>開發者</td><td>Python 官方支援（部分）</td><td>Microsoft（富爸爸）</td></tr><tr><td>執行速度</td><td>較慢，尤其在大型專案中</td><td>非常快</td></tr><tr><td>Type Checking 嚴格性</td><td>偏保守，有些 type error 不會抓</td><td>更嚴格，預設就更接近 TypeScript 的風格</td></tr><tr><td>支援型別提示（PEP）</td><td>完整支援 PEP 484 等標準</td><td>同樣完整，但對 edge cases 處理得更細緻</td></tr><tr><td>自動化工具整合</td><td>較傳統、整合需要設定</td><td>用 VS Code 即可獲得完整體驗</td></tr><tr><td>錯誤訊息易讀性（<strong>重要</strong>）</td><td>普通，訊息有時不夠具體</td><td>很清楚，並且能指出路徑與具體型別差異</td></tr></tbody></table><p>我認為比較重要的是「執行速度」與「錯誤訊息易讀性」這兩點。</p><hr><p>介紹完背景，現在可以來實作了。</p><h2 id="安裝-Pyright"><a href="#安裝-Pyright" class="headerlink" title="安裝 Pyright"></a>安裝 Pyright</h2><p>如前所述，Pyright 是使用 TypeScript 寫成，所以原則上要使用 npm 來安裝——聽到這裡你可能就不是很想用了XD</p><p>別擔心，Pyright 當然提供了 <a href="https://pypi.org/project/pyright/">Python wrapper 版本</a>，因此也可以直接用 Python 套件方式安裝，推薦使用 uv 並安裝到 dev group：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add --dev pyright</span><br></pre></td></tr></table></figure><p>或者更穩健的做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add --dev pyright[nodejs]</span><br></pre></td></tr></table></figure><p>這個套件實際上是在背後幫你自動安裝了 Pyright 的 Node.js 執行檔與環境，並提供了一個 Python wrapper。</p><p>而上述兩種指令的區別，可以參考<strong>留言區的討論</strong>。</p><h3 id="安裝套件的意義"><a href="#安裝套件的意義" class="headerlink" title="安裝套件的意義"></a>安裝套件的意義</h3><p>裝是裝了，但這個工具基本上<strong>不是給開發者直接使用的</strong>。主要用途在：</p><ol><li>作為 pre-commit 執行檔。</li><li>CI 的環境安裝。</li></ol><p>至於開發時，Pylance 本來就安裝了 Pyright，自然就會顯示錯誤提示。</p><hr><h2 id="關於設定檔"><a href="#關於設定檔" class="headerlink" title="關於設定檔"></a>關於設定檔</h2><p>如同 Mypy 使用 <code>mypy.ini</code>或<code>pyproject.toml</code>。</p><p>你可以透過<code>pyrightconfig.json</code>或<code>pyproject.toml</code>來客製化 Pyright 的檢查行為。</p><p>其中<code>pyrightconfig.json</code>是原生的設定檔格式，而<code>pyproject.toml</code>則是後來才追加的。</p><p>如果專案中同時存在<code>pyrightconfig.json</code>和<code>pyproject.toml</code>，Pyright 會優先使用<code>pyrightconfig.json</code>的設定。</p><p>兩者目前基本上可以視為等價，所以要選擇哪一種格式，主要取決於<strong>你希望 Pyright 的設定檔要獨立還和其它工具放在一起</strong>。</p><p>我暫時選擇獨立，採<code>pyrightconfig.json</code>，<a href="https://github.com/kyomind/WeaMind/blob/blog/pyright-v1-20250530/pyrightconfig.json">內容</a>如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;venvPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;venv&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.venv&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;migrations&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;.venv&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typeCheckingMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此外，一旦 VS Code 偵測到有設定檔存在，預設的檢查等級就會是<code>standard</code>——不管你 VS Code 本來怎麼設定。</p><p>此時最好就明示設定<code>typeCheckingMode</code>，如上所示。</p><h2 id="Pyright-的三種等級"><a href="#Pyright-的三種等級" class="headerlink" title="Pyright 的三種等級"></a>Pyright 的三種等級</h2><p>Pyright 提供三種檢查等級：</p><ul><li><code>basic</code>：適合大部分實務開發，檢查範圍涵蓋常見錯誤，擾動小。</li><li><code>standard</code>：預設值，比 basic 略為嚴格。</li><li><code>strict</code>：嚴格，適合對型別非常重視的專案或團隊。</li></ul><p>想知道這三個等級的<strong>具體區別</strong>，可以參考官方文件的這個<a href="https://microsoft.github.io/pyright/#/configuration?id=diagnostic-settings-defaults">對照表</a>。</p><p>個人認為<code>basic</code>或<code>standard</code>就已足夠，能在不影響開發節奏的情況下<strong>提供良好的型別保障</strong>。</p><hr><h2 id="整合-pre-commit-與注意事項"><a href="#整合-pre-commit-與注意事項" class="headerlink" title="整合 pre-commit 與注意事項"></a>整合 pre-commit 與注意事項</h2><p>我習慣將型別檢查加入 pre-commit hook，確保每次 commit 都經過檢查。</p><p>但是，不可否認，型別檢查器的 hook 設定比 linter、formatter 要來得<strong>講究許多</strong>！</p><p>因為它需要<strong>完整的執行環境</strong>——包括相依套件，不像 linter 只需對程式碼直接進行檢查即可。</p><p>所以設定上會麻煩一些，之前使用 Mypy 就踩過不少坑。</p><p>從結論上來說，把 hook 設定為「本地」會單純得多。適合單人開發的 side project，<a href="https://github.com/kyomind/WeaMind/blob/blog/pyright-v1-20250530/pyrightconfig.json">我的設定</a>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pyright</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pyright</span> <span class="string">(local</span> <span class="string">venv)</span></span><br><span class="line">      <span class="attr">entry:</span> <span class="string">.venv/bin/pyright</span></span><br><span class="line">      <span class="attr">language:</span> <span class="string">system</span></span><br><span class="line">      <span class="attr">pass_filenames:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">types:</span> [<span class="string">python</span>]</span><br></pre></td></tr></table></figure><p>其中<code>name</code>欄位的名稱可以自訂，<code>id</code>部分因為是 local hook，也能夠自訂。<code>entry</code>的路徑則要看專案虛擬環境所在。</p><p>值得一提的是，上述 hook 設定還得搭配<code>pyrightconfig.json</code>中的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;venvPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;venv&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.venv&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>才能正常執行。</p><h3 id="使用-Remote-Hook"><a href="#使用-Remote-Hook" class="headerlink" title="使用 Remote Hook"></a>使用 Remote Hook</h3><p>用遠端倉庫的 hook 也行，但常見的做法我試不成功，以下設定則可以 work：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/RobertCraigie/pyright-python</span></span><br><span class="line">  <span class="attr">rev:</span> <span class="string">v1.1.401</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pyright</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pyright</span> <span class="string">(via</span> <span class="string">pyright-python)</span></span><br><span class="line">      <span class="attr">pass_filenames:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>但一樣要搭配上述的<code>pyrightconfig.json</code>設定內容。</p><p>或寫成<code>pyproject.toml</code>格式如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.pyright]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">venvPath</span> = <span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="attr">venv</span> = <span class="string">&quot;.venv&quot;</span></span><br></pre></td></tr></table></figure><p>更多細節可參考上述 hook 的 <a href="https://github.com/RobertCraigie/pyright-python">GitHub 主頁</a>介紹。</p><h2 id="CI-設定待補"><a href="#CI-設定待補" class="headerlink" title="CI 設定待補"></a>CI 設定待補</h2><p>目前還沒有實作 CI，之後實作會再補上設定檔。</p><hr><h2 id="結語：新工具、新氣象"><a href="#結語：新工具、新氣象" class="headerlink" title="結語：新工具、新氣象"></a>結語：新工具、新氣象</h2><p>我感覺光是寫完這篇文章，又讓我對 Pyright 的了解增進許多XD</p><p>其實，無論是 Mypy 或 Pyright，還是其它工具。願意寫 type hints、進行型別檢查，就已經是很好的實踐。</p><p>工具只是細節上的分歧，並不影響大局。</p><p>我們最終想成為的，是優秀的開發者——問題解決者。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/pyright.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 這是 &lt;a href=&quot;https://github.com/kyomind/WeaMind/blob/main/blogs/README.md&quot;&gt;WeaMind 系列&lt;/a&gt; 的第 1 篇。&lt;br&gt;本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如〈&lt;a href=&quot;/introducing-uv/&quot;&gt;Python 套件管理器 uv 介紹——與 Poetry 比較&lt;/a&gt;〉一文中所述，最近我開始了一個新的 &lt;a href=&quot;https://github.com/kyomind/WeaMind&quot;&gt;side project&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我打算好好利用這個專案，練習並實踐那些，在工作中無法盡情揮灑，或想學習但是還用不到的新技術。包括後端、AI、DevOps。&lt;/p&gt;
&lt;p&gt;為了嘗試不同的開發體驗，從框架到工具都有所更新：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因應 AI 時代，後端框架改用 FastAPI——輕量，且非同步支援佳。&lt;/li&gt;
&lt;li&gt;套件管理器從 Poetry 換成 uv——快，就是快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而型別檢查器——本文的主角，則從 Mypy 改為 Pyright。&lt;/p&gt;
&lt;p&gt;這不是一時興起的炫技選擇，而是一連串有意識的技術決策：選擇那些效能更好、體驗更佳，並且有長期潛力的替代方案。&lt;/p&gt;
&lt;p&gt;Pyright，就是其中之一。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;為什麼需要型別檢查？&quot;&gt;&lt;a href=&quot;#為什麼需要型別檢查？&quot; class=&quot;headerlink&quot; title=&quot;為什麼需要型別檢查？&quot;&gt;&lt;/a&gt;為什麼需要型別檢查？&lt;/h2&gt;&lt;p&gt;如果你對 Python 的「型別檢查」議題還不熟，歡迎參考我之前寫的「&lt;a href=&quot;/series/#Mypy-%E4%B8%89%E9%83%A8%E6%9B%B2&quot;&gt;Mypy 三部曲&lt;/a&gt;」，其中對 Python type hints 與型別靜態分析工具做了深入說明。&lt;/p&gt;
&lt;p&gt;Type hints 歷經多代 Python 發展至今，已趨於成熟。但它在實際專案中的流行程度，恐怕還不算高。&lt;/p&gt;
&lt;p&gt;甚至直白地說，對部分 Python 開發者而言，可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;沒聽過。&lt;/li&gt;
&lt;li&gt;知道但無感。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這正是本文要努力的目標——讓更多人加入撰寫 Python type hints 的行列🔥😎&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/pyright.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Type Hints" scheme="https://blog.kyomind.tw/tags/Type-Hints/"/>
    
    <category term="VS Code" scheme="https://blog.kyomind.tw/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>Pocket 替代方案推薦：Raindrop.io 與 Karakeep</title>
    <link href="https://blog.kyomind.tw/pocket-alternatives/"/>
    <id>https://blog.kyomind.tw/pocket-alternatives/</id>
    <published>2025-05-25T16:16:37.000Z</published>
    <updated>2025-07-14T14:05:24.952Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/mind.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>幾天前，我收到了一封來自 Pocket 的電子郵件，開頭是：</p><blockquote><p>感謝您的閱讀：Pocket 向您道別<br>　<br>我們有一些重要訊息要和您分享：幾經思考之後，我們做出了一個艱難的決定，我們的先存再看和內容探索應用程式 Pocket 即將結束服務。</p></blockquote><p>如你所知，知名的「稍後閱讀」服務 Pocket 已經被 Mozilla 正式宣布將於 2025 年 7 月 8 日停止服務。</p><p>對許多知識工作者來說，這是個令人感慨的時刻，Pocket 的結束讓我們再度體認到：<strong>我們存下來的東西真的大多都沒有看</strong>。</p><p>不過，資訊囤積還是要繼續😎，所以本文會介紹兩個，我覺得還不錯的替代品，並說明我的選擇與理由。</p><hr><h2 id="什麼是「稍後閱讀」服務？"><a href="#什麼是「稍後閱讀」服務？" class="headerlink" title="什麼是「稍後閱讀」服務？"></a>什麼是「稍後閱讀」服務？</h2><p>「Read It Later」（稍後閱讀）是一種資訊整理的方式，也是一種使用習慣。</p><p>它允許你在沒心情或沒時間的情況下，把重要但無法即時處理的內容先存起來，日後再回來閱讀。</p><p>對知識工作者或資訊成癮者來說，這類服務是不可或缺的夥伴。</p><p>從食譜、文章到影片，這些被儲存下來的內容，構成了每個人專屬的知識倉庫。</p><span id="more"></span><h2 id="Pocket-的歷史與末路"><a href="#Pocket-的歷史與末路" class="headerlink" title="Pocket 的歷史與末路"></a>Pocket 的歷史與末路</h2><p>Pocket 最初於 2007 年推出，原名 Read It Later，曾是稍後閱讀服務的代表性工具。</p><p>它支援多平台、介面友好，並在 2015 年被 Mozilla 收購後，整合進 Firefox 成為預設功能之一。</p><p>我正是在那時註冊的帳號。</p><p>然而，如果你也是它忠實的用戶，一定會發現，這幾年它的使用體驗在持續下降：進入主頁後，推薦內容越來越多，幾乎形成了一種干擾🤬</p><p>上個月底，Pocket 瀏覽器擴充功能因為不符 Google Chrome 的新標準（Manifest V3）被下架——這對這類服務可是致命打擊。</p><p>這些變動，讓我開始認真思考替代方案。</p><hr><p>我詳細考慮過的方案有兩個，以下是它們的簡介。</p><h2 id="Raindrop-io：穩定、清爽、夠用就好"><a href="#Raindrop-io：穩定、清爽、夠用就好" class="headerlink" title="Raindrop.io：穩定、清爽、夠用就好"></a>Raindrop.io：穩定、清爽、夠用就好</h2><p><a href="https://raindrop.io/">Raindrop.io</a> 是我最終選擇的替代工具。它的介面簡潔、設計現代，重點是沒有多餘的推薦或雜訊，讓我可以專注在自己儲存的內容上。</p><p>它也有<a href="https://raindrop.io/pro/buy">付費功能</a>，可以月付或年付，年費約 30 美元。不算貴。</p><h3 id="稍後閱讀工具的基本要求"><a href="#稍後閱讀工具的基本要求" class="headerlink" title="稍後閱讀工具的基本要求"></a>稍後閱讀工具的基本要求</h3><p>其實，對於這類服務最重要的功能要求，不外乎以下兩者：</p><ol><li>一定要有瀏覽器外掛。</li><li>一定要有手機 APP。</li></ol><p>兩者的重點都在於——讓你可以隨時儲存資訊！</p><p>滿足這些要件之後，才需要討論資訊主頁設計得如何、是否簡潔等等。</p><p><img src="https://img.kyomind.tw/pocket-alternatives.png" alt="Raindrop.io 主頁"><span class="cap">Raindrop.io 主頁</span></p><hr><h2 id="Karakeep：開源、自主、需要投入"><a href="#Karakeep：開源、自主、需要投入" class="headerlink" title="Karakeep：開源、自主、需要投入"></a>Karakeep：開源、自主、需要投入</h2><p><a href="http://karakeep.app/">Karakeep</a> 是另一個替代選項，走「<strong>自己掌控</strong>」路線。它是一個開源稍後閱讀工具，讓你可以自行部署。</p><p>上述的要件 Karakeep 也全部滿足：瀏覽器外掛、手機 app。</p><p>對於喜歡研究技術、重視<strong>資料主權</strong>的人來說，它是一個非常有吸引力的方案。不過，這也意味著你得自己架設伺服器、維護系統與備份資料。</p><p>本來我已經開始著手準備 Karakeep 的 Docker 容器了。但後來想想，我使用這類服務的需求，就真的只是當作「<strong>資訊倉庫</strong>」而已——簡單才是王道。</p><p>所以我最終選擇了 Raindrop.io，因為它「剛剛好」——多一事不如少一事。</p><hr><h2 id="AI-摧毀了「稍後閱讀」嗎？"><a href="#AI-摧毀了「稍後閱讀」嗎？" class="headerlink" title="AI 摧毀了「稍後閱讀」嗎？"></a>AI 摧毀了「稍後閱讀」嗎？</h2><p>部分新聞提到：</p><blockquote><p>Mozilla 表示，關閉 Pocket，是因為「人們儲存與閱讀網路內容的方式已經改變」。</p></blockquote><p>究竟是什麼樣的改變呢？</p><p>有一說是 AI 帶來的影響，我乍聽還有點不解，心想：「兩者有關係嗎？」</p><p>對此，ChatGPT 是這麼解釋的：</p><blockquote><p><strong>用戶心態改變</strong>：人們變得更不願「儲存之後回來看」，因為他們潛意識相信「到時我可以問 AI 就好」。這不是功能問題，是<strong>動機被削弱</strong>。</p></blockquote><p>哈哈，好像有幾分道理！</p><p>但不管怎麼說，可以確信的是——我依舊需要這類服務。</p><hr><h2 id="小結：我對「稍後閱讀」服務的基本態度"><a href="#小結：我對「稍後閱讀」服務的基本態度" class="headerlink" title="小結：我對「稍後閱讀」服務的基本態度"></a>小結：我對「稍後閱讀」服務的基本態度</h2><p>我覺得稍後閱讀這類服務，不值得把它作為一個資訊整理或吸收的重心——所以我鮮少在這些服務中，為儲存的內容分類、做筆記。</p><p>把它視為一個隨手可得的工具，最好可以被替代。</p><p>不可否認，在 AI 時代，資訊囤積的價值正<strong>進一步下降</strong>。甚至可以說，資訊或知識越來越不值錢了。</p><p>真正值錢的還是個人的經驗和觀點，而這些並不是「稍後閱讀」服務能為你提供的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/mind.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;幾天前，我收到了一封來自 Pocket 的電子郵件，開頭是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感謝您的閱讀：Pocket 向您道別&lt;br&gt;　&lt;br&gt;我們有一些重要訊息要和您分享：幾經思考之後，我們做出了一個艱難的決定，我們的先存再看和內容探索應用程式 Pocket 即將結束服務。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如你所知，知名的「稍後閱讀」服務 Pocket 已經被 Mozilla 正式宣布將於 2025 年 7 月 8 日停止服務。&lt;/p&gt;
&lt;p&gt;對許多知識工作者來說，這是個令人感慨的時刻，Pocket 的結束讓我們再度體認到：&lt;strong&gt;我們存下來的東西真的大多都沒有看&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過，資訊囤積還是要繼續😎，所以本文會介紹兩個，我覺得還不錯的替代品，並說明我的選擇與理由。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什麼是「稍後閱讀」服務？&quot;&gt;&lt;a href=&quot;#什麼是「稍後閱讀」服務？&quot; class=&quot;headerlink&quot; title=&quot;什麼是「稍後閱讀」服務？&quot;&gt;&lt;/a&gt;什麼是「稍後閱讀」服務？&lt;/h2&gt;&lt;p&gt;「Read It Later」（稍後閱讀）是一種資訊整理的方式，也是一種使用習慣。&lt;/p&gt;
&lt;p&gt;它允許你在沒心情或沒時間的情況下，把重要但無法即時處理的內容先存起來，日後再回來閱讀。&lt;/p&gt;
&lt;p&gt;對知識工作者或資訊成癮者來說，這類服務是不可或缺的夥伴。&lt;/p&gt;
&lt;p&gt;從食譜、文章到影片，這些被儲存下來的內容，構成了每個人專屬的知識倉庫。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/mind.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
