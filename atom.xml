<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/favicon-32x32.png</icon>
  <subtitle>Kyo 的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2025-07-13T02:20:51.041Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vibe Coding 與人類的時代</title>
    <link href="https://blog.kyomind.tw/vibe-coding/"/>
    <id>https://blog.kyomind.tw/vibe-coding/</id>
    <published>2025-07-10T14:22:29.000Z</published>
    <updated>2025-07-13T02:20:51.041Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><blockquote><p>任何人類都能使用魔法的時代要到來了——《葬送的芙莉蓮》漫畫第 53 話 | 人類的時代</p></blockquote><p>有了強大的 AI 輔助 ，寫程式再也不是軟體工程師的專屬。</p><p>如此的時代巨變，首先讓我聯想到的，就是「芙莉蓮」中的這段劇情。</p><p>不過把這個比喻與感受表達得最好的，當屬財經作家王伯達的這篇<a href="https://www.facebook.com/share/p/173juCsKre/">臉書文</a>。</p><p>他寫道：</p><blockquote><p>AI 讓更多人，用更容易的方式使用程式語言與複雜軟體。</p><p>這讓我想到芙莉蓮的老師，弗蘭梅。</p><p>她說服了人類的皇帝，讓人類得以開始研究魔法，魔法不再是個禁忌，開啟了人人有魔法可以練的年代。</p></blockquote><p>顯然，在我這個軟體工程師眼中，AI 就像芙蘭梅，把原本高門檻的知識、技術變成大眾能輕易接觸的工具，<strong>讓所有人都有機會參與創造</strong>。</p><p>本文聊聊我作為一個軟體工程師，如何看待這個 AI 普及後的「魔法時代」。</p><span id="more"></span><hr><h2 id="工程師的傲慢：自詡為魔法的守門人"><a href="#工程師的傲慢：自詡為魔法的守門人" class="headerlink" title="工程師的傲慢：自詡為魔法的守門人"></a>工程師的傲慢：自詡為魔法的守門人</h2><p>曾幾何時，軟體工程師就像這個世界的魔法使，掌握著一種魔法般的語言——程式碼。</p><p>我們用它來創造服務、建立平台、構築起一個個廣袤無垠的數位世界。</p><p>然而，AI 的出現，讓一切開始改變。</p><p>ChatGPT 問世後，所有的「文本生成」變得簡單起來——包括程式碼。</p><p>隨著 AI 持續演進、AI Agent 工具日漸成熟，你越來越常聽到這種說法：</p><blockquote><p>我不懂程式語言，但我能用 AI 寫程式。</p></blockquote><p>剛聽到這類言論時，老實說，我的內心充滿了鄙夷之情。</p><p>就像師祖賽莉耶說的：「魔法就應該是特別的。」</p><p>我也覺得，程式應該是「特別」的，不是誰都能隨口說自己「會寫程式」。</p><h2 id="因為稀缺，所以傲慢"><a href="#因為稀缺，所以傲慢" class="headerlink" title="因為稀缺，所以傲慢"></a>因為稀缺，所以傲慢</h2><p>這種想法有道理嗎？我覺得，這是人性的一部分。</p><p>作家朱宥勳在《<a href="https://www.books.com.tw/products/0010867642">文壇生態導覽——作家新手村 2 心法篇</a>》一書中提到，如果一位文人既會寫散文又會寫詩，他會希望人們稱他為「詩人」。</p><p>如果既會寫散文又會寫小說呢？當然是小說家！</p><p>為什麼？可能因為——散文的門檻比較低吧。</p><p>任何人，只要識字、能表達，都能自稱會寫散文（文采如何另當別論）。</p><p>而寫詩、寫小說，對我們這種普羅大眾來說，可能連想都不敢想——就像寫程式一樣。</p><hr><h2 id="心態的轉變"><a href="#心態的轉變" class="headerlink" title="心態的轉變"></a>心態的轉變</h2><p>懷抱上述想法，我一直希望自己是特別的。</p><p>直到今年 2 月，當 Andrej Karpathy 提出 Vibe Coding 一詞時，我心中的這份傲慢被敲響了喪鐘。</p><p>我心想：如果連這種大神級的軟體工程師，都提出並嘗試了這樣有趣的軟體開發方式，那一般人用這種方式來開發自己需要的工具或服務，完全說得通啊！</p><p>加上 <a href="https://www.facebook.com/will.fans/?locale=zh_TW">Will 保哥</a>的各種鼓吹，我對 Vibe Coding 的接納度迅速上升。</p><h2 id="什麼是-Vibe-Coding"><a href="#什麼是-Vibe-Coding" class="headerlink" title="什麼是 Vibe Coding"></a>什麼是 Vibe Coding</h2><p>Vibe Coding 這個新鮮的詞彙已經有了自己的<a href="https://zh.wikipedia.org/zh-tw/Vibe_coding">維基百科條目</a>。</p><p>我簡要摘錄如下（定義來自英文頁面）：</p><blockquote><p>Vibe coding is an artificial intelligence-assisted software development style popularized by Andrej Karpathy in early 2025. It describes a fast, improvisational, collaborative approach to creating software where the developer and a large language model (LLM) tuned for coding is acting rather like pair programmers in a conversational loop.</p></blockquote><p>簡單講，就是開發者透過自然語言與 AI 對話，反覆修正，一步步建立並完善軟體。</p><p>作為一個 Vibe Coder，你不需了解各種開發細節，甚至不用懂程式語言，而是專注於想要達成的目標和功能需求。</p><p>AI 成為了翻譯者，把我們的意圖轉化為可執行的程式碼。</p><hr><p>心態的改變，讓我開始重新看待「寫程式」的價值本身。</p><h2 id="軟體只是手段"><a href="#軟體只是手段" class="headerlink" title="軟體只是手段"></a>軟體只是手段</h2><p>越來越多人開始用 AI 寫程式，解決各種日常問題。</p><p>近期讓我最有感的是〈<a href="https://www.inside.com.tw/feature/2025-generative-ai/38545-ai-coding-ngoer">【Generative AI 年會】人力少但服務不打折！Peggy Lo：AI Coding 是 NGO 工作者最強大靠山</a>〉。</p><p>報導中，Peggy Lo 分享了她在僅有四人編制的基金會秘書處，如何運用 AI Coding 應對龐大的行政庶務與人力緊縮。</p><p>透過 AI，她不僅大幅提升了工作效率，還能讓服務變得更細緻、更深入。</p><p>這豈不是 Vibe Coding 的最佳典範？</p><p>我知道，程式從來只是手段。重要的不是「會不會寫」，而是「能不能用來解決真正的問題」。</p><p>一方面覺得自己的傲慢有些可笑，一方面也鬆了口氣。</p><p>我想，我更該在乎的，不是透過 AI 開發到底算不算「會寫程式」。</p><p>而是作為一個軟體工程師，我能解決什麼樣的問題。</p><hr><h2 id="「一般人」的優勢"><a href="#「一般人」的優勢" class="headerlink" title="「一般人」的優勢"></a>「一般人」的優勢</h2><p>而且話說回來，我不禁在想，不會程式的人用 AI 來開發，反而有自己的獨特優勢！</p><p>工程師多少知道某些技術的困難度，這反而會成為心理負擔，限制想像——覺得 AI 應該辦不到。</p><p>事實證明，AI 往往超乎人們的想像——在厲害與不厲害兩個方面都是XD</p><p>不懂程式的人沒這層包袱，做事的方式就很簡單：提出要求，請 AI 想辦法實現。</p><blockquote><p>魔法是想像的世界，在魔法世界中，無法想像的事情就無法實現</p></blockquote><p>沒有限制，反而更能天馬行空，專注於達成目標。</p><p>雖然未必每次都這麼順利，但少了這些束縛，有時候我認為是一個巨大的優勢。</p><p>唉，我就是缺乏想像力。</p><hr><h2 id="工程師也要會-Vibe-Coding"><a href="#工程師也要會-Vibe-Coding" class="headerlink" title="工程師也要會 Vibe Coding"></a>工程師也要會 Vibe Coding</h2><p>當然，這不代表工程師就該束手就擒。</p><p>相反地，我們更需要進化。</p><p>直白地說，我認為軟體工程師比一般人更需要學會 Vibe Coding。</p><p>像我這樣一個只熟悉後端的 Python 工程師，面對不熟的技術領域（例如前端），也需要發揮 Vibe Coding 的精神與實踐能力。</p><p>善於與 AI 協作的工程師（再加上一點想像力😎），可能是這個時代最有力的創造者。</p><h3 id="一般人打造工具，工程師打造系統"><a href="#一般人打造工具，工程師打造系統" class="headerlink" title="一般人打造工具，工程師打造系統"></a>一般人打造工具，工程師打造系統</h3><p>我覺得工程師應用 AI 放大軟體開發的能力，理應遠超過一般人。</p><p>這讓人充滿期待。</p><p>有人說，AI 讓工程師從作者變成了編輯者，<a href="https://www.managertoday.com.tw/articles/view/70451">讓寫程式像審稿</a>。好像自降了格調一般。</p><p>我認為這沒錯啊！重點是——<strong>審稿本身就是門技術活</strong>！</p><p>就像我在〈<a href="https://blog.kyomind.tw/myth-of-ai-writing-efficiency/">AI 讓寫作變輕鬆了？我可不這麼認為</a>〉提到的，AI 對我寫作的影響：</p><blockquote><p>為了善用 AI 的力量，我發現自己<strong>變成了 5 分作者、5 分編輯</strong>，而且<strong>經常在兩種身分間游移互換</strong>：一下子自己寫，讓 AI 看；一下子要 AI 寫、我來看。</p></blockquote><blockquote><p>AI 的普及，讓我們不僅僅是創作者，也成了編輯，甚至是策劃者。<strong>這種角色的轉換增加了工作量和難度，但也讓我們對內容的掌控更為精細。</strong></p></blockquote><p>沒有足夠的經驗，不可能成為優秀的編輯。</p><hr><p>總之，我覺得，工程師也好，非工程師也罷，在 AI 面前，我們都是人類，都需要藉由 AI 的輔助，不斷擴展自己的邊界。</p><p>這是個令人興奮的時代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何人類都能使用魔法的時代要到來了——《葬送的芙莉蓮》漫畫第 53 話 | 人類的時代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了強大的 AI 輔助 ，寫程式再也不是軟體工程師的專屬。&lt;/p&gt;
&lt;p&gt;如此的時代巨變，首先讓我聯想到的，就是「芙莉蓮」中的這段劇情。&lt;/p&gt;
&lt;p&gt;不過把這個比喻與感受表達得最好的，當屬財經作家王伯達的這篇&lt;a href=&quot;https://www.facebook.com/share/p/173juCsKre/&quot;&gt;臉書文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;他寫道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI 讓更多人，用更容易的方式使用程式語言與複雜軟體。&lt;/p&gt;
&lt;p&gt;這讓我想到芙莉蓮的老師，弗蘭梅。&lt;/p&gt;
&lt;p&gt;她說服了人類的皇帝，讓人類得以開始研究魔法，魔法不再是個禁忌，開啟了人人有魔法可以練的年代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顯然，在我這個軟體工程師眼中，AI 就像芙蘭梅，把原本高門檻的知識、技術變成大眾能輕易接觸的工具，&lt;strong&gt;讓所有人都有機會參與創造&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文聊聊我作為一個軟體工程師，如何看待這個 AI 普及後的「魔法時代」。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/20250710-223843-city-7625204_1280.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Vibe Coding" scheme="https://blog.kyomind.tw/tags/Vibe-Coding/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 入門：自動化 Lint、Format 與 Type Check</title>
    <link href="https://blog.kyomind.tw/github-actions/"/>
    <id>https://blog.kyomind.tw/github-actions/</id>
    <published>2025-07-06T02:31:27.000Z</published>
    <updated>2025-07-11T13:55:10.002Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/code-and-me.png"></p><blockquote><p>📌 這是 <a href="https://github.com/kyomind/WeaMind/blob/main/blogs/README.md">WeaMind 系列</a> 的第 2 篇。<br>本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。</p></blockquote><p>從這篇文章開始，我將啟動一個新的系列。</p><p>搭配我正在實作中的 Side Project——<a href="https://github.com/kyomind/WeaMind">WeaMind</a>，寫下一篇又一篇的技術實作心得。</p><p>讓我們一起在專案中成長，並獲得更多的開發樂趣。</p><p>如標題所示，本文主要介紹 <a href="https://github.com/features/actions">GitHub Actions</a>。不過在此之前，我們得先對 CI 有初步的了解。</p><hr><h2 id="什麼是-CI？為什麼需要-CI？"><a href="#什麼是-CI？為什麼需要-CI？" class="headerlink" title="什麼是 CI？為什麼需要 CI？"></a>什麼是 CI？為什麼需要 CI？</h2><p>CI 是「<a href="https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">Continuous Integration</a>」的縮寫，中文是「持續整合」。</p><p>它的核心概念是：<strong>當開發人員提交程式碼時，系統可以「自動執行一系列預先定義的檢查流程」</strong>，例如檢查程式碼是否與現有程式相容、是否能正常運作。</p><p>在軟體開發流程中，我們常常要處理很多<strong>重複但又不可忽略</strong>的工作：檢查程式碼格式、執行靜態分析、跑單元測試，甚至產生 API 文件等。</p><p>如果每次提交都要手動跑一輪，既麻煩又易忘。</p><p>這時 CI 就派上用場了。它能在每次 push 或開 PR 時（或其它事件），自動幫我們做這些事，讓問題提早浮現，使得開發流程更加穩健，也能節省大量重複性勞動。</p><span id="more"></span><h2 id="常見的-CI-工具有哪些？"><a href="#常見的-CI-工具有哪些？" class="headerlink" title="常見的 CI 工具有哪些？"></a>常見的 CI 工具有哪些？</h2><p>市面上已有不少 CI 工具可以選擇，例如：</p><ul><li><strong>Travis CI</strong>：老牌工具，但在開源社群中的使用率逐漸下降。</li><li><strong>CircleCI</strong>：主打高彈性與高度客製化的流程控制。</li><li><strong>GitHub Actions</strong>：GitHub 官方推出、與 GitHub 無縫整合的 CI&#x2F;CD 解決方案。</li></ul><p>這次我們選擇的是 GitHub Actions，理由很簡單：<strong>直接內建於 GitHub、好上手、不用額外註冊帳號</strong>。</p><p>而且對於「公開倉庫」，GitHub 給的 CI 運行時間額度是——無上限！</p><p>即使是私人倉庫，免費用戶也有每月 2000 分鐘，通常很夠用了。</p><hr><h2 id="認識-GitHub-Actions"><a href="#認識-GitHub-Actions" class="headerlink" title="認識 GitHub Actions"></a>認識 GitHub Actions</h2><p><a href="https://github.com/features/actions">GitHub Actions</a> 是 GitHub 提供的 CI&#x2F;CD 解決方案。</p><p>相較於上述提到的其它工具，它誕生的時間算是晚得多。</p><p>雖然推出較晚（2019 年才正式上線），但 GitHub Actions 從一開始就內建於 GitHub 平台，整合度高是它的一大優勢。</p><p>開發者不需額外設定外部服務，就能快速啟用 CI&#x2F;CD 流程，<strong>對個人開發者或小型專案尤其友善。</strong></p><p>你可以透過撰寫一份<code>yaml</code>設定檔，定義「<strong>什麼時候要觸發什麼流程</strong>」，像是：</p><ul><li>每次 push 時跑 Lint</li><li>每次 Pull Request 開啟時跑測試</li></ul><p>它支援容器、多種語言與工具，而且有非常多現成的 actions 可以直接引用。</p><p>這些功能，此刻我們還不需要了解，先著眼於當前的目標即可。</p><hr><h2 id="學習-CI-工具最好的方式：從需求開始"><a href="#學習-CI-工具最好的方式：從需求開始" class="headerlink" title="學習 CI 工具最好的方式：從需求開始"></a>學習 CI 工具最好的方式：從需求開始</h2><p>必須強調，相比於程式語言、後端框架等工具，CI&#x2F;CD 服務是<strong>更加「工具化」的工具</strong>。</p><p>意思是說，雖然有使用上的規則，但其中<strong>並沒有太多的「道理」可言</strong>！</p><p>單純就是看各家廠商怎麼制定與規範、設定檔怎麼寫等等。</p><p>所以，我認為，學習這類工具，最好的方式就是「直接用用看」！</p><p>你不需要一開始就設計一套完整的 CI 流程，只要從<strong>最簡單的需求</strong>開始，例如：</p><ul><li>跑 Lint、跑 Formatter</li><li>檢查型別</li></ul><p>這正是本文的出發點——用 GitHub Actions 設定一個最小可用的 CI 流程，整合 Lint、Format 與 Type Check。</p><h2 id="沒有需求怎麼辦？"><a href="#沒有需求怎麼辦？" class="headerlink" title="沒有需求怎麼辦？"></a>沒有需求怎麼辦？</h2><p>前面強調了需求的重要性，絕非隨便說說。</p><p>為了學習 GitHub Actions，我也看過不少課程，但沒有真實需求，學完很快就忘了。因為它的各種功能對我來說，都<strong>無法產生「具體的連結」。</strong></p><p>所以，如果你沒有實際的需求，我有兩個建議：</p><ol><li>自己創造需求！就像我們這裡的 side project，這不就有需求了嗎😇</li><li>先別學了！事半功倍鵝🪿</li></ol><p>第二點不是開玩笑XD，真的，沒需求就先別學了——晚點再說。軟體開發還有無數的領域等著你探索與投入。</p><hr><p>回到正題，直接來看專案中如何實作 GitHub Actions CI。</p><h2 id="GitHub-Actions-實作"><a href="#GitHub-Actions-實作" class="headerlink" title="GitHub Actions 實作"></a>GitHub Actions 實作</h2><p>我們的小目標是：</p><ul><li>只要有人 push 或開 PR，就自動檢查程式碼品質。（這是<strong>最常見的 CI 觸發時機</strong>）</li><li>用以下工具檢查：<ul><li><strong>Ruff</strong>：作為 Linter 與 Formatter（參考〈<a href="https://blog.kyomind.tw/ruff/">Python 開發：RuffLinter、Formatter 介紹 + 設定教學</a>〉）</li><li><strong>Pyright</strong>：執行靜態型別檢查（參考〈<a href="https://blog.kyomind.tw/pyright/">Pyright 上手指南：Python 型別檢查的新選擇</a>〉）</li></ul></li></ul><p>這些都是我平常在本機開發會執行的操作——無論是透過 VS Code 還是 pre-commit，現在只是搬到 CI 裡執行。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><h2 id="GitHub-Action-YAML-設定"><a href="#GitHub-Action-YAML-設定" class="headerlink" title="GitHub Action YAML 設定"></a>GitHub Action YAML 設定</h2><p>以下是<a href="https://github.com/kyomind/WeaMind/blob/blog/github-actions-2025-07-06-v1/.github/workflows/ci.yml">實際的設定檔內容</a>，放在專案目錄底下的 <code>.github/workflows/ci.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Continuous</span> <span class="string">Integration</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">quality-check:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Lint,</span> <span class="string">Format,</span> <span class="string">Type</span> <span class="string">Check,</span> <span class="string">Test</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ghcr.io/astral-sh/uv:python3.12-bookworm-slim</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">sync</span> <span class="string">--locked</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Lint</span> <span class="string">(ruff)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">ruff</span> <span class="string">check</span> <span class="string">.</span> <span class="string">--fix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Format</span> <span class="string">(ruff</span> <span class="string">format)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">ruff</span> <span class="string">format</span> <span class="string">.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Type</span> <span class="string">check</span> <span class="string">(pyright)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">pyright</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">unit</span> <span class="string">tests</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">uv</span> <span class="string">run</span> <span class="string">pytest</span></span><br></pre></td></tr></table></figure><p>可以看出，它還跑了單元測試！</p><p>我們可以暫時無視這部分，因為測試的相關設定細節更多，之後再另篇討論。</p><p>其餘細節也都先略過，我們只看最後的<code>steps</code>部分。</p><p>每個<code>run:</code>就是執行一個 CLI 指令，只不過是在 GitHub 的遠端 runner 上執行而已。</p><p>這就是 CI 本質：<strong>開另一台機器，做一連串你「事先預定」的事情！</strong></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p>寫好 yaml 設定檔後，只要你 commit 並 push，GitHub 就會開始跑 CI workflow 了！（每一個設定檔都是一個 workflow）</p><p>無論成功或失敗，結果都會顯示在專案的「<a href="https://github.com/kyomind/WeaMind/actions">Actions</a>」分頁：</p><p><img src="https://img.kyomind.tw/20250706-112153-action-min.png" alt="GitHub Actions 執行結果"><span class="cap">GitHub Actions 執行結果</span></p><p>這裡是成功的，如果失敗了，GitHub 還會寄信給你——這很重要。</p><hr><h2 id="結語：最關鍵的第一步"><a href="#結語：最關鍵的第一步" class="headerlink" title="結語：最關鍵的第一步"></a>結語：最關鍵的第一步</h2><p>本文僅對 CI 跟 GitHub Actions 做了基本的介紹，並展示一下我的設定檔。</p><p>因為篇幅有限，沒有對所有細節進行完整說明——或許以後！</p><p>但這並不妨礙你立刻開始動手。</p><p>我認為，在 AI 能夠很好地輔助軟體開發的時代，設定檔的內容大部分都可以由 AI 代勞——當然我們不能對此一無所知😅</p><p>最重要的還是：<strong>你開始使用這些工具，將它們融入到開發流程中</strong>。</p><p>我想這才是最關鍵的第一步。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/code-and-me.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 這是 &lt;a href=&quot;https://github.com/kyomind/WeaMind/blob/main/blogs/README.md&quot;&gt;WeaMind 系列&lt;/a&gt; 的第 2 篇。&lt;br&gt;本系列以真實世界專案為背景，記錄重要技術實作與經驗分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;從這篇文章開始，我將啟動一個新的系列。&lt;/p&gt;
&lt;p&gt;搭配我正在實作中的 Side Project——&lt;a href=&quot;https://github.com/kyomind/WeaMind&quot;&gt;WeaMind&lt;/a&gt;，寫下一篇又一篇的技術實作心得。&lt;/p&gt;
&lt;p&gt;讓我們一起在專案中成長，並獲得更多的開發樂趣。&lt;/p&gt;
&lt;p&gt;如標題所示，本文主要介紹 &lt;a href=&quot;https://github.com/features/actions&quot;&gt;GitHub Actions&lt;/a&gt;。不過在此之前，我們得先對 CI 有初步的了解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什麼是-CI？為什麼需要-CI？&quot;&gt;&lt;a href=&quot;#什麼是-CI？為什麼需要-CI？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 CI？為什麼需要 CI？&quot;&gt;&lt;/a&gt;什麼是 CI？為什麼需要 CI？&lt;/h2&gt;&lt;p&gt;CI 是「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88&quot;&gt;Continuous Integration&lt;/a&gt;」的縮寫，中文是「持續整合」。&lt;/p&gt;
&lt;p&gt;它的核心概念是：&lt;strong&gt;當開發人員提交程式碼時，系統可以「自動執行一系列預先定義的檢查流程」&lt;/strong&gt;，例如檢查程式碼是否與現有程式相容、是否能正常運作。&lt;/p&gt;
&lt;p&gt;在軟體開發流程中，我們常常要處理很多&lt;strong&gt;重複但又不可忽略&lt;/strong&gt;的工作：檢查程式碼格式、執行靜態分析、跑單元測試，甚至產生 API 文件等。&lt;/p&gt;
&lt;p&gt;如果每次提交都要手動跑一輪，既麻煩又易忘。&lt;/p&gt;
&lt;p&gt;這時 CI 就派上用場了。它能在每次 push 或開 PR 時（或其它事件），自動幫我們做這些事，讓問題提早浮現，使得開發流程更加穩健，也能節省大量重複性勞動。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="GitHub Actions" scheme="https://blog.kyomind.tw/tags/GitHub-Actions/"/>
    
    <category term="WeaMind" scheme="https://blog.kyomind.tw/tags/WeaMind/"/>
    
  </entry>
  
  <entry>
    <title>yadm 教學：實作 macOS 與 Linux 的 dotfiles 跨平台同步</title>
    <link href="https://blog.kyomind.tw/yadm-cross-platform/"/>
    <id>https://blog.kyomind.tw/yadm-cross-platform/</id>
    <published>2025-06-28T15:01:29.000Z</published>
    <updated>2025-06-29T02:30:43.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><p>兩年多前，我寫了這篇〈<a href="https://blog.kyomind.tw/yadm/">是時候同步你的 dotfiles 了——我選擇 yadm</a>〉，當時的主要動機是想要在多個 Linux VM 之間同步設定檔。</p><p>該文章介紹了「何謂 dotfiles」（後端工程師應該都很熟悉），以及我認為的「dotfiles 同步工具」的兩大流派：</p><ol><li>Symbolic Link。</li><li>Bare Git。</li></ol><p>然而，兩年之間，我幾乎很少在文中提起它。</p><p>事實上，我這段期間使用的 yadm 的頻率<strong>確實不高</strong>！</p><p>但這並不代表我沒有同步 dotfiles 的需求，只是真正的核心需求在於<strong>跨平台</strong>，尤其是 macOS 與 Linux 之間。</p><p>若僅是在不同 Linux VM 之間同步，就顯得有點小打小鬧，<strong>實用性不足</strong>。</p><hr><p>我日常開發主要都在 Mac 上，而 Mac 與 Linux 的設定落差雖不大，但<strong>絕不會完全相同</strong>——這讓單一套設定難以通用。</p><p>比如我的 Mac 上有一些 Homebrew 的環境變數，在 Linux 上無用武之地不說，還可能造成執行錯誤。</p><p>總之，<strong>若不解決跨平台問題，那 yadm 的價值將發揮不到一半。</strong></p><p>上個月我終於鐵了心，<strong>把這件事搞定了！</strong></p><p>做完只覺得，我實在太晚開始，跨平台同步的<strong>價值非常巨大且實用</strong>。</p><p>因此，儘管使用這類工具的人並不多，我也要寫下這篇文章，供有志之士參考！</p><span id="more"></span><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文重點在於介紹 yadm 的跨平台<strong>設定檔、關聯機制</strong>，還有基本操作。</p><p>所以我會假設你已經用過了 yadm——其實沒用過也無妨，因為常見的操作並不複雜。你可以等看了效果後再決定是否學習 yadm。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>不可否認，本文的目標讀者是軟體工程師，尤其是後端開發者。</p><p>非技術出身的讀者，可能連 dotfiles 的作用都不容易理解——這很正常。</p><p>總之，對於一個熱衷於「客製化工具設定」的開發者，我相信 dotfiles 的同步是肯定要學的。</p><p>太實用了！</p><hr><h2 id="Alternate-Files-介紹"><a href="#Alternate-Files-介紹" class="headerlink" title="Alternate Files 介紹"></a>Alternate Files 介紹</h2><p>yadm 最強大的能力之一，就是透過「<a href="https://yadm.io/docs/alternates">Alternate Files</a>」（下稱 alt files）來實現跨平台同步，<strong>它能依據作業系統、主機名稱等條件，自動尋找對應的設定檔</strong>。</p><p>這是實現跨平台 dotfiles 管理的核心關鍵。</p><h3 id="實際範例：我的-dotfiles-結構"><a href="#實際範例：我的-dotfiles-結構" class="headerlink" title="實際範例：我的 dotfiles 結構"></a>實際範例：我的 dotfiles 結構</h3><p>這是我的 dotfiles repo 現況，我們只要關注這些「檔名」即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .aliases<span class="comment">##default</span></span><br><span class="line">├── .aliases<span class="comment">##os.Darwin</span></span><br><span class="line">├── .aliases<span class="comment">##os.Linux</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Darwin</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Linux</span></span><br><span class="line">├── .zprofile<span class="comment">##default</span></span><br><span class="line">├── .zprofile<span class="comment">##os.Darwin</span></span><br><span class="line">├── .zshrc<span class="comment">##default</span></span><br><span class="line">├── .zshrc<span class="comment">##os.Darwin</span></span><br><span class="line">└── .zshrc<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><p>可以大概看出，我僅僅同步了 4 個主要設定檔，雖然加上 alt files 後，實際上總共有 10 個檔案。</p><p>這個命名結構反映出<strong>兩種</strong>主要形式——共用檔與變體檔：</p><ul><li><code>##default</code>：所有平台共通的預設設定（<strong>共用檔</strong>）</li><li><code>##os.Darwin</code>&#x2F;<code>os.Darwin</code>：依作業系統不同而變化的設定（<strong>變體檔</strong>）</li></ul><p>這種設計的重點是「<strong>分層與組合</strong>」。</p><p>yadm 在處理 alt files 時，會<strong>優先使用符合條件的變體</strong>（如 Darwin），若該變體不存在，則退回（fallback）至 default 檔案。</p><p>如此一來，我們就能<strong>針對特定平台進行客製設定，同時保有共用邏輯</strong>。</p><hr><h2 id="yadm-Alt-Files-的三大重點"><a href="#yadm-Alt-Files-的三大重點" class="headerlink" title="yadm Alt Files 的三大重點"></a>yadm Alt Files 的三大重點</h2><p>我知道，光這樣講並不容易理解。</p><p>簡單來說，我覺得這些 alt files 有三個學習重點。</p><h3 id="一、「後綴」命名格式與樣式"><a href="#一、「後綴」命名格式與樣式" class="headerlink" title="一、「後綴」命名格式與樣式"></a>一、「後綴」命名格式與樣式</h3><p>在特殊標記<code>##</code>之後的「<strong>os 層級</strong>」命名格式是固定的！</p><p>換言之，<code>os.Darwin</code>、<code>os.Darwin</code>這些「後綴」名稱<strong>不可自訂</strong>，千萬不要打錯了。</p><p>事實上這類後綴可以有<strong>非常多樣</strong>的寫法，有些確實需要自定義，比如文件中的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##class.Work</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##class.Work,~os.Darwin</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host1</span></span><br><span class="line"><span class="variable">$HOME</span>/path/example.txt<span class="comment">##os.Darwin,hostname.host2</span></span><br></pre></td></tr></table></figure><p>這允許你即使在同一種平台，也能讓不同主機，甚至不同使用者之間產生一定的差異與客製。</p><p>不過我覺得，<strong>區分 macOS 和 Linux 就已經非常實用</strong>。</p><p><strong>我建議你也這樣做就好</strong>，因為我認為 yadm <strong>已然不算很平易近人的工具XD</strong>，如果還要了解這些複雜的後綴規則與用法，恐怕讓人退避三舍。</p><h3 id="二、路徑的尋找規則"><a href="#二、路徑的尋找規則" class="headerlink" title="二、路徑的尋找規則"></a>二、路徑的尋找規則</h3><p>在<strong>相同前綴不同後綴</strong>的一系列的檔名中，yadm 只會依照「尋找規則」，選取其中一個建立 Symbolic Link，讓它指向<strong>系統真正會讀取的檔案</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── .zshrc<span class="comment">##default</span></span><br><span class="line">├── .zshrc<span class="comment">##os.Darwin</span></span><br><span class="line">└── .zshrc<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><p>以<code>.zshrc</code>為例，在 macOS 上，它會找到<code>.zshrc##os.Darwin</code>。</p><p>而在 Linux 上則是<code>.zshrc##os.Linux</code>。</p><p>透過這套尋找規則，yadm 就能在不同作業系統提供<strong>設定檔的差異化</strong>。</p><h3 id="三、共用檔的角色"><a href="#三、共用檔的角色" class="headerlink" title="三、共用檔的角色"></a>三、共用檔的角色</h3><p>承上，熟悉 dotfiles 的你應該不難猜到，<code>.zshrc##default</code>要放的內容，就是兩邊都會「共用」的部分。</p><p>然後，在「變體」檔的開頭，要去<code>source</code>共用檔的內容！</p><p>以我的<code>.zshrc##os.Darwin</code>為例，開頭內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macOS 專屬 zsh 設定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先載入共用設定</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;<span class="variable">$HOME</span>/.zshrc##default&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Homebrew node@18 路徑（macOS 專屬）</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/opt/homebrew/opt/node@18/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果沒有共用檔，自然就不需要開頭的<code>source</code>。</p><p>像<code>p10k.zsh</code>因為設定複雜，我直接區分兩種版本，根本沒有共用部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── .p10k.zsh<span class="comment">##os.Darwin</span></span><br><span class="line">├── .p10k.zsh<span class="comment">##os.Linux</span></span><br></pre></td></tr></table></figure><hr><h2 id="Link-操作：yadm-alt"><a href="#Link-操作：yadm-alt" class="headerlink" title="Link 操作：yadm alt"></a>Link 操作：yadm alt</h2><p>當你完成上述的檔案設計並同步 dotfiles 後，只需執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm alt</span><br></pre></td></tr></table></figure><p>yadm 會<strong>尋找並關聯</strong>該主機上對應的檔案。</p><p>注意，這個步驟<strong>必不可少</strong>！不然你會發現，雖然所有 dotfiles 都已同步到本機，但這些檔案並沒有被實際使用。</p><p>而所謂的「<strong>關聯</strong>」，如前所述，就是建立 Symbolic Link。</p><p>在 Mac 上執行結果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ yadm alt</span><br><span class="line">Linking /Users/kyo/.aliases<span class="comment">##os.Darwin to /Users/kyo/.aliases</span></span><br><span class="line">Linking /Users/kyo/.p10k.zsh<span class="comment">##os.Darwin to /Users/kyo/.p10k.zsh</span></span><br><span class="line">Linking /Users/kyo/.zprofile<span class="comment">##os.Darwin to /Users/kyo/.zprofile</span></span><br><span class="line">Linking /Users/kyo/.zshrc<span class="comment">##os.Darwin to /Users/kyo/.zshrc</span></span><br></pre></td></tr></table></figure><p>而 Linux 則是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ yadm alt</span><br><span class="line">Linking /home/kyo/.aliases<span class="comment">##os.Linux to /home/kyo/.aliases</span></span><br><span class="line">Linking /home/kyo/.p10k.zsh<span class="comment">##os.Linux to /home/kyo/.p10k.zsh</span></span><br><span class="line">Linking /home/kyo/.zprofile<span class="comment">##default to /home/kyo/.zprofile</span></span><br><span class="line">Linking /home/kyo/.zshrc<span class="comment">##os.Linux to /home/kyo/.zshrc</span></span><br></pre></td></tr></table></figure><p>Beautiful！</p><hr><h2 id="yadm-使用忠告"><a href="#yadm-使用忠告" class="headerlink" title="yadm 使用忠告"></a>yadm 使用忠告</h2><p>yadm 是 Git 的 wrapper，操作它等於在<strong>操作一個裸露的 Git repo</strong>——而且這個 repo 還是<strong>你的 Home 目錄</strong>😱</p><p>這意味著，yadm 的操作<strong>會直接影響到你的系統設定檔</strong>。</p><p>如果你太隨意下達像是<code>yadm reset</code>、<code>yadm add .</code>等指令，有可能會讓你的系統檔案直接損毀XD</p><p>我就曾因為情急不慎操作，導致某台 VM 的設定變得半殘XD，只能砍掉重練。</p><h3 id="安全使用法則"><a href="#安全使用法則" class="headerlink" title="安全使用法則"></a>安全使用法則</h3><p>因此，我歸納了一個更安全的使用之道：</p><ul><li>所有設定修改，都集中在本機上的 dotfiles repo 中，<strong>透過 VS Code 進行編輯</strong>。</li><li>其他機器（包括本機）<strong>僅透過</strong><code>yadm pull</code><strong>同步修改後的結果</strong>，不進行任何<code>yadm commit</code>、<code>yadm push</code>等動作。</li></ul><p>這樣的模式確保你的設定變動<strong>只從單一來源發出</strong>，降低毀損風險，也讓同步過程更安全可控。</p><p>此外，如果我要做<code>yadm pull</code>、<code>yadm list</code>、<code>yadm status</code>三個指令（後兩者並不會改變檔案狀態，所以是安全的）<strong>以外</strong>的操作，<strong>我一定會先問 AI！</strong></p><p>因為這工具看似簡單，但威力絕不容小覷。</p><hr><h2 id="結語：同步-dotfiles-真的非常愉快"><a href="#結語：同步-dotfiles-真的非常愉快" class="headerlink" title="結語：同步 dotfiles 真的非常愉快"></a>結語：同步 dotfiles 真的非常愉快</h2><p>不誇張，自從設好跨平台同步後，<strong>開發幸福感大幅提升</strong>！</p><p>我以前太小看 yadm 了，可以跨平台之後，我變得更常改動 dotfiles、加入新的 alias，絲毫不用擔心同步問題。</p><p>我知道這篇文章不會有太多受眾，怕哪是軟體工程師，也不是人人都熱衷此道。</p><p>但如果你想在多台 Mac 和多台 Linux VM（我目前有 3 台 Mac 與兩台 Linux VM）同步設定檔，卻仍在猶豫要選用哪一款工具的話。</p><p><strong>不用想了，就選 yadm 吧！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;p&gt;兩年多前，我寫了這篇〈&lt;a href=&quot;https://blog.kyomind.tw/yadm/&quot;&gt;是時候同步你的 dotfiles 了——我選擇 yadm&lt;/a&gt;〉，當時的主要動機是想要在多個 Linux VM 之間同步設定檔。&lt;/p&gt;
&lt;p&gt;該文章介紹了「何謂 dotfiles」（後端工程師應該都很熟悉），以及我認為的「dotfiles 同步工具」的兩大流派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symbolic Link。&lt;/li&gt;
&lt;li&gt;Bare Git。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，兩年之間，我幾乎很少在文中提起它。&lt;/p&gt;
&lt;p&gt;事實上，我這段期間使用的 yadm 的頻率&lt;strong&gt;確實不高&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;但這並不代表我沒有同步 dotfiles 的需求，只是真正的核心需求在於&lt;strong&gt;跨平台&lt;/strong&gt;，尤其是 macOS 與 Linux 之間。&lt;/p&gt;
&lt;p&gt;若僅是在不同 Linux VM 之間同步，就顯得有點小打小鬧，&lt;strong&gt;實用性不足&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我日常開發主要都在 Mac 上，而 Mac 與 Linux 的設定落差雖不大，但&lt;strong&gt;絕不會完全相同&lt;/strong&gt;——這讓單一套設定難以通用。&lt;/p&gt;
&lt;p&gt;比如我的 Mac 上有一些 Homebrew 的環境變數，在 Linux 上無用武之地不說，還可能造成執行錯誤。&lt;/p&gt;
&lt;p&gt;總之，&lt;strong&gt;若不解決跨平台問題，那 yadm 的價值將發揮不到一半。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上個月我終於鐵了心，&lt;strong&gt;把這件事搞定了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做完只覺得，我實在太晚開始，跨平台同步的&lt;strong&gt;價值非常巨大且實用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，儘管使用這類工具的人並不多，我也要寫下這篇文章，供有志之士參考！&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/20250628-230318-AGhzS0d.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Gandi 惹惱了我😡——怒將域名轉至 Dynadot</title>
    <link href="https://blog.kyomind.tw/weekly-review-44/"/>
    <id>https://blog.kyomind.tw/weekly-review-44/</id>
    <published>2025-06-21T08:45:35.000Z</published>
    <updated>2025-07-11T15:36:45.042Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/weekly-review.png"> </p><p>我從 2018 年開始租用<code>kyomind.tw</code>這個域名，至今已 7 年。</p><p>每年 9&#x2F;1 是它的續約時間。過去多年來，價格大致穩定，折合新台幣大概 700 多元。</p><p>直到去年續約，我被信用卡帳單上的金額嚇了一跳：<strong>1260 元</strong>。</p><p>這是什麼情況？</p><p>一度以為是哪裡被誤收，或是信用卡出了問題。但查了帳單、比對後台紀錄，確認那筆款項的確是域名供應商 <a href="https://www.gandi.net/zh-Hant">Gandi</a> 對我的 .tw 域名的續約費用。</p><p>當下覺得很不對勁——域名費用可以這樣說漲就漲嗎？而且幅度也太誇張了！</p><hr><p>就這樣過了半年多，想想幾個月後又要續約了，1260 實在有點讓人卻步。</p><p>我們知道，域名在不同供應商之間，價格並不同。</p><p>而且！<strong>域名是可以移轉的</strong>。</p><p>所以我決定查查，目前 .tw 便宜的地方有哪些——發現了 <a href="https://www.dynadot.com/">Dynadot</a> 只要 18 美元！</p><p>而且，其他域名供應商，大概也只要二十幾美元左右啊，怎麼 Gandi 會特別貴？</p><p>於是我決定進一步弄清楚這到底是怎麼回事，這才發現，其實此時此刻，Gandi 的續約價格也只是台幣 700 多。</p><p>這讓我更加惱火了……</p><span id="more"></span><h2 id="發生了什麼事？"><a href="#發生了什麼事？" class="headerlink" title="發生了什麼事？"></a>發生了什麼事？</h2><p>用 ChatGPT 的 o3 模型幫我一探究竟。</p><p>以下匯率會依時間變動，看美元計價即可。</p><table><thead><tr><th>時點</th><th>Gandi 的 .tw 域名價格</th><th>實際反應</th></tr></thead><tbody><tr><td>2022-05-27</td><td>由 US$23.26 漲到 US$25（≈NT$710）</td><td>官方公告「.tw 調價」</td></tr><tr><td>2023-03</td><td>法國 Gandi SAS 與荷蘭的 Total Webhosting Solutions（TWS）正式合併，成立新的歐洲線上服務平台 <strong>Your.Online</strong>（官方<a href="https://news.gandi.net/en/2023/03/your-online-gandi-continues-its-development/">新聞稿</a>）</td><td>合併（<strong>實際上是 Gandi 被收購</strong>）完成後，<a href="http://gandi.net/">Gandi.net</a> 保持自治與原有品牌運營。但經營策略明顯轉變，為後續價格變動埋下伏筆</td></tr><tr><td>2024-08-29</td><td>突然暴漲到 US$39.98（≈NT$1,260）</td><td>客戶收到 30 天預告信，8&#x2F;29 價目表 PDF 生效；我的 9&#x2F;1 續約正好被擊中</td></tr><tr><td>2025-Q1 (未公告)</td><td>悄悄下修到 US$24（≈NT$744）</td><td>現在官網 .tw 頁面顯示的價格</td></tr></tbody></table><p>換句話說：我被收的 1260 元，的確是當時<strong>正式定價</strong>——而且才調漲沒幾天🤬</p><p>但之後 Gandi 又自己把價錢降了回來，整段過程沒有發新聞稿、沒有發聲明，就像整件事從來沒發生過一樣。</p><h2 id="為什麼會「漲了又降」？"><a href="#為什麼會「漲了又降」？" class="headerlink" title="為什麼會「漲了又降」？"></a>為什麼會「漲了又降」？</h2><p>漲價的不只有 .tw 域名，許多常見的域名都有漲，而且漲幅都很驚人。</p><p>雖然沒說明為何漲了又降，但從<a href="https://www.reddit.com/r/Domains/comments/1f4r7nl/the_cost_of_renewing_my_com_domain_is_coming_in/">社群反應</a>與價目表變化來看，極有可能是因為 2024 年暴漲後引發大量客戶流失。</p><p>就像前面說的，域名並非獨家提供的東西，<strong>用戶隨時可以選擇移轉到其他供應商</strong>。</p><p>Gandi 為了止血，在 2025 年初悄悄調以前的合理價格，卻選擇不對外說明。</p><p>畢竟如果有一個正式公告，那就相當於宣布自己做錯了事——確實是大錯特錯。</p><p>最後也只能摸摸鼻子，把價格調回來。</p><hr><h2 id="我還是決定移轉"><a href="#我還是決定移轉" class="headerlink" title="我還是決定移轉"></a>我還是決定移轉</h2><p>說真的，如果沒有去年的事件，就算我發現 Dynadot 上面的 TW 域名只要 18 美元，我基本上還是不會想移轉。</p><p>畢竟一年 6 美元的差距，沒有大到「讓我感到可惜」的地步。</p><p>服務用久了，還是會有感情的。</p><p>可是，想到去年發生的事，加上現在域名已經託管給 Cloudflare 了，註冊商的重要性大幅降低。才讓我有幾分心動。</p><p>在跟 AI 反覆討論之後，他還是力勸我離開，不要吃這種虧。</p><p>幾經考慮，決定移轉！</p><h2 id="域名轉出"><a href="#域名轉出" class="headerlink" title="域名轉出"></a>域名轉出</h2><p>操作不複雜。轉移流程如下：</p><ol><li>從 Gandi 後台解鎖域名，取得 EPP Code。</li><li>在 Dynadot 下單轉入，後續依照指示輸入該 code。</li><li>DNS Server 維持指向原本的 Cloudflare，不用做什麼。轉移期間 0 停機。</li><li>通常 24–48 小時就會完成。<strong>我實際操作只花了 1-2 小時。</strong></li></ol><h3 id="轉出心得"><a href="#轉出心得" class="headerlink" title="轉出心得"></a>轉出心得</h3><p>說真的，我覺得 Gandi 的後台比 Dynadot 更清楚、簡潔。</p><p>但如前所述，因為域名已托管給 Cloudflare，這一點其實已經不重要了。</p><p>所有的域名操作都是在 Cloudflare 上，除了每年（或每幾年）續約一次，平時根本不需要再登入註冊商後台。</p><p>在這種使用情境下，「價格」（或供應商的可靠度）幾乎成了唯一考量。</p><blockquote><p>有興趣在 Dynadot 購買域名的朋友，可以考慮透過我的<a href="http://www.dynadot.com/?s8WF6Q818Y8s748P">邀請連結</a>註冊。</p></blockquote><p>新戶透過這個連結註冊，並購買域名滿 9.99 美元時，雙方可各獲得 5 美元的優惠。</p><hr><h2 id="哪裡買域名最划算？Cloudflare-是首選"><a href="#哪裡買域名最划算？Cloudflare-是首選" class="headerlink" title="哪裡買域名最划算？Cloudflare 是首選"></a>哪裡買域名最划算？Cloudflare 是首選</h2><p>無論是購買新的域名，或是移轉既有的域名，我都建議<strong>優先查看 <a href="https://www.cloudflare.com/zh-tw/products/registrar/">Cloudflare Registrar</a></strong> 提供的價格與支援範圍。</p><p>只要 Cloudflare 支援該 <a href="https://zh.wikipedia.org/zh-tw/%E9%A0%82%E7%B4%9A%E5%9F%9F">TLD</a>，它幾乎都提供「<strong>接近成本價</strong>」的續費方案，而且整合自家 DNS，操作與安全性也更有保障。</p><blockquote><p><strong>頂級域名</strong>（英語：Top-level Domain, TLD）是<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">網際網路</a><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系統</a>的等級中，位於根域名空間的最高級域名，例如<code>com</code>是網址<code>example.com</code>的頂級域名。</p></blockquote><p>若 Cloudflare 沒有你需要的 TLD（很可惜它就不支援 .tw 域名），再去像 Dynadot、Namecheap 等註冊商比價會更有效率。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>從 Gandi 被收購後接連出現的價格波動與溝通失誤，可以看出一件事：當一家註冊商不再把用戶信任當作優先考量，無論它過去再穩，都可能在一夜之間變得不可靠。</p><p>這不是單一價格調漲的問題，而是<strong>整體經營思維轉變</strong>的結果。</p><p>這種「<strong>恣意妄為</strong>」的態度，讓我對 Gandi 的信任度大幅下降。既然有了更好的選擇，為什麼不換呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/weekly-review.png&quot;&gt; &lt;/p&gt;
&lt;p&gt;我從 2018 年開始租用&lt;code&gt;kyomind.tw&lt;/code&gt;這個域名，至今已 7 年。&lt;/p&gt;
&lt;p&gt;每年 9&amp;#x2F;1 是它的續約時間。過去多年來，價格大致穩定，折合新台幣大概 700 多元。&lt;/p&gt;
&lt;p&gt;直到去年續約，我被信用卡帳單上的金額嚇了一跳：&lt;strong&gt;1260 元&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是什麼情況？&lt;/p&gt;
&lt;p&gt;一度以為是哪裡被誤收，或是信用卡出了問題。但查了帳單、比對後台紀錄，確認那筆款項的確是域名供應商 &lt;a href=&quot;https://www.gandi.net/zh-Hant&quot;&gt;Gandi&lt;/a&gt; 對我的 .tw 域名的續約費用。&lt;/p&gt;
&lt;p&gt;當下覺得很不對勁——域名費用可以這樣說漲就漲嗎？而且幅度也太誇張了！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;就這樣過了半年多，想想幾個月後又要續約了，1260 實在有點讓人卻步。&lt;/p&gt;
&lt;p&gt;我們知道，域名在不同供應商之間，價格並不同。&lt;/p&gt;
&lt;p&gt;而且！&lt;strong&gt;域名是可以移轉的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以我決定查查，目前 .tw 便宜的地方有哪些——發現了 &lt;a href=&quot;https://www.dynadot.com/&quot;&gt;Dynadot&lt;/a&gt; 只要 18 美元！&lt;/p&gt;
&lt;p&gt;而且，其他域名供應商，大概也只要二十幾美元左右啊，怎麼 Gandi 會特別貴？&lt;/p&gt;
&lt;p&gt;於是我決定進一步弄清楚這到底是怎麼回事，這才發現，其實此時此刻，Gandi 的續約價格也只是台幣 700 多。&lt;/p&gt;
&lt;p&gt;這讓我更加惱火了……&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/weekly-review.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
  </entry>
  
  <entry>
    <title>為 e2-micro VM 建立 SSH 連線：本機與 GitHub</title>
    <link href="https://blog.kyomind.tw/vm-ssh-setup/"/>
    <id>https://blog.kyomind.tw/vm-ssh-setup/</id>
    <published>2025-06-14T02:59:31.000Z</published>
    <updated>2025-06-22T03:15:46.519Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/code-and-me.png"></p><p>不久前，我看完了朋友<a href="https://kucw.io/about/">古古</a>的電子報〈<a href="https://kucw.io/blog/gcp-free-tier/">終身免費的 VM 服務！Google Cloud 免費方案分享</a>〉，介紹 GCP 的 E2 Micro（產品代號：e2-micro）免費 VM。</p><p>簡言之，我們可以在<strong>一定資源額度與條件範圍內</strong>，免費使用 Google Cloud Platform 上的 Compute Engine 虛擬機器。</p><p>我對此深感興趣，因為它的規格比之前的 F1 Micro 好上一截。</p><p>F1 時代的 RAM 大約只有 0.6 GiB（約 600MB），有開發經驗的都知道，這在某些情況下，用起來會有點捉襟見肘😂</p><p>於是，我也跟著教學開了一台！免費的午餐怎麼能不拿呢？</p><p>附帶一提，對 GCP 不熟的人——比如我，<strong>請一定要照著教學來建立 VM</strong>，以免設定時有所遺漏，一不小心就被收費。</p><h2 id="最後一塊拼圖"><a href="#最後一塊拼圖" class="headerlink" title="最後一塊拼圖"></a>最後一塊拼圖</h2><p>不過原來的教學只寫到 VM 建立完成為止，對於我們這些後端工程師而言，顯然還有一個很重要的基礎設定沒做——SSH 連線。 </p><p>因此，我想補齊這剩下的部分，包含：</p><ol><li>建立自己的 Linux 帳號。</li><li>建立本機與 VM 的 SSH 連線金鑰，並完成連線。</li><li>建立 VM 與 GitHub 的 SSH 連線，且能正常 clone Github 專案。</li></ol><p>剛好我在之前文章〈<a href="/linux-dev-setup/">Linux 上的 Python 開發環境設定</a>〉中，略過了「<a href="/linux-dev-setup/#%E4%B8%80%E3%80%81%E8%A8%AD%E5%AE%9A-SSH-%E9%80%A3%E7%B7%9A">設定 SSH 連線</a>」環節——老實說只是因為我懶得寫XD</p><p>但仔細想想，這個流程我自己做了很多次，不如直接寫在文章裡，方便大家回顧。</p><p>雖說是寫給 e2-micro，不過，這些內容適用於任何 Linux VM。</p><p>本文就來補完這些步驟，並講述我對於這個免費 VM 的看法。</p><span id="more"></span><hr><h2 id="為什麼你值得一台-E2-Micro？"><a href="#為什麼你值得一台-E2-Micro？" class="headerlink" title="為什麼你值得一台 E2 Micro？"></a>為什麼你值得一台 E2 Micro？</h2><p>因為免費囉！但不止如此。</p><p>〈<a href="/hetzner/">從 DigitalOcean 到 Hetzner：我為何轉向這家德國 VPS 供應商</a>〉一文中，有讀者<a href="https://github.com/kyomind/blog-reply/issues/70#issuecomment-2875240486">留言</a>問道：</p><blockquote><p>想問問不選擇 <a href="https://fly.io/">Fly.io</a> 或 <a href="https://render.com/">render</a> 來部署的原因，他們看起來有免費額度可以部署。</p></blockquote><p>我則回應：</p><blockquote><p>這類帶有免費額度的服務，主要是為了吸引不想花錢的用戶，條款常有變更的可能，比較適合短期或實驗性質（雖然 memos 備份挺容易的），長期部署我比較不會考慮</p></blockquote><p>退一步來說，如果你真的需要一台免費的 VM 來部署 memos 這類的小服務，那麼與其選擇 <a href="https://fly.io/">Fly.io</a> 或 <a href="https://render.com/">render</a>，還不如先開一台 E2 免費 VM！</p><p>等到不堪負荷了（但仍不想付錢XD），再考慮像 Fly.io 或 render 這些供應商也不遲。</p><p>畢竟 GCP 這樣的大廠，福利政策突然變更、收回的機率，通常比上述公司小得多。</p><p>除此之外，還有兩個關鍵理由。 </p><h3 id="一、延遲優勢"><a href="#一、延遲優勢" class="headerlink" title="一、延遲優勢"></a>一、延遲優勢</h3><p>我覺得，這台免費 VM 的最大亮點，是「<strong>延遲低</strong>」。</p><p>GCP 雖然只開放美國三個地區的資料中心供免費機器使用，但實際測試從台灣連線，<strong>延遲還可以</strong>！</p><p>請優先選擇<code>us-west1</code>（美國西部）地區，因為這個地區的延遲最低。</p><p>經實測比我在 Hetzner（德國）上的機器表現好非常多。與 DigitalOcean（新加坡）的延遲相當。</p><p>我自己的 <a href="https://www.cloudpingtest.com/">Cloud Ping Test</a> 網站測試結果如下：</p><ul><li>GCP（us-west1）：130-150 ms</li><li>Hetzner（德國）：600-800 ms</li><li>DigitalOcean（新加坡）：120-150 ms</li></ul><p>雖然比不上 GCP 台灣機房動輒 10-30 ms 的延遲，但對於大多數應用來說，130-150 ms 的延遲應屬「<strong>可接受</strong>」。</p><h3 id="二、免費額度堪稱大方"><a href="#二、免費額度堪稱大方" class="headerlink" title="二、免費額度堪稱大方"></a>二、免費額度堪稱大方</h3><p>免費機器的內容如下：</p><ul><li>0.25 至 2 個 vCPU（1 個共用核心，動態分配資源）</li><li>1 GB RAM</li><li>30 GB 標準磁碟（傳統 HDD）</li><li>每月 1 GB 出站流量</li></ul><p>這些規格看似陽春，但其實已能支撐許多日常小 app。若對照 DigitalOcean，類似的 VM 要價在每個月 5 美元以上。</p><p><img src="https://img.kyomind.tw/20250614-110147-vm-ssh-setup.png">  </p><p>所以，這樣的 VM 竟然可以免費使用，我覺得已經很大方。</p><h2 id="小提醒：對外流量限制"><a href="#小提醒：對外流量限制" class="headerlink" title="小提醒：對外流量限制"></a>小提醒：對外流量限制</h2><p>雖然一直強調它的優點，但是 1GB 的「對外流量」如果要拿來做公開服務，很可能會不夠用。</p><p>你看上圖 DigitalOcean 的價格，6 美元的 VM 每月有著 1000 GiB 的流量。</p><p>E2 Micro <strong>強烈建議只拿來部署自用服務</strong>。</p><hr><p>介紹完我認為的 E2 Micro 優點，接下來進入正題。</p><h2 id="設定-SSH-連線"><a href="#設定-SSH-連線" class="headerlink" title="設定 SSH 連線"></a>設定 SSH 連線</h2><p>在使用雲端平台或 VPS 服務建立 VM 後，通常有<strong>兩種</strong>主要的<strong>初次登入方式</strong>：</p><ol><li><strong>Web 界面提供內建 SSH 終端機</strong>：使用者可從平台介面直接開啟瀏覽器終端登入虛擬機器，無需事先設定金鑰。</li><li><strong>建立 VM 時預先設定 SSH 金鑰</strong>：在建立過程中指定公鑰，平台會在 VM 建立時將其寫入<code>authorized_keys</code>，讓你能用該金鑰從本機連入。（通常是用 root 帳號）</li></ol><p>這兩種方式大多數平台都支援，在原文的教學中，採用的是第一種方式，也就是透過 Web SSH 登入 VM。</p><p>登入之後，我們就可以開始設定<strong>真正屬於自己</strong>的登入方式。</p><h3 id="建立-Linux-帳號"><a href="#建立-Linux-帳號" class="headerlink" title="建立 Linux 帳號"></a>建立 Linux 帳號</h3><p>不管是 root 帳號還是 GCP 給你的帳號，都不是我們自己建立的帳號。</p><p>開發時，通常不會直接使用這些帳號來進行日常操作，尤其 root 帳號權限過大，存在一定的安全風險。</p><p>所以我們習慣先建立自己的 Linux 帳號，然後再設定 SSH 連線。</p><p>建立新帳號，並加入管理者群組：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser kyo</span><br><span class="line">sudo usermod -aG sudo kyo</span><br></pre></td></tr></table></figure><p>這裡直接用<code>kyo</code>舉例，實際操作時，請自行替換帳號名稱。</p><p>為<code>kyo</code>建立<code>.ssh</code>目錄，設定並權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /home/kyo/.ssh</span><br><span class="line">sudo <span class="built_in">chown</span> kyo:kyo /home/kyo/.ssh</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 /home/kyo/.ssh</span><br></pre></td></tr></table></figure><h3 id="本機建立-SSH-金鑰"><a href="#本機建立-SSH-金鑰" class="headerlink" title="本機建立 SSH 金鑰"></a>本機建立 SSH 金鑰</h3><p>接下來，我們在<strong>本機電腦</strong>產出 SSH 金鑰，建議使用 <a href="https://zh.wikipedia.org/zh-tw/EdDSA#Ed25519">Ed25519</a> 演算法，它更加現代，而且更重要的是——<strong>公鑰很短</strong>！（方便複製）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;odinxp@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>採用預設選項一路按<code>Enter</code>的話，會產生下面兩個檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.ssh/</span></span><br><span class="line">id_ed25519</span><br><span class="line">id_ed25519.pub</span><br></pre></td></tr></table></figure><p>通常我會先產出，再自行改名。比如把檔名改成<code>gcp</code>、<code>gcp.pub</code>，方便辨識。</p><p>將產生的公鑰內容複製，並貼到 VM 上<code>kyo</code>帳戶下的<code>authorized_keys</code>中，此時因為是透過 Web SSH 登入的管理者帳號來操作自非身帳號，指令要加上<code>sudo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/gcp.pub</span><br><span class="line"><span class="comment"># 複製內容後在 VM 上操作</span></span><br><span class="line">sudo nano /home/kyo/.ssh/authorized_keys <span class="comment"># 貼上內容後存檔</span></span><br><span class="line">sudo <span class="built_in">chown</span> kyo:kyo /home/kyo/.ssh/authorized_keys</span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /home/kyo/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>在本機建立 <a href="https://chusiang.gitbooks.io/working-on-gnu-linux/content/20.ssh_config.html">SSH config</a> 來簡化連線設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.ssh/config</span><br></pre></td></tr></table></figure><p>然後編輯<code>~/.ssh/config</code>，加入以下內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host gcp</span><br><span class="line">    HostName &lt;VM 的實際 ip&gt;</span><br><span class="line">    User kyo</span><br><span class="line">    IdentityFile ~/.ssh/gcp</span><br></pre></td></tr></table></figure><p>本機測試使用新帳號連線 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh kyo@gcp</span><br></pre></td></tr></table></figure><p>這樣基本就完成了！</p><hr><h2 id="Github-SSH-設定"><a href="#Github-SSH-設定" class="headerlink" title="Github SSH 設定"></a>Github SSH 設定</h2><p>設定完本機連線，我通常會緊接著設定 GitHub 連線。</p><p>注意，<strong>本機連線</strong>指的是「<strong>本機和 VM 之間</strong>」；而 <strong>GitHub 連線</strong>在本文的語境下，則是指「<strong>VM 和 GitHub 之間</strong>」。</p><p>所以這部分的主要操作都是<strong>在 VM 上進行</strong>。</p><p>一樣，先在 VM 上產生新的 SSH 金鑰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;odinxp@gmail.com&quot;</span> -f ~/.ssh/github</span><br></pre></td></tr></table></figure><p>加上<code>-f ~/.ssh/github</code>後，可以省去手動更名的麻煩，不過要注意，它同時也會<strong>覆蓋</strong>原有的檔案！（如果有的話）</p><p>複製公鑰內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/github.pub</span><br></pre></td></tr></table></figure><p>前往 <a href="https://github.com/settings/ssh/new">Github SSH 設定頁</a>，貼上金鑰。</p><p>新增、編輯<code>~/.ssh/config</code>加入 Github 設定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/github</span><br></pre></td></tr></table></figure><p>測試是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com -i ~/.ssh/github</span><br><span class="line">Hi kyomind! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>直接 clone 一個自己的 repo 確認沒問題：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:kyomind/WeaMind.git</span><br><span class="line">Cloning into <span class="string">&#x27;WeaMind&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 193, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (193/193), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (121/121), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 193 (delta 87), reused 161 (delta 58), pack-reused 0 (from 0)</span><br><span class="line">Receiving objects: 100% (193/193), 63.91 KiB | 661.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (87/87), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>大功告成，讚！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/code-and-me.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;不久前，我看完了朋友&lt;a href=&quot;https://kucw.io/about/&quot;&gt;古古&lt;/a&gt;的電子報〈&lt;a href=&quot;https://kucw.io/blog/gcp-free-tier/&quot;&gt;終身免費的 VM 服務！Google Cloud 免費方案分享&lt;/a&gt;〉，介紹 GCP 的 E2 Micro（產品代號：e2-micro）免費 VM。&lt;/p&gt;
&lt;p&gt;簡言之，我們可以在&lt;strong&gt;一定資源額度與條件範圍內&lt;/strong&gt;，免費使用 Google Cloud Platform 上的 Compute Engine 虛擬機器。&lt;/p&gt;
&lt;p&gt;我對此深感興趣，因為它的規格比之前的 F1 Micro 好上一截。&lt;/p&gt;
&lt;p&gt;F1 時代的 RAM 大約只有 0.6 GiB（約 600MB），有開發經驗的都知道，這在某些情況下，用起來會有點捉襟見肘😂&lt;/p&gt;
&lt;p&gt;於是，我也跟著教學開了一台！免費的午餐怎麼能不拿呢？&lt;/p&gt;
&lt;p&gt;附帶一提，對 GCP 不熟的人——比如我，&lt;strong&gt;請一定要照著教學來建立 VM&lt;/strong&gt;，以免設定時有所遺漏，一不小心就被收費。&lt;/p&gt;
&lt;h2 id=&quot;最後一塊拼圖&quot;&gt;&lt;a href=&quot;#最後一塊拼圖&quot; class=&quot;headerlink&quot; title=&quot;最後一塊拼圖&quot;&gt;&lt;/a&gt;最後一塊拼圖&lt;/h2&gt;&lt;p&gt;不過原來的教學只寫到 VM 建立完成為止，對於我們這些後端工程師而言，顯然還有一個很重要的基礎設定沒做——SSH 連線。 &lt;/p&gt;
&lt;p&gt;因此，我想補齊這剩下的部分，包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立自己的 Linux 帳號。&lt;/li&gt;
&lt;li&gt;建立本機與 VM 的 SSH 連線金鑰，並完成連線。&lt;/li&gt;
&lt;li&gt;建立 VM 與 GitHub 的 SSH 連線，且能正常 clone Github 專案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;剛好我在之前文章〈&lt;a href=&quot;/linux-dev-setup/&quot;&gt;Linux 上的 Python 開發環境設定&lt;/a&gt;〉中，略過了「&lt;a href=&quot;/linux-dev-setup/#%E4%B8%80%E3%80%81%E8%A8%AD%E5%AE%9A-SSH-%E9%80%A3%E7%B7%9A&quot;&gt;設定 SSH 連線&lt;/a&gt;」環節——老實說只是因為我懶得寫XD&lt;/p&gt;
&lt;p&gt;但仔細想想，這個流程我自己做了很多次，不如直接寫在文章裡，方便大家回顧。&lt;/p&gt;
&lt;p&gt;雖說是寫給 e2-micro，不過，這些內容適用於任何 Linux VM。&lt;/p&gt;
&lt;p&gt;本文就來補完這些步驟，並講述我對於這個免費 VM 的看法。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Imgur 封鎖台灣 IP，我把圖床搬到 Cloudflare R2</title>
    <link href="https://blog.kyomind.tw/weekly-review-43/"/>
    <id>https://blog.kyomind.tw/weekly-review-43/</id>
    <published>2025-06-07T03:00:10.000Z</published>
    <updated>2025-06-10T00:12:44.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/weekly-review.png">  </p><p>上個月中，我在寫部落格時，突然發現圖片上傳失敗，無論怎麼嘗試都無法成功。</p><p>我的寫作流程是用 VS Code 的 <a href="https://code.visualstudio.com/docs/languages/markdown">Markdown Image</a> 外掛，透過鍵盤快捷鍵，直接把圖片傳到 Imgur 上，這個流程已經持續了好幾年，非常方便、順手。</p><p>但這次踢到鐵板了。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/my-markdown-writing-flow/">Notion + VS Code：我的 Markdown 寫作工作流</a></p></blockquote><p>認真查了一下，才發現原來是 Imgur 大概從 5 月 16 日開始，<strong>無預警地封鎖</strong>了來自台灣的 IP，不再允許台灣使用者上傳圖片。（所幸已上傳的圖片還是可以看）</p><p>PTT 上也有<a href="http://ptt.cc/bbs/Gossiping/M.1747406974.A.003.html">討論</a>。</p><p>可以想見，這是多麼大的衝擊！</p><p>官方既然沒有給出任何理由，這個舉動（封鎖 IP）又顯然是<strong>蓄意</strong>的，那我們可以合理推測——短期內恐怕不會恢復正常了。</p><p>但我的部落格還是要繼續寫啊！只能乖乖尋找替代方案。</p><span id="more"></span><hr><h2 id="尋找替代方案"><a href="#尋找替代方案" class="headerlink" title="尋找替代方案"></a>尋找替代方案</h2><p>Markdown Image 這個外掛其實支援不少圖床服務，其中也包括 AWS <a href="https://aws.amazon.com/tw/s3/">S3</a> 或其他相容於 S3 API 的服務。</p><p>這讓我想到，可以用 <a href="https://www.cloudflare.com/zh-tw/developer-platform/products/r2/">Cloudflare R2</a> 來當圖床（網路上確實有很多人這麼做），畢竟它支援 S3 相容 API，而且最大的優勢是「出口流量」免費，整體成本會比 AWS S3 更低——<strong>基本上就是 0</strong>。</p><h3 id="其他考慮過的選項：GitHub-公開-Repo"><a href="#其他考慮過的選項：GitHub-公開-Repo" class="headerlink" title="其他考慮過的選項：GitHub 公開 Repo"></a>其他考慮過的選項：GitHub 公開 Repo</h3><p>除了 R2，我也考慮過其他可能性，其中一個就是直接使用 GitHub 的公開 Repository 來當圖床。</p><p>這方法在開發者社群間其實蠻流行的，只要把圖片放進一個公開 Repo，再拿原始連結當作圖床的連結使用。</p><p>而且已有許多工具可以自動化（包括上述的 Markdown Image），操作起來頗為簡便，不過畢竟不是 GitHub 官方鼓勵的用途，多少讓人有點不安心。</p><p>和 AI 討論了一下這個方案的可行性，結論是：如果 GitHub 政策哪天改了，整個圖床系統可能會瞬間失效，到時候就得從頭來過，光想就覺得頭皮發麻。</p><p>相較之下，把 Cloudflare R2 當作圖床，則是一種<strong>完全合理且可長期運作</strong>的使用情境，因此我最後還是選擇了 R2。</p><hr><h2 id="認識-Cloudflare"><a href="#認識-Cloudflare" class="headerlink" title="認識 Cloudflare"></a>認識 Cloudflare</h2><p><a href="http://zh.wikipedia.org/zh-tw/Cloudflare">Cloudflare</a> 是一家美國的網路基礎建設公司，主要提供 <a href="https://www.cloudflare.com/zh-tw/learning/cdn/what-is-a-cdn/">CDN</a>（內容傳遞網路）、網站加速、防火牆與 DDoS 防護等服務。</p><p>許多網站背後的流量處理，其實都仰賴他們的基礎設施——包括我的 blog。</p><p>後來他們推出了一系列<strong>開發者導向</strong>的服務，像是 Workers、KV、Pages、R2 等，試圖建立一整套雲端應用的堆疊。</p><p>我本來就對 Cloudflare 的服務很感興趣，常常聽聞他們家的服務如何「佛心」等等，只是一直苦無實際應用的契機。</p><p>這次 Imgur 事件，讓我終於有了理由動手玩看看 R2。</p><blockquote><p>延伸閱讀（Podcast）：<a href="https://pythonhunter.org/episodes/ep46"><strong>Ep 46. 你知道『赛博佛祖』Cloudflare 吗？</strong></a></p></blockquote><hr><h2 id="遷移的大綱與挑戰"><a href="#遷移的大綱與挑戰" class="headerlink" title="遷移的大綱與挑戰"></a>遷移的大綱與挑戰</h2><p>這個圖床遷移實際上花了我好一些功夫才完成，其中的細節頗多，無法在本文詳述。</p><p>但我們可以簡單講講，讓你有個方向。 </p><h3 id="一、域名托管"><a href="#一、域名托管" class="headerlink" title="一、域名托管"></a>一、域名托管</h3><p>我希望圖片網址是以我自己的網域開頭，而不是 Cloudflare 給的預設網址。這樣網址比較乾淨、也容易管理。</p><p>為此，我得先把 DNS 託管給 Cloudflare，接著才能用自定義網域綁定 R2 的 Bucket。</p><p>這個部分花了一點時間摸索，好在有 AI，最後順利完成。</p><p>如此一來，圖片的網址會長得像這樣：</p><blockquote><p><a href="https://img.kyomind.tw/poetry-multi-stage-build.jpg">https://img.kyomind.tw/poetry-multi-stage-build.jpg</a></p></blockquote><p>非常精美！</p><h3 id="二、Cache-Rule-設定"><a href="#二、Cache-Rule-設定" class="headerlink" title="二、Cache Rule 設定"></a>二、Cache Rule 設定</h3><p>事情還沒結束。Imgur 本身是一個專業圖床，所以他們對圖片的<a href="https://www.cloudflare.com/zh-tw/learning/cdn/what-is-caching/">快取</a>做了非常多優化。</p><p>但 Cloudflare R2 是一個<strong>通用</strong>的「<a href="https://aws.amazon.com/tw/what-is/object-storage/">物件儲存</a>」服務，可以用來存放各種資料——不限於圖片。</p><p>所以它不會主動幫你把快取設定成「最適合公開分享圖片」的模式。</p><p>我們得<strong>手動設定快取策略</strong>，透過 Cloudflare 的 <a href="http://developers.cloudflare.com/cache/how-to/cache-rules/">Cache Rules</a> 來提升圖片的載入速度。</p><p>雖然是附加工作（你不做也不影響使用），但這同時讓我更了解 Cloudflare 的服務內容與運作方式。還增進了對 CDN、瀏覽器快取與 Cookie 設定的一些了解。</p><p>感覺收獲良多耶XD！</p><h3 id="三、Markdown-Image-外掛設定"><a href="#三、Markdown-Image-外掛設定" class="headerlink" title="三、Markdown Image 外掛設定"></a>三、Markdown Image 外掛設定</h3><p>完成前兩步後，你便能透過 Cloudflare 官網的 UI 來上傳圖片並<strong>取得網址</strong>：</p><!-- ![](https://img.kyomind.tw/20250607-112306-wr43.png)   --><p><img src="https://img.kyomind.tw/20250607-131952-1312-min.png">  </p><p>但這樣做<strong>非常不方便</strong>！</p><p>所以我們還要設定 Markdown Image，讓它可以成功支援 R2 上傳。</p><p>這過程我進行得不太順利，在 Google + AI 的協作下，花了快兩個小時才成功。（明明應該是很簡單的事😅）</p><p>除了用 Markdown Image（限 VS Code），更多人則是選擇 <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 這個開源工具來上傳圖片——需要加裝 Cloudflare R2 外掛，這方面的資料就多很多！</p><p>但畢竟我是 VS Code 用戶，也用它來寫作，Markdown Image 對我而言，仍是最簡單有效的選擇。</p><hr><h2 id="結語：失之東隅，收之桑榆"><a href="#結語：失之東隅，收之桑榆" class="headerlink" title="結語：失之東隅，收之桑榆"></a>結語：失之東隅，收之桑榆</h2><p>這次的圖床搬遷，原本只是為了解決一個外部服務封鎖問題。沒想到最後竟發展成一次<strong>基礎建設升級</strong>。</p><p>從依賴 Imgur 這類圖床平台，轉為使用 Cloudflare R2 + 自定義網域，我對 blog 圖片的掌控力更高了，未來也比較不怕平台政策突變造成影響。</p><p>R2 作為我接觸 Cloudflare 服務的開端，但不會是最後一步。接下來，我要嘗試他們家的 Pages、Workers、D1 等等。</p><p>想想不禁有點小興奮！</p><p>這是一種專屬於開發者的愉悅，是<a href="https://www.youtube.com/watch?v=bFd3l8Mrhgw">知覺與快樂的螺旋</a>❤️</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/weekly-review.png&quot;&gt;  &lt;/p&gt;
&lt;p&gt;上個月中，我在寫部落格時，突然發現圖片上傳失敗，無論怎麼嘗試都無法成功。&lt;/p&gt;
&lt;p&gt;我的寫作流程是用 VS Code 的 &lt;a href=&quot;https://code.visualstudio.com/docs/languages/markdown&quot;&gt;Markdown Image&lt;/a&gt; 外掛，透過鍵盤快捷鍵，直接把圖片傳到 Imgur 上，這個流程已經持續了好幾年，非常方便、順手。&lt;/p&gt;
&lt;p&gt;但這次踢到鐵板了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/my-markdown-writing-flow/&quot;&gt;Notion + VS Code：我的 Markdown 寫作工作流&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;認真查了一下，才發現原來是 Imgur 大概從 5 月 16 日開始，&lt;strong&gt;無預警地封鎖&lt;/strong&gt;了來自台灣的 IP，不再允許台灣使用者上傳圖片。（所幸已上傳的圖片還是可以看）&lt;/p&gt;
&lt;p&gt;PTT 上也有&lt;a href=&quot;http://ptt.cc/bbs/Gossiping/M.1747406974.A.003.html&quot;&gt;討論&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;可以想見，這是多麼大的衝擊！&lt;/p&gt;
&lt;p&gt;官方既然沒有給出任何理由，這個舉動（封鎖 IP）又顯然是&lt;strong&gt;蓄意&lt;/strong&gt;的，那我們可以合理推測——短期內恐怕不會恢復正常了。&lt;/p&gt;
&lt;p&gt;但我的部落格還是要繼續寫啊！只能乖乖尋找替代方案。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/weekly-review.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Pyright 上手指南：Python 型別檢查的新選擇</title>
    <link href="https://blog.kyomind.tw/pyright/"/>
    <id>https://blog.kyomind.tw/pyright/</id>
    <published>2025-05-30T02:23:51.000Z</published>
    <updated>2025-06-12T06:45:19.058Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/pyright.jpg"></p><p>如〈<a href="/introducing-uv/">Python 套件管理器 uv 介紹——與 Poetry 比較</a>〉一文中所述，最近我開始了一個新的 <a href="https://github.com/kyomind/WeaMind">side project</a>。</p><p>我打算好好利用這個專案，練習並實踐那些，在工作中無法盡情揮灑，或想學習但是還用不到的新技術。包括後端、AI、DevOps。</p><p>為了嘗試不同的開發體驗，從框架到工具都有所更新：</p><ul><li>因應 AI 時代，後端框架改用 FastAPI——輕量，且非同步支援佳。</li><li>套件管理器從 Poetry 換成 uv——快，就是快。</li></ul><p>而型別檢查器——本文的主角，則從 Mypy 改為 Pyright。</p><p>這不是一時興起的炫技選擇，而是一連串有意識的技術決策：選擇那些效能更好、體驗更佳，並且有長期潛力的替代方案。</p><p>Pyright，就是其中之一。</p><hr><h2 id="為什麼需要型別檢查？"><a href="#為什麼需要型別檢查？" class="headerlink" title="為什麼需要型別檢查？"></a>為什麼需要型別檢查？</h2><p>如果你對 Python 的「型別檢查」議題還不熟，歡迎參考我之前寫的「<a href="/series/#Mypy-%E4%B8%89%E9%83%A8%E6%9B%B2">Mypy 三部曲</a>」，其中對 Python type hints 與型別靜態分析工具做了深入說明。</p><p>Type hints 歷經多代 Python 發展至今，已趨於成熟。但它在實際專案中的流行程度，恐怕還不算高。</p><p>甚至直白地說，對部分 Python 開發者而言，可能：</p><ol><li>沒聽過。</li><li>知道但無感。</li></ol><p>這正是本文要努力的目標——讓更多人加入撰寫 Python type hints 的行列🔥😎</p><span id="more"></span><h3 id="型別檢查的價值"><a href="#型別檢查的價值" class="headerlink" title="型別檢查的價值"></a>型別檢查的價值</h3><p>簡言之，型別檢查不是為了「多寫幾行」程式碼，而是為了讓 IDE 幫我們多想一點、早點報錯，減少 runtime 的 trial &amp; error。</p><p>它能比單元測試讓你更早、更容易發現語法錯誤。</p><p>要做到這點——讓 Python 像「<strong>半個靜態語言</strong>」一樣可靠。我們除了需要好好寫 type hints，還要搭配「型別檢查器」（type checker）。</p><p>對我來說，type hints 與型別檢查，已經從「選配」變成「開發必需品」，就像 linter、formatter 一樣。</p><hr><p>在擁抱 type hints 成為開發習慣後，接下來就是要選擇一個好用的「型別檢查器」來幫我們把關。</p><p>除了老牌的 Mypy 之外，有沒有其它選擇呢？</p><p>答案是肯定的，這就是本文接下來要介紹的主角——Pyright。</p><h2 id="Pyright-簡介——為什麼選它？"><a href="#Pyright-簡介——為什麼選它？" class="headerlink" title="Pyright 簡介——為什麼選它？"></a>Pyright 簡介——為什麼選它？</h2><p>如〈<a href="/mypy/">Python type checker：Mypy 介紹</a>〉中所言，Mypy 誕生於 2012 年——這甚至比 Python 正式導入 type hints 還早！</p><p>作為第一個被廣泛採用的型別檢查工具，它為 Python 型別註解奠定了基礎，但同時也背負了早期設計的限制與<strong>歷史包袱</strong>。</p><p>Pyright 誕生於 2019 年，由微軟開發，設計之初即參考 TypeScript 的靜態型別系統，並針對 IDE 整合與效能優化。它更年輕、設計更現代——後發者優勢。</p><p><strong>直接擺脫漫長歲月所累積下來的歷史包袱，就是我選擇 Mypy 以外選項的主要理由。</strong></p><h2 id="Pyright-的三大優勢"><a href="#Pyright-的三大優勢" class="headerlink" title="Pyright 的三大優勢"></a>Pyright 的三大優勢</h2><p>Pyright 有以下三大賣點。</p><h3 id="1-效能極快，檢查大型專案也很輕鬆"><a href="#1-效能極快，檢查大型專案也很輕鬆" class="headerlink" title="1. 效能極快，檢查大型專案也很輕鬆"></a>1. 效能極快，檢查大型專案也很輕鬆</h3><p>Pyright 以<strong>高效能</strong>著稱。</p><blockquote><p>Pyright is a full-featured, standards-based static type checker for Python. It is designed for high performance and can be used with large Python source bases.</p></blockquote><p>使用 TypeScript 實現並運行於 Node.js 上，號稱效能比 Mypy 快 5 倍以上，特別適合大型 Python 專案。</p><h3 id="2-能進行「型別推斷」"><a href="#2-能進行「型別推斷」" class="headerlink" title="2. 能進行「型別推斷」"></a>2. 能進行「型別推斷」</h3><p>Pyright 能對「未型別註解」的程式碼進行<strong>型別推斷（type inference）</strong>，嘗試分析並提供檢查結果。</p><p>這使得它對舊有的程式碼專案（無型別註解）依然有效。</p><p>不過，Pyright 的型別檢查效果在「有明確型別註解時」會<strong>更好</strong>，且對於未註解的程式碼，檢查深度可能<strong>不如</strong>有註解的程式碼嚴謹。</p><h4 id="型別推斷的真正意義"><a href="#型別推斷的真正意義" class="headerlink" title="型別推斷的真正意義"></a>型別推斷的真正意義</h4><p>不過說真的，型別推斷和「好好寫 type hints」的核心精神是<strong>有些違背</strong>的，把它當成一個 <strong>bonus</strong> 就好。</p><p>我認為 type hints 的本質是在實踐 <a href="https://peps.python.org/pep-0020/">Zen of Python</a> 中的：</p><blockquote><p>Explicit is better than implicit</p></blockquote><p>而 Pyright 的型別推斷則是為了兼容舊有程式碼，讓你可以慢慢補上 type hints。</p><h3 id="3-與-VS-Code-的整合幾乎是零設定"><a href="#3-與-VS-Code-的整合幾乎是零設定" class="headerlink" title="3 .與 VS Code 的整合幾乎是零設定"></a>3 .與 VS Code 的整合幾乎是零設定</h3><p>直接內建於 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance">Pylance</a>！</p><p>用 VS Code 寫 Python，一定會裝 Pylance，相當於當年 Windows 綁 IE 的概念XD</p><p>只需要你在 VS Code 的 UI <strong>把型別檢查打開</strong>即可。如下圖：</p><p><img src="https://img.kyomind.tw/p4-min.png"></p><p>這樣就能享受 Pyright 的型別檢查功能，不需要額外設定。</p><hr><p>看完 Pyright 的優勢，接下來和老牌的 Mypy 比較一下。</p><h2 id="Mypy-vs-Pyright-重點比較"><a href="#Mypy-vs-Pyright-重點比較" class="headerlink" title="Mypy vs Pyright 重點比較"></a>Mypy vs Pyright 重點比較</h2><p>兩者雖然都是 Python 的靜態型別檢查工具，但設計哲學與使用體驗有所不同。</p><table><thead><tr><th>特性</th><th><strong>Mypy</strong></th><th><strong>Pyright</strong></th></tr></thead><tbody><tr><td>開發者</td><td>Python 官方支援（部分）</td><td>Microsoft（富爸爸）</td></tr><tr><td>執行速度</td><td>較慢，尤其在大型專案中</td><td>非常快</td></tr><tr><td>Type Checking 嚴格性</td><td>偏保守，有些 type error 不會抓</td><td>更嚴格，預設就更接近 TypeScript 的風格</td></tr><tr><td>支援型別提示（PEP）</td><td>完整支援 PEP 484 等標準</td><td>同樣完整，但對 edge cases 處理得更細緻</td></tr><tr><td>自動化工具整合</td><td>較傳統、整合需要設定</td><td>用 VS Code 即可獲得完整體驗</td></tr><tr><td>錯誤訊息易讀性（<strong>重要</strong>）</td><td>普通，訊息有時不夠具體</td><td>很清楚，並且能指出路徑與具體型別差異</td></tr></tbody></table><p>我認為比較重要的是「執行速度」與「錯誤訊息易讀性」這兩點。</p><hr><p>介紹完背景，現在可以來實作了。</p><h2 id="安裝-Pyright"><a href="#安裝-Pyright" class="headerlink" title="安裝 Pyright"></a>安裝 Pyright</h2><p>如前所述，Pyright 是使用 TypeScript 寫成，所以原則上要使用 npm 來安裝——聽到這裡你可能就不是很想用了XD</p><p>別擔心，Pyright 當然提供了 <a href="https://pypi.org/project/pyright/">Python wrapper 版本</a>，因此也可以直接用 Python 套件方式安裝，推薦使用 uv 並安裝到 dev group：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add --dev pyright</span><br></pre></td></tr></table></figure><p>或者更穩健的做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add --dev pyright[nodejs]</span><br></pre></td></tr></table></figure><p>這個套件實際上是在背後幫你自動安裝了 Pyright 的 Node.js 執行檔與環境，並提供了一個 Python wrapper。</p><p>而上述兩種指令的區別，可以參考<strong>留言區的討論</strong>。</p><h3 id="安裝套件的意義"><a href="#安裝套件的意義" class="headerlink" title="安裝套件的意義"></a>安裝套件的意義</h3><p>裝是裝了，但這個工具基本上<strong>不是給開發者直接使用的</strong>。主要用途在：</p><ol><li>作為 pre-commit 執行檔。</li><li>CI 的環境安裝。</li></ol><p>至於開發時，Pylance 本來就安裝了 Pyright，自然就會顯示錯誤提示。</p><hr><h2 id="關於設定檔"><a href="#關於設定檔" class="headerlink" title="關於設定檔"></a>關於設定檔</h2><p>如同 Mypy 使用 <code>mypy.ini</code>或<code>pyproject.toml</code>。</p><p>你可以透過<code>pyrightconfig.json</code>或<code>pyproject.toml</code>來客製化 Pyright 的檢查行為。</p><p>其中<code>pyrightconfig.json</code>是原生的設定檔格式，而<code>pyproject.toml</code>則是後來才追加的。</p><p>如果專案中同時存在<code>pyrightconfig.json</code>和<code>pyproject.toml</code>，Pyright 會優先使用<code>pyrightconfig.json</code>的設定。</p><p>兩者目前基本上可以視為等價，所以要選擇哪一種格式，主要取決於<strong>你希望 Pyright 的設定檔要獨立還和其它工具放在一起</strong>。</p><p>我暫時選擇獨立，採<code>pyrightconfig.json</code>，<a href="https://github.com/kyomind/WeaMind/blob/main/pyrightconfig.json">內容</a>如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;venvPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;venv&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.venv&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;migrations&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;.venv&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typeCheckingMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此外，一旦 VS Code 偵測到有設定檔存在，預設的檢查等級就會是<code>standard</code>——不管你 VS Code 本來怎麼設定。</p><p>此時最好就明示設定<code>typeCheckingMode</code>，如上所示。</p><h2 id="Pyright-的三種等級"><a href="#Pyright-的三種等級" class="headerlink" title="Pyright 的三種等級"></a>Pyright 的三種等級</h2><p>Pyright 提供三種檢查等級：</p><ul><li><code>basic</code>：適合大部分實務開發，檢查範圍涵蓋常見錯誤，擾動小。</li><li><code>standard</code>：預設值，比 basic 略為嚴格。</li><li><code>strict</code>：嚴格，適合對型別非常重視的專案或團隊。</li></ul><p>想知道這三個等級的<strong>具體區別</strong>，可以參考官方文件的這個<a href="https://microsoft.github.io/pyright/#/configuration?id=diagnostic-settings-defaults">對照表</a>。</p><p>個人認為<code>basic</code>或<code>standard</code>就已足夠，能在不影響開發節奏的情況下<strong>提供良好的型別保障</strong>。</p><hr><h2 id="整合-pre-commit-與注意事項"><a href="#整合-pre-commit-與注意事項" class="headerlink" title="整合 pre-commit 與注意事項"></a>整合 pre-commit 與注意事項</h2><p>我習慣將型別檢查加入 pre-commit hook，確保每次 commit 都經過檢查。</p><p>但是，不可否認，型別檢查器的 hook 設定比 linter、formatter 要來得<strong>講究許多</strong>！</p><p>因為它需要<strong>完整的執行環境</strong>——包括相依套件，不像 linter 只需對程式碼直接進行檢查即可。</p><p>所以設定上會麻煩一些，之前使用 Mypy 就踩過不少坑。</p><p>從結論上來說，把 hook 設定為「本地」會單純得多。適合單人開發的 side project，我的設定如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pyright</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pyright</span> <span class="string">(local</span> <span class="string">venv)</span></span><br><span class="line">      <span class="attr">entry:</span> <span class="string">.venv/bin/pyright</span></span><br><span class="line">      <span class="attr">language:</span> <span class="string">system</span></span><br><span class="line">      <span class="attr">pass_filenames:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">types:</span> [<span class="string">python</span>]</span><br></pre></td></tr></table></figure><p>其中<code>name</code>欄位的名稱可以自訂，<code>id</code>部分因為是 local hook，也能夠自訂。<code>entry</code>的路徑則要看專案虛擬環境所在。</p><p>值得一提的是，上述 hook 設定還得搭配<code>pyrightconfig.json</code>中的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;venvPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;venv&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.venv&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>才能正常執行。</p><h3 id="使用-Remote-Hook"><a href="#使用-Remote-Hook" class="headerlink" title="使用 Remote Hook"></a>使用 Remote Hook</h3><p>用遠端倉庫的 hook 也行，但常見的做法我試不成功，以下設定則可以 work：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/RobertCraigie/pyright-python</span></span><br><span class="line">  <span class="attr">rev:</span> <span class="string">v1.1.401</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pyright</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pyright</span> <span class="string">(via</span> <span class="string">pyright-python)</span></span><br><span class="line">      <span class="attr">pass_filenames:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>但一樣要搭配上述的<code>pyrightconfig.json</code>設定內容。</p><p>或寫成<code>pyproject.toml</code>格式如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.pyright]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">venvPath</span> = <span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="attr">venv</span> = <span class="string">&quot;.venv&quot;</span></span><br></pre></td></tr></table></figure><p>更多細節可參考上述 hook 的 <a href="https://github.com/RobertCraigie/pyright-python">GitHub 主頁</a>介紹。</p><h2 id="CI-設定待補"><a href="#CI-設定待補" class="headerlink" title="CI 設定待補"></a>CI 設定待補</h2><p>目前還沒有實作 CI，之後實作會再補上設定檔。</p><hr><h2 id="結語：新工具、新氣象"><a href="#結語：新工具、新氣象" class="headerlink" title="結語：新工具、新氣象"></a>結語：新工具、新氣象</h2><p>我感覺光是寫完這篇文章，又讓我對 Pyright 的了解增進許多XD</p><p>其實，無論是 Mypy 或 Pyright，還是其它工具。願意寫 type hints、進行型別檢查，就已經是很好的實踐。</p><p>工具只是細節上的分歧，並不影響大局。</p><p>我們最終想成為的，是優秀的開發者——問題解決者。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/pyright.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如〈&lt;a href=&quot;/introducing-uv/&quot;&gt;Python 套件管理器 uv 介紹——與 Poetry 比較&lt;/a&gt;〉一文中所述，最近我開始了一個新的 &lt;a href=&quot;https://github.com/kyomind/WeaMind&quot;&gt;side project&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我打算好好利用這個專案，練習並實踐那些，在工作中無法盡情揮灑，或想學習但是還用不到的新技術。包括後端、AI、DevOps。&lt;/p&gt;
&lt;p&gt;為了嘗試不同的開發體驗，從框架到工具都有所更新：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因應 AI 時代，後端框架改用 FastAPI——輕量，且非同步支援佳。&lt;/li&gt;
&lt;li&gt;套件管理器從 Poetry 換成 uv——快，就是快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而型別檢查器——本文的主角，則從 Mypy 改為 Pyright。&lt;/p&gt;
&lt;p&gt;這不是一時興起的炫技選擇，而是一連串有意識的技術決策：選擇那些效能更好、體驗更佳，並且有長期潛力的替代方案。&lt;/p&gt;
&lt;p&gt;Pyright，就是其中之一。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;為什麼需要型別檢查？&quot;&gt;&lt;a href=&quot;#為什麼需要型別檢查？&quot; class=&quot;headerlink&quot; title=&quot;為什麼需要型別檢查？&quot;&gt;&lt;/a&gt;為什麼需要型別檢查？&lt;/h2&gt;&lt;p&gt;如果你對 Python 的「型別檢查」議題還不熟，歡迎參考我之前寫的「&lt;a href=&quot;/series/#Mypy-%E4%B8%89%E9%83%A8%E6%9B%B2&quot;&gt;Mypy 三部曲&lt;/a&gt;」，其中對 Python type hints 與型別靜態分析工具做了深入說明。&lt;/p&gt;
&lt;p&gt;Type hints 歷經多代 Python 發展至今，已趨於成熟。但它在實際專案中的流行程度，恐怕還不算高。&lt;/p&gt;
&lt;p&gt;甚至直白地說，對部分 Python 開發者而言，可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;沒聽過。&lt;/li&gt;
&lt;li&gt;知道但無感。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這正是本文要努力的目標——讓更多人加入撰寫 Python type hints 的行列🔥😎&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/pyright.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="VS Code" scheme="https://blog.kyomind.tw/tags/VS-Code/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Type Hints" scheme="https://blog.kyomind.tw/tags/Type-Hints/"/>
    
  </entry>
  
  <entry>
    <title>Pocket 替代方案推薦：Raindrop.io 與 Karakeep</title>
    <link href="https://blog.kyomind.tw/pocket-alternatives/"/>
    <id>https://blog.kyomind.tw/pocket-alternatives/</id>
    <published>2025-05-25T16:16:37.000Z</published>
    <updated>2025-05-30T04:05:19.434Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/mind.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>幾天前，我收到了一封來自 Pocket 的電子郵件，開頭是：</p><blockquote><p>感謝您的閱讀：Pocket 向您道別<br>　<br>我們有一些重要訊息要和您分享：幾經思考之後，我們做出了一個艱難的決定，我們的先存再看和內容探索應用程式 Pocket 即將結束服務。</p></blockquote><p>如你所知，知名的「稍後閱讀」服務 Pocket 已經被 Mozilla 正式宣布將於 2025 年 7 月 8 日停止服務。</p><p>對許多知識工作者來說，這是個令人感慨的時刻，Pocket 的結束讓我們再度體認到：<strong>我們存下來的東西真的大多都沒有看</strong>。</p><p>不過，資訊囤積還是要繼續😎，所以本文會介紹兩個，我覺得還不錯的替代品，並說明我的選擇與理由。</p><hr><h2 id="什麼是「稍後閱讀」服務？"><a href="#什麼是「稍後閱讀」服務？" class="headerlink" title="什麼是「稍後閱讀」服務？"></a>什麼是「稍後閱讀」服務？</h2><p>「Read It Later」（稍後閱讀）是一種資訊整理的方式，也是一種使用習慣。</p><p>它允許你在沒心情或沒時間的情況下，把重要但無法即時處理的內容先存起來，日後再回來閱讀。</p><p>對知識工作者或資訊成癮者來說，這類服務是不可或缺的夥伴。</p><p>從食譜、文章到影片，這些被儲存下來的內容，構成了每個人專屬的知識倉庫。</p><span id="more"></span><h2 id="Pocket-的歷史與末路"><a href="#Pocket-的歷史與末路" class="headerlink" title="Pocket 的歷史與末路"></a>Pocket 的歷史與末路</h2><p>Pocket 最初於 2007 年推出，原名 Read It Later，曾是稍後閱讀服務的代表性工具。</p><p>它支援多平台、介面友好，並在 2015 年被 Mozilla 收購後，整合進 Firefox 成為預設功能之一。</p><p>我正是在那時註冊的帳號。</p><p>然而，如果你也是它忠實的用戶，一定會發現，這幾年它的使用體驗在持續下降：進入主頁後，推薦內容越來越多，幾乎形成了一種干擾🤬</p><p>上個月底，Pocket 瀏覽器擴充功能因為不符 Google Chrome 的新標準（Manifest V3）被下架——這對這類服務可是致命打擊。</p><p>這些變動，讓我開始認真思考替代方案。</p><hr><p>我詳細考慮過的方案有兩個，以下是它們的簡介。</p><h2 id="Raindrop-io：穩定、清爽、夠用就好"><a href="#Raindrop-io：穩定、清爽、夠用就好" class="headerlink" title="Raindrop.io：穩定、清爽、夠用就好"></a>Raindrop.io：穩定、清爽、夠用就好</h2><p><a href="https://raindrop.io/">Raindrop.io</a> 是我最終選擇的替代工具。它的介面簡潔、設計現代，重點是沒有多餘的推薦或雜訊，讓我可以專注在自己儲存的內容上。</p><p>它也有<a href="https://raindrop.io/pro/buy">付費功能</a>，可以月付或年付，年費約 30 美元。不算貴。</p><h3 id="稍後閱讀工具的基本要求"><a href="#稍後閱讀工具的基本要求" class="headerlink" title="稍後閱讀工具的基本要求"></a>稍後閱讀工具的基本要求</h3><p>其實，對於這類服務最重要的功能要求，不外乎以下兩者：</p><ol><li>一定要有瀏覽器外掛。</li><li>一定要有手機 APP。</li></ol><p>兩者的重點都在於——讓你可以隨時儲存資訊！</p><p>滿足這些要件之後，才需要討論資訊主頁設計得如何、是否簡潔等等。</p><p><img src="https://img.kyomind.tw/pocket-alternatives.png" alt="Raindrop.io 主頁"><span class="cap">Raindrop.io 主頁</span></p><hr><h2 id="Karakeep：開源、自主、需要投入"><a href="#Karakeep：開源、自主、需要投入" class="headerlink" title="Karakeep：開源、自主、需要投入"></a>Karakeep：開源、自主、需要投入</h2><p><a href="http://karakeep.app/">Karakeep</a> 是另一個替代選項，走「<strong>自己掌控</strong>」路線。它是一個開源稍後閱讀工具，讓你可以自行部署。</p><p>上述的要件 Karakeep 也全部滿足：瀏覽器外掛、手機 app。</p><p>對於喜歡研究技術、重視<strong>資料主權</strong>的人來說，它是一個非常有吸引力的方案。不過，這也意味著你得自己架設伺服器、維護系統與備份資料。</p><p>本來我已經開始著手準備 Karakeep 的 Docker 容器了。但後來想想，我使用這類服務的需求，就真的只是當作「<strong>資訊倉庫</strong>」而已——簡單才是王道。</p><p>所以我最終選擇了 Raindrop.io，因為它「剛剛好」——多一事不如少一事。</p><hr><h2 id="AI-摧毀了「稍後閱讀」嗎？"><a href="#AI-摧毀了「稍後閱讀」嗎？" class="headerlink" title="AI 摧毀了「稍後閱讀」嗎？"></a>AI 摧毀了「稍後閱讀」嗎？</h2><p>部分新聞提到：</p><blockquote><p>Mozilla 表示，關閉 Pocket，是因為「人們儲存與閱讀網路內容的方式已經改變」。</p></blockquote><p>究竟是什麼樣的改變呢？</p><p>有一說是 AI 帶來的影響，我乍聽還有點不解，心想：「兩者有關係嗎？」</p><p>對此，ChatGPT 是這麼解釋的：</p><blockquote><p><strong>用戶心態改變</strong>：人們變得更不願「儲存之後回來看」，因為他們潛意識相信「到時我可以問 AI 就好」。這不是功能問題，是<strong>動機被削弱</strong>。</p></blockquote><p>哈哈，好像有幾分道理！</p><p>但不管怎麼說，可以確信的是——我依舊需要這類服務。</p><hr><h2 id="小結：我對「稍後閱讀」服務的基本態度"><a href="#小結：我對「稍後閱讀」服務的基本態度" class="headerlink" title="小結：我對「稍後閱讀」服務的基本態度"></a>小結：我對「稍後閱讀」服務的基本態度</h2><p>我覺得稍後閱讀這類服務，不值得把它作為一個資訊整理或吸收的重心——所以我鮮少在這些服務中，為儲存的內容分類、做筆記。</p><p>把它視為一個隨手可得的工具，最好可以被替代。</p><p>不可否認，在 AI 時代，資訊囤積的價值正<strong>進一步下降</strong>。甚至可以說，資訊或知識越來越不值錢了。</p><p>真正值錢的還是個人的經驗和觀點，而這些並不是「稍後閱讀」服務能為你提供的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/mind.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;幾天前，我收到了一封來自 Pocket 的電子郵件，開頭是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感謝您的閱讀：Pocket 向您道別&lt;br&gt;　&lt;br&gt;我們有一些重要訊息要和您分享：幾經思考之後，我們做出了一個艱難的決定，我們的先存再看和內容探索應用程式 Pocket 即將結束服務。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如你所知，知名的「稍後閱讀」服務 Pocket 已經被 Mozilla 正式宣布將於 2025 年 7 月 8 日停止服務。&lt;/p&gt;
&lt;p&gt;對許多知識工作者來說，這是個令人感慨的時刻，Pocket 的結束讓我們再度體認到：&lt;strong&gt;我們存下來的東西真的大多都沒有看&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過，資訊囤積還是要繼續😎，所以本文會介紹兩個，我覺得還不錯的替代品，並說明我的選擇與理由。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什麼是「稍後閱讀」服務？&quot;&gt;&lt;a href=&quot;#什麼是「稍後閱讀」服務？&quot; class=&quot;headerlink&quot; title=&quot;什麼是「稍後閱讀」服務？&quot;&gt;&lt;/a&gt;什麼是「稍後閱讀」服務？&lt;/h2&gt;&lt;p&gt;「Read It Later」（稍後閱讀）是一種資訊整理的方式，也是一種使用習慣。&lt;/p&gt;
&lt;p&gt;它允許你在沒心情或沒時間的情況下，把重要但無法即時處理的內容先存起來，日後再回來閱讀。&lt;/p&gt;
&lt;p&gt;對知識工作者或資訊成癮者來說，這類服務是不可或缺的夥伴。&lt;/p&gt;
&lt;p&gt;從食譜、文章到影片，這些被儲存下來的內容，構成了每個人專屬的知識倉庫。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/mind.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="學習" scheme="https://blog.kyomind.tw/tags/%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
  <entry>
    <title>OpenRouter 上的 5 個「免費」模型推薦</title>
    <link href="https://blog.kyomind.tw/openrouter-free-models/"/>
    <id>https://blog.kyomind.tw/openrouter-free-models/</id>
    <published>2025-05-24T16:23:24.000Z</published>
    <updated>2025-06-06T07:01:03.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/openrouter-free-models.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><blockquote><p><code>2025/06/04</code>: 更新「<a href="#%E5%B0%8F%E7%B5%90%EF%BC%9A1000-%E6%AC%A1%E8%AB%8B%E6%B1%82%E7%9A%84%E6%9C%80%E4%BD%B3%E5%A0%B4%E6%99%AF">1000 次請求的最佳場景</a>」落段。並感謝〈<a href="https://ihower.tw/blog/archives/12744">愛好 AI Engineer 電子報 🚀 模型上下文協定 MCP 應用開發 #27</a>〉的推薦，本期的含金量極高，除了 MCP 最新進展，還討論 AI 應用開發的一些「<strong>哲學</strong>」（ex：框架是必要的嗎？）議題。推薦必讀！</p></blockquote><p>在這個 AI 應用百花齊放的時代，我們可以透過各種方式來接觸 AI。</p><p>可以使用線上服務——比如 ChatGPT，也可以直接使用 LLM API 來更加客製化自己的需求。</p><p>最近我開始使用 OpenRouter 這個平台上的 API 服務，對於 AI 開發人員或 LLM 重度用戶，想必不陌生。</p><p>本文介紹 OpenRouter 上的 5 個免費模型，幫助你快速上手並選擇合適的模型。</p><hr><h2 id="OpenRouter-是什麼？"><a href="#OpenRouter-是什麼？" class="headerlink" title="OpenRouter 是什麼？"></a>OpenRouter 是什麼？</h2><p><a href="https://openrouter.ai/">OpenRouter</a> 是一個<strong>語言模型的 API 聚合平台服務</strong>，讓使用者可以透過單一介面，就能夠付費存取多家公司的大語言模型，包括 OpenAI、Anthropic、Google 等大公司的 LLM API 產品。</p><p>而且像 <a href="https://zh.wikipedia.org/zh-tw/LLaMA">LLaMa</a>、<a href="https://zh.wikipedia.org/zh-tw/%E6%B7%B1%E5%BA%A6%E6%B1%82%E7%B4%A2">DeepSeek</a> 這類開源模型，你想要使用的話，除了在本地跑之外，也可以透過 OpenRouter 提供的 API 來使用。</p><p>好處就是你不用擁有機器、顯卡，就能體驗這些開源模型的能力，而且價格相對於閉源模型，通常有一定的競爭力。</p><p>總之，OpenRouter 不僅為開發者提供了統一的介面，更讓非技術出身的用戶也能輕鬆使用 AI。</p><span id="more"></span><h3 id="白吃的午餐"><a href="#白吃的午餐" class="headerlink" title="白吃的午餐"></a>白吃的午餐</h3><p>更吸引我的是，它上面提供不少「免費」模型，只要在搜尋欄輸入「free」，即可找到供免費使用的模型。</p><p>這不禁引發了我的興趣！因為我最近在試用 VS Code <a href="https://github.com/cline/cline">Cline</a> 這個 AI 開發外掛，發現它真的非常消耗 Token。</p><p>叫我付錢用 API——我不願意XD，太貴了。</p><p>剛好可以試試 OpenRouter 上的免費模型！順便寫下這篇心得。</p><hr><p>在推薦模型之前，我們先來介紹一下在 OpenRouter <strong>使用免費模型的規則與限制</strong>。</p><h2 id="免費模型與使用限制"><a href="#免費模型與使用限制" class="headerlink" title="免費模型與使用限制"></a>免費模型與使用限制</h2><p>就在上個月，OpenRouter 調整了免費額度與規則，如下。</p><h3 id="具體限制"><a href="#具體限制" class="headerlink" title="具體限制"></a>具體限制</h3><ul><li><strong>未儲值或餘額不足 10 美元用戶：每日 50 次請求</strong>。（以前是 200 次）</li><li><strong>帳戶餘額在 10 美元以上用戶</strong>：每日請求從以前的 200 次提高至 <strong>1000 次</strong>。</li><li><strong>每分鐘 20 次請求</strong>：不論哪種用戶，免費模型維持每分鐘最多 20 次請求的限制，確保不會因短時間內大量請求導致伺服器超載。</li><li><strong>影響範圍</strong>：此限制適用於所有免費模型。</li></ul><p>這個變動顯然是逼你要儲值啊！</p><p>不過說真的，對於有儲值 10 美元以上的人，一天高達 1000 次的免費模型請求額度，我個人覺得還是蠻大方的——所以我儲值了XD</p><p><img src="https://img.kyomind.tw/openrouter-free-models-1.png"></p><hr><p>有了 1000 次的免費請求後，如何運用這些資源是一個值得思考的問題，否則空有額度卻無處使用也是白搭。</p><h2 id="三個常見的應用場景"><a href="#三個常見的應用場景" class="headerlink" title="三個常見的應用場景"></a>三個常見的應用場景</h2><p>以下 3 個應用場景可供讀者參考，我自己其實也還沒有找到真正的殺手級應用。</p><h3 id="沉浸式翻譯外掛"><a href="#沉浸式翻譯外掛" class="headerlink" title="沉浸式翻譯外掛"></a>沉浸式翻譯外掛</h3><p>在 Chrome 使用「<a href="https://immersivetranslate.com/zh-TW/">沉浸式翻譯</a>」外掛，搭配 OpenRouter 提供的翻譯引擎，在瀏覽英文網頁時獲得更流暢、自然的翻譯體驗。</p><h3 id="GUI-工具整合"><a href="#GUI-工具整合" class="headerlink" title="GUI 工具整合"></a>GUI 工具整合</h3><p>指的就是那些讓你自己接 API 的軟體或服務，例如 <a href="https://anythingllm.com/">AnythingLLM</a>，可以將本地的文件轉成向量資料，並搭配語言模型進行 <a href="https://aws.amazon.com/tw/what-is/retrieval-augmented-generation/">RAG</a> 問答。</p><p>或者像 <a href="https://github.com/lobehub/lobe-chat">LoboChat</a>、<a href="https://github.com/wandb/openui">OpenUI</a> 這些 Web 聊天工具，可以自訂模型來源為 OpenRouter，輕鬆切換不同模型、快速測試。</p><p>這裡提到的工具基本上都是開源的，即<strong>不用花錢</strong>。</p><h3 id="VS-Code-Cline-外掛"><a href="#VS-Code-Cline-外掛" class="headerlink" title="VS Code Cline 外掛"></a>VS Code Cline 外掛</h3><p>如前所述，VS Code 擴充套件 <a href="https://github.com/cline/cline">Cline</a> 有支援 OpenRouter，能直接在編輯器中呼叫 LLM 協助寫程式，是個實用的開發助手。</p><p>我也是因為它才開始使用 OpenRouter 的，不過對我而言這只是實驗性質，我日常開發還是使用 GitHub Copilot 為主。</p><p>雖然支援 OpenRouter 的 VS Code 外掛或 IDE 不少，但<strong>不一定都支援免費模型</strong>。如果你是為了寫程式而儲值，記得先研究一下工具是否支援免費模型。</p><h3 id="小結：1000-次請求的最佳場景"><a href="#小結：1000-次請求的最佳場景" class="headerlink" title="小結：1000 次請求的最佳場景"></a>小結：1000 次請求的最佳場景</h3><p>我們可以仔細思考一下，如何<strong>充分利用</strong> OpenRouter 的 1000 次免費請求。</p><p>最佳的場景無疑是——<strong>「單次」請求需要使用「大量」Token 的情況</strong>。</p><p>因為它是算「<strong>次數</strong>」而不是「Token 總量」，所以如果你每次請求都需要輸入 1 萬個 Token 或更多，那麼這 1000 次請求就<strong>相當於 1000 萬個 Token 以上</strong>。</p><p>一天 1000 萬免費 Token？Amazing！</p><hr><h2 id="模型評比網站推薦：LiveBench"><a href="#模型評比網站推薦：LiveBench" class="headerlink" title="模型評比網站推薦：LiveBench"></a>模型評比網站推薦：LiveBench</h2><p>新模型發表時，常常會強調自己跑分多高、表現多亮眼，而且我們在評估模型性能時，的確也需要一定的<strong>客觀指標</strong>——是否「真的」客觀則是另一個議題。</p><p>常見的跑分網站很多，有時候模型會針對這類網站進行最佳化，這相當於<strong>作弊</strong>。</p><p>因此，我個人主要參考 <a href="https://livebench.ai/#/">LiveBench</a> 這個網站，透過它來了解新模型的戰鬥力！</p><p>這個網站好在哪，為什麼值得相信，請看 AI 的解說：</p><blockquote><p>LiveBench 是一個高度可信的 LLM 基準測試平台，因為它通過動態更新的問題、客觀的自動化評分、學術與業界的支持、透明的數據公開以及與其他基準的公正比較，有效改善數據污染和評審偏見的問題。它不僅適用於研究人員評估模型性能，也為企業選擇合適 LLM 提供可靠參考。</p></blockquote><p>不用說，我個人在看跑分的時候，會特別重視 LLM 在軟體開發的能力。</p><hr><h2 id="5-款值得一試的免費模型"><a href="#5-款值得一試的免費模型" class="headerlink" title="5 款值得一試的免費模型"></a>5 款值得一試的免費模型</h2><p>接下來就簡單介紹一下，這些免費模型之中，我覺得值得使用的 5 個。你也可以參考上述網站自行評估。 </p><p>必須強調，「<strong>中文能力</strong>」是我挑選模型的一大指標，所以像 Llama 這種中文不友善的，我連試都不想試。</p><p>考慮到這點，中國公司所開發的模型在這方面肯定有它的優勢。 </p><h3 id="1-DeepSeek-R1"><a href="#1-DeepSeek-R1" class="headerlink" title="1. DeepSeek R1"></a>1. DeepSeek R1</h3><blockquote><p><code>2025/05/29</code>: 更新模型連結為 0528 版本。</p></blockquote><p><a href="https://openrouter.ai/deepseek/deepseek-r1-0528:free">▶️ DeepSeek: R1 0528 (free)</a></p><p>這個應該不用多說，某種程度上可以說是<strong>改變世界的開源模型</strong>。</p><p>開源模型在它誕生之前，很大程度上被視為一種<strong>玩具</strong>，但在它之後，大家發現開源模型是一個重要的發展方向，而且性能可以與閉源模型一較高下。</p><p>R1 絕對是跨時代的作品，而且到了現在，表現依舊名列前茅。</p><p>實際上 R1 是由 V3 的架構改進而來，只是 R1 在訓練上特別加強了推理能力。</p><h3 id="2-DeepSeek-V3"><a href="#2-DeepSeek-V3" class="headerlink" title="2. DeepSeek V3"></a>2. DeepSeek V3</h3><p><a href="https://openrouter.ai/deepseek/deepseek-chat-v3-0324:free">▶️ DeepSeek: DeepSeek V3 0324 (free)</a></p><p>0324 又稱為 DeepSeek V3.1，是 DeepSeek 在 2025 年 3 月 24 日發表的<strong>更新</strong>版本。</p><p>DeepSeek V3 屬於「<strong>非推理</strong>」模型，而且寫程式能力頗受好評，是 OpenRouter 網站上被大量工具用來寫程式的頂尖模型之一。</p><p>在所有開源模型中，用量基本上穩居<a href="https://openrouter.ai/rankings">第一名</a>。</p><p>不過要特別注意：OpenRouter 上的這個免費版本，在 Input Token 超過 25K 之後，可能會出現回答時「<strong>不斷自我重複</strong>」的問題——我就遇到過。</p><h3 id="3-Qwen3-32B"><a href="#3-Qwen3-32B" class="headerlink" title="3. Qwen3-32B"></a>3. Qwen3-32B</h3><p><a href="https://openrouter.ai/qwen/qwen3-32b:free">▶️ Qwen: Qwen3 32B (free)</a></p><p>阿里巴巴的通義千問系列，英文是 Qwen。</p><p>Qwen3 這系列的模型非常新，發表還未滿一個月，而且全都是推理與非推理的<strong>混合型模型</strong>。可參考官方 <a href="https://qwenlm.github.io/blog/qwen3/">blog 介紹</a>，值得一讀。</p><p>它們本質上仍是<strong>推理模型</strong>，但可以透過提示詞「<code>/no_think</code>」來<strong>關閉</strong>它的推理能力，這樣你就不用等待它在回答過程中的「自言自語」了。</p><p>而 Qwen3-32B 是「緊湊」模型中，規模最大的那個，能力相當不錯。</p><p>基本上擁有 32 GB 統一記憶體的 Mac 就能跑起來，接 API 的好處則是——輸出更快！</p><h3 id="4-Qwen3-235B-A22B"><a href="#4-Qwen3-235B-A22B" class="headerlink" title="4. Qwen3-235B-A22B"></a>4. Qwen3-235B-A22B</h3><p><a href="https://openrouter.ai/qwen/qwen3-235b-a22b:free">▶️ Qwen: Qwen3 235B A22B (free)</a></p><p>除了「混合推理」這個特色之外，Qwen3 系列還包含了兩個 MoE 模型（<a href="https://zh.wikipedia.org/zh-tw/%E6%B7%B7%E5%90%88%E4%B8%93%E5%AE%B6%E6%A8%A1%E5%9E%8B">混合專家模型</a>）：</p><ol><li>Qwen3-30B-A3B</li><li>Qwen3-235B-A22B</li></ol><p>這類模型的特色就是<strong>輸出結果（回答）時，只需要動用到一部分的參數</strong>，所以計算速度特別快——因為計算量少很多。</p><p>以 Qwen3-30B-A3B 為例，作為一個 30B 模型，它的「聰明程度」是 30B 等級的，但輸出速度卻像 3B 的小模型這麼快。</p><p>附帶一提，DeepSeek R1、V3 也是 MoE 模型（兩者系出同源），只是通常不會特別強調。</p><p>Qwen3-235B-A22B 這樣超過 200B 的規模，很難在消費級硬體中跑起它，所以 API 更顯得有價值。</p><h3 id="5-Google-Gemma-3-27B"><a href="#5-Google-Gemma-3-27B" class="headerlink" title="5. Google Gemma 3 27B"></a>5. Google Gemma 3 27B</h3><p><a href="https://openrouter.ai/google/gemma-3-27b-it:free">▶️ Google: Gemma 3 27B (free)</a></p><p>Google 推出的開源模型，個人評價很高，我曾經在〈<a href="https://kyomind.notion.site/17-Gemma-3-Vibe-Coding-1c66a92a98a680fe94cfde64ccb96719">訂戶限定 17：強大的 Gemma 3、上班前夕的花蓮之旅、Vibe Coding</a>〉中大力推薦過。</p><p>雖然跑分比不上前述四個模型——畢竟它的規模相對較小，但繁體中文能力出色，適合對話、文章創作類的應用。</p><p>更難能可貴的是——它還有「<strong>視覺</strong>」能力。</p><blockquote><p>備註：Google 在 OpenRouter 上還有另一款免費模型 <a href="https://openrouter.ai/google/gemini-2.0-flash-exp:free">Google: Gemini 2.0 Flash Experimental (free)</a>，屬於閉源模型，能力自然不在話下。但流量高峰時段常會出現 HTTP 429（限流），故不列入推薦名單。</p></blockquote><hr><h2 id="表格比較"><a href="#表格比較" class="headerlink" title="表格比較"></a>表格比較</h2><p>以下是這五個模型的簡易比較表，提供給讀者快速參考：</p><table><thead><tr><th>模型名稱</th><th>開發者</th><th>模型規模</th><th>特點摘要</th></tr></thead><tbody><tr><td>DeepSeek R1</td><td>DeepSeek</td><td>超大型（MoE）</td><td>改變時代的開源推理型模型，號稱比美 OpenAI o1</td></tr><tr><td>DeepSeek V3</td><td>DeepSeek</td><td>超大型（MoE）</td><td>非推理型，程式能力強，社群使用率第一</td></tr><tr><td>Qwen3-32B</td><td>阿里巴巴</td><td>中型</td><td>混合推理模型，可以使用「非推理」模式</td></tr><tr><td>Qwen3-235B-A22B</td><td>阿里巴巴</td><td>超大型（MoE）</td><td>混合專家模型，平衡了性能與產出速度</td></tr><tr><td>Gemma 3 27B</td><td>Google</td><td>中型</td><td>多語言能力強，尤其是台灣繁體中文，適合對話與創作</td></tr></tbody></table><hr><h2 id="結語：百花齊放的時代"><a href="#結語：百花齊放的時代" class="headerlink" title="結語：百花齊放的時代"></a>結語：百花齊放的時代</h2><p>綜上所述，這五款模型在生成品質、穩定性與實用性之間取得了較好的平衡。</p><p>無論寫程式、翻譯，還是想打造自己的 AI 工具，這些模型都能成為你起步的好夥伴。</p><p>希望這篇文章能幫助你快速上手 OpenRouter，並找到適合自己的免費模型。</p><p>讓我們繼續在 AI 的浪潮上，乘風破浪吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/openrouter-free-models.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;2025/06/04&lt;/code&gt;: 更新「&lt;a href=&quot;#%E5%B0%8F%E7%B5%90%EF%BC%9A1000-%E6%AC%A1%E8%AB%8B%E6%B1%82%E7%9A%84%E6%9C%80%E4%BD%B3%E5%A0%B4%E6%99%AF&quot;&gt;1000 次請求的最佳場景&lt;/a&gt;」落段。並感謝〈&lt;a href=&quot;https://ihower.tw/blog/archives/12744&quot;&gt;愛好 AI Engineer 電子報 🚀 模型上下文協定 MCP 應用開發 #27&lt;/a&gt;〉的推薦，本期的含金量極高，除了 MCP 最新進展，還討論 AI 應用開發的一些「&lt;strong&gt;哲學&lt;/strong&gt;」（ex：框架是必要的嗎？）議題。推薦必讀！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在這個 AI 應用百花齊放的時代，我們可以透過各種方式來接觸 AI。&lt;/p&gt;
&lt;p&gt;可以使用線上服務——比如 ChatGPT，也可以直接使用 LLM API 來更加客製化自己的需求。&lt;/p&gt;
&lt;p&gt;最近我開始使用 OpenRouter 這個平台上的 API 服務，對於 AI 開發人員或 LLM 重度用戶，想必不陌生。&lt;/p&gt;
&lt;p&gt;本文介紹 OpenRouter 上的 5 個免費模型，幫助你快速上手並選擇合適的模型。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OpenRouter-是什麼？&quot;&gt;&lt;a href=&quot;#OpenRouter-是什麼？&quot; class=&quot;headerlink&quot; title=&quot;OpenRouter 是什麼？&quot;&gt;&lt;/a&gt;OpenRouter 是什麼？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://openrouter.ai/&quot;&gt;OpenRouter&lt;/a&gt; 是一個&lt;strong&gt;語言模型的 API 聚合平台服務&lt;/strong&gt;，讓使用者可以透過單一介面，就能夠付費存取多家公司的大語言模型，包括 OpenAI、Anthropic、Google 等大公司的 LLM API 產品。&lt;/p&gt;
&lt;p&gt;而且像 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/LLaMA&quot;&gt;LLaMa&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E6%B7%B1%E5%BA%A6%E6%B1%82%E7%B4%A2&quot;&gt;DeepSeek&lt;/a&gt; 這類開源模型，你想要使用的話，除了在本地跑之外，也可以透過 OpenRouter 提供的 API 來使用。&lt;/p&gt;
&lt;p&gt;好處就是你不用擁有機器、顯卡，就能體驗這些開源模型的能力，而且價格相對於閉源模型，通常有一定的競爭力。&lt;/p&gt;
&lt;p&gt;總之，OpenRouter 不僅為開發者提供了統一的介面，更讓非技術出身的用戶也能輕鬆使用 AI。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/openrouter-free-models.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</title>
    <link href="https://blog.kyomind.tw/poetry-multi-stage-build/"/>
    <id>https://blog.kyomind.tw/poetry-multi-stage-build/</id>
    <published>2025-05-24T02:36:33.000Z</published>
    <updated>2025-05-25T02:27:16.694Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/poetry-multi-stage-build.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>最近都在為〈<a href="/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a>〉一文進行「減肥」，讓它更容易閱讀、回顧。</p><p>除此之外，是時候為「<a href="/series/#Python-Poetry-%E4%B8%89%E9%83%A8%E6%9B%B2">Python Poetry</a>」這個系列畫下句點了——而本文就是最後一塊拼圖！</p><p>我曾在前文中提到，為什麼不在 Docker 容器中使用 Poetry。主要原因是：</p><blockquote><p>啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會<strong>增加新的耦合與依賴</strong>，需要更細緻的管理。</p></blockquote><p>但這樣的限制，其實可以透過 Docker 的 <strong>multi-stage build</strong> 解決。</p><p>本文將從實務角度出發，介紹如何使用 multi-stage build，在 Docker 中整合 Poetry。</p><p>讓你既能享有 Poetry 的套件管理優勢，又不會對部署流程增加額外負擔。</p><h3 id="系列：Python-Poetry-三部曲"><a href="#系列：Python-Poetry-三部曲" class="headerlink" title="系列：Python Poetry 三部曲"></a>系列：Python Poetry 三部曲</h3><blockquote><ol><li><a href="/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a></li><li><a href="/poetry-pyenv-practical-tips/">Poetry + pyenv 教學：常用指令與注意事項</a></li><li><strong>Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</strong></li></ol></blockquote><p>我們開始吧！</p><span id="more"></span><hr><h2 id="舊有做法：requirements-txt-及其限制"><a href="#舊有做法：requirements-txt-及其限制" class="headerlink" title="舊有做法：requirements.txt 及其限制"></a>舊有做法：requirements.txt 及其限制</h2><p>在過去的容器建構流程中，我們多半會使用<code>requirements.txt</code>來安裝 Python 套件、建立容器中的專案虛擬環境。</p><p>這是因為 Python 的官方 image <strong>已經內建 pip</strong>，我們可以在 Docker（Dockerfile）直接透過下列指令安裝相依套件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure><p>這種做法最大的優勢就是<strong>方便</strong>。</p><p>然而仔細想想，我們在開發階段使用 Poetry，部署時卻用 pip，這樣的流程會產生一個「斷點」。</p><p>我們必須從 Poetry 匯出一份與<code>poetry.lock</code>對應的<code>requirements.txt</code>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">export</span> -f requirements.txt --without-hashes -o requirements.txt</span><br></pre></td></tr></table></figure><p>這樣做看似簡單、直觀，但經驗告訴我，在更新<code>poetry.lock</code>時，<strong>常常會忘記同步</strong>到<code>requirements.txt</code>。所以 uv 還專門提供了一個 pre-commit hook 來自動化同步。</p><p>退一步來說，<code>export</code>指令產出的結果，其實和 pip 也<strong>不是 100% 相容</strong>，如果遇到相容問題，將會使得<code>requirements.txt</code>無法如預期安裝。</p><blockquote><p>真麻煩！</p></blockquote><h2 id="為什麼不直接在-Docker-image-中安裝-Poetry？"><a href="#為什麼不直接在-Docker-image-中安裝-Poetry？" class="headerlink" title="為什麼不直接在 Docker image 中安裝 Poetry？"></a>為什麼不直接在 Docker image 中安裝 Poetry？</h2><p>我們已經知道使用<code>requirements.txt</code>的方式有其限制，那是否可以直接在 Docker 中安裝 Poetry，來避免 export 同步的麻煩呢？</p><p>這似乎是一個<strong>簡單粗暴</strong>的解法，但除了開頭說的「增加新的耦合與依賴」問題外，這樣做還會導致<strong>另一個棘手問題</strong>——<strong>image 會變得過於龐大</strong>。</p><p>因為我們必須額外安裝 Poetry 及其所有相依套件（如 curl、build tools 等），這些工具在部署時其實並不需要。</p><p>結果是：</p><ul><li>不必要的工具進入部署環境，增加潛在維護成本。</li><li>Docker image 體積變得難以控管。</li></ul><p>而這正是 Docker multi-stage build 要解決的關鍵痛點。</p><p>它讓我們可以在前一階段「<strong>用完即丟</strong>」，只保留執行需要的檔案與相依套件，而非將整套開發工具都一併打包進去。</p><hr><h2 id="Multi-stage-build-是什麼？為什麼重要？"><a href="#Multi-stage-build-是什麼？為什麼重要？" class="headerlink" title="Multi-stage build 是什麼？為什麼重要？"></a>Multi-stage build 是什麼？為什麼重要？</h2><p>Docker 的 multi-stage build 允許我們在一個 Dockerfile 中定義<strong>多個建構階段</strong>。</p><p>透過這種方式，我們可以在前一階段中安裝與建構需要的工具（例如 Poetry 與依賴套件），然後<strong>在後續階段捨棄它們</strong>，只留下必要的執行檔與依賴，大幅減少最終 image 的體積與耦合程度。</p><p>對於使用 Poetry 管理套件的 Python 專案而言，這是一種相對理想的建構策略：</p><ol><li>只在第一階段使用 Poetry，並安裝專案所需的套件。</li><li>第二階段則不再需要 Poetry——<strong>留下建好的 Python 虛擬環境已足</strong>。</li></ol><h2 id="Multi-stage-build-的常見應用場景"><a href="#Multi-stage-build-的常見應用場景" class="headerlink" title="Multi-stage build 的常見應用場景"></a>Multi-stage build 的常見應用場景</h2><p>Multi-stage build 適用於多種開發與部署情境，以下是幾個常見的應用場景。</p><h3 id="1-編譯型語言的建構階段與執行階段分離"><a href="#1-編譯型語言的建構階段與執行階段分離" class="headerlink" title="1. 編譯型語言的建構階段與執行階段分離"></a>1. 編譯型語言的建構階段與執行階段分離</h3><ul><li>在 Go、Rust、C++ 等語言中，編譯階段通常需要安裝大量工具與編譯器。</li><li>透過 multi-stage build，可以在第一階段完成編譯，第二階段僅保留編譯後的 binary，讓 image 更精簡。</li></ul><p>這部分可參考<a href="https://kucw.io/about/">古古</a>的〈<a href="https://kucw.io/blog/springboot-docker-image/">為 Spring Boot 生成 Docker image</a>〉，對編譯型語言（文中為 Java）的 multi-stage build 應用，有著更加詳細的講解。</p><h3 id="2-執行環境的依賴管理分離"><a href="#2-執行環境的依賴管理分離" class="headerlink" title="2. 執行環境的依賴管理分離"></a>2. 執行環境的依賴管理分離</h3><ul><li>Poetry 就是典型範例：建構階段需要 Poetry 處理 dependencies，執行階段只需保留 site-packages 即可。</li><li>pipenv、npm&#x2F;yarn（JS 世界）也可套用類似概念，第一階段建構，第二階段保留 node_modules 或 dist。</li></ul><h3 id="3-CI-CD-中的環境控制與-image-輕量化"><a href="#3-CI-CD-中的環境控制與-image-輕量化" class="headerlink" title="3. CI&#x2F;CD 中的環境控制與 image 輕量化"></a>3. CI&#x2F;CD 中的環境控制與 image 輕量化</h3><ul><li>有些 CI pipeline 在建構階段需要額外工具（如 linters、testing frameworks），但最終部署不需要。</li><li>Multi-stage 可讓這些工具不進入最終 image，保持部署清爽。</li></ul><hr><h2 id="Dockerfile-範例與解說"><a href="#Dockerfile-範例與解說" class="headerlink" title="Dockerfile 範例與解說"></a>Dockerfile 範例與解說</h2><p>以下範例中，我們將整個建構流程分為兩個階段：</p><ul><li><strong>第一階段（builder）</strong>：專責安裝 Poetry 與專案相依套件，不進入最終 image 中。</li><li><strong>第二階段（runtime）</strong>：為實際執行環境，僅保留必要的程式碼與套件。</li></ul><p>以下是一份簡化過後的 Dockerfile 範例，為你展示如何使用 multi-stage build 來整合 Poetry，同時<strong>省略與主題無關的環節</strong>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一階段：建構環境與安裝 Poetry 相依套件</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.12</span>-slim AS builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝系統相依套件（Poetry 需要 curl 等工具）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y curl build-essential ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝 Poetry 並設定環境變數</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -sSL https://install.python-poetry.org | python3 -</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/root/.local/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pyproject.toml poetry.lock ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> your_module your_module</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Poetry 安裝相依套件</span></span><br><span class="line"><span class="comment"># 變更設定：不建立虛擬環境，因為 Docker 本身就是隔離環境</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> poetry config virtualenvs.create <span class="literal">false</span> \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># 只安裝 main 的套件，即不含 dev、test 等 group</span></span></span><br><span class="line">    &amp;&amp; poetry install --only main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二階段：建立乾淨的 image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.12</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 從 builder 階段複製已安裝的 site-packages(重點在這裡)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;your_entrypoint.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="重點說明"><a href="#重點說明" class="headerlink" title="重點說明"></a>重點說明</h3><ul><li>第一階段只負責安裝 Poetry 與相依套件——透過<code>poetry install</code>安裝。這裡的 Dockerfile 慣用語是<code>FROM xxx AS yyy</code>，其中<code>builder</code>是常見名稱。</li><li>Poetry 安裝套件時，可先調整設定，改成<strong>不建立虛擬環境</strong>，因為 Docker 本身即為獨立環境，沒必要再隔離。<ul><li>用於部署階段，所以也不必安裝開發、測試相關套件。</li><li>使用<code>--only main</code>來安裝主要的相依套件。</li></ul></li><li>第二階段只保留已安裝好的 site-packages 與應用程式程式碼。<ul><li>具體做法就是<strong>複製「前階段」產生的檔案、目錄到當前環境。</strong></li><li>關鍵句則是<code>COPY --from=builder xxx</code>。</li></ul></li></ul><p>一切就這麼簡單！</p><p>在 AI 時代，重要的是<strong>知曉這些概念</strong>，至於 Dockerfile 具體該怎麼寫，我認為只要實際操作時一邊詢問 AI 就可以了。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Poetry 是一個強大的 Python 套件管理工具，但若直接將它納入部署環境，可能導致不必要的複雜與耦合。</p><p>透過 multi-stage build，我們可以同時兼顧建構效率與部署簡潔。</p><p>使用正確策略，Poetry 不只是開發者的利器，也能優雅地融入部署流程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/poetry-multi-stage-build.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近都在為〈&lt;a href=&quot;/python-poetry/&quot;&gt;Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉一文進行「減肥」，讓它更容易閱讀、回顧。&lt;/p&gt;
&lt;p&gt;除此之外，是時候為「&lt;a href=&quot;/series/#Python-Poetry-%E4%B8%89%E9%83%A8%E6%9B%B2&quot;&gt;Python Poetry&lt;/a&gt;」這個系列畫下句點了——而本文就是最後一塊拼圖！&lt;/p&gt;
&lt;p&gt;我曾在前文中提到，為什麼不在 Docker 容器中使用 Poetry。主要原因是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會&lt;strong&gt;增加新的耦合與依賴&lt;/strong&gt;，需要更細緻的管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但這樣的限制，其實可以透過 Docker 的 &lt;strong&gt;multi-stage build&lt;/strong&gt; 解決。&lt;/p&gt;
&lt;p&gt;本文將從實務角度出發，介紹如何使用 multi-stage build，在 Docker 中整合 Poetry。&lt;/p&gt;
&lt;p&gt;讓你既能享有 Poetry 的套件管理優勢，又不會對部署流程增加額外負擔。&lt;/p&gt;
&lt;h3 id=&quot;系列：Python-Poetry-三部曲&quot;&gt;&lt;a href=&quot;#系列：Python-Poetry-三部曲&quot; class=&quot;headerlink&quot; title=&quot;系列：Python Poetry 三部曲&quot;&gt;&lt;/a&gt;系列：Python Poetry 三部曲&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/python-poetry/&quot;&gt;Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/poetry-pyenv-practical-tips/&quot;&gt;Poetry + pyenv 教學：常用指令與注意事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/poetry-multi-stage-build.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
  </entry>
  
</feed>
