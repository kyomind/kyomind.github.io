<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-11-14T14:49:15.411Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>去了兩個月健身房之後——我的「有氧運動」進化史</title>
    <link href="https://blog.kyomind.tw/cardio-evolution-2-months/"/>
    <id>https://blog.kyomind.tw/cardio-evolution-2-months/</id>
    <published>2024-11-14T09:21:31.000Z</published>
    <updated>2024-11-14T14:49:15.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>兩個多月前，我發表了〈<a href="/weekly-review-37/">37，加入健身房，專注 Zone 2</a>〉，宣誓著我投入有氧運動的決心！</p><p>75 天過去，我仍持續嗎？還是已經半途而廢？</p><p>本文就來整理一下，這兩個月多的變化，以及我獲得的體驗與感悟。</p><hr><h2 id="以減脂為起點"><a href="#以減脂為起點" class="headerlink" title="以減脂為起點"></a>以減脂為起點</h2><p>8 月底，我為了「減脂」（嚴格來說是降低體脂率）而報名健身房。</p><p>當時的計畫很簡單：不涉及重訓（另有教練），把這個健身房當成「<strong>有氧專區</strong>」，全力投入有氧運動來達成減脂的目標。</p><p>加入健身房的第一個月，<strong>跑步機是我的首選</strong>。使用方式也很簡單——以 Zone 2 的中低強度運動為主。<strong>我不跑步</strong>，而是設定坡度，採用走路的方式訓練。</p><p>那時我的期望是慢慢來，讓身體自然適應。</p><p>這兩個月來，經歷了幾個階段的改變（當然少不了和 AI 討論😎），訓練模式和目標也逐漸調整。</p><p>可說是一段「有氧運動進化史」，是不是真的愈來愈好，我敢不說。但顯然更符合我的期待。以下分三個階段講述——<strong>純個人經驗，僅供參考</strong>。</p><span id="more"></span><hr><h2 id="第一階段：跑步機上坡走路"><a href="#第一階段：跑步機上坡走路" class="headerlink" title="第一階段：跑步機上坡走路"></a>第一階段：跑步機上坡走路</h2><p>剛開始的前兩週，重點放在上坡走路。</p><p>因為右膝比較沒那麼穩定，讓我對跑步有所遲疑，但為了達成一定心率，光快走也不足以進入 <a href="https://www.google.com/search?q=Zone%202">Zone 2</a>（最大心率 60-70% 左右，對我而言相當於 115-133）。</p><p>具體做法是，跑步機設定坡度 10，時速 4 公里，行走約 45 分鐘。</p><p>結束後再用 15 分鐘橢圓機，作為強度上的補充，達成所謂的「80&#x2F;20」黃金比例——這裡指的是<strong>中低強度運動佔 80%，高強度佔 20%。</strong></p><p>這種平穩且強度不大的運動方式，很快身體就習慣了。<strong>這帶來了一個問題：感覺真的很無聊！</strong>而且時間又得要長才行——中低強度就是靠時間取勝。</p><p>隨著身體的適應，我意識到需要調整訓練方式才能打破僵局。</p><hr><h2 id="第二階段：跑步機、橢圓機-1-1"><a href="#第二階段：跑步機、橢圓機-1-1" class="headerlink" title="第二階段：跑步機、橢圓機 1 : 1"></a>第二階段：跑步機、橢圓機 1 : 1</h2><p>為避免中低強度訓練帶來的<strong>無趣與厭煩感</strong>，進入第三週後，我開始調整兩種器械的使用比例：<strong>改為跑步機和橢圓機各 25 分鐘。</strong></p><p>這樣的「1 : 1」分配讓運動的變化更多，主要是提高了整體強度，但仍繼續保有一定的 Zone 2 比例。</p><p>在此簡介一下我對橢圓機的用法，基本上<strong>以 5 分鐘為一個週期</strong>，前 3 分鐘是低強度，RPM（每分鐘轉速）約 80-100，阻力 8（上限 20）。</p><p>後 2 分鐘則是高度強，RPM 提高到 120 左右。</p><p>如此交錯，效果不錯！比單純高強度要來得持久——不然我 10 分鐘就想下來了。這樣的交錯也符合「間歇訓練」的精神。</p><p>在 RPM 120 的高強度階段，心率可以來到 140 甚至 150。</p><p>維持了 3 週，感覺不錯，但如你所料，身體又又又開始適應了。</p><p>到了本階段後期，120 RPM 已經連心率 140 都難以企及，而且身體也不那麼喘了，是時候繼續向前邁進了。</p><hr><h2 id="第三階段：徹底擁抱橢圓機，轉為-Zone-3-的心肺訓練"><a href="#第三階段：徹底擁抱橢圓機，轉為-Zone-3-的心肺訓練" class="headerlink" title="第三階段：徹底擁抱橢圓機，轉為 Zone 3 的心肺訓練"></a>第三階段：徹底擁抱橢圓機，轉為 Zone 3 的心肺訓練</h2><p>10 月中起，我將跑步機「<strong>邊緣化</strong>」，只用來進行<strong>短暫的熱身</strong>（約 5-7 分鐘），橢圓機正式成為我的有氧主力，每次使用約 35 分鐘。</p><p>此時我已經不滿足於 Zone 2 減脂，而更想要鍛鍊心肺——這需要一定的強度。</p><p>橢圓機一樣以 5 分鐘為週期，但做法調整為，第 2 和 4、5 分鐘為高強度時間，RPM 140-160，剩下兩分鐘則是低強度，RPM 100 左右。</p><p>隨著運動強度的提升，帶來的感受也有所不同，<strong>運動後的愉悅感變得更強</strong>，心肺耐力和體能也都有明顯的進步——主要是不太容易喘。</p><p>這樣的訓練強度也改變了我對有氧運動的看法。之前單純為了減脂而動，現在則是為了進步與挑戰（在合理的範圍內），有氧運動逐漸成為我生活中的小小重心。</p><h2 id="表格整理"><a href="#表格整理" class="headerlink" title="表格整理"></a>表格整理</h2><p>我們稍微整理一下這三個階段的<strong>運動內容、強度和心率</strong>，如下表所示：</p><table><thead><tr><th>階段</th><th>訓練內容</th><th>心率範圍</th><th>備註</th></tr></thead><tbody><tr><td><strong>第一階段</strong></td><td>跑步機上坡走路，坡度 10，時速 4 公里，45 分鐘 + 橢圓機 15 分鐘</td><td>115-135 BPM</td><td>主要以 Zone 2 減脂為主</td></tr><tr><td><strong>第二階段</strong></td><td>跑步機 25 分鐘 + 橢圓機 25 分鐘（間歇訓練）</td><td>120-150 BPM</td><td>提升強度，加入高低交替</td></tr><tr><td><strong>第三階段</strong></td><td>橢圓機 35 分鐘，週期性高強度（RPM 140-160）</td><td>130-155 BPM</td><td>以 Zone 3 心肺訓練為主</td></tr></tbody></table><p>總的來說，最有滿足感的還是第三階段。</p><p>不僅是因為強度的提升，更因為<strong>運動後的愉悅感</strong>。</p><hr><p>除了階段性的變化，我還有兩個有趣的發現，如下。</p><h2 id="頻率與現實"><a href="#頻率與現實" class="headerlink" title="頻率與現實"></a>頻率與現實</h2><p>一開始，給自己設定了一個十分積極的頻率——每週去五次健身房。</p><p>對此，我只有兩個字評論：作夢😆</p><p>這個頻率很快被證明根本<strong>不切實際</strong>：每次運動加上通勤、暖身，至少需要 1 小時。5 次就 5 小時了。</p><p>還有強度要求，心理上很容易<strong>產生抗拒</strong>——這是為何我堅持橢圓機只用 35 分鐘，不能再多了。</p><p>最後的定論是：每週二到三次，保持適度的頻率。這樣的節奏既能持續進行，又不會讓訓練變成生活中的壓力。</p><h2 id="意外收穫：文思泉湧的創作狀態"><a href="#意外收穫：文思泉湧的創作狀態" class="headerlink" title="意外收穫：文思泉湧的創作狀態"></a>意外收穫：文思泉湧的創作狀態</h2><p>值得一提的是，在橢圓機上進行高強度訓練時，我發現大腦進入了一種「<strong>文思泉湧</strong>」的狀態，很容易產生新的靈感——尤其是寫作的靈感！</p><p><strong>短短 35 分鐘，腦海裡不斷浮現出有趣的想法。</strong></p><p>我特別珍惜這樣的時刻，不過我也不會拿起手機就開始記錄，這多少有點冒險。只能等運動結束後，趕緊記下來。</p><p>事實上，本文的標題就是在橢圓機上想到的。</p><hr><h2 id="總結與未來展望"><a href="#總結與未來展望" class="headerlink" title="總結與未來展望"></a>總結與未來展望</h2><p>展望——其實沒什麼展望XD</p><p>我覺得能夠維持現在這個狀態與頻率，就<strong>已經相當不錯</strong>了！</p><p>畢竟，現實往往是：好的習慣不易養成，要中斷卻非常簡單。</p><p>我希望繼續保持這個平衡，試著讓運動成為生活中一部分，而不是一種負擔。</p><p>這段時間的經歷讓我再次體會到，<strong>持續的小進步比短期的大爆發更有價值</strong>——而且總是如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;兩個多月前，我發表了〈&lt;a href=&quot;/weekly-review-37/&quot;&gt;37，加入健身房，專注 Zone 2&lt;/a&gt;〉，宣誓著我投入有氧運動的決心！&lt;/p&gt;
&lt;p&gt;75 天過去，我仍持續嗎？還是已經半途而廢？&lt;/p&gt;
&lt;p&gt;本文就來整理一下，這兩個月多的變化，以及我獲得的體驗與感悟。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;以減脂為起點&quot;&gt;&lt;a href=&quot;#以減脂為起點&quot; class=&quot;headerlink&quot; title=&quot;以減脂為起點&quot;&gt;&lt;/a&gt;以減脂為起點&lt;/h2&gt;&lt;p&gt;8 月底，我為了「減脂」（嚴格來說是降低體脂率）而報名健身房。&lt;/p&gt;
&lt;p&gt;當時的計畫很簡單：不涉及重訓（另有教練），把這個健身房當成「&lt;strong&gt;有氧專區&lt;/strong&gt;」，全力投入有氧運動來達成減脂的目標。&lt;/p&gt;
&lt;p&gt;加入健身房的第一個月，&lt;strong&gt;跑步機是我的首選&lt;/strong&gt;。使用方式也很簡單——以 Zone 2 的中低強度運動為主。&lt;strong&gt;我不跑步&lt;/strong&gt;，而是設定坡度，採用走路的方式訓練。&lt;/p&gt;
&lt;p&gt;那時我的期望是慢慢來，讓身體自然適應。&lt;/p&gt;
&lt;p&gt;這兩個月來，經歷了幾個階段的改變（當然少不了和 AI 討論😎），訓練模式和目標也逐漸調整。&lt;/p&gt;
&lt;p&gt;可說是一段「有氧運動進化史」，是不是真的愈來愈好，我敢不說。但顯然更符合我的期待。以下分三個階段講述——&lt;strong&gt;純個人經驗，僅供參考&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>iThome 鐵人賽寫作攻略——新手必看指南</title>
    <link href="https://blog.kyomind.tw/ithome-ironman-tips/"/>
    <id>https://blog.kyomind.tw/ithome-ironman-tips/</id>
    <published>2024-11-13T04:07:49.000Z</published>
    <updated>2024-11-14T09:22:18.069Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/8kDoWyy.jpeg"></p><p>除了「加碼」組別，<a href="https://ithelp.ithome.com.tw/2024ironman/">2024 iThome 鐵人賽</a>已圓滿落幕，而我也順利完賽。</p><p>在讀完〈<a href="https://kucw.io/blog/ithome-sharing/">iThome 鐵人賽 - 得《優選》獎項的寫作心法</a>〉和〈<a href="https://ithelp.ithome.com.tw/articles/10358571">【Day 31】- 忙碌上班族如何在鐵人賽中堅持30天寫作？從靈感到策略：9個關鍵步驟</a>〉這兩篇大作後，我不禁見獵心喜、心癢難耐🤩</p><p>也想好好寫一篇攻略，獻給還在觀望中、猶豫明年是否要參賽的你。</p><p>雖說是「寫作」攻略，但其實更適合稱為「<strong>參賽與完賽</strong>」攻略。</p><p>本文不會介紹任何寫作技巧，而是聚焦於<strong>如何成功跑完這場「寫作馬拉松」</strong>——最好再拿個獎！</p><p>接下來，我將分享我的鐵人賽參賽經驗，以及一些實際的做法。</p><span id="more"></span><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文的最大目標，就是<strong>試圖鼓吹你在明年參賽</strong>——畢竟今年已經來不及了🤣</p><p>如果閱讀後你依舊沒有這樣的衝動，那麼這篇文章就算是失敗了。</p><p>因此，我們無須講太多「細節」，而是從「更高的層級」與「可行性角度」來討論這個議題。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文主要寫給下列這三種人：</p><ol><li>平常沒有寫作習慣，但想藉由參賽來磨練寫作能力的軟體工程師。</li><li>已經有在寫作，希望獲得更多文章曝光度、聲望的工程師。</li><li>別說了！我就是要得獎、出書。</li></ol><p>本文對三者都有幫助，但話說回來，我們還是會更加著重在「<strong>新手鐵人</strong>」，以降低你的行動（報名參賽）門檻。</p><p>此外，我之前已有兩篇文章討論過鐵人賽，所以本文可以視為對兩者的（大量）補充：</p><ul><li><a href="/weekly-review-35/">35，開始備戰 2024 iThome 鐵人賽</a></li><li><a href="/2024-ironman-event/">2024 iThome 鐵人賽參賽思路：主題選擇、命名與標題策略</a></li></ul><p>了解完上述前提後，我們正式開始。</p><hr><h2 id="一、心態區別：是否以「得獎」為目標"><a href="#一、心態區別：是否以「得獎」為目標" class="headerlink" title="一、心態區別：是否以「得獎」為目標"></a>一、心態區別：是否以「得獎」為目標</h2><p>參賽不一定非得為了得獎。</p><p>不過，在參賽之前，我們可以先問自己：「我是否要以得獎為目標？」</p><p><strong>因為兩者的道路可能會有很大的不同</strong>。</p><p><strong>不以得獎為目標，有時更利於學習</strong>。但代價就是——沒有獎😂</p><p>以我自己為例，我在〈<a href="/weekly-review-35/">35，開始備戰 2024 iThome 鐵人賽</a>〉就提到目標是<a href="/weekly-review-35/#%E5%80%8B%E4%BA%BA%E6%9C%9F%E5%BE%85">為了得獎</a>。什麼獎都可以，但就是要得獎！</p><h3 id="得獎的取捨"><a href="#得獎的取捨" class="headerlink" title="得獎的取捨"></a>得獎的取捨</h3><p>一旦想得獎，就不得不研究一下，哪些是<strong>重點</strong>。</p><p>不可否認，這樣的創作多少是「<strong>不自由</strong>」的，但也有它自己的價值。</p><p>我認為，先想清楚這個問題，<strong>會讓自己更享受參賽的過程</strong>。</p><p>如果明年繼續參賽，我應該就<strong>不會</strong>以獲獎為目標了，而是更多放在學習與嘗試——然後順便寫個文章。</p><p>很多時候，兩者無法兼得，選擇往往是必要的。</p><hr><h2 id="二、了解評審標準"><a href="#二、了解評審標準" class="headerlink" title="二、了解評審標準"></a>二、了解評審標準</h2><p>我們假設你是以「得獎」為目標參賽，因為這樣才能發揮本文的<strong>最大價值</strong>。</p><p>以此為前提，了解評審時的重點顯然相當必要。<a href="https://s.itho.me/vendor/2024/iThome/iThome%E9%90%B5%E4%BA%BA%E8%B3%BD%E6%B4%BB%E5%8B%95%E7%B0%A1%E7%AB%A0-20240614.pdf">報名簡章</a>是這樣寫的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">陸、主題競賽評審要點：</span><br><span class="line">- 主題：主題規劃符合該組別的立意，並能充份切合所選參賽主題下，參賽者所訂定之議題</span><br><span class="line">- 結構：30 篇文章組織良好、其所規劃結構足以引導讀者理解參賽者訂定之議題</span><br><span class="line">- 內容：文章內容的技術或經驗具備專業性、豐富性、深入性</span><br><span class="line">- 表達：透過適當文字、圖片、程式碼或影片等方式，讓人更容易理解</span><br></pre></td></tr></table></figure><p>這 4 項要全都做到滿分，我想很難。</p><h3 id="讀者意識"><a href="#讀者意識" class="headerlink" title="讀者意識"></a>讀者意識</h3><p>但它們都指向了一個<strong>共同的上位概念</strong>——「<strong>請務必讓讀者好了解！</strong>」</p><p>這不正是所謂的「<strong>讀者意識</strong>」？要求你了解讀者的需求與可能有的疑惑，並以此來調整內容的深度和表達方式。</p><p>這種意識能幫助你在保持專業的同時，讓文章<strong>更容易被理解和接受</strong>。</p><p>覺得自己寫得很棒，還不算數。<strong>讀者們也這麼認為，那才算數</strong>！</p><h3 id="我的著眼點"><a href="#我的著眼點" class="headerlink" title="我的著眼點"></a>我的著眼點</h3><p>所以，我對這段要點的解讀，會更加著重在「<strong>結構</strong>」與「<strong>表達</strong>」這兩部分。</p><p>結構務必清晰（這並不容易，後面會再討論），而文字表達則要「<strong>善解人意</strong>」。最忌諱的就是簡單介紹一下，然後丟一大段程式碼讓讀者自行理解——這樣不太體貼唷！</p><p>能做好這兩點，就已經相當不錯了。</p><hr><h2 id="三、提前開始準備"><a href="#三、提前開始準備" class="headerlink" title="三、提前開始準備"></a>三、提前開始準備</h2><p>既然想要拿獎，提前準備就是必要的——非常必要。</p><p>即使像我這樣在參賽期間已經離職、不必工作的人，也<strong>不可能</strong>在開賽日當天才開始動筆，同時還妄想能確保寫作品質——我對寫作很完美主義☺️</p><p>具體而言，我在 9&#x2F;13 開賽日之前，已寫完系列的前 13 篇文章。</p><p>假設「正常」參賽者必須一邊工作一邊創作，那我認為「最好」能在參賽前，<strong>預先完成 10-15 篇</strong>。</p><h3 id="囤稿以緩衝"><a href="#囤稿以緩衝" class="headerlink" title="囤稿以緩衝"></a>囤稿以緩衝</h3><p>這樣的準備量可能看起來有點多，但它能夠<strong>大大減輕你在比賽期間的壓力</strong>。想像一下，當其他參賽者正在為每天的截稿時間而焦急時，你已經有了足夠的「緩衝」。</p><p>這不僅能讓你<strong>更加從容</strong>地面對每天的寫作任務，<strong>還能賦予你額外的時間，去重新編輯和完善你的文章</strong>——非常適合我這種完美主義者😇</p><p>事實證明，這很重要。</p><p>系列後半段的文章，儘管我早早就列出了大綱、定完標題。但實際創作時，<strong>發現要改動的幅度極大</strong>，涉及了文章主題和系列架構的調整。</p><p>如果沒有之前 13 篇囤稿作為緩衝，那不是累死自己，就是虎頭蛇尾。</p><p>兩者都不是我想要的！</p><hr><h2 id="四、選擇熟悉的主題"><a href="#四、選擇熟悉的主題" class="headerlink" title="四、選擇熟悉的主題"></a>四、選擇熟悉的主題</h2><p>關於參賽主題的選擇，我在開賽前就討論過，那時主要強調「<a href="/weekly-review-35/#%E4%B8%80%E3%80%81%E9%81%BF%E9%96%8B%E5%A4%AA%E5%B8%B8%E8%A6%8B%E7%9A%84%E4%B8%BB%E9%A1%8C">避開太常見的主題</a>」。</p><p>現在完賽了，我還想補充一點：「如果是以<strong>獲獎</strong>為目標，那麼勢必得選擇<strong>自己熟悉的主題</strong>」。</p><p>即使這個主題是常見的，也比嘗試創作一個自己不熟悉的技術主題要來得好。</p><p>其中的道理不難理解：<strong>熟悉的主題，你可以更好地掌握內容，更好地表達</strong>。</p><p>如果真的很想寫自己不熟悉的主題怎麼辦？很簡單，先放下得獎的念頭，好好享受學習與分享的過程😘</p><h3 id="熟悉不等於好寫"><a href="#熟悉不等於好寫" class="headerlink" title="熟悉不等於好寫"></a>熟悉不等於好寫</h3><p>更別說，<strong>熟悉並不意味著好寫</strong>。畢竟，<strong>自己會</strong>和<strong>教別人做</strong>往往是兩回事。所以寫完之後你很可能會發現——「自己<strong>好像沒有</strong>原先以為的那麼懂！」</p><p>就像我在〈<a href="/django-ninja-30/">卷 30：系列回顧與完賽心得</a>〉中說的：</p><blockquote><p>在我看來，寫作的滿足感在於「提供價值、發揮影響力」。這份價值不僅是對讀者，也包括對作者自己——<strong>透過這 30 篇文章創作，我對 Django Ninja 的理解又增進許多</strong>。</p></blockquote><p>恭喜你！又進步了。</p><hr><h2 id="五、結構、結構，還是結構"><a href="#五、結構、結構，還是結構" class="headerlink" title="五、結構、結構，還是結構"></a>五、結構、結構，還是結構</h2><p>前面提到，「結構」與「表達」是我認為在 4 項評分標準中特別重要的部分。</p><p>其實就算不是參加比賽，<strong>任何一篇文章都需要良好的結構和友善的表達</strong>——這是寫作的基本，同時也是<strong>最難的部分</strong>。</p><p>在鐵人賽這樣以 30 篇作為一個完整系列的「<strong>連載型創作</strong>」中，我認為結構的重要性，可以說<strong>再強調也不為過</strong>。</p><p>好的結構和壞的結構，或者說沒有結構，寫出來的作品可能是<strong>天壤之別</strong>。（注意，這裡的「作品」不是指單篇文章，而是一整個系列）</p><p>就像蓋一層樓的矮房，結構影響不大；但要蓋 30 層大樓，結構就<strong>至關重要</strong>了。</p><h3 id="具體做法"><a href="#具體做法" class="headerlink" title="具體做法"></a>具體做法</h3><p>講完了結構的重要性，那具體要怎麼做呢？</p><p>我自己的做法是先跟 AI 好好討論，把 30 篇標題都先定下來。不過這有點強人所難，尤其在最開始的時候。</p><p>為了降低壓力與兼顧彈性，我們可以採取<strong>折衷方案</strong>：先確定<strong>前 10 篇的標題</strong>，後 20 篇僅擬定大綱——也就是章節名稱。</p><p>在寫完前面的部分後，後面你就會有靈感了！</p><p>但無論如何，<strong>絕對不要沒有先草擬系列的架構就開始寫</strong>！很容易虎頭蛇尾。</p><hr><h2 id="六、別讓「字數」成為壓力"><a href="#六、別讓「字數」成為壓力" class="headerlink" title="六、別讓「字數」成為壓力"></a>六、別讓「字數」成為壓力</h2><p>關於字數，我有很多話想說。不過篇幅所限，我們可以總結為 3 點。</p><h3 id="一、保持各篇字數的相對均衡"><a href="#一、保持各篇字數的相對均衡" class="headerlink" title="一、保持各篇字數的相對均衡"></a>一、保持各篇字數的相對均衡</h3><p>這一點很少人提及，但我個人還蠻重視的。因為<strong>字數的均勻</strong>表示你在系列的編排上<strong>的確有經過深思熟慮</strong>。</p><p><strong>這是另一種用心的展現。</strong></p><p>想像一下，如果這一篇為 800 字，而下一篇卻有 2500 字，作為讀者，你可能會感到<strong>思緒有些混亂</strong>。至少我個人<strong>不那麼喜歡閱讀</strong>字數起伏太大的系列文章。</p><p>當然，字數均勻並不是說每一篇都要一樣多——這恐怕也不切實際。只要<strong>差距別太大</strong>，讓讀者感到舒適即可。</p><p>下圖是我 30 篇文章的字數分布，除了第 29 篇有點「失手」外，其餘文章的字數均落在「<a href="https://zh.wikipedia.org/zh-tw/68%E2%80%9395%E2%80%9399.7%E6%B3%95%E5%89%87">兩個標準差</a>」以內。</p><p><img src="https://i.imgur.com/qoUSere.png"></p><p>可見我不是說說而已——還身體力行🐥</p><h3 id="二、字數不是多多益善"><a href="#二、字數不是多多益善" class="headerlink" title="二、字數不是多多益善"></a>二、字數不是多多益善</h3><p>說真的，這是一個不易突破的「<strong>心魔</strong>」！</p><p>連我自己都不容易說服自己：<strong>真的不需要寫太多字。</strong></p><p>但我們得承認：<strong>現代讀者的注意力是很有限的</strong>。就算是寫給有心學習的讀者，適度控制篇幅也是一種「<strong>保護閱讀注意力</strong>」的體貼表現。</p><p>所以，我認為網路文章的最佳字數確實存在一個<strong>相對理想的區間</strong>。</p><p>如果你問我，我會說這個區間是 1000 到 2000 中文字。</p><p>而我正是以每篇 1500 字作為單篇的字數目標——雖然後半段開始有點守不住XD</p><h3 id="三、字數偏少會不會不容易得獎？"><a href="#三、字數偏少會不會不容易得獎？" class="headerlink" title="三、字數偏少會不會不容易得獎？"></a>三、字數偏少會不會不容易得獎？</h3><p>我可以告訴你——我不知道XD</p><p>但是！確實是有字數不算多，但獲得<strong>優選</strong>的唷！（冠軍可能有點難）</p><p>比如去年 <strong>Vue.js 組優選</strong>——《<a href="https://ithelp.ithome.com.tw/users/20130500/ironman/6236">Nuxt.js 3.x 筆記－打造 SSR 專案</a>》。言簡意賅，搭配精心製作的解說圖片，讀起來非常舒服。</p><p>我就是看完這個系列，才有了足夠的勇氣，下定決心好好控制字數——雖然從結果而言不算成功😅</p><hr><h2 id="七、參考前人的作品"><a href="#七、參考前人的作品" class="headerlink" title="七、參考前人的作品"></a>七、參考前人的作品</h2><p>參考他人是一個很好的學習方法，尤其是那些獲獎或頗受好評的系列。畢竟所有的學習都是<strong>從模仿開始</strong>。</p><p>透過閱讀這些作品，你可以學習到他們的寫作風格、內容組織方式，以及<strong>如何維持整個系列的連貫性</strong>——這是新手鐵人<strong>最需要學習的</strong>，包括我自己。</p><p>以下是我在開賽前就已大致拜讀過的系列：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20130500/ironman/6236">Nuxt.js 3.x 筆記－打造 SSR 專案</a></li><li><a href="https://ithelp.ithome.com.tw/users/20162175/ironman/6445">時光之鏡：透視過去、現在與未來的 Observability</a></li><li><a href="https://ithelp.ithome.com.tw/users/20151036/ironman/6130">Spring Boot 零基礎入門</a></li><li><a href="https://ithelp.ithome.com.tw/users/20152669/ironman/6306">FastAPI 入門30天</a></li></ul><p>我用一份專屬的 Notion 筆記，記錄下我認為值得參考的部分，並在寫作時隨時翻閱。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>連續寫作 30 天，真的別具滋味。</p><p>這段旅程所帶來的收穫與學習，遠比創作單篇或數篇文章要來得多。更令人驚喜的是，你會發現自己的潛力比想像中大。</p><p>希望這篇攻略能對你有所助益，讓你在明年的鐵人賽中，大展身手。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/8kDoWyy.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了「加碼」組別，&lt;a href=&quot;https://ithelp.ithome.com.tw/2024ironman/&quot;&gt;2024 iThome 鐵人賽&lt;/a&gt;已圓滿落幕，而我也順利完賽。&lt;/p&gt;
&lt;p&gt;在讀完〈&lt;a href=&quot;https://kucw.io/blog/ithome-sharing/&quot;&gt;iThome 鐵人賽 - 得《優選》獎項的寫作心法&lt;/a&gt;〉和〈&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10358571&quot;&gt;【Day 31】- 忙碌上班族如何在鐵人賽中堅持30天寫作？從靈感到策略：9個關鍵步驟&lt;/a&gt;〉這兩篇大作後，我不禁見獵心喜、心癢難耐🤩&lt;/p&gt;
&lt;p&gt;也想好好寫一篇攻略，獻給還在觀望中、猶豫明年是否要參賽的你。&lt;/p&gt;
&lt;p&gt;雖說是「寫作」攻略，但其實更適合稱為「&lt;strong&gt;參賽與完賽&lt;/strong&gt;」攻略。&lt;/p&gt;
&lt;p&gt;本文不會介紹任何寫作技巧，而是聚焦於&lt;strong&gt;如何成功跑完這場「寫作馬拉松」&lt;/strong&gt;——最好再拿個獎！&lt;/p&gt;
&lt;p&gt;接下來，我將分享我的鐵人賽參賽經驗，以及一些實際的做法。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/8kDoWyy.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>39，10 月回顧——鐵人賽、演算法與 AI</title>
    <link href="https://blog.kyomind.tw/weekly-review-39/"/>
    <id>https://blog.kyomind.tw/weekly-review-39/</id>
    <published>2024-11-01T13:06:08.000Z</published>
    <updated>2024-11-02T13:15:02.904Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>好些日子沒寫 Weekly Review 了！</p><p>十月剛過，正是個不錯的時間點。</p><p>本篇就來整理一下「<strong>待業的第 2 個月</strong>」我都做了什麼。</p><span id="more"></span><hr><h2 id="iThome-鐵人賽"><a href="#iThome-鐵人賽" class="headerlink" title="iThome 鐵人賽"></a>iThome 鐵人賽</h2><p>雙十連假 4 天我幾乎都在寫作，連假落幕時，也是我的參賽劃下句點之時。</p><p>不過，正如〈<a href="https://blog.kyomind.tw/django-ninja-30/">Django Ninja 30：系列回顧與完賽心得</a>〉文中說的，這系列還沒有完全結束。我預計還會再新增 3 到 4 篇相關內容，其中心得與花絮就佔兩篇。</p><p>但請原諒我，並不是鐵人賽結束後就閒著了，所以剩下的內容只能一篇篇慢慢生出來。</p><p>在「<a href="https://kyomind.notion.site/40b324f98ca94827921a6831b0d7a38f">訂戶限定</a>」中提過，比賽結束後，我去了一趟「福隆 - 石城」徒步之旅。造訪<a href="https://newtaipei.travel/zh-tw/attractions/detail/110829">舊草嶺隧道</a>與<a href="https://www.yilan.travel/">頭城五漁鐵</a>。</p><p><img src="https://i.imgur.com/UcjquRE.jpeg" alt="舊草嶺隧道"><span class="cap">舊草嶺隧道</span></p><p>感覺很好！尤其在經歷了這一大波腦力勞動之後。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-33/">33，Tony Huang 與我的坪林之旅</a></p></blockquote><p>下星期，我打算繼續走訪<strong>苗栗海線——從白沙屯到通霄</strong>。</p><p>一邊動腦，一邊身體力行。</p><hr><h2 id="演算法與-LeetCode"><a href="#演算法與-LeetCode" class="headerlink" title="演算法與 LeetCode"></a>演算法與 LeetCode</h2><p>不知道大家是否看過這篇〈<a href="https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/">與 AI 共舞：我的 LeetCode 刷題之道（上）準備篇</a>〉了，可以說是我近期的力作！</p><p>重點並不在刷題本身，而是其中蘊含的一種精神。怎麼說呢？就是<strong>遵從主流，但不完全按照主流的做法</strong>。</p><blockquote><p>這裡的「主流」是指什麼？</p></blockquote><p>指的是普遍認為刷題是找工作的必經之路，或至少是一個重要的手段。</p><p>我們很難否定這件事，但我的選擇是，將 AI 工具融入刷題過程中，<strong>用「更慢」的速度來刷題</strong>——這是反主流的。</p><p>在主流之中，選擇一條「不那麼主流」的分支。</p><p>這種方法既遵循了主流的刷題建議，又加入了<strong>個人的元素（AI、深度與反思）</strong>，更符合我的價值觀。</p><h3 id="初步感受"><a href="#初步感受" class="headerlink" title="初步感受"></a>初步感受</h3><p>從 10 月中到今天，我已經連續 15 天刷題了！</p><p>目前完成 <a href="https://www.techinterviewhandbook.org/grind75/">Grind 75</a> 中的 17 題，Easy 的題目也快被消耗完畢。（平心而論，有些 Easy 題目挺無聊的，難怪 <a href="https://neetcode.io/practice">NeetCode 150</a> 沒有選入）</p><p><img src="https://i.imgur.com/1UJOP42.png" alt="LeetCode Dashboard"><span class="cap">LeetCode Dashboard</span></p><p>只能說，這種方式<strong>很適合我</strong>，讓人想起台灣軟體圈那本你一定聽過的暢銷書——高見龍大大的《<a href="https://gitbook.tw/">為你自己學 Git</a>》。</p><p>或許可以稱作「<strong>為你自己刷 LeetCode</strong>」。</p><p>不過，人還是要<strong>適度休息</strong>。我已決定，明後兩天都不刷題！</p><p>明天要去宜蘭玩，後天則是前往新竹，參加「<a href="https://ithelp.ithome.com.tw/2024ironman/signup/team/339">AI 寶寶上學去！</a>」的團隊完賽慶功宴。真是令人期待🤩</p><hr><h2 id="再論職涯中的-gap-time"><a href="#再論職涯中的-gap-time" class="headerlink" title="再論職涯中的 gap time"></a>再論職涯中的 gap time</h2><p>在〈<a href="https://www.threads.net/@kyomind.tw/post/C-qEHRxyuIQ">Day 15：《上班，辭職，還是撐下去？》節選（一）</a>〉中引用了書裡的這段話：</p><blockquote><p>未來我們也許會工作幾年後就先「退休」幾年，去學習一段時間之後，再投入下一階段的工作生涯。</p></blockquote><p>我非常喜歡這樣的想法，和前面的「用自己的方式刷 LeetCode」類似，都是一種<strong>既不違反主流（相信人還是需要工作），又不完全按照主流價值行事的生存之道</strong>。</p><p>我想，「擁有自己的價值觀」這件事情本身，就足以讓人感到幸福。</p><h3 id="更大的舞台"><a href="#更大的舞台" class="headerlink" title="更大的舞台"></a>更大的舞台</h3><p>不過話說回來，在這個時間點，我也沒有以前那麼大的勇氣，再 gap 超過 1 年。</p><p>但，幾個月總可以吧！用我認同的方式去實現自己認為重要的事——學習演算法和系統設計。（其實這些都是在符合主流的「審美」😅）</p><p>畢竟，想成為優秀的軟體工程師，不就該如此？</p><p>可以說，離職待業這兩個月以來，我覺得自己過得很充實，最近的狀態也挺不錯。但我心裡清楚，做這些事，付出這些時間，終歸是為了尋找更好、更大的舞台。</p><p>且讓我們拭目以待。</p><hr><h2 id="AI-與我"><a href="#AI-與我" class="headerlink" title="AI 與我"></a>AI 與我</h2><blockquote><p>AI 會取代軟體工程師嗎？</p></blockquote><p>這是最近（或說一直以來）十分熱門的議題。尤其在 <a href="https://blog.kyomind.tw/cursor/">Cursor</a> 大紅之後！畢竟現在不用懂程式就可以寫出軟體服務或功能了。</p><p>先說說我個人的極簡看法：理性上覺得「沒那麼容易」，但情感上則常常在擔心這天的到來，哈哈哈！</p><p>答案究竟為何，沒人知道。</p><p>可是有一件事，對我而言是 100% 確定——<strong>我非常依賴 AI</strong>。</p><h2 id="Copilot-with-AI"><a href="#Copilot-with-AI" class="headerlink" title="Copilot with AI"></a>Copilot with AI</h2><p>今年寫了好幾篇和 AI 有關的文章：</p><ol><li><a href="https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/">與 AI 共舞：我的 LeetCode 刷題之道（上）準備篇</a></li><li><a href="https://blog.kyomind.tw/myth-of-ai-writing-efficiency/">AI 讓寫作變輕鬆了？我可不這麼認為</a></li><li><a href="https://blog.kyomind.tw/my-ai-dialogue-notes/">我寫「AI 對話筆記」的方法與思考</a></li><li><a href="https://blog.kyomind.tw/not-by-ai/">為文章標註 Not By AI？ 我覺得大可不必</a></li></ol><p>訂戶限定也有兩篇：</p><ol><li>訂戶限定 07：鐵人賽尾聲 × 續論 AI 工具 × 我的滑鼠停產了！</li><li>訂戶限定 06：待業週記（二）失眠症與 AI輔助思考</li></ol><p>以後應該會更多。</p><h3 id="依賴-AI"><a href="#依賴-AI" class="headerlink" title="依賴 AI"></a>依賴 AI</h3><p>我對 AI 的「依賴」可能超過絕大多數人。</p><p>如上述這些文章所說，AI 對我來說，不僅僅是一個工具，也不僅僅是一個「懶人」的幫手。</p><p>真正讓我依賴 AI 的原因，是它已經成為我<strong>思考和生活的一部分</strong>。</p><p>無論是寫作、學習還是人生的重大難題，我總是先想到 AI，讓它扮演我的良師益友，來回討論，再決定下一步的行動。</p><p>如同我在「<a href="https://blog.kyomind.tw/about/#AI-%E6%99%82%E4%BB%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%80%85">AI 時代的工作者</a>」中所言：</p><blockquote><p>它不僅提升了產能，更挑戰我的思維模式，迫使我重新審視自己，以更深刻的方式思考問題。</p></blockquote><p>這種<strong>智識上的滿足感</strong>，以前可是很難得的，而現在不同了。</p><p>因為我們有了 AI。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;好些日子沒寫 Weekly Review 了！&lt;/p&gt;
&lt;p&gt;十月剛過，正是個不錯的時間點。&lt;/p&gt;
&lt;p&gt;本篇就來整理一下「&lt;strong&gt;待業的第 2 個月&lt;/strong&gt;」我都做了什麼。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>與 AI 共舞：我的 LeetCode 刷題之道（上）準備篇</title>
    <link href="https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/"/>
    <id>https://blog.kyomind.tw/grind-leetcode-with-ai-preparation/</id>
    <published>2024-10-24T05:12:52.000Z</published>
    <updated>2024-10-25T03:45:09.379Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/g9WO9S7.jpeg"></p><!-- ![picture 2](https://i.imgur.com/SsRLsJl.jpeg) --><p>最近，我剛結束了 iThome 鐵人賽的寫作之旅——真是不輕鬆，但值得！</p><blockquote><p>相關文章：<a href="/django-ninja-30/">Django Ninja 30：系列回顧與完賽心得</a></p></blockquote><p>隨著比賽結束，我開始進入<strong>求職準備</strong>的第二階段——學習演算法（主要是 LeetCode 刷題）和系統設計。</p><p>老實說，我一直很排斥刷 LeetCode，因為感覺很「填鴨」，一點也不吸引人。</p><p>這可能是因為這件事和求職面試掛勾，所以讓人有壓力；又或者我還沒有真正領略資料結構與演算法之美。</p><p>總之，<strong>我很逃避！</strong></p><hr><p>但這次不同了。</p><p>我找到了一個全新的方法，讓刷題<strong>不再那麼痛苦</strong>，還幫助我盡可能理解每一道題——這都要歸功於 AI。</p><p>我將分享如何透過 <strong>AI 輔助</strong>來提升刷 LeetCode 的學習效果。關鍵是——它讓原本枯燥的過程（對我來說）<strong>變得有趣</strong>。</p><p>當然，這樣的方法也有一些「<strong>限制</strong>」，後續會提及。</p><p>我將這個主題分成上、下兩篇，各有不同的著眼。</p><span id="more"></span><h3 id="上篇：準備篇"><a href="#上篇：準備篇" class="headerlink" title="上篇：準備篇"></a>上篇：準備篇</h3><p>依不同的刷題目的，說明<strong>適合與不適合</strong>本文的讀者。</p><p>然後是兩項<strong>前置準備</strong>，包括演算法學習教材與刷題清單推薦。</p><p>接著是 AI 輔助學習的方法論，這是我個人的看法與歸納。</p><p>最後則是關於這個刷題法的「原則」介紹。</p><h3 id="下篇：實戰篇"><a href="#下篇：實戰篇" class="headerlink" title="下篇：實戰篇"></a>下篇：實戰篇</h3><p>分享我和 AI 一起刷題的具體流程、做法。題目就是那些，沒什麼特別，其中的重點在於「<strong>我的個人經驗</strong>」——怎麼做比較好，而哪些方式可能不妥。</p><p>我會以實際的 LeetCode 題目作為範例，展示我如何運用 AI 來增進解題與學習效果，包括和 AI 的對話過程。</p><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>要闡述的內容眾多（本文就有 3000 字），不得不拆分篇幅，降低讀者的<strong>認知負擔</strong>。</p><p>而且，分成兩篇的另一個好處是：當你需要回過頭來參考時，只要看下篇就足夠了。</p><p>此外，如果已有自己的刷題習慣，只是想參考一下我的做法，那跳過本文直接看實戰篇也無妨。</p><hr><p>接下來，介紹本文的輪廓。</p><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文闡述如何運用 AI，將 LeetCode 刷題變成一種「互動式的學習之旅」。</p><p>我們的<strong>首要目標</strong>是——<strong>有效降低刷題的痛苦與排斥感</strong>！（這不止和 AI 有關，還包括了選用的教材、個人動機、心態等）</p><p>這方法不僅讓刷題變得有趣，還能幫助我們理解每道題目背後的演算法思維。換言之，你會<strong>學得更好</strong>。</p><p>如果你和我一樣，曾經對 LeetCode 感到困頓或厭倦，希望尋找一個更有效、更愉快的學習方式，這篇文章將會對你有所幫助。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文<strong>特別適合</strong>下列讀者：</p><ul><li>討厭機械式刷題、希望刷題<strong>不止是為了面試</strong>的人</li><li>想了解如何利用 AI 助手提升學習效率的人</li><li><strong>不想刷太多題</strong>的人！（沒錯，你沒看錯，後面會闡述<strong>為何不多刷題</strong>）</li></ul><p>尤其要強調——本文非常適合演算法<strong>初學者</strong>，俗稱「小白」。</p><h3 id="不適合的讀者"><a href="#不適合的讀者" class="headerlink" title="不適合的讀者"></a>不適合的讀者</h3><p>有光有就影，我覺得本文可能不適合下列讀者：</p><ul><li>已有豐富刷題經驗的人</li><li>希望在短時間內刷大量題目以通過面試的人</li><li>偏好傳統學習方式，不太習慣使用 AI 輔助工具的人</li></ul><p>這類讀者通常已有自己的學習方式或目標，可能與本文的方法不太契合。</p><hr><p>開始正文，我們從刷題前的「<strong>前置準備</strong>」說起。</p><p>具體而言，有兩個前置準備：<strong>自學教材與刷題清單</strong>。</p><h2 id="前置準備一：演算法自學教材推薦"><a href="#前置準備一：演算法自學教材推薦" class="headerlink" title="前置準備一：演算法自學教材推薦"></a>前置準備一：演算法自學教材推薦</h2><p>像我這類半路轉職且演算法基礎為零的人。先讀過一些教材再開始，肯定會比較好。</p><p>但不必事先就花大量時間，可以學習教材到一定階段後，比如最常見的 array 和 linked list，就開始練習相關題目，讓理論與應用相輔相成。</p><p>關於教材選擇，我嘗試過好些書或線上課，從結果來看，只能說<strong>不盡理想</strong>。</p><p>但其中還是有些優質資源，特別適合初學者。</p><p>以下是我推薦且正在使用的教材，它們相當程度考慮了無基礎者的自學需求。</p><h3 id="一、《Hello-演算法》"><a href="#一、《Hello-演算法》" class="headerlink" title="一、《Hello 演算法》"></a>一、《Hello 演算法》</h3><p>這是一個<a href="https://www.hello-algo.com/zh-hant/chapter_hello_algo/">網站</a>（線上版的電子書），本質上是一個 <a href="https://github.com/krahets/hello-algo">GitHub 開源專案</a>。目前已有繁體中文版，同時也出版了實體書。</p><p>本書完全面向新手，還搭配了各種實用的動畫幫助理解——這是實體書辦不到的。</p><p>此外，它支援多種程式語言，能滿足不同開發者對熟悉程式碼範例的需求——這也是實體書無法擁有的優勢。</p><h3 id="二、《大話資料結構：全新彩色版》"><a href="#二、《大話資料結構：全新彩色版》" class="headerlink" title="二、《大話資料結構：全新彩色版》"></a>二、《大話資料結構：全新彩色版》</h3><p>這本《<a href="https://www.tenlong.com.tw/products/9789865501693">大話資料結構</a>》和更加知名的《<a href="https://www.tenlong.com.tw/products/9786267146804">大話設計模式</a>》是同一位作者。</p><p>書中有大量插圖幫助你理解，更重要的是，作者在自序中<strong>強調</strong>，這是一本面向「<strong>自學</strong>」的教材。</p><p>所以很多概念都會<strong>從頭講起</strong>，不會讓你有<strong>囫圇吞棗</strong>之感。</p><p>我個人已經讀完一輪，覺得確實有做到上述承諾。不過書中仍有少數比較進階的內容，我都是先跳過——建議你也如此。</p><p>附帶一提，本書的實作語言是 C，所以我閱讀時比較少看程式碼實作，而是著重於圖示和觀念的理解。</p><hr><p>教材部分，以上兩樣就足夠了！</p><p>有些人可能注意到，我並沒有推薦大多數刷題者所熟知的《<a href="https://www.tenlong.com.tw/products/9789865025526">提升程式設計師的面試力｜189道面試題目與解答</a>》，不是它不好，只是我還沒看而已😅</p><h2 id="前置準備二：刷題清單"><a href="#前置準備二：刷題清單" class="headerlink" title="前置準備二：刷題清單"></a>前置準備二：刷題清單</h2><p>有了書可以作為參考，接著就從第 1 題直接開刷了嗎？當然不是。</p><p>LeetCode 題目成百上千，題海茫茫，所以我們還需要「刷題清單」，它們能幫助我們更有效地學習。</p><p>尤其對於初學者，<strong>信心</strong>很重要！刷題的<strong>路徑</strong>也是。</p><p>這意謂著<strong>挫折感不能太多</strong>，不然容易半途而廢。</p><p>這些精心挑選的題目，涵蓋了各種基本且常見的演算法和資料結構，讓我們能夠系統性地提升自己，循序漸進。</p><p>這裡，我要介紹兩個廣受歡迎的題單：<a href="https://www.techinterviewhandbook.org/grind75/">Grind 75</a> 和 <a href="https://neetcode.io/practice">NeetCode 150</a>。</p><h3 id="Grind-75"><a href="#Grind-75" class="headerlink" title="Grind 75"></a>Grind 75</h3><blockquote><p>A modern Blind 75 you can customize, by the author of Blind 75.</p></blockquote><p>由 Blind 75——可能是史上最知名的 LeetCode 刷題清單——的作者，經過改良之後的新版。</p><p>用網站的方式呈現，而且加入更多功能！不再是固定的 75 題。而是可以讓你依照實際的準備時間，選擇更多（最多 169 題）或更少。</p><p>網站會依照<strong>你設定的條件</strong>，顯示你應該刷哪些題目，以獲得最高的刷題 CP 值。</p><p><img src="https://i.imgur.com/yy8wngp.png" alt="Grind 75"><span class="cap">Grind 75</span></p><p>這是我目前的刷題進度，我選擇了「Group by Weeks」、「Order by Difficulty」，這樣會從 Easy 題目開始一一列給你。</p><h3 id="NeetCode-150"><a href="#NeetCode-150" class="headerlink" title="NeetCode 150"></a>NeetCode 150</h3><blockquote><p>The NeetCode 150 is the Blind 75 plus 75 more problems. It’s a more beginner friendly and comprehensive list.</p></blockquote><p>和上述網站大同小異，這 150 題是以 Blind 75 為基礎加以擴充。</p><p>兩者主要的差別是，作者是個<a href="https://www.youtube.com/@NeetCode">知名 YouTuber</a>。所以這 150 題都有<strong>影片版的題解</strong>，可作為你學習上的參考。</p><p>如果只是單純想要題單，那 Grind 75 應該就足夠了。</p><hr><p>講完了前置準備，我們還有一件事要聊聊。</p><p>本文標題既然叫「<strong>刷題之『道』</strong>」，那就要展現一點<strong>獨特的價值觀</strong>，以符合「<strong>道</strong>」這個字的重量與意涵。</p><p>而我認為，這其中的道，關鍵就在於——<strong>如何與 AI 互動</strong>。</p><h2 id="AI-的兩種用法：快與慢"><a href="#AI-的兩種用法：快與慢" class="headerlink" title="AI 的兩種用法：快與慢"></a>AI 的兩種用法：快與慢</h2><p>我將 AI 的使用方式（互動模式） 分為兩種：「快速模式」和「深度模式」。</p><h3 id="快速模式"><a href="#快速模式" class="headerlink" title="快速模式"></a>快速模式</h3><p>所謂的「<strong>快速模式</strong>」，就是讓 AI 幫你做那些，人類做起來很慢、很無聊，但機器做卻非常輕鬆的活。</p><p>大概就是各式各樣<strong>需要自動化的繁瑣任務</strong>，比如整理報表、改錯字之類的。</p><p>不用說，這類的需求還挺多的。</p><p>甚至你有一個程式開發上的需求，想知道怎麼寫，直接問它，叫它給出程式碼——<strong>直接拿來用，而不管其中的原理</strong>。這也是一種「<strong>快</strong>」。</p><p>簡言之，所謂的「快」，就是讓 AI「<strong>代替</strong>」你做事——包括<strong>思考</strong>。</p><h3 id="深度模式"><a href="#深度模式" class="headerlink" title="深度模式"></a>深度模式</h3><p>AI 可以代替你做很多事——通常是那些你<strong>不喜歡做</strong>的事。</p><p>但它（就目前而言）還不能<strong>代替你學習</strong>。所以學習「本身」往往不適用於快速模式。</p><p>AI 確實已經學會了！<strong>但你還沒</strong>。</p><p>而「<strong>深度模式</strong>」則是與 AI 進行<strong>深入的對話與討論</strong>，以獲得<strong>更全面的理解</strong>。</p><p>這個模式下，我們要的<strong>不僅僅是答案</strong>，而是探索<strong>問題的本質</strong>和<strong>背後的原理</strong>。通過與 AI 進行深度交流，我們可以激發新的思考，發現自己思維中的盲點，最終達到<strong>更高的學習層次</strong>。</p><p>如同我在「<a href="/about/#AI-%E6%99%82%E4%BB%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%80%85">AI 時代的工作者</a>」中說的，這是我喜歡，也是我使用 AI 的<strong>主要方式</strong>。</p><blockquote><p>相關文章：<a href="/myth-of-ai-writing-efficiency/">AI 讓寫作變輕鬆了？我可不這麼認為</a></p></blockquote><hr><p>快速模式適用於需要<strong>立刻解決問題</strong>或<strong>取得資訊</strong>的情況，而深度模式則適合<strong>深刻的理解和學習</strong>。</p><p>在刷題過程中，我們可以靈活運用這兩種模式（但<strong>主軸</strong>仍是深度模式），以達到最佳的學習效果。</p><h2 id="我的刷題原則與價值觀"><a href="#我的刷題原則與價值觀" class="headerlink" title="我的刷題原則與價值觀"></a>我的刷題原則與價值觀</h2><p>如前所述，這一篇我們還不會講到具體的做法， 但可以先解釋一些<strong>原則與價值觀</strong>。</p><p>這是我目前刷題的基本原則：</p><ul><li>每天只刷一題。</li><li>每天只刷一小時。</li><li>每一題要盡可能深入理解、釐清細節，或嘗試不同的做法。</li></ul><p>這也是為何這個方法<strong>並不適合</strong>現在就要透過大量刷題來求職的人——它更多是為了長遠打算。</p><h3 id="多多益善？"><a href="#多多益善？" class="headerlink" title="多多益善？"></a>多多益善？</h3><p>你可能會覺得：「那我一天刷 2 小時，每小時刷 2 題，這樣一天就可以做 4 題了！」</p><p>這我不反對，但也不建議。因為太在意刷題的「<strong>數量</strong>」可能會導致淺層學習，無法真正掌握核心概念。</p><p>更重要的是，長時間、高強度的刷題，容易造成<strong>疲勞和厭煩感</strong>，反而降低學習效率——甚至<strong>放棄</strong>。</p><h3 id="少則得"><a href="#少則得" class="headerlink" title="少則得"></a>少則得</h3><p>我是這樣想的：顯然我不太熱衷於刷題，更喜歡做具體的專案。</p><p>所以<strong>這輩子</strong>可能就<strong>只會完成</strong> NeetCode 150 或 Grind 75 的最大題數（169 題）。對於「熟悉常見演算法與資料結構」這個命題，我認為這些題目已經足夠。</p><p>既然如此，求快就不是重點，數量當然也不是。</p><p>同時我們還要考慮到「<strong>複習</strong>」，畢竟好的學習肯定包含了<strong>有效的複習</strong>。做的題目不多，對複習反而是一大<strong>優勢</strong>，至少心理上不會那麼猶豫。</p><p>最後補充 Grind 75 作者在 <a href="https://www.techinterviewhandbook.org/grind75/faq">FAQ</a> 中的最後一道問答，很能表達我的想法：</p><blockquote><p>Will you add more questions in future?（問題）</p></blockquote><blockquote><p>You have time to do more than 169 questions?! <strong>The returns on doing questions beyond this list is diminishing and not very recommended.</strong> But if there’s high demand, I could add more.（回答）</p></blockquote><p>少則得，多則惑。</p><hr><h2 id="上篇結語"><a href="#上篇結語" class="headerlink" title="上篇結語"></a>上篇結語</h2><p>本文探討了刷題的準備工作、基本原則和價值觀。</p><p>我們介紹了一些有用的資源，比如《Hello 演算法》 或 Grind 75。還討論了為什麼我不打算追求刷題的數量，並解釋了背後的思維。</p><p>這些看法不免存在著個人偏好，但也有一定的普世價值。</p><p>每個人都有自己的學習風格和目標，對於希望深入理解演算法，而不僅僅是為了應付面試的人來說，本文應該會是個不錯的參考。</p><p>下篇中，我將介紹具體的刷題策略和技巧，以及如何運用 AI 助手來最大化我們的學習成果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/g9WO9S7.jpeg&quot;&gt;&lt;/p&gt;
&lt;!-- ![picture 2](https://i.imgur.com/SsRLsJl.jpeg) --&gt;

&lt;p&gt;最近，我剛結束了 iThome 鐵人賽的寫作之旅——真是不輕鬆，但值得！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;/django-ninja-30/&quot;&gt;Django Ninja 30：系列回顧與完賽心得&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;隨著比賽結束，我開始進入&lt;strong&gt;求職準備&lt;/strong&gt;的第二階段——學習演算法（主要是 LeetCode 刷題）和系統設計。&lt;/p&gt;
&lt;p&gt;老實說，我一直很排斥刷 LeetCode，因為感覺很「填鴨」，一點也不吸引人。&lt;/p&gt;
&lt;p&gt;這可能是因為這件事和求職面試掛勾，所以讓人有壓力；又或者我還沒有真正領略資料結構與演算法之美。&lt;/p&gt;
&lt;p&gt;總之，&lt;strong&gt;我很逃避！&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;但這次不同了。&lt;/p&gt;
&lt;p&gt;我找到了一個全新的方法，讓刷題&lt;strong&gt;不再那麼痛苦&lt;/strong&gt;，還幫助我盡可能理解每一道題——這都要歸功於 AI。&lt;/p&gt;
&lt;p&gt;我將分享如何透過 &lt;strong&gt;AI 輔助&lt;/strong&gt;來提升刷 LeetCode 的學習效果。關鍵是——它讓原本枯燥的過程（對我來說）&lt;strong&gt;變得有趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;當然，這樣的方法也有一些「&lt;strong&gt;限制&lt;/strong&gt;」，後續會提及。&lt;/p&gt;
&lt;p&gt;我將這個主題分成上、下兩篇，各有不同的著眼。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/g9WO9S7.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="LeetCode" scheme="https://blog.kyomind.tw/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Django Ninja 30：系列回顧與完賽心得</title>
    <link href="https://blog.kyomind.tw/django-ninja-30/"/>
    <id>https://blog.kyomind.tw/django-ninja-30/</id>
    <published>2024-10-12T03:39:06.000Z</published>
    <updated>2024-10-25T03:49:53.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 30 篇。</p><p>系列最終章，我們的「<strong>Django Ninja 探險</strong>」將暫時告一段落。</p><p>這當然不是結束，畢竟 Django Ninja 還只是一個<strong>相對新的專案</strong>——我對它的未來充滿期待。</p><p>本文將分為兩個部分：</p><ol><li>回顧整個系列，檢視我們在各章中學到的概念與技術——盡可能只提重點。</li><li>分享我在寫作過程中的最大挑戰、對 Django Ninja 的期待，最後則是我的鐵人賽完賽心得。</li></ol><p>受限於篇幅，更多的<strong>幕後花絮、創作細節及個人心得</strong>，我將在與正賽無關的第 31、32 篇中，再行分享。</p><p>此外，我還會不定期更新「<strong>Django Ninja 番外篇</strong>」，補充正篇中未能詳述的內容。有興趣的讀者，<strong>歡迎<a href="https://ithelp.ithome.com.tw/users/20167825/ironman/7451">訂閱本系列</a>或<a href="/subscribe/">本站 email</a>。</strong></p><p>話不多說，我們直接開始。</p><hr><h2 id="一、系列目標與主要學習成果"><a href="#一、系列目標與主要學習成果" class="headerlink" title="一、系列目標與主要學習成果"></a>一、系列目標與主要學習成果</h2><p>回到第 1 篇的開頭，整個系列的目標是：</p><blockquote><p>在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的<strong>基礎實作</strong>，透過<strong>文字教學</strong>與<strong>範例專案</strong>的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。</p></blockquote><p>沒錯，而我們具體做了哪些事呢？</p><h3 id="主要學習成果"><a href="#主要學習成果" class="headerlink" title="主要學習成果"></a>主要學習成果</h3><p>透過本系列，讀者掌握了以下 Django Ninja 核心技能：</p><ol><li>設定 Django Ninja 路由。（卷 7-8）</li><li>處理各種 HTTP 請求及參數——路徑參數、查詢參數、body。（卷 9-12）</li><li>使用 Schema 設計和定義 API 回應的資料結構。（卷 13-16）</li><li>從專案程式碼自動產生 API 文件、透過 Pydantic 驗證資料、有效處理系統拋出的錯誤。（卷 17-22）</li><li>靈活運用進階功能，包括檔案上傳、分頁和資料過濾。（卷 23-27）</li></ol><p>還有最後的身分認證與單元測試。可說是一段<strong>相當完整的旅程</strong>。</p><span id="more"></span><hr><p>其中的精妙與困難，這裡不再贅述。</p><p>讓我們一起回顧，我認為學習 Django Ninja 的一些重點，以及它帶來的<strong>滿足感</strong>——這很重要！</p><h2 id="二、各章節重點回顧"><a href="#二、各章節重點回顧" class="headerlink" title="二、各章節重點回顧"></a>二、各章節重點回顧</h2><p>我們只挑各章節中<strong>特別值得一提</strong>的部分。有我<strong>個人的觀點</strong>。</p><h3 id="第二章：範例專案與環境設定"><a href="#第二章：範例專案與環境設定" class="headerlink" title="第二章：範例專案與環境設定"></a><strong>第二章：範例專案與環境設定</strong></h3><p>本章最重要的，莫過於對「Python 現代開發工具」的介紹。再次推薦「<a href="https://blog.wei-lee.me/posts/tech/2020/02/python-table-manners-series/">Python Table Manners</a>」系列。</p><p>從 Poetry 到 Mypy，我認為這些工具都是現代專案中的<strong>必備要素</strong>。它們各有替代品，你可以選擇自己偏好的工具，只要確保這些要素都已整合到開發流程中。</p><p>我相信，無論 AI 如何發展，專案的「<strong>基礎建設</strong>」總是不可少的。</p><h3 id="第三章第一節：路由"><a href="#第三章第一節：路由" class="headerlink" title="第三章第一節：路由"></a>第三章第一節：路由</h3><p>Django Ninja 的路由設定與傳統的 Django、Django REST framework 有<strong>很大的不同</strong>。</p><p>這部分，後起之秀基本上都向 Flask 首創的「<strong>路由裝飾器</strong>」看齊——優秀的設計，值得相互借鑑、學習🫡</p><p>新寫法不僅更直覺、簡單，還減少了路由設定<strong>分散</strong>在不同檔案的<strong>窘境</strong>。</p><p>不過，路由也因此成了一開始學習 Django Ninja 的<strong>小小門檻</strong>。所以我花了足足兩篇，比較兩者的差異，讓你能更清楚其中的思路與考慮。</p><h3 id="第三章第三節：HTTP-回應"><a href="#第三章第三節：HTTP-回應" class="headerlink" title="第三章第三節：HTTP 回應"></a>第三章第三節：HTTP 回應</h3><p>表面上是講 HTTP 回應，其實重點在介紹 Django Ninja Schema——也就是 Pydantic BaseModel。</p><p>說本節是「<strong>Pydantic 入門</strong>」，一點也不為過。</p><p>而且，對 Pydantic 的了解，其重要性還延伸至 API 文件、資料驗證等後續章節。可說是一切的基礎。</p><p>Django Ninja 用 Schema 來<strong>組織與序列化</strong> HTTP 回應，這與 Django REST framework 使用的<strong>序列化器</strong>，<strong>本質上並無區別</strong>。</p><p>但兩者在<strong>使用思維上的差異</strong>，卻帶給我<strong>截然不同</strong>的體驗。主要見解我已寫在〈卷 15：回應（三）為何不用 ModelSchema？——相比 DRF，我更偏愛 Django Ninja 的理由〉，值得你再三回味。</p><h3 id="第四章：API-文件"><a href="#第四章：API-文件" class="headerlink" title="第四章：API 文件"></a>第四章：API 文件</h3><p>這還有什麼好說的呢？太關鍵了！</p><p>如果沒有「依程式碼、type hints 自動產生 API 文件」這個<strong>殺手級功能</strong>，習慣 Django REST framework 的開發者如我，怎麼會有動力再學習一個<strong>定位類似</strong>的新框架？</p><p><strong>懶就是一切的動力！</strong></p><h3 id="第五章：資料驗證與錯誤處理"><a href="#第五章：資料驗證與錯誤處理" class="headerlink" title="第五章：資料驗證與錯誤處理"></a>第五章：資料驗證與錯誤處理</h3><p>這一章是我的血與淚😂</p><p>Django Ninja 的資料驗證與錯誤處理方式，和 Django REST framework <strong>很不一樣</strong>。更讓我頭痛的是，之前工作中我並非以「最正規」的方式實踐——仍受到 Django REST framework 開發習慣的影響。</p><p>那時還想說：「這也太難用了吧！」——原來是我自己誤解了。為了寫好這 4 篇，我幾乎是<strong>重新學習</strong>。不得不說，有一種<strong>豁然開朗</strong>的感覺。</p><p>因此，你在本系列看到的實作方式，應該是相當合理、道地的用法。結合經驗，那些坑我都幫你踩過了，請勿擔心。</p><hr><p>接下來是<strong>個人心得</strong>部分。</p><h2 id="三、寫作上的最大挑戰"><a href="#三、寫作上的最大挑戰" class="headerlink" title="三、寫作上的最大挑戰"></a>三、寫作上的最大挑戰</h2><p>我覺得，整個系列在創作上的<strong>最大挑戰</strong>，就是要盡可能<strong>搭配</strong> <a href="https://github.com/kyomind/Django-Ninja-Tutorial">GitHub 專案</a>中的<strong>程式碼</strong>，來為文章提供<strong>稱職且連貫的範例</strong>。</p><p>（不用說，這個專案非常歡迎「<strong>來自你的星星</strong>」唷🌟）</p><p>這比單純的舉例要<strong>麻煩許多</strong>，我必須事先規劃整個系列的內容進度，思考 API 實作如何跟每一篇的主題<strong>契合</strong>，讓人有「<strong>帶入感</strong>」。</p><p>此外，還得考慮到敘事上的<strong>連貫性</strong>——程式碼要<strong>循序漸進，從簡單到複雜</strong>，而不能反過來。這樣讀者才能夠順暢地跟著專案一起學習。</p><p>這樣的規劃不僅需要技術知識，更多的是教學思維與<strong>讀者意識</strong>——知道讀者可能會在哪裡「卡關」。</p><p>整體而言，是個<strong>極具挑戰但也非常有趣</strong>的過程。</p><hr><h2 id="四、我對-Django-Ninja-的評價與期待"><a href="#四、我對-Django-Ninja-的評價與期待" class="headerlink" title="四、我對 Django Ninja 的評價與期待"></a>四、我對 Django Ninja 的評價與期待</h2><p>Django Ninja 是烏克蘭開發者 <a href="https://github.com/vitalik">Vitaliy Kucheryaviy</a> 一人維護的開源專案，更新的頻率不高，通常無法立刻回應用戶們的期待。</p><p>但我想說：「如果可以，我真的不願再回去寫 Django REST framework 了。」</p><p>原因只有一個，就是第 15 篇提到的——「<strong>明確優於隱晦</strong>」（Explicit is better than implicit）。</p><p>Django Ninja 也許沒讓開發更「快」，但絕對更透明、更可控。</p><p>我相信，從長遠來看，這種<strong>透明與可控</strong>，能為我們省下的 debug 時間，遠不是簡單的「快」可以比擬的。</p><h3 id="未來期待"><a href="#未來期待" class="headerlink" title="未來期待"></a>未來期待</h3><p>隨著 Django 本身對<strong>非同步</strong>（async）的支援日益增加，我相信 Django Ninja 的潛力正被逐步釋放。</p><p>我期待，在不久的將來，當人們談到「<strong>用 Django 寫 API</strong>」時，不再只有想到 Django REST framework，還會提及這個<strong>強而有力的新選擇——Django Ninja</strong>。</p><hr><h2 id="五、完賽心得"><a href="#五、完賽心得" class="headerlink" title="五、完賽心得"></a>五、完賽心得</h2><p>呼！終於寫完了，這個過程比我想像的更加漫長。</p><p>從 9 月初到雙十節，整整 40 天（含開賽前的備稿），我每天早上醒來就是寫作，全心全意投入到這場盛宴當中。最終，我交出了一份自己也覺得滿意的作品。</p><p>在我看來，寫作的滿足感在於「<strong>提供價值、發揮影響力</strong>」。這份價值不僅是對讀者，也包括對作者自己——透過這 30 篇文章創作，我對 Django Ninja 的理解又增進許多。</p><p>希望這個系列能為你帶來些許價值，讓你在接下來的開發旅程中更加得心應手。</p><p>每一次的寫作都是一次學習，而每一次的學習都是一次成長。這個系列或許已經結束，但我們的軟體工程師之路，還遠遠沒有。</p><p>而且，如果可以，我希望這能成為一生的追求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 30 篇。&lt;/p&gt;
&lt;p&gt;系列最終章，我們的「&lt;strong&gt;Django Ninja 探險&lt;/strong&gt;」將暫時告一段落。&lt;/p&gt;
&lt;p&gt;這當然不是結束，畢竟 Django Ninja 還只是一個&lt;strong&gt;相對新的專案&lt;/strong&gt;——我對它的未來充滿期待。&lt;/p&gt;
&lt;p&gt;本文將分為兩個部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回顧整個系列，檢視我們在各章中學到的概念與技術——盡可能只提重點。&lt;/li&gt;
&lt;li&gt;分享我在寫作過程中的最大挑戰、對 Django Ninja 的期待，最後則是我的鐵人賽完賽心得。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;受限於篇幅，更多的&lt;strong&gt;幕後花絮、創作細節及個人心得&lt;/strong&gt;，我將在與正賽無關的第 31、32 篇中，再行分享。&lt;/p&gt;
&lt;p&gt;此外，我還會不定期更新「&lt;strong&gt;Django Ninja 番外篇&lt;/strong&gt;」，補充正篇中未能詳述的內容。有興趣的讀者，&lt;strong&gt;歡迎&lt;a href=&quot;https://ithelp.ithome.com.tw/users/20167825/ironman/7451&quot;&gt;訂閱本系列&lt;/a&gt;或&lt;a href=&quot;/subscribe/&quot;&gt;本站 email&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;話不多說，我們直接開始。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、系列目標與主要學習成果&quot;&gt;&lt;a href=&quot;#一、系列目標與主要學習成果&quot; class=&quot;headerlink&quot; title=&quot;一、系列目標與主要學習成果&quot;&gt;&lt;/a&gt;一、系列目標與主要學習成果&lt;/h2&gt;&lt;p&gt;回到第 1 篇的開頭，整個系列的目標是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在這個 30 天的系列文章中，我們將詳細探討 Django Ninja 的&lt;strong&gt;基礎實作&lt;/strong&gt;，透過&lt;strong&gt;文字教學&lt;/strong&gt;與&lt;strong&gt;範例專案&lt;/strong&gt;的程式碼，帶你一步一步熟悉這個強大而靈活的 Django API 開發框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;沒錯，而我們具體做了哪些事呢？&lt;/p&gt;
&lt;h3 id=&quot;主要學習成果&quot;&gt;&lt;a href=&quot;#主要學習成果&quot; class=&quot;headerlink&quot; title=&quot;主要學習成果&quot;&gt;&lt;/a&gt;主要學習成果&lt;/h3&gt;&lt;p&gt;透過本系列，讀者掌握了以下 Django Ninja 核心技能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定 Django Ninja 路由。（卷 7-8）&lt;/li&gt;
&lt;li&gt;處理各種 HTTP 請求及參數——路徑參數、查詢參數、body。（卷 9-12）&lt;/li&gt;
&lt;li&gt;使用 Schema 設計和定義 API 回應的資料結構。（卷 13-16）&lt;/li&gt;
&lt;li&gt;從專案程式碼自動產生 API 文件、透過 Pydantic 驗證資料、有效處理系統拋出的錯誤。（卷 17-22）&lt;/li&gt;
&lt;li&gt;靈活運用進階功能，包括檔案上傳、分頁和資料過濾。（卷 23-27）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;還有最後的身分認證與單元測試。可說是一段&lt;strong&gt;相當完整的旅程&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="鐵人賽" scheme="https://blog.kyomind.tw/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Django REST framework" scheme="https://blog.kyomind.tw/tags/Django-REST-framework/"/>
    
  </entry>
  
  <entry>
    <title>單元測試——使用 Test Client 與 pytest 測試 API</title>
    <link href="https://blog.kyomind.tw/django-ninja-29/"/>
    <id>https://blog.kyomind.tw/django-ninja-29/</id>
    <published>2024-10-11T02:48:06.000Z</published>
    <updated>2024-11-07T01:44:45.390Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 29 篇。</p><p>「請問你們的專案有單元測試嗎？」</p><p>面試中如果你提出這個問題，可能會讓面試官面有難色。</p><p>測試的重要性，大部分開發者都心知肚明。只是願意認真對待的人未必很多。</p><p>但如果真心想提高程式碼品質、減少 bug，讓專案更容易維護，那單元測試依舊是<strong>不可或缺</strong>的工具。</p><p>良好的測試不僅能幫助我們<strong>及早發現問題</strong>，還能在專案<strong>重構或新增功能</strong>時，確保現有的功能不會被破壞。</p><p>雖然寫測試會增加初期的開發時間，而且維護上也需要花費心力——這本來就不是一件輕鬆的事。但長期而言，它能為專案帶來持續的健全與穩定性。</p><p>所以，我們還是好好寫測試吧！</p><hr><h2 id="本文大綱"><a href="#本文大綱" class="headerlink" title="本文大綱"></a>本文大綱</h2><p>這是整個系列中唯一一篇有全文大綱的教學。</p><p>原因是，本文<strong>要提及的事項較多</strong>，畢竟單元測試這麼大的主題，怎麼可能靠一篇 2500 字的文章說完。限於篇幅，無法一一詳談——但也不能直接省略。</p><p>所以需要有一個供讀者鳥瞰的全文輪廓，讓你更容易了解、吸收。大綱如下：</p><ol><li>單元測試的理想與現實。</li><li>Django API 測試重要概念說明。<ul><li>Test Client 的意義與用途。</li><li>pytest 和 pytest-django 簡介。</li><li>pytest fixtures 與測試函式。</li></ul></li><li>測試程式碼的實作與解說。</li><li>結語。</li></ol><p>簡單來說，本文不會講解所有的程式碼改動，而是在<strong>必要時提及</strong>。其餘部分，由我直接實作並收錄在範例專案中，讓讀者自行參考。</p><p>在有限的篇幅中，帶你了解<strong>整體概念</strong>比關注細節更重要。當你掌握了基本概念，再去看程式碼會更加得心應手。</p><p>有關單元測試的<strong>更多討論</strong>，歡迎參考這篇心得〈<a href="https://blog.kyomind.tw/python-craftsman-02/">為什麼你「應該」寫單元測試——《Python 工匠》筆記</a>〉。這是一本立論紮實的好書，相信你會有所收獲。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/20">這個 PR</a>。</p><span id="more"></span><hr><h2 id="一、單元測試的理想與現實"><a href="#一、單元測試的理想與現實" class="headerlink" title="一、單元測試的理想與現實"></a>一、單元測試的理想與現實</h2><p>我覺得，討論單元測試，就必須先<strong>直面現實</strong>。</p><p>在軟體測試領域，充斥著各種關於測試的狂熱與教條主義，有時反而讓人卻步。</p><h3 id="單元測試的理想"><a href="#單元測試的理想" class="headerlink" title="單元測試的理想"></a>單元測試的理想</h3><p>理論上，撰寫單元測試應該是每位開發者都要做的事（我確實是這麼想的） 。</p><p>此外，還有「<a href="https://zh.wikipedia.org/zh-tw/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">測試驅動開發</a>（TDD）」的理念，這是一種以測試為主導的開發模式，要求在撰寫功能程式碼之前，先撰寫測試。</p><p>甚至有少部分人認為，測試覆蓋率就是要 100%。因為如果不是 100%，比如 70%，那我們就可以問：「為什麼不是其它數字？」</p><h3 id="現實：大部分人不在乎那些理想"><a href="#現實：大部分人不在乎那些理想" class="headerlink" title="現實：大部分人不在乎那些理想"></a>現實：大部分人不在乎那些理想</h3><p>然而，現實中，我們很少能看到理想的測試——甚至常常沒有測試。</p><p>現實中的專案因為時間、資源等諸多限制，往往不願投入心力去撰寫測試。</p><p>一些老舊專案，由於前期沒有測試基礎，後續要再補上測試變得更加困難（畢竟都亂成一團💩了），這就是我們常說的「<strong>技術債</strong>」。</p><p>再者，過度的「測試理想主義」有時也會讓初學者<strong>望而卻步</strong>。許多新手在接觸測試時，會擔心自己無法達到 100% 的覆蓋率，因此對測試產生了<strong>抗拒</strong>或<strong>懷疑</strong>。</p><p>這樣的完美主義往往有害無利，我們需要在理想與現實之間找到一個<strong>折衷</strong>。</p><h3 id="折衷：務實的測試策略"><a href="#折衷：務實的測試策略" class="headerlink" title="折衷：務實的測試策略"></a>折衷：務實的測試策略</h3><p>在實際開發中，我們應秉持著一個<strong>實用且可行</strong>的測試策略，重點放在測試專案中最核心的功能，例如 API 的呼叫與 200 回應。</p><p>多數情況下，只要能覆蓋 <strong>60-70%</strong> 功能，就已經能<strong>明顯提高</strong>專案程式碼的品質，並為後續開發提供一定的<strong>安全感</strong>——這真的很重要。</p><p>不必追求完美的測試覆蓋率，只要<strong>願意開始行動</strong>，測試就能發揮它<strong>應有的價值</strong>。</p><hr><h2 id="二、Django-API-測試重要概念說明"><a href="#二、Django-API-測試重要概念說明" class="headerlink" title="二、Django API 測試重要概念說明"></a>二、Django API 測試重要概念說明</h2><p>回到專案本身。</p><p>雖然本文無法提及太多 API 單元測試的具體細節，但重要的概念仍不可略過。以下一一說明。</p><h3 id="Test-Client-的意義與用途"><a href="#Test-Client-的意義與用途" class="headerlink" title="Test Client 的意義與用途"></a>Test Client 的意義與用途</h3><p>Test client 對 API 的測試至關重要，因為它能模擬真實的 HTTP 請求——注意，只是模擬。</p><p>API 測試和一般的程式碼測試<strong>略有不同</strong>，一般的測試，只要寫好相關的測試函式、邏輯並執行即可。但在 API 測試中，還需要一個「<strong>假的客戶端</strong>」來模擬請求的發送。</p><p>手動測試 API，我們通常會使用 API client，比如 Postman。而自動化的單元測試，則需要把這個「假的客戶端」直接寫在測試程式碼中——即 test client。</p><p>它相當於一個「<strong>專案內部的 API client</strong>」，而且能<strong>自動執行</strong>。</p><p>Django Ninja 有提供自己的 <a href="https://github.com/vitalik/django-ninja/blob/master/ninja/testing/client.py">test client</a>，但我建議你先不要用，因為它還<strong>不夠健全</strong>。</p><p>在範例專案中，我使用的是 Django 內建的 <a href="https://docs.djangoproject.com/en/5.1/topics/testing/tools/#the-test-client">test client</a>——歷史悠久、穩定可靠。</p><h3 id="pytest-簡介"><a href="#pytest-簡介" class="headerlink" title="pytest 簡介"></a>pytest 簡介</h3><p><a href="https://docs.pytest.org/en/stable/">pytest</a>（對，它的 p 是小寫，同 <a href="https://github.com/pyenv/pyenv">pyenv</a>）是一個廣受歡迎的 Python 測試框架，擁有自己的<strong>生態系</strong>——包含大量實用的外掛。</p><p>相較於 Python 內建的<code>unittest</code>模組，pytest 的<strong>語法更直觀</strong>、使用上的靈活性更好。尤其是它的 <strong>fixtures</strong>、<strong>參數化測試</strong>等功能，讓測試的撰寫更加簡單、高效。</p><h3 id="pytest-django"><a href="#pytest-django" class="headerlink" title="pytest-django"></a>pytest-django</h3><p><a href="https://pytest-django.readthedocs.io/en/latest/">pytest-django</a> 是一個專為 Django 設計的 pytest 整合套件。它提供了豐富的 Django 整合功能，包括許多內建的 fixtures 和實用的裝飾器。</p><p>其中又以<code>@pytest.mark.django_db</code>裝飾器最常用，它能自動管理測試過程中的<strong>資料庫狀態</strong>。</p><p>它讓 pytest 在每次測試執行前自動建立一個全新的資料庫，並在測試結束後刪除。這確保每次測試的<strong>環境一致</strong>，防止<strong>資料殘留</strong>導致的測試結果不準確。</p><h3 id="pytest-Fixtures-與測試函式"><a href="#pytest-Fixtures-與測試函式" class="headerlink" title="pytest Fixtures 與測試函式"></a>pytest Fixtures 與測試函式</h3><p><a href="https://docs.pytest.org/en/stable/fixture.html">Fixtures</a> 是 pytest 提供的一種<strong>機制</strong>，用來<strong>設定</strong>測試所需的<strong>初始環境</strong>。它們本質上是<strong>函式</strong>，但用法卻不像一般的函式。只要事先定義好，即可在測試函式中<strong>作為參數引用</strong>。</p><p>Fixtures 可以定義在 Django app 的<code>tests.py</code>中，但我們通常將它們放在可供全專案共用的<code>conftest.py</code>模組。</p><p>測試 API 時，我們經常需要一些初始資料，例如使用者、產品等。這些資料可以<strong>透過 fixtures 自動產生</strong>，無需每次手動重建。</p><p>如此一來，撰寫測試的效率提高，還避免了重複的狀態設定。</p><hr><h2 id="五、測試程式碼實作與解說"><a href="#五、測試程式碼實作與解說" class="headerlink" title="五、測試程式碼實作與解說"></a>五、測試程式碼實作與解說</h2><p>本篇我實作 3 個 fixture 和 3 個測試函式，它們都與 user 有關，容我<strong>擇要</strong>解說其中的細節。</p><h3 id="強大而靈活的-pytest-Fixtures"><a href="#強大而靈活的-pytest-Fixtures" class="headerlink" title="強大而靈活的 pytest Fixtures"></a>強大而靈活的 pytest Fixtures</h3><p>這是專案的 3 個 fixture，定義在<code>conftest.py</code>中：（為減少篇幅我省略了 docstring）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> Client</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&#x27;session&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client</span>() -&gt; Client:</span><br><span class="line">    <span class="keyword">return</span> Client()</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>() -&gt; User:</span><br><span class="line">    <span class="keyword">return</span> User.objects.create_user(</span><br><span class="line">        username=<span class="string">&#x27;testuser&#x27;</span>,</span><br><span class="line">        email=<span class="string">&#x27;testuser@example.com&#x27;</span>,</span><br><span class="line">        password=<span class="string">&#x27;testpassword123&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticated_client</span>(<span class="params">client: Client, user: User</span>) -&gt; Client:</span><br><span class="line">    response = client.post(</span><br><span class="line">        <span class="string">&#x27;/users/login/&#x27;</span>,</span><br><span class="line">        &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;testuser&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;testpassword123&#x27;</span>&#125;,</span><br><span class="line">        content_type=<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">    <span class="comment"># 設定登入後的 cookies</span></span><br><span class="line">    client.cookies.update(response.cookies)</span><br><span class="line">    <span class="keyword">return</span> client</span><br></pre></td></tr></table></figure><p>在這段程式碼中：</p><ol><li><code>client</code>：提供了一個可以用來模擬發送請求的 Django test client。（未認證）</li><li><code>user</code>：自動建立一個測試用的使用者，供測試函式甚至<strong>其它 fixture</strong> 引用。</li><li><code>authenticated_client</code>：引用上述的 2 個 fixture，組合並模擬了一個<strong>登入過的 client</strong>，這樣才能測試那些有「認證保護」的 API。</li></ol><p>Fixtures 的<strong>定義、組合與使用</strong>，是 pytest 的<strong>一大特色</strong>。</p><p>不僅能簡化測試的環境設定，還能提高測試程式碼的可讀性——把<strong>測試狀態</strong>和<strong>測試邏輯</strong>分開，這也是一種「<strong>關注點分離</strong>」。</p><p>在實際的測試函式中，我們只需要將所需的 fixtures <strong>作為參數傳入</strong>，pytest 會<strong>自動處理</strong>它們的<strong>初始化和清理</strong>工作。</p><p>這種設計大大減少了重複程式碼，讓測試更加<strong>專注於</strong> API 的邏輯驗證而非環境設定。</p><h3 id="測試函式"><a href="#測試函式" class="headerlink" title="測試函式"></a>測試函式</h3><p>最後是測試函式，我們看其中的兩個就好：（我省略了參數的 type hints，讓你聚焦於 fixtures 本身）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_get_users</span>(<span class="params">authenticated_client</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    測試取得所有使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = authenticated_client.get(<span class="string">&#x27;/users/&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_login_user</span>(<span class="params">client, user</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    測試登入使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = client.post(</span><br><span class="line">        <span class="string">&#x27;/users/login/&#x27;</span>,</span><br><span class="line">        data=&#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;testuser&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;testpassword123&#x27;</span>&#125;,</span><br><span class="line">        content_type=<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure><p>選擇這兩個函式是有<strong>教學用意</strong>的：</p><ol><li><code>test_login_user</code>函式測試「使用者登入」API，該 API 是給「<strong>未登入</strong>」的用戶存取，所以引用<strong>一般的 client</strong>（未認證）即可。<ul><li>函式也引用了 user fixture，因為登入成功的前提是：該用戶已經「<strong>存在</strong>」。</li><li>而 user fixture 的作用正是在測試開始前，<strong>先建立</strong>該用戶。</li></ul></li><li><code>test_get_users</code>測試的是「<strong>有認證保護</strong>」的 API，需要登入才能存取，所以我們引用了<code>authenticated_client</code>。<ul><li>這個測試函式「<strong>只有</strong>」引用 authenticated_client，但實際的測試結果會是：清單中存在一個用戶。（程式碼不包含這部分）</li><li>因為 authenticated_client 引用了 user 和 client 這兩個 fixture。所以<strong>只要</strong>引用了authenticated_client，<strong>就相當於引用了上述二者</strong>。</li></ul></li></ol><p>該「<strong>引用</strong>」哪些 fixture，就看各函式需要什麼樣的<strong>測試狀態與條件</strong>。</p><p>Fixtures 本身可以重複使用，這樣的設計讓測試本身也非常「<strong>模組化</strong>」——這是 pytest 如此受歡迎的原因之一。</p><h3 id="執行單元測試"><a href="#執行單元測試" class="headerlink" title="執行單元測試"></a>執行單元測試</h3><p>最後，來跑一下測試！</p><p>你可以在專案的根目錄直接使用<code>pytest</code>指令，或透過 VS Code 的 Testing UI 來執行單元測試：</p><p><img src="https://i.imgur.com/OtM4FXn.png" alt="VS Code - Testing"><span class="cap">VS Code - Testing</span></p><p>Beautiful！</p><hr><h2 id="六、結語"><a href="#六、結語" class="headerlink" title="六、結語"></a>六、結語</h2><p>理想與現實總有差距，透過務實的測試策略，我們可以在不過度追求完美的前提下，為專案提供足夠的品質保證。</p><p>Test client 和 pytest 等工具，讓 API 測試變得簡單、有條理。測試覆蓋率不必是百分之百，只要能達到<strong>一定水準</strong>，就可以為開發過程帶來<strong>巨大的助力</strong>。</p><p>本系列教學<strong>已接近尾聲</strong>。我們探討了 Django Ninja 的核心功能與進階特性——從路由設計到單元測試。這是一個<strong>辛苦但充實</strong>的過程——無論對你我而言。</p><p>下一篇，也就是最後一篇。我們要簡單回顧整個系列，並分享我在本次鐵人賽的創作與完賽心得。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 29 篇。&lt;/p&gt;
&lt;p&gt;「請問你們的專案有單元測試嗎？」&lt;/p&gt;
&lt;p&gt;面試中如果你提出這個問題，可能會讓面試官面有難色。&lt;/p&gt;
&lt;p&gt;測試的重要性，大部分開發者都心知肚明。只是願意認真對待的人未必很多。&lt;/p&gt;
&lt;p&gt;但如果真心想提高程式碼品質、減少 bug，讓專案更容易維護，那單元測試依舊是&lt;strong&gt;不可或缺&lt;/strong&gt;的工具。&lt;/p&gt;
&lt;p&gt;良好的測試不僅能幫助我們&lt;strong&gt;及早發現問題&lt;/strong&gt;，還能在專案&lt;strong&gt;重構或新增功能&lt;/strong&gt;時，確保現有的功能不會被破壞。&lt;/p&gt;
&lt;p&gt;雖然寫測試會增加初期的開發時間，而且維護上也需要花費心力——這本來就不是一件輕鬆的事。但長期而言，它能為專案帶來持續的健全與穩定性。&lt;/p&gt;
&lt;p&gt;所以，我們還是好好寫測試吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文大綱&quot;&gt;&lt;a href=&quot;#本文大綱&quot; class=&quot;headerlink&quot; title=&quot;本文大綱&quot;&gt;&lt;/a&gt;本文大綱&lt;/h2&gt;&lt;p&gt;這是整個系列中唯一一篇有全文大綱的教學。&lt;/p&gt;
&lt;p&gt;原因是，本文&lt;strong&gt;要提及的事項較多&lt;/strong&gt;，畢竟單元測試這麼大的主題，怎麼可能靠一篇 2500 字的文章說完。限於篇幅，無法一一詳談——但也不能直接省略。&lt;/p&gt;
&lt;p&gt;所以需要有一個供讀者鳥瞰的全文輪廓，讓你更容易了解、吸收。大綱如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;單元測試的理想與現實。&lt;/li&gt;
&lt;li&gt;Django API 測試重要概念說明。&lt;ul&gt;
&lt;li&gt;Test Client 的意義與用途。&lt;/li&gt;
&lt;li&gt;pytest 和 pytest-django 簡介。&lt;/li&gt;
&lt;li&gt;pytest fixtures 與測試函式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;測試程式碼的實作與解說。&lt;/li&gt;
&lt;li&gt;結語。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;簡單來說，本文不會講解所有的程式碼改動，而是在&lt;strong&gt;必要時提及&lt;/strong&gt;。其餘部分，由我直接實作並收錄在範例專案中，讓讀者自行參考。&lt;/p&gt;
&lt;p&gt;在有限的篇幅中，帶你了解&lt;strong&gt;整體概念&lt;/strong&gt;比關注細節更重要。當你掌握了基本概念，再去看程式碼會更加得心應手。&lt;/p&gt;
&lt;p&gt;有關單元測試的&lt;strong&gt;更多討論&lt;/strong&gt;，歡迎參考這篇心得〈&lt;a href=&quot;https://blog.kyomind.tw/python-craftsman-02/&quot;&gt;為什麼你「應該」寫單元測試——《Python 工匠》筆記&lt;/a&gt;〉。這是一本立論紮實的好書，相信你會有所收獲。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/20&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="單元測試" scheme="https://blog.kyomind.tw/tags/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"/>
    
    <category term="pytest" scheme="https://blog.kyomind.tw/tags/pytest/"/>
    
  </entry>
  
  <entry>
    <title>身分認證——Session 認證與全域設定</title>
    <link href="https://blog.kyomind.tw/django-ninja-28/"/>
    <id>https://blog.kyomind.tw/django-ninja-28/</id>
    <published>2024-10-10T01:42:57.000Z</published>
    <updated>2024-10-24T10:02:55.937Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 28 篇。</p><p>歡迎來到第七章！本章總共有兩篇內容：</p><ul><li>卷 28：身分認證——Session 認證與全域設定</li><li>卷 29：單元測試——使用 Test Client 與 pytest 測試 API</li></ul><p>這些主題的核心功能，<strong>並非由 Django Ninja 實作</strong>，但框架仍提供了<strong>一定程度的整合</strong>。並且，這些功能對於任何 Django 專案來說，都至關重要。</p><p>本文介紹幾乎所有 API 專案都需要的——<strong>身分認證</strong>（<a href="https://django-ninja.dev/guides/authentication/">Authentication</a>）。</p><p>我們將探討如何在 Django Ninja 中利用 Django 內建的 session-based 認證，實現完整的登入驗證功能，並進一步說明如何設定<strong>全域認證</strong>，以減少程式碼的重複。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/19">這個 PR</a>。</p><hr><h2 id="認證的兩個層次"><a href="#認證的兩個層次" class="headerlink" title="認證的兩個層次"></a>認證的兩個層次</h2><p>進入實作前，我們要先了解，所謂的<strong>身分認證</strong>，究竟代表什麼。</p><p>以「帳號密碼 + session 認證」為例，身分認證的範圍主要涵蓋<strong>兩個階段</strong>。</p><p>首先，當使用者透過帳號密碼進行登入時，系統會檢查這些內容、確認身分<strong>合法</strong>。登入成功後，系統會將使用者資訊（比如用戶 id）儲存至 session，以<strong>維持登入狀態</strong>。</p><p>這是<strong>登入時的認證</strong>，也是我們最常說的認證。（<strong>狹義的認證</strong>）</p><p>接著，當使用者嘗試存取受「<strong>認證保護</strong>」的 API 時，系統會檢查 session 並確認身分，確保每個 API 請求都來自<strong>合法登入</strong>的使用者。</p><p>簡言之：</p><ul><li>第一階段：初次登入時的身分確認。</li><li>第二階段：後續請求時的身分確認。</li></ul><p>兩個層次相輔相成、一體兩面，確保服務能夠在使用者<strong>登入</strong>和<strong>後續操作</strong>中，提供適當的安全保障。</p><span id="more"></span><hr><h2 id="實作「使用者登入」API"><a href="#實作「使用者登入」API" class="headerlink" title="實作「使用者登入」API"></a>實作「使用者登入」API</h2><p>了解了上述兩個層次後，我們要先來實作「<strong>狹義</strong>」的認證——也就是<strong>登入驗證</strong>本身。</p><p>我們將建立一個「使用者登入」API，並直接透過 Django 的<code>authenticate</code>和<code>login</code>函式處理<strong>帳號密碼驗證</strong>和<strong>登入狀態</strong>——非常方便！</p><p><code>authenticate</code>用來<strong>驗證</strong>使用者輸入的帳號（<code>username</code>）和密碼是否正確，<code>login</code>則將使用者的登入狀態<strong>儲存</strong>至 session。</p><h3 id="程式碼實作"><a href="#程式碼實作" class="headerlink" title="程式碼實作"></a>程式碼實作</h3><p>先新增一個登入請求 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/schemas.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    username: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line">    password: <span class="built_in">str</span> = Field(examples=[<span class="string">&#x27;password123&#x27;</span>])</span><br></pre></td></tr></table></figure><p>然後是 view 函式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate, login</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> user.schemas <span class="keyword">import</span> CreateUserRequest, LoginRequest</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&#x27;/users/login/&#x27;</span>, summary=<span class="string">&#x27;登入使用者&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_user</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest, payload: LoginRequest</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    登入使用者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    user = authenticate(</span><br><span class="line">        request,</span><br><span class="line">        username=payload.username,</span><br><span class="line">        password=payload.password</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        login(request, user)  <span class="comment"># 將使用者登入狀態儲存至 session</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;登入成功&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">401</span>, <span class="string">&#x27;帳號或密碼錯誤&#x27;</span>)</span><br></pre></td></tr></table></figure><p>非常簡單！</p><p>附帶一提，我不太喜歡程式中有「不必要」的<code>else</code>，此時的寫法仍不盡理想——因為<code>else</code><strong>完全可以省略</strong>。</p><p>在最新的程式碼中，你可以看到我已改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = authenticate(...)</span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> HttpError(<span class="number">401</span>, <span class="string">&#x27;帳號或密碼錯誤&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login(request, user)  <span class="comment"># 將使用者登入狀態儲存至 session</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;登入成功&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>這樣的做法即所謂的 <a href="https://zh.wikipedia.org/zh-tw/%E5%8D%AB%E8%AF%AD%E5%8F%A5">Guard Clause</a> 或 <a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/early-return-coding-skill-9f3016d4b88d">Early Return</a>（雖然這裡是 raise）。</p><h3 id="簡評與重要補充"><a href="#簡評與重要補充" class="headerlink" title="簡評與重要補充"></a>簡評與重要補充</h3><p><code>authenticate</code>和<code>login</code>的用法幾乎是固定的，很容易理解：</p><ul><li><code>authenticate</code>在驗證成功時會 return 對應的<code>User</code>物件，失敗時則返回<code>None</code>。</li><li><code>login</code>不會 return，但<code>request</code>和<code>user</code>為必要的參數。</li></ul><p>成功登入後，你會得到 200 回應，並獲得兩組 cookie：</p><p><img src="https://i.imgur.com/c6gMBDY.png"></p><p>這對於 API client（比如 Postman）使用者很重要，畢竟瀏覽器會自動幫你存，但這些工具可不會——好吧，我錯了，至少我用的 RapidAPI 會<strong>自動存儲、發送</strong>！</p><p>（我測試 API 時還覺得奇怪，怎麼認證防護都失效了🤣）</p><p>如果工具沒有幫你做，記得自己在請求的 headers 加上：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/users/2/avatar/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">...</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>csrftoken=...; sessionid=...</span><br><span class="line"><span class="attribute">X-CSRFToken</span><span class="punctuation">: </span>...</span><br></pre></td></tr></table></figure><p><code>authenticate</code>預設是以<code>AbstractUser</code>的<code>username</code>欄位和密碼作為認證基準，如果想用別的欄位，比如<code>email</code>，則要自己覆寫 Django 的認證後端。</p><hr><h2 id="為-API-加上「認證保護」"><a href="#為-API-加上「認證保護」" class="headerlink" title="為 API 加上「認證保護」"></a>為 API 加上「認證保護」</h2><p>登入功能完成後，接下來要將「需要登入才能存取」的 API，分別加上<strong>認證保護</strong>，使用 Django Ninja 提供的<code>django_auth</code>——這是專門給 Django 內建的 session 認證使用。</p><p>我們以「上傳 avatar」API 為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja.security <span class="keyword">import</span> django_auth</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    path=<span class="string">&#x27;/users/&#123;int:user_id&#125;/avatar/&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    summary=<span class="string">&#x27;上傳 avatar&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    auth=django_auth  <span class="comment"># 加上這組參數</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br></pre></td></tr></table></figure><p>這個例子中，<code>auth=django_auth</code>確保只有「已登入的使用者」才能存取此 API，否則將得到 401 或 403 回應。</p><hr><h2 id="Django-Ninja-的-request-auth"><a href="#Django-Ninja-的-request-auth" class="headerlink" title="Django Ninja 的 request.auth"></a>Django Ninja 的 request.auth</h2><p>但你可能會想到：</p><blockquote><p>光是驗證「已登入」還不夠吧？</p></blockquote><p>「上傳 avatar」應該只能幫「<strong>自己</strong>」上傳，總不能幫「<strong>別人</strong>」上傳大頭照吧！</p><p>沒錯，所以我們在 <strong>view 函式內部</strong>，還要<strong>多一層驗證</strong>。</p><h3 id="Django-的request-user"><a href="#Django-的request-user" class="headerlink" title="Django 的request.user"></a>Django 的<code>request.user</code></h3><p>傳統的 Django 專案，我們會透過函式的第一參數——<code>request</code>，用<code>request.user</code>來獲得<strong>當前使用者資訊</strong>，比如：（參考<a href="https://docs.djangoproject.com/en/5.1/topics/auth/default/#authentication-in-web-requests">文件</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.user.is_authenticated:</span><br><span class="line">    <span class="comment"># Do something for authenticated users.</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Do something for anonymous users.</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>具體來說：</p><ul><li>當使用者已登入，<code>request.user</code>會是一個<code>User</code>實例，代表<strong>當前登入的使用者</strong>。</li><li>未登入時，<code>request.user</code>則是一個<code>AnonymousUser</code>實例，代表<strong>未登入使用者</strong>。</li></ul><p>當使用者已登入，我們可以檢查<code>request.user</code>的屬性，比如<code>request.user.id</code>，來確認<strong>是否為「本人」</strong>。</p><h3 id="Django-Ninja-的request-auth"><a href="#Django-Ninja-的request-auth" class="headerlink" title="Django Ninja 的request.auth"></a>Django Ninja 的<code>request.auth</code></h3><p>但寫 Django Ninja 則需要使用它提供的<code>request.auth</code>，實作結果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_avatar</span>(<span class="params">...</span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上傳 avatar</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 檢查登入的使用者是否為「本人」</span></span><br><span class="line">    <span class="keyword">if</span> request.auth.<span class="built_in">id</span> != user_id:</span><br><span class="line">        <span class="keyword">raise</span> HttpError(<span class="number">403</span>, <span class="string">&#x27;無權限上傳其他使用者的 avatar&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>測試一下，登入後在 URL path 打別人的 id 來呼叫此 API：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 403 Forbidden</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;無權限上傳其他使用者的 avatar&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>非常好！</p><hr><h2 id="request-auth-解析"><a href="#request-auth-解析" class="headerlink" title="request.auth 解析"></a>request.auth 解析</h2><p>雖然這裡用<code>request.auth</code>來取代<code>request.user</code>，但其實兩者的內涵有<strong>很大的不同</strong>。</p><p>在 Django Ninja 中，<code>request.auth</code>代表的是<strong>認證流程 return 的結果</strong>。此外，Django Ninja 允許你<strong>自定義認證方法</strong>，所以<code>request.auth</code>的內容是<strong>不固定的</strong>。</p><p>讓我們深入了解一下。</p><h3 id="認證結果"><a href="#認證結果" class="headerlink" title="認證結果"></a>認證結果</h3><p><code>request.auth</code>包含了<strong>當前認證方法</strong>返回的值。</p><ul><li>這個值可以是<strong>任何類型</strong>，取決於你<strong>如何實現認證邏輯</strong>。</li><li>這給了開發者極大的靈活性，它可以是<code>User</code>物件、字串、Python 字典等等。</li></ul><h3 id="認證方法與常見用例"><a href="#認證方法與常見用例" class="headerlink" title="認證方法與常見用例"></a>認證方法與常見用例</h3><ul><li>使用 Django 的 session 認證時，<code>request.auth</code>是 Django 的<code>User</code>物件。</li><li>對於 API key 認證，<code>request.auth</code>可能是 API key 本身或與之相關的資訊。</li><li>在 JWT 認證中，<code>request.auth</code>可能包含解碼後的 token 資訊。</li></ul><p>總之，只要記得，想在 view 函式內進一步取得<strong>認證資訊</strong>，要透過<code>request.auth</code>。</p><hr><p>這樣就已經實作完認證了，但我們可以讓事情更「簡單」一點。</p><h2 id="全域認證的設定與例外"><a href="#全域認證的設定與例外" class="headerlink" title="全域認證的設定與例外"></a>全域認證的設定與例外</h2><p>一一對每個 API 設定認證保護，感覺有點<strong>繁瑣</strong>——尤其在 API 多的時候。</p><p>對此，Django Ninja 支援<strong>全域認證</strong>，讓所有 API <strong>預設都直接受到保護</strong>，開發者只需在特定路由中進行<strong>例外</strong>處理，<strong>排除</strong>不想套用的 API 即可。</p><p>實作上非常簡單，Django Ninja 直接提供了<code>SessionAuth</code>認證類別，用來處理全域的 session-based 認證。</p><h3 id="實作全域認證：使用SessionAuth"><a href="#實作全域認證：使用SessionAuth" class="headerlink" title="實作全域認證：使用SessionAuth"></a>實作全域認證：使用<code>SessionAuth</code></h3><p>在專案的<code>api.py</code>中加入下面內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NinjaForum/api.py</span></span><br><span class="line"><span class="keyword">from</span> ninja.security <span class="keyword">import</span> SessionAuth</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">api = NinjaAPI(</span><br><span class="line">    auth=SessionAuth(),  <span class="comment"># 設定全域認證</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如此一來，全部的 API 都<strong>預設擁有認證保護</strong>，你可以在特定 API 中排除，比如「登入使用者」：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.post(<span class="params">path=<span class="string">&#x27;/users/login/&#x27;</span>, summary=<span class="string">&#x27;登入使用者&#x27;</span>, auth=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure><p>在路由裝飾器中，把<code>auth</code>定義為<code>None</code>，<strong>解除</strong>認證保護。</p><hr><h2 id="測試認證保護"><a href="#測試認證保護" class="headerlink" title="測試認證保護"></a>測試認證保護</h2><p>我們來測試一下「<strong>有認證保護</strong>」的 API，你會發現在<strong>未登入</strong>的情況下，<strong>嘗試不同 HTTP 方法的 API</strong>，你將會得到不同的錯誤回應：</p><ul><li>GET：401 Unauthorized</li><li>POST：403 Forbidden</li></ul><p>所以前面才會說你會得到「401 或 403」回應。</p><h3 id="測試「取得所有使用者」API"><a href="#測試「取得所有使用者」API" class="headerlink" title="測試「取得所有使用者」API"></a>測試「取得所有使用者」API</h3><p>在我們的專案設計中，只有登入的使用者才能存取「取得所有使用者」API。</p><p>未登入的情況下，你會得到 401 回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 401 Unauthorized</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unauthorized&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="測試「新增文章」API"><a href="#測試「新增文章」API" class="headerlink" title="測試「新增文章」API"></a>測試「新增文章」API</h3><p>未登入也無法存取「新增文章」API——這顯然非常合理，否則文章不就沒作者了😅</p><p>你會得到 403 回應：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 403 Forbidden</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CSRF check Failed&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>你心想：「奇怪？為什麼是 CSRF check Failed？」</p><p>這是 Django 的 CSRF 保護機制，因為我們的 API 是 POST 方法，所以 Django 會自動檢查 CSRF token，但我們沒有提供 CSRF token，所以就會出現這個錯誤。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>在這篇文章中，我們探討了 Django 的 session 認證與 Django Ninja 的整合，實作了「使用者登入」API，並為其他 API 加上認證保護。最後還示範了如何實現全域認證，讓整個流程更加簡單。</p><p>這個系列的<strong>最後實踐</strong>，我們要來為專案——<strong>寫測試</strong>！</p><p>下一篇將探討，如何使用 test client 和 pytest 來為我們的 Django API 撰寫<strong>單元測試</strong>。這不僅能幫助我們驗證現有功能，還能為未來的開發和重構提供多一層的保障。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 28 篇。&lt;/p&gt;
&lt;p&gt;歡迎來到第七章！本章總共有兩篇內容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷 28：身分認證——Session 認證與全域設定&lt;/li&gt;
&lt;li&gt;卷 29：單元測試——使用 Test Client 與 pytest 測試 API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些主題的核心功能，&lt;strong&gt;並非由 Django Ninja 實作&lt;/strong&gt;，但框架仍提供了&lt;strong&gt;一定程度的整合&lt;/strong&gt;。並且，這些功能對於任何 Django 專案來說，都至關重要。&lt;/p&gt;
&lt;p&gt;本文介紹幾乎所有 API 專案都需要的——&lt;strong&gt;身分認證&lt;/strong&gt;（&lt;a href=&quot;https://django-ninja.dev/guides/authentication/&quot;&gt;Authentication&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;我們將探討如何在 Django Ninja 中利用 Django 內建的 session-based 認證，實現完整的登入驗證功能，並進一步說明如何設定&lt;strong&gt;全域認證&lt;/strong&gt;，以減少程式碼的重複。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/19&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;認證的兩個層次&quot;&gt;&lt;a href=&quot;#認證的兩個層次&quot; class=&quot;headerlink&quot; title=&quot;認證的兩個層次&quot;&gt;&lt;/a&gt;認證的兩個層次&lt;/h2&gt;&lt;p&gt;進入實作前，我們要先了解，所謂的&lt;strong&gt;身分認證&lt;/strong&gt;，究竟代表什麼。&lt;/p&gt;
&lt;p&gt;以「帳號密碼 + session 認證」為例，身分認證的範圍主要涵蓋&lt;strong&gt;兩個階段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，當使用者透過帳號密碼進行登入時，系統會檢查這些內容、確認身分&lt;strong&gt;合法&lt;/strong&gt;。登入成功後，系統會將使用者資訊（比如用戶 id）儲存至 session，以&lt;strong&gt;維持登入狀態&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是&lt;strong&gt;登入時的認證&lt;/strong&gt;，也是我們最常說的認證。（&lt;strong&gt;狹義的認證&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;接著，當使用者嘗試存取受「&lt;strong&gt;認證保護&lt;/strong&gt;」的 API 時，系統會檢查 session 並確認身分，確保每個 API 請求都來自&lt;strong&gt;合法登入&lt;/strong&gt;的使用者。&lt;/p&gt;
&lt;p&gt;簡言之：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一階段：初次登入時的身分確認。&lt;/li&gt;
&lt;li&gt;第二階段：後續請求時的身分確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兩個層次相輔相成、一體兩面，確保服務能夠在使用者&lt;strong&gt;登入&lt;/strong&gt;和&lt;strong&gt;後續操作&lt;/strong&gt;中，提供適當的安全保障。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>資料查詢與過濾（下）FilterSchema 多欄位查詢</title>
    <link href="https://blog.kyomind.tw/django-ninja-27/"/>
    <id>https://blog.kyomind.tw/django-ninja-27/</id>
    <published>2024-10-09T06:04:46.000Z</published>
    <updated>2024-10-24T10:02:55.938Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 27 篇。</p><p>上篇中，我們學習了 Django ORM 的<code>Q</code>物件和 Django Ninja 的 FilterSchema，但後者感覺只學了一半。</p><p>討論比較多的是，view 函式中使用 FilterSchema 的<strong>參數定義方式</strong>——這確實很重要，但這只是 FilterSchema 的一部分。</p><p>本篇要來補完剩下的內容：</p><ol><li>完善 FilterSchema：使用「<strong>更道地</strong>」的寫法，釋放 FilterSchema <strong>真正的力量</strong>。</li><li>實作更進階的欄位查詢功能：<strong>多欄位查詢——篩選日期區間。</strong></li><li>追加實作第 20 篇學到的「<strong>跨欄位驗證</strong>」：驗證查詢參數的<strong>日期區間是否合法</strong>。</li></ol><p>看來又是資訊滿滿的一篇，話不多說，直接開始吧！</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/18">這個 PR</a>。</p><span id="more"></span><hr><h2 id="一、將查詢邏輯遷移到-FilterSchema"><a href="#一、將查詢邏輯遷移到-FilterSchema" class="headerlink" title="一、將查詢邏輯遷移到 FilterSchema"></a>一、將查詢邏輯遷移到 FilterSchema</h2><p>還記得我們上一篇的程式碼實作嗎？</p><p>明明多定義了 FilterSchema，但 view 函式中的程式碼<strong>不僅沒有減少，反而還增加了</strong>！（雖然查詢邏輯也變多了，因為要同時查詢兩個欄位）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">CustomPagination</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    filters: PostFilterSchema = Query(<span class="params"></span>),  <span class="comment"># 使用 FilterSchema</span></span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> filters.query:</span><br><span class="line">        q = Q(title__icontains=filters.query) | \</span><br><span class="line">            Q(content__icontains=filters.query)</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(q)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這簡直莫名其妙🐸</p><p>那是因為，FilterSchema 不是這麼用的！</p><h3 id="FilterSchema-的「正確」用法"><a href="#FilterSchema-的「正確」用法" class="headerlink" title="FilterSchema 的「正確」用法"></a>FilterSchema 的「正確」用法</h3><p>我們應該盡可能將查詢邏輯<strong>封裝到 FilterSchema 中</strong>，這樣可以讓 view 函式更簡潔，並達到「<strong>關注點分離</strong>」的效果。</p><p>來看看更合理的寫法——將查詢邏輯遷移到 FilterSchema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    query: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        q=[<span class="string">&#x27;title__icontains&#x27;</span>, <span class="string">&#x27;author__username__icontains&#x27;</span>],</span><br><span class="line">        min_length=<span class="number">2</span>,</span><br><span class="line">        max_length=<span class="number">10</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>主要的變動是<code>query</code>欄位的 Field 部分，現在加上了<code>q=</code>參數內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=[<span class="string">&quot;title__icontains&quot;</span>, <span class="string">&quot;author__name__icontains&quot;</span>]</span><br></pre></td></tr></table></figure><p>很眼熟吧？沒錯，它們實際上就是<code>Q</code>物件的<strong>條件語句</strong>，Django Ninja 會在背後自動調用<code>Q</code>物件來執行這些查詢。</p><h3 id="來自-Mypy-的提醒"><a href="#來自-Mypy-的提醒" class="headerlink" title="來自 Mypy 的提醒"></a>來自 Mypy 的提醒</h3><p>一旦使用<code>q=</code>參數，Mypy 又會提醒你：</p><blockquote><p>Unexpected keyword argument “q” for “Field”</p></blockquote><p>它說的並沒有錯，因為 Pydantic Field <strong>確實沒有</strong>這個參數——這是 Django Ninja 自行實作的。</p><p>你可以無視它，或加上必要的註解。</p><h3 id="View-函式簡化"><a href="#View-函式簡化" class="headerlink" title="View 函式簡化"></a>View 函式簡化</h3><p>如此一來，view 函式<strong>只需要</strong>這樣寫就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    filters: PostFilterSchema = Query(<span class="params"></span>),</span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.select_related(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    posts = filters.<span class="built_in">filter</span>(posts)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>是不是<strong>簡單很多</strong>？</p><p>因為查詢邏輯從 view 函式「分離」出來了，這使得 view 函式的職責更單一、更利於維護。</p><hr><h2 id="二、多欄位查詢：新增日期篩選功能"><a href="#二、多欄位查詢：新增日期篩選功能" class="headerlink" title="二、多欄位查詢：新增日期篩選功能"></a>二、多欄位查詢：新增日期篩選功能</h2><p>新需求：除了可以查文章標題或作者名稱，現在還要加入對「<strong>發文日期</strong>」的過濾！</p><p>我們將引入兩個<strong>新的 URL 查詢參數</strong>：</p><ul><li><code>start_date</code></li><li><code>end_date</code></li></ul><p>兩者將用來查詢、過濾<code>Post</code>模型中的<code>created_at</code>欄位（即發文日期），以篩選特定時間範圍內的文章資料。</p><p>還有一個<strong>額外要求</strong>：兩者必須「<strong>全有全無</strong>」——可以都沒有，但不可以只填其中一個。</p><p>這是一個典型的「<strong>多欄位</strong>」查詢。</p><h3 id="新增程式碼"><a href="#新增程式碼" class="headerlink" title="新增程式碼"></a>新增程式碼</h3><p>這是加入了上述邏輯後的 FilterSchema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    query: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">        <span class="literal">None</span>, q=[<span class="string">&quot;title__icontains&quot;</span>, <span class="string">&quot;author__username__icontains&quot;</span>])</span><br><span class="line">    start_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&quot;created_at__gte&quot;</span>)</span><br><span class="line">    end_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&quot;created_at__lte&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>start_date</code>和<code>end_date</code>都是對模型欄位<code>created_at</code>的<strong>查詢條件</strong>。</p><p>所以我們使用<code>created_at__gte</code>和<code>created_at__lte</code>來<strong>描述過濾邏輯</strong>（它們都對應了各自的<code>Q</code>物件），以<strong>篩選</strong>出符合條件的資料。</p><p>那 view 函式呢？你猜得沒錯——<strong>完全不用動</strong>！</p><p>這就是使用 FilterSchema 的好處。</p><h3 id="API-文件渲染問題"><a href="#API-文件渲染問題" class="headerlink" title="API 文件渲染問題"></a>API 文件渲染問題</h3><p>有趣的是，當我試著為這些查詢參數加上<strong>文件範例</strong>時，如果這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(</span><br><span class="line">    <span class="literal">None</span>, q=<span class="string">&#x27;created_at__gte&#x27;</span>, examples=[<span class="string">&#x27;2021-01-01&#x27;</span>]</span><br></pre></td></tr></table></figure><p>查看 API 文件將會得到：</p><blockquote><p>😱 Could not render Parameters, see the console.</p></blockquote><p>但寫<code>example=&#39;2021-01-01&#39;</code>卻可以成功。</p><p>這可能是 Django Ninja 與 Pydantic 在整合上的一個 bug，我們暫且就先略過吧！</p><h3 id="客戶端查詢範例"><a href="#客戶端查詢範例" class="headerlink" title="客戶端查詢範例"></a>客戶端查詢範例</h3><p>當我們要查詢某段時間內的文章時，可以使用以下的 URL 查詢參數：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?start_date=2023-01-01&amp;end_date=2023-01-31</span><br></pre></td></tr></table></figure><p>這樣就能輕鬆查詢出 2023 年 1 月份的所有文章。</p><p>附帶一提，日期中的時間因為沒有指定，預設上都是 0 點 0 分 0 秒。所以如果填同一天，就查不到任何東西。</p><p>這是一個需要<strong>改善</strong>或<strong>重新調整</strong>的細節，常見的做法是在程式內部把<code>end_date</code>加 1 天，而我直接選擇<strong>讓兩者不能相同</strong>XD。實際該怎麼做，取決於你的需求。</p><p>除了單純的期間查詢，我們也可以查詢<strong>某作者在某段時間內</strong>的文章，以查詢作者 Alice 為例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?start_date=2023-01-01&amp;end_date=2023-01-31&amp;query=alice</span><br></pre></td></tr></table></figure><p>結果將顯示 Alice 在 2023 年 1 月份的所有文章。</p><hr><h2 id="FilterSchema-的預設查詢條件關係"><a href="#FilterSchema-的預設查詢條件關係" class="headerlink" title="FilterSchema 的預設查詢條件關係"></a>FilterSchema 的預設查詢條件關係</h2><p>這部分一定要特別介紹，依<a href="https://django-ninja.dev/guides/input/filtering/#combining-expressions">文件</a>所述，預設上：</p><ul><li>Field-level expressions are joined together using <code>OR</code> operator.</li><li>The fields themselves are joined together using <code>AND</code> operator.</li></ul><p>意思就是說，單一欄位內的多個 Q 語句，彼此是 OR 關係，比如上面<code>query</code>的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=[<span class="string">&#x27;title__icontains&#x27;</span>, <span class="string">&#x27;author__username__icontains&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以查詢文章標題「<strong>或</strong>」作者名稱。</p><p>而<strong>不同欄位</strong>中的條件（如果都有），則是 AND 關係——必須<strong>同時符合</strong>才行。所以作者名稱與日期區間，兩者的條件必須同時符合。</p><p>這些預設邏輯可以自行變更，詳情請參考上述文件內容。</p><hr><h2 id="三、日期區間驗證"><a href="#三、日期區間驗證" class="headerlink" title="三、日期區間驗證"></a>三、日期區間驗證</h2><p>本例中，除了欄位查詢，我們還要確保，使用者輸入的開始日期<strong>必須早於</strong>結束日期。</p><p>並且，兩個欄位的查詢值必須是「全有」或「全無」（<strong>全無則不必驗證</strong>）。</p><p>這個需求非常眼熟——不就是第 20 篇提到的「<strong>跨欄位驗證</strong>」嗎？</p><p>沒錯，我們要透過 Pydantic 的<code>model_validator</code>來實現，它允許我們在驗證過程中，對輸入資料進行<strong>自定義的邏輯檢查</strong>。</p><h3 id="使用-Pydantic-model-validator-實作日期區間驗證"><a href="#使用-Pydantic-model-validator-實作日期區間驗證" class="headerlink" title="使用 Pydantic model_validator 實作日期區間驗證"></a>使用 Pydantic model_validator 實作日期區間驗證</h3><p>程式碼有點多，我們直接看重點：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    ...</span><br><span class="line">    start_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&#x27;created_at__gte&#x27;</span>)</span><br><span class="line">    end_date: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, q=<span class="string">&#x27;created_at__lte&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @model_validator(<span class="params">mode=<span class="string">&#x27;after&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_date_range</span>(<span class="params">self</span>) -&gt; Self:</span><br><span class="line">        <span class="comment"># 如果開始日期和結束日期都是 None，則不進行任何檢查</span></span><br><span class="line">        <span class="keyword">if</span> self.start_date <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self.end_date <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([self.start_date, self.end_date]):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;開始日期和結束日期必須同時提供或同時不提供&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            start_date_dt = datetime.strptime(self.start_date, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">            end_date_dt = datetime.strptime(self.end_date, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;日期格式無效，應為 YYYY-MM-DD&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start_date_dt &gt; end_date_dt:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;開始日期必須早於結束日期&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>對於查詢條件，我們使用 Pydantic 的<code>model_validator</code>進行跨欄位驗證，確保使用者輸入的日期是<strong>有效且合理</strong>的。</p><p>事實上，跨欄位驗證往往要<strong>考慮很多細節</strong>，否則可能掛一漏萬，間接產生新的 bug。</p><p>這個例子就是一個典型案例。</p><p>我們必須<strong>全盤考慮</strong>各種可能的輸入情況，包括日期格式是否正確、日期範圍是否合理，以及兩個日期欄位是否同時存在或同時為空。</p><p><strong>細緻的驗證邏輯</strong>能提升 API 的<strong>可靠性</strong>，避免因為無效或不合理的輸入而導致系統出現<strong>意外行為</strong>。而粗糙的邏輯則反之。</p><h3 id="測試錯誤回應"><a href="#測試錯誤回應" class="headerlink" title="測試錯誤回應"></a>測試錯誤回應</h3><p>PS：這裡的拋出錯誤，範例程式碼中仍使用了<code>ValueError</code>，我並沒有變更為 Django 的<code>ValidationError</code>。（最新版已修正）</p><p>但以下回應則是<strong>模擬</strong> Django 的<code>ValidationError</code>，以減少不必要的重複。</p><p>一、<strong>只輸入開始日期</strong>：（這發生機率不高，因為前端通常會限制）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;開始日期和結束日期必須同時提供或同時不提供&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>二、輸入<strong>不合法的日期</strong>，比如<code>2023-02-30</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;日期格式無效，應為 YYYY-MM-DD&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>三、輸入<strong>不合法的日期區間</strong>，比如<code>start_date=2023-01-31&amp;end_date=2023-01-01</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;開始日期必須早於結束日期&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>這兩篇文章，我們介紹了 FilterSchema 的有效用法，完成了多欄位查詢和日期篩選，並示範如何使用<code>model_validator</code>來強化資料驗證，確保查詢邏輯的正確性。</p><p>我們還看了這些應用場景的實例程式碼，幫助讀者更好地理解每個步驟的用途和效果。</p><p>下一章，我們將探討 Django Ninja 中的認證（Authentication）機制，並介紹如何使用 pytest 進行單元測試，這些都是後端開發中，不可或缺的要素。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 27 篇。&lt;/p&gt;
&lt;p&gt;上篇中，我們學習了 Django ORM 的&lt;code&gt;Q&lt;/code&gt;物件和 Django Ninja 的 FilterSchema，但後者感覺只學了一半。&lt;/p&gt;
&lt;p&gt;討論比較多的是，view 函式中使用 FilterSchema 的&lt;strong&gt;參數定義方式&lt;/strong&gt;——這確實很重要，但這只是 FilterSchema 的一部分。&lt;/p&gt;
&lt;p&gt;本篇要來補完剩下的內容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完善 FilterSchema：使用「&lt;strong&gt;更道地&lt;/strong&gt;」的寫法，釋放 FilterSchema &lt;strong&gt;真正的力量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;實作更進階的欄位查詢功能：&lt;strong&gt;多欄位查詢——篩選日期區間。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;追加實作第 20 篇學到的「&lt;strong&gt;跨欄位驗證&lt;/strong&gt;」：驗證查詢參數的&lt;strong&gt;日期區間是否合法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看來又是資訊滿滿的一篇，話不多說，直接開始吧！&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/18&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
  </entry>
  
  <entry>
    <title>資料查詢與過濾（上）FilterSchema 介紹</title>
    <link href="https://blog.kyomind.tw/django-ninja-26/"/>
    <id>https://blog.kyomind.tw/django-ninja-26/</id>
    <published>2024-10-08T02:31:58.000Z</published>
    <updated>2024-10-25T08:49:26.641Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 26 篇。</p><p>「<strong>查詢</strong>」是 API 中常見的附加需求，本質上是<strong>對資料的過濾（filtering）與篩選</strong>。</p><p>無論是篩選文章、商品，還是查詢用戶，<strong>根據不同條件來過濾資料並獲得結果</strong>，可說是大部分專案的必備功能。</p><p>在 view 函式中，實作查詢<strong>最簡單</strong>的方式，就是使用 Django ORM 的過濾方法。例如，我們可以用<code>filter</code>方法來根據特定條件篩選 QuerySet。</p><p>這種方法簡單直接，適合基本的查詢需求。然而，它也有其<strong>局限性</strong>——隨著欄位與需求的增加，查詢條件可能變得<strong>越來越複雜</strong>，導致程式碼<strong>冗長</strong>且難以維護。</p><p>為了解決這一問題，Django Ninja 提供了 FilterSchema，讓我們可以用更「<strong>結構化</strong>」的方式，定義並管理查詢條件。</p><p>本文將介紹 FilterSchema，一步步實作與講解，讓你了解如何在 Django Ninja 中使用 FilterSchema，實現<strong>更加靈活、模組化</strong>的 API 查詢功能。</p><p>本文所有的程式碼改動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/17">這個 PR</a>。</p><span id="more"></span><hr><h2 id="傳統查詢方法與問題"><a href="#傳統查詢方法與問題" class="headerlink" title="傳統查詢方法與問題"></a>傳統查詢方法與問題</h2><p>上一篇我們提到「取得文章列表」API，還記得我們在〈<a href="/django-ninja-11/">卷 11：請求（三）查詢參數 - Query Parameters</a>〉為它加上的「<strong>依文章標題查詢</strong>」功能嗎？</p><p>這是目前程式碼的現況：（請留意<strong>查詢參數</strong>名稱<code>title</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    title: <span class="literal">None</span> | <span class="built_in">str</span> = Query(<span class="params"><span class="literal">None</span>, min_length=<span class="number">2</span>, max_length=<span class="number">10</span></span>),</span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> title:</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">            title__icontains=title).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>那時我們就是用了 Django ORM 的<code>filter</code>方法！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts.<span class="built_in">filter</span>(title__icontains=title).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最後的<code>select_related(&#39;author&#39;)</code>是為了避免「N+1」問題，和查詢邏輯<strong>無關</strong>，可以先不管。</p><h3 id="潛在問題"><a href="#潛在問題" class="headerlink" title="潛在問題"></a>潛在問題</h3><p>這樣的寫法很直觀，對於<strong>簡單的查詢需求</strong>很有效。</p><p>但隨著專案規模的擴大、查詢需求變得<strong>複雜</strong>時，就會產生以下<strong>困境</strong>：</p><ul><li><strong>程式碼重複</strong>：當你有多個地方需要進行<strong>相似的過濾</strong>時，你可能會發現自己在重複相同的過濾邏輯。</li><li><strong>維護困難</strong>：隨著過濾條件的增加，<strong>你的 view 函式可能變得難以維護</strong>。每增加一個新的過濾條件，都可能需要修改多個地方的程式碼。</li><li><strong>資料驗證與轉換</strong>：你需要手動處理資料驗證和轉換的問題，這不僅增加了錯誤的可能性，也增加了開發的複雜度。</li><li><strong>擴充性</strong>：當你需要支援更複雜的過濾條件，比如範圍查詢、多條件組合查詢時，<strong>手動組裝 ORM 查詢</strong>的方法可能會顯得<strong>非常笨重</strong>且難以管理。</li></ul><p>因此，我們並不推薦在<strong>複雜查詢</strong>的情況下，直接使用 ORM 的<code>filter</code>方法來<strong>組裝</strong>查詢條件。</p><hr><h2 id="新需求：同時查詢作者名字"><a href="#新需求：同時查詢作者名字" class="headerlink" title="新需求：同時查詢作者名字"></a>新需求：同時查詢作者名字</h2><p>新的需求是，用<strong>同一個關鍵字</strong>， 同時查詢<strong>文章的標題或作者的名字</strong>， 只要任一符合就顯示在結果中。（二者滿足其一即可，也可以<strong>都符合</strong>）</p><p>這需求類似於 iThome 鐵人賽官網的<a href="https://ithelp.ithome.com.tw/2024ironman/signup/list">這個查詢功能</a>：</p><p><img src="https://i.imgur.com/nCU56Bk.png"></p><p>不過我們只能查 2 種，而它可以同時查 3 種：題目、簡介、參賽者暱稱。</p><p>但本質上是一樣的。</p><h3 id="用傳統方法-Q-物件實作"><a href="#用傳統方法-Q-物件實作" class="headerlink" title="用傳統方法 + Q 物件實作"></a>用傳統方法 + Q 物件實作</h3><p>如果用傳統方法 + Django 的 Q 物件實作，則查詢會長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    Q(title__icontains=title) | Q(author__name__icontains=title)</span><br><span class="line">).select_related(<span class="string">&#x27;author&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此時查詢參數不適合再叫<code>title</code>，因為它要查詢<strong>兩個欄位</strong>。沒關係，我們之後會改成<code>query</code>。</p><p>這段程式碼有兩個重點：</p><ol><li>查詢果然<strong>變長</strong>了！之後如果還有新的查詢條件，那豈不是……</li><li>這個<code>Q</code>是什麼東西？</li></ol><p><code>Q</code>則是 Django ORM 的 <a href="https://docs.djangoproject.com/en/5.1/topics/db/queries/#complex-lookups-with-q-objects">Q 物件</a>，它在<strong>複雜查詢邏輯</strong>中佔據了重要地位。因此，我們有必要先簡單介紹一下。</p><hr><h2 id="Django-Q-物件簡介"><a href="#Django-Q-物件簡介" class="headerlink" title="Django Q 物件簡介"></a>Django Q 物件簡介</h2><p>為了改善<strong>多條件查詢</strong>時，程式<strong>結構複雜</strong>的問題，Django 提供了<code>Q</code>物件。</p><p><code>Q</code>物件允許我們<strong>靈活地組織查詢條件</strong>，使用<strong>邏輯運算子</strong>（如<code>&amp;</code>、<code>|</code>）進行<strong>條件合併</strong>。在處理<strong>複雜條件過濾</strong>時非常有用。</p><p>比如說，我們想要篩選出標題包含「Ninja」<strong>並且</strong>作者名稱包含「Alice」的文章，可以這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    Q(title__icontains=<span class="string">&#x27;Ninja&#x27;</span>) &amp; Q(author__name__icontains=<span class="string">&#x27;Alice&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上述寫法，其實就<strong>等價</strong>於我們常見的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    title__icontains=<span class="string">&#x27;Ninja&#x27;</span>, author__name__icontains=<span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>所以你通常不會在「AND」需求時使用<code>Q</code>物件。</p><p>「OR」查詢條件才是<code>Q</code>的<strong>經典場景</strong>。</p><p>現在條件改為——文章標題「<strong>或</strong>」作者名字有「Alice」就行。可以使用<code>|</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">posts = posts.<span class="built_in">filter</span>(</span><br><span class="line">    Q(title__icontains=<span class="string">&#x27;Ninja&#x27;</span>) | Q(author__name__icontains=<span class="string">&#x27;Alice&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>Q</code>物件讓查詢更加靈活且清晰，特別是在面對<strong>多個可選條件</strong>時。</p><hr><h2 id="使用-FilterSchema-改進查詢"><a href="#使用-FilterSchema-改進查詢" class="headerlink" title="使用 FilterSchema 改進查詢"></a>使用 FilterSchema 改進查詢</h2><p>了解傳統查詢方法容易造成<strong>程式冗長</strong>的問題，並學習了<code>Q</code>物件的基礎後，我們要開始介紹今天的主角——<a href="https://django-ninja.dev/guides/input/filtering/">FilterSchema</a>。</p><p>Django Ninja 提供的 FilterSchema，主要的功能是讓查詢語句更加<strong>結構化、模組化</strong>，避免 view 函式變得冗長、難讀。</p><p>而且，與 Schema 中的驗證方法相同，它也一定程度實現了「<strong>關注點分離</strong>」原則——藉由將查詢邏輯從 view 函式中<strong>抽離</strong>出來。</p><p>不過，我們先不急著一步到位，容我<strong>分階段地改進</strong>程式碼。</p><p>這樣雖然有點笨拙，但你會對 FilterSchema 與複雜查詢的實作，有更深刻的了解。</p><h2 id="第一版「改進」"><a href="#第一版「改進」" class="headerlink" title="第一版「改進」"></a>第一版「改進」</h2><p>我們先用 FilterSchema 實現上述的「新需求：同時查詢作者名字」。</p><p>在<code>schemas.py</code>中建立新的 Schema，不過這次是 FilterSchema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post/schemas.py</span></span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Field, FilterSchema, Schema</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostFilterSchema</span>(<span class="title class_ inherited__">FilterSchema</span>):</span><br><span class="line">    query: <span class="built_in">str</span> | <span class="literal">None</span> = Field(<span class="literal">None</span>, min_length=<span class="number">2</span>, max_length=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>這個 FilterSchema，其實是給「<strong>查詢參數</strong>（query parameters）」使用的。所以它的欄位（屬性）名稱，就是你認為客戶端<strong>應該使用的查詢參數名稱</strong>。</p><p>因為同時要查「文章標題」和「作者名字」，所以我命名為<code>query</code>。</p><p>接下來，我們在 view 函式中使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@router.get(<span class="params">...</span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">CustomPagination</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: HttpRequest,</span></span><br><span class="line"><span class="params">    filters: PostFilterSchema = Query(<span class="params"></span>),  <span class="comment"># 使用 FilterSchema</span></span></span><br><span class="line"><span class="params"></span>) -&gt; QuerySet[Post]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    取得文章列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> filters.query:</span><br><span class="line">        q = Q(title__icontains=filters.query) | \</span><br><span class="line">            Q(author__username__icontains=filters.query)</span><br><span class="line">        posts = posts.<span class="built_in">filter</span>(q)</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>PS：這裡的<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/17/files">專案範例程式碼</a><strong>有誤</strong>，第二個<code>Q</code>查詢誤植為「<code>content__icontains</code>」，請讀者留意。我已在下一個分支中修復。</p><p>看完這個新的 view 函式，你可能不禁心想：</p><blockquote><p>這是在搞笑吧？完全沒有變簡單啊！</p></blockquote><p>沒錯，因為這只是 FilterSchema 的「<strong>半成品</strong>」，所以看起來比不用還冗長。</p><p>儘管如此，其中還是有一些看點，值得我們了解。</p><hr><h2 id="重點解析"><a href="#重點解析" class="headerlink" title="重點解析"></a>重點解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = Q(title__icontains=filters.query) | \</span><br><span class="line">    Q(content__icontains=filters.query)</span><br><span class="line">posts = posts.<span class="built_in">filter</span>(q)</span><br></pre></td></tr></table></figure><p>從這段能看出，<code>Q</code>物件可以<strong>單獨進行各種合併操作</strong>，最後再丟給 Django <code>filter</code>方法作為參數。</p><h3 id="Django-Ninja-常見句型"><a href="#Django-Ninja-常見句型" class="headerlink" title="Django Ninja 常見句型"></a>Django Ninja 常見句型</h3><p>本例中，這樣的 view <strong>函式參數</strong>「句型」在 Django Ninja 非常普遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filters: PostFilterSchema = Query()</span><br></pre></td></tr></table></figure><p>而初學者看了會很容易「<strong>誤解</strong>」。</p><p>為什麼？因為你可能會以為，<code>filters</code>的型別是<code>PostFilterSchema</code>（這沒問題），然後它的<strong>預設值</strong>是<code>Query()</code>，因為 Python 函式就是這樣定義的。</p><p>但並不是。</p><p><code>Query()</code>並不是<code>filters</code>參數的預設值，否則它的型別不應該是<code>Query</code>嗎？</p><p>事實上，<code>= Query()</code>這段標記<strong>不是給你看的</strong>，是給 Django Ninja 看的，它相當於是在告訴 Django Ninja：</p><blockquote><p>這個參數內容應該從 HTTP 請求中的查詢參數（query parameters）中取得，而不是從 body 或 path。</p></blockquote><p>這樣想就很容易明白了。</p><p>Django Ninja 會試圖從查詢參數獲取字串，拆解它們（如果有複數個查詢字串），然後一一丟給<code>PostFilterSchema</code>進行<strong>初始化與驗證：</strong></p><ol><li>驗證失敗：回傳 422。</li><li>驗證成功：將 Schema 物件傳入 view 函式作為<strong>函式的參數</strong>（<strong>區域變數</strong>）。</li></ol><h2 id="查詢結果"><a href="#查詢結果" class="headerlink" title="查詢結果"></a>查詢結果</h2><p>這是用「Alice」作為關鍵字的查詢結果：</p><p><img src="https://i.imgur.com/Omr7Pag.png"></p><p>查到了 30 篇文章，全都來自於作者名稱包含「Alice」的用戶。</p><hr><h2 id="小結與下一步"><a href="#小結與下一步" class="headerlink" title="小結與下一步"></a>小結與下一步</h2><p>本篇先講到這裡，我們已經接觸了兩個新概念——Q 物件和 FilterSchema。</p><p>我們還分析了 Django Ninja 中常見的 view 函式參數「句型」，這對於理解框架的使用方式、習慣非常重要。</p><p>這些概念需要時間消化，但我可以向你保證，這樣的鋪陳是值得的。</p><p>比起直接深入 FilterSchema 的進階用法，這種循序漸進的學習方式更有助於理解。</p><p>下一篇你將會看到，<strong>為什麼認識 Q 物件很重要</strong>。以及如何透過 FilterSchema，來建立結構化、符合「關注點分離」的<strong>多欄位查詢</strong>。</p><p>我們下篇見。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 26 篇。&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;查詢&lt;/strong&gt;」是 API 中常見的附加需求，本質上是&lt;strong&gt;對資料的過濾（filtering）與篩選&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;無論是篩選文章、商品，還是查詢用戶，&lt;strong&gt;根據不同條件來過濾資料並獲得結果&lt;/strong&gt;，可說是大部分專案的必備功能。&lt;/p&gt;
&lt;p&gt;在 view 函式中，實作查詢&lt;strong&gt;最簡單&lt;/strong&gt;的方式，就是使用 Django ORM 的過濾方法。例如，我們可以用&lt;code&gt;filter&lt;/code&gt;方法來根據特定條件篩選 QuerySet。&lt;/p&gt;
&lt;p&gt;這種方法簡單直接，適合基本的查詢需求。然而，它也有其&lt;strong&gt;局限性&lt;/strong&gt;——隨著欄位與需求的增加，查詢條件可能變得&lt;strong&gt;越來越複雜&lt;/strong&gt;，導致程式碼&lt;strong&gt;冗長&lt;/strong&gt;且難以維護。&lt;/p&gt;
&lt;p&gt;為了解決這一問題，Django Ninja 提供了 FilterSchema，讓我們可以用更「&lt;strong&gt;結構化&lt;/strong&gt;」的方式，定義並管理查詢條件。&lt;/p&gt;
&lt;p&gt;本文將介紹 FilterSchema，一步步實作與講解，讓你了解如何在 Django Ninja 中使用 FilterSchema，實現&lt;strong&gt;更加靈活、模組化&lt;/strong&gt;的 API 查詢功能。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼改動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/17&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django ORM" scheme="https://blog.kyomind.tw/tags/Django-ORM/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>分頁（下）自定義分頁類別</title>
    <link href="https://blog.kyomind.tw/django-ninja-25/"/>
    <id>https://blog.kyomind.tw/django-ninja-25/</id>
    <published>2024-10-07T02:44:36.000Z</published>
    <updated>2024-10-25T04:52:04.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5gGprsq.png" alt="2024 iThome 鐵人賽"><span class="cap">2024 iThome 鐵人賽</span></p><p>這是 Django Ninja 系列教學的第 25 篇。</p><p>上一篇我們介紹了 Django Ninja 的內建分頁器，並用它實作了簡單的分頁功能。</p><p>雖然內建的<code>PageNumberPagination</code>確實方便，但在很多時候，我們仍需要一些<strong>客製化</strong>功能。</p><p>為了實現這個目的，你需要<strong>自定義一個分頁類別</strong>。</p><p>不過別擔心，這種自定義，<strong>並非從零開始</strong>。而是繼承 Django Ninja 所提供的基礎分頁類別，再進行自己的「<strong>加工</strong>」。</p><p>這篇文章就要來教你怎麼做。</p><p>本文所有的程式碼變動，可參考<a href="https://github.com/kyomind/Django-Ninja-Tutorial/pull/16">這個 PR</a>。</p><hr><h2 id="客製化需求"><a href="#客製化需求" class="headerlink" title="客製化需求"></a>客製化需求</h2><p>除了基本的分頁，我們還希望能夠：</p><ul><li><strong>允許客戶端選擇</strong>每頁顯示的資料數量，<strong>可選範圍</strong>限定在 1 至 100 之間。</li><li>在回應中<strong>新增兩個欄位</strong>，顯示當前的<strong>分頁資訊</strong>：<ul><li>當前頁數（<code>page</code>）。</li><li>每頁顯示數量（<code>per_page</code>）。</li></ul></li></ul><p>這無疑是很常見的需求。我們將透過自定義分頁類別，來實現這些功能。</p><p>話不多說，直接開始！</p><span id="more"></span><h2 id="實作：自定義分頁類別"><a href="#實作：自定義分頁類別" class="headerlink" title="實作：自定義分頁類別"></a>實作：自定義分頁類別</h2><p>分頁器（分頁類別）通常是是<strong>供全專案使用</strong>，所以不適合放在 Django app 目錄中。但也不能像 exception handlers 一樣，放在專案的<code>api.py</code>，因為會引發<strong>循環引用</strong>。</p><p>所以，我在專案目錄 NinjaForum 建立一個新的 Python 模組——<code>pagination.py</code>。</p><p>在這個新模組中，直接撰寫一個名為<code>CustomPagination</code>的分頁類別，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models.query <span class="keyword">import</span> QuerySet</span><br><span class="line"><span class="keyword">from</span> ninja <span class="keyword">import</span> Field, Schema</span><br><span class="line"><span class="keyword">from</span> ninja.pagination <span class="keyword">import</span> PaginationBase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomPagination</span>(<span class="title class_ inherited__">PaginationBase</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line">        per_page: <span class="built_in">int</span> = Field(<span class="number">10</span>, ge=<span class="number">1</span>, le=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Output</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">        items: <span class="built_in">list</span></span><br><span class="line">        page: <span class="built_in">int</span> = Field(examples=[<span class="number">1</span>])</span><br><span class="line">        per_page: <span class="built_in">int</span> = Field(examples=[<span class="number">10</span>])</span><br><span class="line">        total: <span class="built_in">int</span> = Field(examples=[<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paginate_queryset</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        queryset: QuerySet,</span></span><br><span class="line"><span class="params">        pagination: Input,</span></span><br><span class="line"><span class="params">        **params: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        start = (pagination.page - <span class="number">1</span>) * pagination.per_page</span><br><span class="line">        end = start + pagination.per_page</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;items&#x27;</span>: queryset[start:end],</span><br><span class="line">            <span class="string">&#x27;page&#x27;</span>: pagination.page,</span><br><span class="line">            <span class="string">&#x27;per_page&#x27;</span>: pagination.per_page,</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: queryset.count(),</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>這個分頁類別<strong>允許我們透過查詢參數</strong>——<code>page</code>和<code>per_page</code>——來決定分頁的大小與頁數，而且回應中<strong>還多了兩個同名的新欄位</strong>，作為額外的分頁資訊。</p><hr><h2 id="自定義分頁類別解說"><a href="#自定義分頁類別解說" class="headerlink" title="自定義分頁類別解說"></a>自定義分頁類別解說</h2><p>雖然程式碼看起來細節繁多，但仔細閱讀後，你會發現它其實不難理解。</p><p>限於篇幅，我們只挑一些重點來講。</p><h3 id="重點一：整體結構來自繼承的類別——PaginationBase"><a href="#重點一：整體結構來自繼承的類別——PaginationBase" class="headerlink" title="重點一：整體結構來自繼承的類別——PaginationBase"></a>重點一：整體結構來自繼承的類別——<code>PaginationBase</code></h3><p>第一個疑惑應該是：「啊我<strong>怎麼會知道</strong>分頁類別要這樣寫？」</p><p>沒錯，我們<strong>當然不知道</strong>，所以要看<a href="https://django-ninja.dev/guides/response/pagination/#creating-custom-pagination-class">官方文件</a>，還有<a href="https://github.com/vitalik/django-ninja/blob/master/ninja/pagination.py">原始碼</a>。</p><p>從官方文件我們可以得知，要繼承一個叫<code>PaginationBase</code>的類別。但文件中對該類別的描寫還是有點簡略，所以需要看原始碼來了解更多的具體資訊。</p><p>然後模仿並覆寫類別中的一些屬性、方法——差不多就是如此。</p><h3 id="重點二：Input-Schema"><a href="#重點二：Input-Schema" class="headerlink" title="重點二：Input Schema"></a>重點二：Input Schema</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    page: <span class="built_in">int</span> = Field(<span class="number">1</span>, ge=<span class="number">1</span>)</span><br><span class="line">    per_page: <span class="built_in">int</span> = Field(<span class="number">10</span>, ge=<span class="number">1</span>, le=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>你一定能看出來，這個 Schema 就是拿來<strong>定義和驗證</strong>與分頁有關的 <strong>URL 查詢參數</strong>。</p><p>此外，<code>Input</code>類別會作為<strong>引數</strong>傳入<code>paginate_queryset</code>方法中，作為實現分頁邏輯的一部分。</p><p><code>Input</code>中的每一個屬性，就<strong>代表一個查詢參數</strong>（限分頁相關）——而且一樣可以使用<code>Field</code>來設定細節！</p><p>這裡的<code>Field</code>是 Pydantic 的<code>Field</code>，我們在第 18 篇詳細介紹過。它允許我們為每個參數設定<strong>預設值</strong>、<strong>文件範例</strong>和<strong>基本的驗證規則</strong>。</p><p>本例中，<code>page</code>的預設值是 1，且必須大於等於 1；<code>per_page</code>的預設值是 10，且必須在 1 到 100 之間。這樣可以確保我們的分頁參數<strong>始終在合理的範圍內</strong>。</p><p>同樣的道理也適用於<code>Output</code>，它決定了 HTTP 回應「<strong>應該要有</strong>」的格式，相當於分頁回應的 Schema。</p><h3 id="重點三：paginate-queryset-方法"><a href="#重點三：paginate-queryset-方法" class="headerlink" title="重點三：paginate_queryset 方法"></a>重點三：paginate_queryset 方法</h3><p>這個方法是所有分頁類別的<strong>核心</strong>，它實現了<strong>具體的分頁邏輯</strong>。</p><p>它的第一參數是<code>self</code>，可見它是一個「<strong>實例方法</strong>」。</p><p><strong>最值得注意</strong>的是<strong>第二參數</strong>——<code>queryset</code>，它實際上就是 view 函式的 return 值，而且類型<strong>必須是</strong> <a href="https://docs.djangoproject.com/en/5.1/ref/models/querysets/">QuerySet</a>。</p><p><code>paginate_queryset</code>會利用我們熟悉的「<a href="https://vocus.cc/article/649392c3fd8978000166bbc5">切片與索引</a>」，對傳入的 QuerySet 進行「切割」。這是 Django 為 QuerySet 自行實作的功能，行為上類似 Python 的<code>list</code>、<code>tuple</code>等容器。</p><p>當它回應給客戶端時，我們就得到了<strong>切片後的 QuerySet</strong> 和<strong>自定義的回應格式</strong>。</p><hr><h2 id="測試自定義分頁"><a href="#測試自定義分頁" class="headerlink" title="測試自定義分頁"></a>測試自定義分頁</h2><p>寫完上述的自定義類別，view 函式只要多一行<code>@paginate(CustomPagination)</code>即可，這裡就省略程式碼。</p><p>直接看結果吧！我使用了<code>/?page=2&amp;per_page=5</code>（第 2 頁、每頁 5 筆）查詢參數：</p><p><img src="https://i.imgur.com/GuYj6Bk.png"></p><p>十分理想！</p><p>那如果每頁數量設定為<strong>超過 100</strong> 會怎樣呢？</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;less_than_equal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;query&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;per_page&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Input should be less than or equal to 100&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ctx&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;le&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>答案是 422 回應。</p><hr><h2 id="分頁功能總結"><a href="#分頁功能總結" class="headerlink" title="分頁功能總結"></a>分頁功能總結</h2><p>透過這兩篇文章，我們展示了如何在 DjangoNinja 中實作分頁，從簡單的內建方法，到複雜的自定義分頁類別。</p><p>根據專案需求，你可以選擇<strong>適合自己的分頁策略</strong>，讓每一個回應，都能以最適合的方式呈現給使用者。</p><hr><h2 id="為什麼「多重狀態碼回應」不實用？"><a href="#為什麼「多重狀態碼回應」不實用？" class="headerlink" title="為什麼「多重狀態碼回應」不實用？"></a>為什麼「多重狀態碼回應」不實用？</h2><p>還記得我們在第 13 篇、第 21 篇留下的<strong>伏筆</strong>嗎？</p><p>在〈卷 13：回應（一）Django Ninja 處理 HTTP 回應〉中我提到：</p><blockquote><p>但我覺得這個「多重狀態碼回應」設定在實務上<strong>沒有很實用</strong>，為何？我們後續再談。</p></blockquote><p>幫你複習一下，「多重狀態碼回應」指的是這個用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.post(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    ...,</span></span></span><br><span class="line"><span class="params"><span class="meta">    response=&#123;<span class="number">200</span>: Token, <span class="number">401</span>: Message, <span class="number">402</span>: Message&#125;  <span class="comment"># 這裡</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br></pre></td></tr></table></figure><p>然後在 view 函式中，依照不同情況，給出不同的 return。</p><p>我在〈卷 21：錯誤處理（上）HttpError 與自定義 HTTP 回應〉又說了：</p><blockquote><p>這樣看起來確實不錯，也很符合直覺，我以前寫 Django REST framework，都是這樣寫的。</p></blockquote><blockquote><p>可是，這個寫法在 Django Ninja 中，使用「分頁裝飾器」時，就會<strong>踢到鐵板</strong>了。</p></blockquote><blockquote><p>目前<strong>時機未到</strong>，在後續的〈卷 25：分頁（下）自定義分頁類別〉中，我們再把這件說清楚。</p></blockquote><p><strong>這不就來了嗎！</strong></p><p>理由很簡單，關鍵就在於本文「重點三：paginate_queryset 方法」中的那句：</p><blockquote><p>最值得注意的是第二參數——<code>queryset</code>，它實際上就是 view 函式的 return 值，而且類型<strong>必須是 QuerySet</strong>。</p></blockquote><p>因為<code>paginate_queryset</code>方法中，第二參數的類型<strong>必須是 QuerySet！</strong></p><p>在<code>paginate_queryset</code>內部，我們將這個參數視為 QuerySet 使用、操作。若傳入的<strong>不是</strong> QuerySet，分頁邏輯就會<strong>出錯</strong>。</p><h3 id="「多重狀態碼回應」與-paginate-queryset-方法的衝突"><a href="#「多重狀態碼回應」與-paginate-queryset-方法的衝突" class="headerlink" title="「多重狀態碼回應」與 paginate_queryset 方法的衝突"></a>「多重狀態碼回應」與 paginate_queryset 方法的衝突</h3><p>然而，多重狀態碼的回應，return 型別<strong>未必</strong>是 QuerySet——很可能是<code>tuple</code>。</p><p>我舉一個簡單的例子你就懂，我們把「取得文章列表」API 改成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.get(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    path=<span class="string">&quot;/posts&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    response=&#123;<span class="number">200</span>: <span class="built_in">list</span>[PostResponse], <span class="number">404</span>: ErrorMessage&#125;</span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="meta">@paginate(<span class="params">CustomPagination</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">...</span>) -&gt; QuerySet[Post] | <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">dict</span>]：</span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> posts.exists()：</span><br><span class="line">        <span class="keyword">return</span> <span class="number">404</span>， &#123;<span class="string">&quot;message&quot;</span>： <span class="string">&quot;沒有找到符合條件的文章&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> posts</span><br></pre></td></tr></table></figure><p>這個例子清楚地顯示了「多重狀態碼回應」與分頁器之間的<strong>衝突</strong>：</p><ul><li>當查詢結果<strong>正常</strong>時，view 函式 return 一個 <strong>QuerySet</strong>（即<code>posts</code>），丟給分頁器進行分頁，一切運作良好。</li><li>當<strong>沒有找到文章</strong>時，view 函式則會試圖回傳一個<code>tuple</code>——因為 Django Ninja 的「<strong>非 200 回應</strong>」必須有<strong>狀態碼</strong>，所以是<code>tuple</code>，而<strong>不是</strong> QuerySet。</li></ul><p>這將導致<code>paginate_queryset</code>方法出錯，因為它預期接收一個 QuerySet，後續的內部操作也是以此為前提。</p><hr><p>如果專案中所有的 API <strong>都沒有分頁</strong>，使用「多重狀態碼回應」來處理「非 200」回應是<strong>完全可行</strong>的。</p><p>但<strong>只要有一個</strong> API 需要分頁，這個有分頁的 API，為了避免上述衝突，就要改用一樣是第 21 篇提到的方式——<code>raise HttpError</code>。</p><p>考慮到<strong>專案整體的一致性</strong>，其餘的 API，也應該採用<code>raise HttpError</code>這個方式。</p><p>而分頁需求是<strong>如此的常見</strong>，所以「多重狀態碼回應」也就成為了<strong>雞肋</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5gGprsq.png&quot; alt=&quot;2024 iThome 鐵人賽&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 Django Ninja 系列教學的第 25 篇。&lt;/p&gt;
&lt;p&gt;上一篇我們介紹了 Django Ninja 的內建分頁器，並用它實作了簡單的分頁功能。&lt;/p&gt;
&lt;p&gt;雖然內建的&lt;code&gt;PageNumberPagination&lt;/code&gt;確實方便，但在很多時候，我們仍需要一些&lt;strong&gt;客製化&lt;/strong&gt;功能。&lt;/p&gt;
&lt;p&gt;為了實現這個目的，你需要&lt;strong&gt;自定義一個分頁類別&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過別擔心，這種自定義，&lt;strong&gt;並非從零開始&lt;/strong&gt;。而是繼承 Django Ninja 所提供的基礎分頁類別，再進行自己的「&lt;strong&gt;加工&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;這篇文章就要來教你怎麼做。&lt;/p&gt;
&lt;p&gt;本文所有的程式碼變動，可參考&lt;a href=&quot;https://github.com/kyomind/Django-Ninja-Tutorial/pull/16&quot;&gt;這個 PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;客製化需求&quot;&gt;&lt;a href=&quot;#客製化需求&quot; class=&quot;headerlink&quot; title=&quot;客製化需求&quot;&gt;&lt;/a&gt;客製化需求&lt;/h2&gt;&lt;p&gt;除了基本的分頁，我們還希望能夠：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;允許客戶端選擇&lt;/strong&gt;每頁顯示的資料數量，&lt;strong&gt;可選範圍&lt;/strong&gt;限定在 1 至 100 之間。&lt;/li&gt;
&lt;li&gt;在回應中&lt;strong&gt;新增兩個欄位&lt;/strong&gt;，顯示當前的&lt;strong&gt;分頁資訊&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;當前頁數（&lt;code&gt;page&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;每頁顯示數量（&lt;code&gt;per_page&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這無疑是很常見的需求。我們將透過自定義分頁類別，來實現這些功能。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5gGprsq.png" type="image"/>
    
    
    <category term="Django Ninja 系列" scheme="https://blog.kyomind.tw/categories/Django-Ninja-%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
</feed>
