<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/favicon-32x32.png</icon>
  <subtitle>Kyo 的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2025-05-24T16:47:52.805Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenRouter 上的 5 個「免費」模型推薦</title>
    <link href="https://blog.kyomind.tw/openrouter-free-models/"/>
    <id>https://blog.kyomind.tw/openrouter-free-models/</id>
    <published>2025-05-24T16:23:24.000Z</published>
    <updated>2025-05-24T16:47:52.805Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/openrouter-free-models.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>在這個 AI 應用百花齊放的時代，我們可以透過各種方式來接觸 AI。</p><p>可以使用線上服務——比如 ChatGPT ，也可以直接使用 LLM API 來更加客製化自己的需求。</p><p>最近我開始使用 OpenRouter 這個平台上的 API 服務，對於 AI 開發人員或 LLM 重度用戶，想必不陌生。</p><p>本文介紹 OpenRouter 上的 5 個免費模型，幫助你快速上手並選擇合適的模型。</p><hr><h2 id="OpenRouter-是什麼？"><a href="#OpenRouter-是什麼？" class="headerlink" title="OpenRouter 是什麼？"></a>OpenRouter 是什麼？</h2><p><a href="https://openrouter.ai/">OpenRouter</a> 是一個<strong>語言模型的 API 聚合平台服務</strong>，讓使用者可以透過單一介面，就能夠付費存取多家公司的大語言模型，包括 OpenAI、Anthropic、Google 等大公司的 LLM API 產品。</p><p>而且像 <a href="https://zh.wikipedia.org/zh-tw/LLaMA">LLaMa</a>、<a href="https://zh.wikipedia.org/zh-tw/%E6%B7%B1%E5%BA%A6%E6%B1%82%E7%B4%A2">DeepSeek</a> 這類開源模型，你想要使用的話，除了在本地跑之外，也可以透過 OpenRouter 提供的 API 來使用。</p><p>好處就是你不用擁有機器、顯卡，就能體驗這些開源模型的能力，而且價格相對於閉源模型，通常有一定的競爭力。</p><p>總之，OpenRouter 不僅為開發者提供了統一的介面，更讓非技術出身的用戶也能輕鬆使用 AI。</p><span id="more"></span><h3 id="白吃的午餐"><a href="#白吃的午餐" class="headerlink" title="白吃的午餐"></a>白吃的午餐</h3><p>更吸引我的是，它上面提供不少「免費」模型，只要在搜尋欄輸入「free」，即可找到供免費使用的模型。</p><p>這不禁引發了我的興趣！因為我最近在試用 VS Code <a href="https://github.com/cline/cline">Cline</a> 這個 AI 開發外掛，發現它真的非常消耗 Token。</p><p>叫我付錢用 API——我不願意XD，太貴了。</p><p>剛好可以試試 OpenRouter 上的免費模型！順便寫下這篇心得。</p><hr><p>在推薦模型之前，我們先來介紹一下在 OpenRouter <strong>使用免費模型的規則與限制</strong>。</p><h2 id="免費模型與使用限制"><a href="#免費模型與使用限制" class="headerlink" title="免費模型與使用限制"></a>免費模型與使用限制</h2><p>就在上個月，OpenRouter 調整了免費額度與規則，如下。</p><h3 id="具體限制"><a href="#具體限制" class="headerlink" title="具體限制"></a>具體限制</h3><ul><li><strong>未儲值或餘額不足 10 美元用戶：每日 50 次請求</strong>。（以前是 200 次）</li><li><strong>帳戶餘額在 10 美元以上用戶</strong>：每日請求從以前的 200 次提高至 <strong>1000 次</strong>。</li><li><strong>每分鐘 20 次請求</strong>：不論哪種用戶，免費模型維持每分鐘最多 20 次請求的限制，確保不會因短時間內大量請求導致伺服器超載。</li><li><strong>影響範圍</strong>：此限制適用於所有免費模型。</li></ul><p>這個變動顯然是逼你要儲值啊！</p><p>不過說真的，對於有儲值 10 美元以上的人，一天高達 1000 次的免費模型請求額度，我個人覺得還是蠻大方的——所以我儲值了XD</p><p><img src="https://img.kyomind.tw/openrouter-free-models-1.png"></p><hr><p>有了 1000 次的免費請求後，如何運用這些資源是一個值得思考的問題，否則空有額度卻無處使用也是白搭。</p><h2 id="三個常見的應用場景"><a href="#三個常見的應用場景" class="headerlink" title="三個常見的應用場景"></a>三個常見的應用場景</h2><p>以下 3 個應用場景可供讀者參考，我自己其實也還沒有找到真正的殺手級應用。</p><h3 id="沉浸式翻譯外掛"><a href="#沉浸式翻譯外掛" class="headerlink" title="沉浸式翻譯外掛"></a>沉浸式翻譯外掛</h3><p>在 Chrome 使用「<a href="https://immersivetranslate.com/zh-TW/">沉浸式翻譯</a>」外掛，搭配 OpenRouter 提供的翻譯引擎，在瀏覽英文網頁時獲得更流暢、自然的翻譯體驗。</p><p>不過我預計六月才會啟用，因為目前還在消耗 Grok 送的免費 150 美元額度。 </p><h3 id="GUI-工具整合"><a href="#GUI-工具整合" class="headerlink" title="GUI 工具整合"></a>GUI 工具整合</h3><p>指的就是那些讓你自己接 API 的軟體或服務，例如 <a href="https://anythingllm.com/">AnythingLLM</a>，可以將本地的文件轉成向量資料，並搭配語言模型進行 <a href="https://aws.amazon.com/tw/what-is/retrieval-augmented-generation/">RAG</a> 問答。</p><p>或者像 <a href="https://github.com/lobehub/lobe-chat">LoboChat</a>、<a href="https://github.com/wandb/openui">OpenUI</a> 這些 Web 聊天工具，可以自訂模型來源為 OpenRouter，輕鬆切換不同模型、快速測試。</p><p>這裡提到的工具基本上都是開源的，即不用花錢。</p><h3 id="VS-Code-Cline-外掛"><a href="#VS-Code-Cline-外掛" class="headerlink" title="VS Code Cline 外掛"></a>VS Code Cline 外掛</h3><p>如前所述，VS Code 擴充套件 <a href="https://github.com/cline/cline">Cline</a> 有支援 OpenRouter，能直接在編輯器中呼叫 LLM 協助寫程式，是個實用的開發助手。</p><p>我也是因為它才開始使用 OpenRouter 的，不過對我而言這只是實驗性質，我日常開發還是使用 GitHub Copilot 為主。</p><p>雖然支援 OpenRouter 的 VS Code 外掛或 IDE 不少，但<strong>不一定都支援免費模型</strong>。如果你是為了寫程式而儲值，記得先研究一下工具是否支援免費模型。</p><hr><h2 id="模型評比網站推薦：LiveBench"><a href="#模型評比網站推薦：LiveBench" class="headerlink" title="模型評比網站推薦：LiveBench"></a>模型評比網站推薦：LiveBench</h2><p>新模型發表時，常常會強調自己跑分多高，數字會說話，而且我們在評估模型性能時，確實需要一定的客觀指標——是否「真的」客觀則是另一個議題。</p><p>常見的跑分網站很多，有時候模型會針對這類網站進行最佳化，這相當於<strong>作弊</strong>。</p><p>因此，我個人主要參考 <a href="https://livebench.ai/#/">LiveBench</a> 這個網站，透過它來了解新模型的戰鬥力！</p><p>這個網站好在哪，為什麼值得相信，請看 AI 的解說：</p><blockquote><p>LiveBench 是一個高度可信的 LLM 基準測試平台，因為它通過動態更新的問題、客觀的自動化評分、學術與業界的支持、透明的數據公開以及與其他基準的公正比較，有效改善數據污染和評審偏見的問題。它不僅適用於研究人員評估模型性能，也為企業選擇合適 LLM 提供可靠參考。</p></blockquote><p>不用說，我個人在看跑分的時候，會特別重視 LLM 在軟體開發的能力。</p><hr><h2 id="5-款值得一試的免費模型"><a href="#5-款值得一試的免費模型" class="headerlink" title="5 款值得一試的免費模型"></a>5 款值得一試的免費模型</h2><p>接下來就簡單介紹一下，這些免費模型之中，我覺得值得使用的 5 個。你也可以參考上述網站自行評估。 </p><p>必須強調，「中文能力」是我挑選模型的一大指標，所以像 Llama 這種中文不友善的，我連試都不想試。</p><p>因此，中國公司所開發的模型在這方面肯定有它的優勢。 </p><h3 id="1-DeepSeek-R1"><a href="#1-DeepSeek-R1" class="headerlink" title="1. DeepSeek R1"></a>1. DeepSeek R1</h3><p>這個應該不用多說，某種程度上可以說是<strong>改變世界的開源模型</strong>。</p><p>開源模型在它誕生之前，很大程度上被視為一種<strong>玩具</strong>，但在它之後，大家發現開源模型是一個重要的發展方向，而且性能可以與閉源模型一較高下。</p><p>R1 絕對是跨時代的作品，而且到了現在，表現依舊名列前茅。</p><h3 id="2-DeepSeek-V3"><a href="#2-DeepSeek-V3" class="headerlink" title="2. DeepSeek V3"></a>2. DeepSeek V3</h3><p>DeepSeek V3 屬於「非推理」模型，而且寫程式的能力特別強，是 OpenRouter 網站上被大量工具用來寫程式的頂尖模型之一。</p><p>在所有開源模型中，用量基本上穩居<a href="https://openrouter.ai/rankings">第一名</a>。</p><p>不過要特別注意：OpenRouter 的這個免費版本，在 Input Token 超過 25K 之後，可能會出現不斷重複的問題，我就曾經遇到過。</p><h3 id="3-Qwen3-32B"><a href="#3-Qwen3-32B" class="headerlink" title="3. Qwen3-32B"></a>3. Qwen3-32B</h3><p>阿里巴巴的通義千問系列，英文是 Qwen。</p><p>Qwen3 這系列的模型非常新，發表還未滿一個月，而且全都是推理與非推理的<strong>混合型模型</strong>。可參考官方 <a href="https://qwenlm.github.io/blog/qwen3/">blog 介紹</a>，值得一讀。</p><p>本質上是推理模型，但可以透過提示詞「<code>/no_think</code>」來關閉它的推理能力，這樣你就不用等太久。</p><p>而 Qwen3-32B 是「緊湊」模型中，規模最大的那個，能力相當不錯。</p><p>基本上擁有 32 GB 統一記憶體的 Mac 就能跑起來，接 API 的好處則是——輸出更快！</p><h3 id="4-Qwen3-235B-A22B"><a href="#4-Qwen3-235B-A22B" class="headerlink" title="4. Qwen3-235B-A22B"></a>4. Qwen3-235B-A22B</h3><p>除了混合型這個特色之外，Qwen3 還推出了兩個 MoE 模型（混合專家模型）：</p><ol><li>Qwen3-30B-A3B</li><li>Qwen3-235B-A22B</li></ol><p>這類模型的特色就是在推理時——也就是<strong>輸出結果時，只需要動用到一部分的參數</strong>，所以計算速度特別快。（因為計算量少很多）</p><p>以 Qwen3-30B-A3B 為例，作為一個 30B 模型，它的「聰明程度」是 30B 等級的，但輸出速度卻像 3B 的小模型這麼快。</p><p>附帶一提，DeepSeek V3 也是 MoE 模型，只是通常不會特別強調。</p><p>Qwen3-235B-A22B 這樣超過 200B 的規模，很難在消費級硬體中跑起它，所以 API 更顯得有價值。</p><h3 id="5-Google-Gemma-3-27B"><a href="#5-Google-Gemma-3-27B" class="headerlink" title="5. Google Gemma 3 27B"></a>5. Google Gemma 3 27B</h3><p>Google 推出的開源模型，個人評價很高，我曾經在〈<a href="https://www.notion.so/17-Gemma-3-Vibe-Coding-1c66a92a98a680fe94cfde64ccb96719?pvs=21">訂戶限定 17：強大的 Gemma 3、上班前夕的花蓮之旅、Vibe Coding</a>〉中大力推薦過。</p><p>雖然跑分比不上前述四個模型——畢竟它的規模相對較小，但繁體中文能力出色，適合對話、文章創作類的應用。</p><p>更難能可貴的是——它還有「視覺」能力。</p><blockquote><p>備註：Google 在 OpenRouter 上還有另一款免費模型 <a href="https://openrouter.ai/google/gemini-2.0-flash-exp:free">google&#x2F;gemini-2.0-flash-exp:free</a>，屬於閉源模型，能力自然不在話下。但流量高峰時段常出現 HTTP 429（限流），故不列入推薦名單。</p></blockquote><hr><h2 id="表格比較"><a href="#表格比較" class="headerlink" title="表格比較"></a>表格比較</h2><p>以下是這五個模型的簡易比較表，提供給讀者快速參考：</p><table><thead><tr><th>模型名稱</th><th>開發者</th><th>模型規模</th><th>特點摘要</th></tr></thead><tbody><tr><td>DeepSeek R1</td><td>DeepSeek</td><td>超大型</td><td>改變時代的開源推理型模型，號稱比美 OpenAI o1</td></tr><tr><td>DeepSeek V3</td><td>DeepSeek</td><td>超大型（MoE）</td><td>非推理型，程式能力強，社群使用率第一</td></tr><tr><td>Qwen3-32B</td><td>阿里巴巴</td><td>中型</td><td>混合推理模型，可以使用「非推理」模式</td></tr><tr><td>Qwen3-235B-A22B</td><td>阿里巴巴</td><td>超大型（MoE）</td><td>混合專家模型，平衡了性能與產出速度</td></tr><tr><td>Gemma 3 27B</td><td>Google</td><td>中型</td><td>多語言能力強，尤其是台灣繁體中文，適合對話與創作</td></tr></tbody></table><hr><h2 id="結語：百花齊放的時代"><a href="#結語：百花齊放的時代" class="headerlink" title="結語：百花齊放的時代"></a>結語：百花齊放的時代</h2><p>綜上所述，這五款模型在生成品質、穩定性與實用性之間取得了較好的平衡。</p><p>無論寫程式、翻譯，還是想打造自己的 AI 工具，這些模型都能成為你起步的好夥伴。</p><p>希望這篇文章能幫助你快速上手 OpenRouter，並找到適合自己的免費模型。</p><p>讓我們繼續在 AI 的浪潮上，乘風破浪吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/openrouter-free-models.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;在這個 AI 應用百花齊放的時代，我們可以透過各種方式來接觸 AI。&lt;/p&gt;
&lt;p&gt;可以使用線上服務——比如 ChatGPT ，也可以直接使用 LLM API 來更加客製化自己的需求。&lt;/p&gt;
&lt;p&gt;最近我開始使用 OpenRouter 這個平台上的 API 服務，對於 AI 開發人員或 LLM 重度用戶，想必不陌生。&lt;/p&gt;
&lt;p&gt;本文介紹 OpenRouter 上的 5 個免費模型，幫助你快速上手並選擇合適的模型。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OpenRouter-是什麼？&quot;&gt;&lt;a href=&quot;#OpenRouter-是什麼？&quot; class=&quot;headerlink&quot; title=&quot;OpenRouter 是什麼？&quot;&gt;&lt;/a&gt;OpenRouter 是什麼？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://openrouter.ai/&quot;&gt;OpenRouter&lt;/a&gt; 是一個&lt;strong&gt;語言模型的 API 聚合平台服務&lt;/strong&gt;，讓使用者可以透過單一介面，就能夠付費存取多家公司的大語言模型，包括 OpenAI、Anthropic、Google 等大公司的 LLM API 產品。&lt;/p&gt;
&lt;p&gt;而且像 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/LLaMA&quot;&gt;LLaMa&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E6%B7%B1%E5%BA%A6%E6%B1%82%E7%B4%A2&quot;&gt;DeepSeek&lt;/a&gt; 這類開源模型，你想要使用的話，除了在本地跑之外，也可以透過 OpenRouter 提供的 API 來使用。&lt;/p&gt;
&lt;p&gt;好處就是你不用擁有機器、顯卡，就能體驗這些開源模型的能力，而且價格相對於閉源模型，通常有一定的競爭力。&lt;/p&gt;
&lt;p&gt;總之，OpenRouter 不僅為開發者提供了統一的介面，更讓非技術出身的用戶也能輕鬆使用 AI。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/openrouter-free-models.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</title>
    <link href="https://blog.kyomind.tw/poetry-multi-stage-build/"/>
    <id>https://blog.kyomind.tw/poetry-multi-stage-build/</id>
    <published>2025-05-24T02:36:33.000Z</published>
    <updated>2025-05-24T03:31:38.197Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/poetry-multi-stage-build.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>最近都在為〈<a href="/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a>〉一文進行「減肥」，讓它更容易閱讀、回顧。</p><p>除此之外，是時候為「<a href="/series/#Python-Poetry-%E4%B8%89%E9%83%A8%E6%9B%B2">Python Poetry</a>」這個系列畫下句點了——而本文就是最後一塊拼圖！</p><p>我曾在前文中提到，為什麼不在 Docker 容器中使用 Poetry。主要原因是：</p><blockquote><p>啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會<strong>增加新的耦合與依賴</strong>，需要更細緻的管理。</p></blockquote><p>但這樣的限制，其實可以透過 Docker 的 <strong>multi-stage build</strong> 解決。</p><p>本文將從實務角度出發，介紹如何使用 multi-stage build，在 Docker 中整合 Poetry。</p><p>讓你既能享有 Poetry 的套件管理優勢，又不會對部署流程增加額外負擔。</p><h3 id="系列：Python-Poetry-三部曲"><a href="#系列：Python-Poetry-三部曲" class="headerlink" title="系列：Python Poetry 三部曲"></a>系列：Python Poetry 三部曲</h3><blockquote><ol><li><a href="/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a></li><li><a href="/poetry-pyenv-practical-tips/">Poetry + pyenv 教學：常用指令與注意事項</a></li><li><strong>Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境</strong></li></ol></blockquote><p>我們開始吧！</p><span id="more"></span><hr><h2 id="舊有做法：requirements-txt-及其限制"><a href="#舊有做法：requirements-txt-及其限制" class="headerlink" title="舊有做法：requirements.txt 及其限制"></a>舊有做法：requirements.txt 及其限制</h2><p>在過去的容器建構流程中，我們多半會使用<code>requirements.txt</code>來安裝 Python 套件、建立專案虛擬環境。</p><p>這是因為 Python 的官方 image <strong>已經內建 pip</strong>，我們可以在 Docker（Dockerfile）直接透過下列指令安裝相依套件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure><p>這種做法最大的優勢就是<strong>方便</strong>。</p><p>然而仔細想想，我們在開發階段使用 Poetry，部署時卻用 pip，這樣的流程會產生一個「斷點」。</p><p>我們必須從 Poetry 匯出一份與<code>poetry.lock</code>對應的<code>requirements.txt</code>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">export</span> -f requirements.txt --without-hashes -o requirements.txt</span><br></pre></td></tr></table></figure><p>這樣做看似簡單、直觀，但經驗告訴我，在更新<code>poetry.lock</code>時，<strong>常常會忘記同步</strong>到<code>requirements.txt</code>。所以 uv 還專門提供了一個 pre-commit hook 來自動化同步。</p><p>退一步來說，<code>export</code>指令產出的結果，其實和 pip 也<strong>不是 100% 相容</strong>，如果遇到相容問題，將會使得<code>requirements.txt</code>無法如預期安裝。</p><blockquote><p>真麻煩！</p></blockquote><h2 id="為什麼不直接在-Docker-image-中安裝-Poetry？"><a href="#為什麼不直接在-Docker-image-中安裝-Poetry？" class="headerlink" title="為什麼不直接在 Docker image 中安裝 Poetry？"></a>為什麼不直接在 Docker image 中安裝 Poetry？</h2><p>我們已經知道使用<code>requirements.txt</code>的方式有其限制，那是否可以直接在 Docker 中安裝 Poetry，來避免 export 同步的麻煩呢？</p><p>這似乎是一個<strong>簡單粗暴</strong>的解法，但除了開頭說的「增加新的耦合與依賴」問題外，這樣做還會導致<strong>另一個棘手問題</strong>——<strong>image 會變得過於龐大</strong>。</p><p>因為我們必須額外安裝 Poetry 及其所有相依套件（如 curl、build tools 等），這些工具在部署時其實並不需要。</p><p>結果是：</p><ul><li>不必要的工具進入部署環境，增加潛在維護成本。</li><li>Docker image 體積變得難以控管。</li></ul><p>而這正是 Docker multi-stage build 要解決的關鍵痛點。</p><p>它讓我們可以在前一階段「<strong>用完即丟</strong>」，只保留執行需要的檔案與相依套件，而非將整套開發工具都一併打包進去。</p><hr><h2 id="Multi-stage-build-是什麼？為什麼重要？"><a href="#Multi-stage-build-是什麼？為什麼重要？" class="headerlink" title="Multi-stage build 是什麼？為什麼重要？"></a>Multi-stage build 是什麼？為什麼重要？</h2><p>Docker 的 multi-stage build 允許我們在一個 Dockerfile 中定義<strong>多個建構階段</strong>。</p><p>透過這種方式，我們可以在前一階段中安裝與建構需要的工具（例如 Poetry 與依賴套件），然後<strong>在後續階段捨棄它們</strong>，只留下必要的執行檔與依賴，大幅減少最終 image 的體積與耦合程度。</p><p>對於使用 Poetry 管理套件的 Python 專案而言，這是一種相對理想的建構策略：</p><ol><li>只在第一階段使用 Poetry，並安裝專案所需的套件。</li><li>第二階段則不再需要 Poetry——<strong>留下建好的 Python 虛擬環境已足</strong>。</li></ol><h2 id="Multi-stage-build-的常見應用場景"><a href="#Multi-stage-build-的常見應用場景" class="headerlink" title="Multi-stage build 的常見應用場景"></a>Multi-stage build 的常見應用場景</h2><p>Multi-stage build 適用於多種開發與部署情境，以下是幾個常見的應用場景。</p><h3 id="1-編譯型語言的建構階段與執行階段分離"><a href="#1-編譯型語言的建構階段與執行階段分離" class="headerlink" title="1. 編譯型語言的建構階段與執行階段分離"></a>1. 編譯型語言的建構階段與執行階段分離</h3><ul><li>在 Go、Rust、C++ 等語言中，編譯階段通常需要安裝大量工具與編譯器。</li><li>透過 multi-stage build，可以在第一階段完成編譯，第二階段僅保留編譯後的 binary，讓 image 更精簡。</li></ul><p>這部分可參考<a href="https://kucw.io/about/">古古</a>的〈<a href="https://kucw.io/blog/springboot-docker-image/">為 Spring Boot 生成 Docker image</a>〉，對編譯型語言（文中為 Java）的 multi-stage build 應用，有著更加詳細的講解。</p><h3 id="2-執行環境的依賴管理分離"><a href="#2-執行環境的依賴管理分離" class="headerlink" title="2. 執行環境的依賴管理分離"></a>2. 執行環境的依賴管理分離</h3><ul><li>Poetry 就是典型範例：建構階段需要 Poetry 處理 dependencies，執行階段只需保留 site-packages 即可。</li><li>pipenv、npm&#x2F;yarn（JS 世界）也可套用類似概念，第一階段建構，第二階段保留 node_modules 或 dist。</li></ul><h3 id="3-CI-CD-中的環境控制與-image-輕量化"><a href="#3-CI-CD-中的環境控制與-image-輕量化" class="headerlink" title="3. CI&#x2F;CD 中的環境控制與 image 輕量化"></a>3. CI&#x2F;CD 中的環境控制與 image 輕量化</h3><ul><li>有些 CI pipeline 在建構階段需要額外工具（如 linters、testing frameworks），但最終部署不需要。</li><li>Multi-stage 可讓這些工具不進入最終 image，保持部署清爽。</li></ul><hr><h2 id="Dockerfile-範例與解說"><a href="#Dockerfile-範例與解說" class="headerlink" title="Dockerfile 範例與解說"></a>Dockerfile 範例與解說</h2><p>以下範例中，我們將整個建構流程分為兩個階段：</p><ul><li><strong>第一階段（builder）</strong>：專責安裝 Poetry 與專案相依套件，不進入最終 image 中。</li><li><strong>第二階段（runtime）</strong>：為實際執行環境，僅保留必要的程式碼與套件。</li></ul><p>以下是一份簡化過後的 Dockerfile 範例，展示如何使用 multi-stage build 來整合 Poetry，同時<strong>省略與主題無關的環節</strong>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一階段：建構環境與安裝 Poetry 相依套件</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.12</span>-slim AS builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝系統相依套件（Poetry 需要 curl 等工具）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y curl build-essential ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝 Poetry 並設定環境變數</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -sSL https://install.python-poetry.org | python3 -</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/root/.local/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pyproject.toml poetry.lock ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> your_module your_module</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Poetry 安裝相依套件</span></span><br><span class="line"><span class="comment"># 變更設定：不建立虛擬環境，因為 Docker 本身就是隔離環境</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> poetry config virtualenvs.create <span class="literal">false</span> \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># 只安裝 main 的套件，即不含 dev、test 等 group</span></span></span><br><span class="line">    &amp;&amp; poetry install --only main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二階段：建立乾淨的 image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.12</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝運行 Poetry 時需要的 Linux 系統套件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y libpq-dev ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;your_entrypoint.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="重點說明"><a href="#重點說明" class="headerlink" title="重點說明"></a>重點說明</h3><ul><li>第一階段只負責安裝 Poetry 與相依套件——透過<code>poetry install</code>安裝。這裡的 Dockerfile 慣用語是<code>FROM xxx AS yyy</code>，其中<code>builder</code>是常見名稱。</li><li>Poetry 安裝套件時，可先調整設定，改成<strong>不建立虛擬環境</strong>，因為 Docker 本身即為獨立環境，沒必要再隔離。<ul><li>用於部署階段，所以也不必安裝開發、測試相關套件。</li><li>使用<code>--only main</code>來安裝主要的相依套件。</li></ul></li><li>第二階段只保留已安裝好的 site-packages 與應用程式程式碼。<ul><li>具體做法就是<strong>複製「前階段」產生的檔案、目錄到當前環境。</strong></li><li>關鍵句則是<code>COPY --from=builder xxx</code>。</li></ul></li></ul><p>一切就這麼簡單！</p><p>在 AI 時代，重要的是<strong>知曉這些概念</strong>，至於 Dockerfile 具體該怎麼寫，我認為只要實際操作時一邊詢問 AI 就可以了。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Poetry 是一個強大的 Python 套件管理工具，但若直接將它納入部署環境，可能導致不必要的複雜與耦合。</p><p>透過 multi-stage build，我們可以同時兼顧建構效率與部署簡潔。</p><p>使用正確策略，Poetry 不只是開發者的利器，也能優雅地融入部署流程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/poetry-multi-stage-build.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近都在為〈&lt;a href=&quot;/python-poetry/&quot;&gt;Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉一文進行「減肥」，讓它更容易閱讀、回顧。&lt;/p&gt;
&lt;p&gt;除此之外，是時候為「&lt;a href=&quot;/series/#Python-Poetry-%E4%B8%89%E9%83%A8%E6%9B%B2&quot;&gt;Python Poetry&lt;/a&gt;」這個系列畫下句點了——而本文就是最後一塊拼圖！&lt;/p&gt;
&lt;p&gt;我曾在前文中提到，為什麼不在 Docker 容器中使用 Poetry。主要原因是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會&lt;strong&gt;增加新的耦合與依賴&lt;/strong&gt;，需要更細緻的管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但這樣的限制，其實可以透過 Docker 的 &lt;strong&gt;multi-stage build&lt;/strong&gt; 解決。&lt;/p&gt;
&lt;p&gt;本文將從實務角度出發，介紹如何使用 multi-stage build，在 Docker 中整合 Poetry。&lt;/p&gt;
&lt;p&gt;讓你既能享有 Poetry 的套件管理優勢，又不會對部署流程增加額外負擔。&lt;/p&gt;
&lt;h3 id=&quot;系列：Python-Poetry-三部曲&quot;&gt;&lt;a href=&quot;#系列：Python-Poetry-三部曲&quot; class=&quot;headerlink&quot; title=&quot;系列：Python Poetry 三部曲&quot;&gt;&lt;/a&gt;系列：Python Poetry 三部曲&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/python-poetry/&quot;&gt;Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/poetry-pyenv-practical-tips/&quot;&gt;Poetry + pyenv 教學：常用指令與注意事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker 教學：用 Multi-stage build 建立 Poetry 虛擬環境&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/poetry-multi-stage-build.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
  </entry>
  
  <entry>
    <title>Python 套件管理器 uv 介紹——與 Poetry 比較</title>
    <link href="https://blog.kyomind.tw/introducing-uv/"/>
    <id>https://blog.kyomind.tw/introducing-uv/</id>
    <published>2025-05-18T13:07:27.000Z</published>
    <updated>2025-05-19T12:58:12.563Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/introducing-uv-min.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>3 年前，我寫了這篇〈<a href="/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a>〉，它成為了本站最受歡迎的文章之一。</p><p>隨著 Python 開發生態的發展，新的工具不斷湧現，你可能已經聽過，我們今天要介紹的主角——Astral 的 uv。</p><p>之前有讀者希望我介紹 uv，但因為沒有急迫需求，所以一直拖到最近才開始嘗試。</p><p>這幾天，我終於在 side project 中開始使用它，因此有了初步的心得。</p><p>這篇文章將先介紹 uv 的背景、特點，以及<strong>和 Poetry 的比較</strong>（這是我最在乎的，也是所有習慣 Poetry 的讀者可能感興趣的），幫助你評估是否要轉向這個新工具。</p><p>至於教學，我會在下一篇文章中分享 uv 的實際使用方式，包括安裝、專案初始化、依賴管理等操作，協助你快速上手。</p><span id="more"></span><hr><h2 id="Python-套件管理的現況與挑戰"><a href="#Python-套件管理的現況與挑戰" class="headerlink" title="Python 套件管理的現況與挑戰"></a>Python 套件管理的現況與挑戰</h2><p>在 Python 開發生態中，<code>pip</code>和<code>virtualenv</code>在過去很長一段時間裡，都是套件安裝與虛擬環境管理的主流工具。</p><p>然而，隨著專案規模的擴大與需求的多樣化，這些工具逐漸暴露出一些限制，例如安裝速度慢、依賴衝突難以解決，以及缺乏統一的專案管理流程。</p><p>為了解決這些問題，社群中出現了如 <code>pip-tools</code>、<code>pipenv</code> 和 <code>poetry</code> 等工具，試圖提供更完善的解決方案。</p><p>這些工具在一定程度上改善了套件管理的體驗，但也引入了<strong>新的學習曲線和複雜度</strong>。</p><p>讓人不禁羨慕起 Rust 的 <a href="https://github.com/rust-lang/cargo">Cargo</a> 套件管理器——唯一的選擇，而且體驗絕佳。</p><h3 id="該如何選擇？"><a href="#該如何選擇？" class="headerlink" title="該如何選擇？"></a>該如何選擇？</h3><p>總之，我們不得不選擇，而且<strong>沒有一個完全壓倒性的方案</strong>——這是 Python 生態的一大特色XD</p><p>過去我選擇了 Poetry，現在則開始嘗試 uv。</p><p>本文記錄我的<strong>思路與心得</strong>，讓你可以根據自己的需求做出判斷。</p><hr><h2 id="uv-是什麼？"><a href="#uv-是什麼？" class="headerlink" title="uv 是什麼？"></a>uv 是什麼？</h2><p><a href="https://github.com/astral-sh/uv">uv</a> 是由 <a href="https://astral.sh/">Astral</a> 團隊開發的一款現代化的 Python 套件管理暨打包（packing）工具。</p><p>乍聽之下，它做的事和 <a href="https://python-poetry.org/">Poetry</a> 大小同異——確實如此，只是更加<strong>包山包海</strong>，並且是用 Rust 寫的。</p><p>就像同為 Astral 出品的 <a href="https://docs.astral.sh/ruff/">Ruff</a>，它們的共同目標都是成為該領域的「<strong>唯一選擇</strong>」XD</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/ruff/">Python 開發：Ruff Linter、Formatter 介紹 + 設定教學</a></p></blockquote><p>而且從目前的趨勢看起來，似乎很有機會！</p><h3 id="uv-的核心特點"><a href="#uv-的核心特點" class="headerlink" title="uv 的核心特點"></a>uv 的核心特點</h3><p>uv 作為一個現代化的 Python 套件管理工具，具有以下幾個核心特點：</p><ul><li><strong>高效能</strong>：uv 在套件安裝與依賴解析方面比傳統工具快上 10 到 100 倍。</li><li><strong>整合式工具</strong>：結合了打包、套件管理、虛擬環境管理、<strong>Python 版本管理</strong>等功能。其中 Python 版本管理是 uv 的一大特色，意味著你不必再搭配<code>pyenv</code>等工具。</li><li><strong>跨平台支援</strong>：支援 macOS、Linux 和 Windows，適用於多種開發環境。雖然是 Rust 寫的，但你無須擔心環境設定與安裝問題。</li></ul><p>uv 的特點很多，作為使用者，我必須要找到一些<strong>具體切入點</strong>，來作為是否使用的判斷依據。</p><hr><p>因此，身為一個 Poetry 長期使用者，我自然會更關心它<strong>相對於 Poetry 有哪些優勢、是否值得我學習並轉向這個新工具</strong>。</p><p>經過幾天的嘗試，我認為 uv 相較於 Poetry 具備三個主要優勢。</p><h2 id="優勢一：後發優勢與透明度"><a href="#優勢一：後發優勢與透明度" class="headerlink" title="優勢一：後發優勢與透明度"></a>優勢一：後發優勢與透明度</h2><p>uv 比較晚出現，所以它的「<strong>歷史包袱</strong>」遠比 Poetry 要少得多。</p><p>Poetry 在 2018 年開始發展，這意味著它需要考慮到許多舊版的相容問題。而且很多時候，Poetry 團隊<strong>直接選擇不相容</strong>——而且也沒有充分說明，然後被社群罵爆。</p><p>例如，某個 minor&#x2F;patch release 引入了不向後相容的變更，導致 CI&#x2F;CD 流程或 Docker 容器重建失敗。</p><p>這類事件讓部分使用者對 Poetry 的版本管理失去信心。</p><p>我從 1.1.x 開始使用，幾乎每個大版本都會有一些惱人 breaking change🤬</p><p>uv 不止比較新，而且在 breaking change 的透明度和文件化方面，看起來比 Poetry 更謹慎。</p><hr><h2 id="優勢二：更快、更簡單"><a href="#優勢二：更快、更簡單" class="headerlink" title="優勢二：更快、更簡單"></a>優勢二：更快、更簡單</h2><p>uv 用 Rust 寫的，這意味著它在性能上有著天然的優勢。</p><p>本來我是覺得這不算很重要的事情，畢竟套件的安裝、依賴解析等操作，通常不會頻繁發生。</p><p>但實際上，這些操作的速度如果不夠快，還是會影響<strong>開發者體驗</strong>——尤其在套件愈裝愈多的情況下。</p><p>如果考慮到 CI&#x2F;CD 流程，差異就更明顯了。</p><h3 id="更簡單的指令設計"><a href="#更簡單的指令設計" class="headerlink" title="更簡單的指令設計"></a>更簡單的指令設計</h3><p>我一直覺得，Poetry 的指令設計<strong>有些複雜</strong>，而且<strong>太多了</strong>！</p><p>uv 則相對好一些（雖然還是不少），子命令的設計也更為<strong>直觀</strong>，例如 <code>uv python</code>、<code>uv pip</code>等。</p><p>這裡我覺得「更簡單」的主要意思是：uv 在日常操作下的<strong>常用指令更少、更精簡</strong>。</p><hr><h2 id="優勢三：包含了-Python-版本管理"><a href="#優勢三：包含了-Python-版本管理" class="headerlink" title="優勢三：包含了 Python 版本管理"></a>優勢三：包含了 Python 版本管理</h2><p>事實上，不止 Python 的套件管理生態是一鍋大雜燴，Python 的版本管理生態也是。</p><p>什麼 Anaconda、pyenv，甚至是 Docker，都可以用來管理 Python 環境。</p><p>太煩了！</p><p>尤其在使用 Poetry 建立虛擬環境時，你很可能會遇到<strong>無法精確控制</strong>它用哪個 Python 版本的情況。</p><p>為此我又寫了這篇〈<a href="https://blog.kyomind.tw/poetry-pyenv-practical-tips/">Poetry + pyenv 教學：常用指令與注意事項</a>〉——這實在是無奈之舉。</p><p>uv 的一大特色是內建了 Python 版本管理功能，你可以直接透過它<strong>下載與管理不同的 Python</strong> 版本，無需額外安裝<code>pyenv</code>或其他工具。</p><p>省去這個 Python 版本指定的麻煩，讓我在使用 uv 時感覺輕鬆許多。</p><hr><h2 id="我要學-uv-嗎？三種讀者情境分析"><a href="#我要學-uv-嗎？三種讀者情境分析" class="headerlink" title="我要學 uv 嗎？三種讀者情境分析"></a>我要學 uv 嗎？三種讀者情境分析</h2><p>在了解了 uv 的三個主要優勢後，接下來我們可以根據不同的使用情境，來探討它是否適合你的需求。</p><p>以下是我給下列三種讀者的建議。</p><h3 id="1-只用過pip"><a href="#1-只用過pip" class="headerlink" title="1. 只用過pip"></a>1. 只用過<code>pip</code></h3><p>不用說，這個年代只有<code>pip</code>肯定是不夠的，而此時此刻要學一個能夠長久使用的套件管理工具，我應該還是會推薦 uv。（而不是 Poetry）</p><h3 id="2-正在使用-Poetry，覺得還行"><a href="#2-正在使用-Poetry，覺得還行" class="headerlink" title="2. 正在使用 Poetry，覺得還行"></a>2. 正在使用 Poetry，覺得還行</h3><p>學習新的 Python 套件管理工具的「<strong>認知成本</strong>」並不低，如果沒有實際需求，<strong>維持現狀</strong>也不失為一個好選擇。</p><h3 id="3-已經使用-Poetry，但有很多不滿"><a href="#3-已經使用-Poetry，但有很多不滿" class="headerlink" title="3. 已經使用 Poetry，但有很多不滿"></a>3. 已經使用 Poetry，但有很多不滿</h3><p>如果上述 uv 相對 Poetry 的優勢，正好是你不滿的地方，則可以認真考慮轉向 uv。</p><h3 id="我的選擇"><a href="#我的選擇" class="headerlink" title="我的選擇"></a>我的選擇</h3><p>我目前在工作上還是使用 Poetry，所以沒辦法直接捨棄它。</p><p>不過，預計未來個人專案應該都會轉向 uv。</p><p>要說理由，對我來說核心理由<strong>只有一個</strong>，就是<strong>它包含了 Python 版本的管理</strong>。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>綜上所述，uv 相較於 Poetry，確實有它<strong>令人心動</strong>的地方。</p><p>無論你是剛接觸 Python 套件管理的新手，還是對現有工具感到不滿的進階使用者，uv 都是一個值得嘗試的選擇。</p><p>在下一篇文章中，我將進一步介紹 uv 的實際使用方式，包含安裝、專案初始化、依賴管理等操作，幫助你快速上手這個新工具。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/introducing-uv-min.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;3 年前，我寫了這篇〈&lt;a href=&quot;/python-poetry/&quot;&gt;Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉，它成為了本站最受歡迎的文章之一。&lt;/p&gt;
&lt;p&gt;隨著 Python 開發生態的發展，新的工具不斷湧現，你可能已經聽過，我們今天要介紹的主角——Astral 的 uv。&lt;/p&gt;
&lt;p&gt;之前有讀者希望我介紹 uv，但因為沒有急迫需求，所以一直拖到最近才開始嘗試。&lt;/p&gt;
&lt;p&gt;這幾天，我終於在 side project 中開始使用它，因此有了初步的心得。&lt;/p&gt;
&lt;p&gt;這篇文章將先介紹 uv 的背景、特點，以及&lt;strong&gt;和 Poetry 的比較&lt;/strong&gt;（這是我最在乎的，也是所有習慣 Poetry 的讀者可能感興趣的），幫助你評估是否要轉向這個新工具。&lt;/p&gt;
&lt;p&gt;至於教學，我會在下一篇文章中分享 uv 的實際使用方式，包括安裝、專案初始化、依賴管理等操作，協助你快速上手。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/introducing-uv-min.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
  </entry>
  
  <entry>
    <title>寫好 Python Docstring 的 4 個層次——從簡單到詳細</title>
    <link href="https://blog.kyomind.tw/python-docstring/"/>
    <id>https://blog.kyomind.tw/python-docstring/</id>
    <published>2025-05-03T00:06:20.000Z</published>
    <updated>2025-05-20T15:04:18.565Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.kyomind.tw/code-and-me.png"></p><p>在〈<a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/">Docstring 的重要性——《Python 功力提升的樂趣》</a>〉一文中，我提到了：</p><blockquote><p>Docstring 也不是有寫就行，還需要從「<strong>讀者</strong>（也就是你的同事）」的角度去思考與表達。不然看起來會很像開發者的自言自語——沒人看得懂。</p></blockquote><p>在工作上使用 Python 多年，即便是經驗豐富的 Python 工程師，很多人也未必養成了撰寫 Docstring 的習慣。</p><p>畢竟在日常趕專案的場景下，一段程式碼能否 work，往往比「好讀、好理解」更重要——至少更急迫。</p><p>然而，當專案逐漸擴大、團隊成員增加時，沒有良好的 Docstring，<strong>協作上的痛苦</strong>就會慢慢浮現。</p><p>Docstring 不是單純寫給自己的備忘，而是寫給「<strong>下一個會看這份程式的人</strong>」。</p><p>當你開始用這個角度思考，你會發現，寫好 Docstring 並不是加分項，而是基本功。</p><blockquote><p><strong>那要怎樣才能寫好 Python Docstring 呢？</strong></p></blockquote><p>作為 Docstring 信奉者，本文將分享我在過去工作經驗中所累積的 <strong>Python Docstring</strong> 寫作心得，並整理成<strong>教學指南</strong>。</p><span id="more"></span><hr><h2 id="什麼是-Docstring？"><a href="#什麼是-Docstring？" class="headerlink" title="什麼是 Docstring？"></a>什麼是 Docstring？</h2><p><a href="https://en.wikipedia.org/wiki/Docstring">Docstring</a>（Documentation String）是 Python 中用來描述<strong>模組、類別、函式（包括類別中的方法）</strong>用途的<strong>字串</strong>。</p><p>它通常放在定義語法（比如<code>def xxx</code>）之後，由<strong>三個雙引號</strong>（<code>&quot;&quot;&quot;</code>）包覆，方便工具或 IDE 自動擷取，生成文件或顯示說明。</p><p>良好的 Docstring 不僅可以幫助他人快速理解程式碼，也能在開發、維護、協作中扮演關鍵角色。</p><p>它是「<a href="https://blog.kyomind.tw/django-ninja-17/#Documentation-as-Code">程式碼即文件</a>」理念的具體實踐方式之一。</p><p>Docstring 這種設計在許多語言中都有，例如 Java 的 JavaDoc、C# 的 XML Comments 等，Python 版本因為簡單好用，更成為日常開發不可或缺的一環。</p><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p><strong>我將透過具體的案例來闡述如何寫好 Docstring。</strong></p><p>本文主要的目標讀者，是那些已經在用 Python 開發專案、參與團隊協作的工程師們——在團隊協作的場景下，Docstring 的重要性會<strong>遠超過</strong>個人開發。</p><p>換言之，Docstring 象徵的是「<strong>溝通的藝術</strong>」😎</p><p>當專案愈來愈複雜，或有新成員加入時，Docstring 會展現它的價值：</p><ul><li>協助他人快速理解你的函式用途與用法</li><li>減少口頭或書面文件的補充說明成本</li><li>提升程式碼自我解釋（self-explanatory）的能力</li><li>幫助自己未來回頭維護時快速理解程式</li></ul><p>本文將從「實用角度」出發，分享如何根據不同情境，靈活且有效地撰寫（或選擇不寫）Python Docstring。</p><h2 id="Docstring-的基本格式與風格"><a href="#Docstring-的基本格式與風格" class="headerlink" title="Docstring 的基本格式與風格"></a>Docstring 的基本格式與風格</h2><p>Python Docstring 的格式與風格並沒有固定的規範，但有一些通用的慣例與建議。</p><p>按照〈<a href="https://peps.python.org/pep-0257/">PEP 257 – Docstring Conventions</a>〉的建議，Docstring 必須用三個雙引號（<code>&quot;&quot;&quot;</code>）包起來。</p><p>以下是 Python 社群中常見的 Docstring 風格：</p><ul><li>Google Style</li><li>Numpy Style</li><li>reStructuredText (Sphinx)</li></ul><p>本文範例皆採用 Google Style，這是我過去工作中使用的風格，它簡潔且容易閱讀。</p><p>不過，我覺得風格不是重點，清楚與一致才是關鍵。</p><p>下一篇文章會介紹如何用 VS Code 的套件快速生成各種風格的 Docstring，這裡就先不深入。</p><hr><h2 id="不是每個函式都需要-Docstring"><a href="#不是每個函式都需要-Docstring" class="headerlink" title="不是每個函式都需要 Docstring"></a>不是每個函式都需要 Docstring</h2><p>Docstring 可以寫在模組、類別與函式的開頭，我們在這裡主要討論函式的 Docstring 撰寫，因為它是<strong>最常用</strong>，同時也是<strong>最需要說明</strong>的程式碼元件。</p><p>在開始介紹四個層次之前，有一個觀念必須先釐清：<strong>不是每個函式都需要 Docstring</strong>。</p><p>有些函式，一看就知道用途，例如簡單的資料轉換、資料初始化，或是完全沒有參數。</p><p>這些函式若執意要寫 Docstring，反而可能造成<strong>雜訊</strong>。</p><p>簡單來說：</p><blockquote><p>如果一個函式「一望即知」，那就不需要為寫而寫。</p></blockquote><p>Docstring 的重點在於補充「<strong>別人不容易一眼看懂的東西</strong>」，它是一種<strong>基於「同理心」的實踐</strong>，而非教條。</p><hr><h2 id="Docstring-的四個層次"><a href="#Docstring-的四個層次" class="headerlink" title="Docstring 的四個層次"></a>Docstring 的四個層次</h2><p>根據不同的情境與複雜度，決定 Docstring 撰寫的詳細程度很重要。</p><p>不過，必須承認，在多數情況下，我們都是透過工具輔助——而工具產生的通常是下述<strong>第三層次</strong>（對輸入輸出有完整說明）的 Docstring 框架。</p><p>因此，如果把每一個 Docstring 都寫到第三層次，我也不反對。畢竟它最常見。</p><p>我自己則會依照程式碼的複雜度，進行一定程度的調整。</p><p>無論如何，在實務情境中，<strong>有寫通常比沒寫好</strong>☺️ </p><h2 id="一、只有主旨的-Docstring"><a href="#一、只有主旨的-Docstring" class="headerlink" title="一、只有主旨的 Docstring"></a>一、只有主旨的 Docstring</h2><p>有些簡單但<strong>需要了解「大概意圖」</strong>的函式，只需要一句話就足夠：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_internal_user</span>(<span class="params">email</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;判斷電子郵件是否為內部使用者&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> email.endswith(<span class="string">&quot;@company.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>這樣的 Docstring 雖然簡單，卻仍比沒有好。</p><p>這段主旨的文眼在於「<strong>判斷</strong>」二字，它直接說明了程式的行為與意圖，讓別人一眼就能知曉這個函式<strong>打算做什麼</strong>——判斷並回傳布林值。</p><h3 id="錯誤示範"><a href="#錯誤示範" class="headerlink" title="錯誤示範"></a>錯誤示範</h3><p>要寫好一行式的 Docstring 有時並不容易，我們偶爾會陷入<strong>過於細節的描述</strong>，以下是個不太好的示範：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;透過 SQL 查詢比對用戶的電子郵件是否為內部使用者&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>這種寫法就太底層了，提到了那些<strong>不必要的細節</strong>（SQL 查詢），容易讓人分心。</p><p>Docstring 應描述<strong>高階意圖</strong>，而非內部細節。</p><hr><h2 id="二、主旨-說明（加上-context，讓人看得懂用在什麼情境）"><a href="#二、主旨-說明（加上-context，讓人看得懂用在什麼情境）" class="headerlink" title="二、主旨 + 說明（加上 context，讓人看得懂用在什麼情境）"></a>二、主旨 + 說明（加上 context，讓人看得懂用在什麼情境）</h2><p>當函式稍微複雜，或有特定使用情境時，可以有更多的<strong>說明</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clear_user_session</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    清除使用者的登入狀態</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意：此操作會立即登出使用者，需要重新登入</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>主旨和說明中間推薦有<strong>一行空白</strong>。</p><p>這樣不僅格式美觀，也是許多 IDE 或文件生成工具提取摘要的重要依據。</p><p>直接在 Docstring 說明，能<strong>避免不必要的推測</strong>，這樣的補充既實用又貼心。</p><h3 id="說明的變化與彈性"><a href="#說明的變化與彈性" class="headerlink" title="說明的變化與彈性"></a>說明的變化與彈性</h3><p>說明沒有一定規則，重點在於補充那些「使用者<strong>不容易自行推測</strong>」的資訊。</p><p>你覺得<strong>最需要提醒使用者（開發者）什麼</strong>，就寫下這些內容。</p><p>只要能幫助他人更好理解，怎麼寫都可以。</p><p>對於複雜的情境，說明<strong>可能會很長</strong>（常見於開源專案的 Docstring），這是正常的！</p><hr><h2 id="3-主旨-參數與回傳"><a href="#3-主旨-參數與回傳" class="headerlink" title="3. 主旨 + 參數與回傳"></a>3. 主旨 + 參數與回傳</h2><p>若函式有多個參數，清楚列出參數與回傳型態與說明，能大幅降低理解門檻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_discounted_price</span>(<span class="params">original_price, discount_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    計算折扣後的價格</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        original_price (float): 原價</span></span><br><span class="line"><span class="string">        discount_rate (float): 折扣率，介於 0 到 1 之間</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        float: 折扣後的價格</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> original_price * (<span class="number">1</span> - discount_rate)</span><br></pre></td></tr></table></figure><p>這個第三層次，大概是我們寫 Docstring 時<strong>最常使用的格式</strong>！</p><p>函式的<strong>參數與回傳</strong>，是最容易讓人感到困惑的地方。</p><p>我們可以想像：同事寫了一個共用函式，現在你要去調用它，你肯定需要知道，它應該有什麼樣的 input，以及調用之後會得到<strong>什麼樣的結果</strong>。</p><p>如果不清楚這些，根本無法正常使用這個函式。</p><p>因此，在有參數的函式裡，每個參數代表什麼，包括參數型別，都很重要。</p><p><strong>Docstring 的價值在這裡得到了充分發揮。</strong></p><h3 id="說明的轉換"><a href="#說明的轉換" class="headerlink" title="說明的轉換"></a>說明的轉換</h3><p>細心的你可能發現了，這個例子沒有一段獨立的說明。</p><p>原因很簡單，在這個地方的說明，<strong>已經化為了對 input 跟 output 的闡釋。</strong></p><p>額外再寫一段說明，可能會有些冗餘。（但也不盡然）</p><p>這裡只是要提醒，在這種有參數的情境下，說明落段往往會被省略。 </p><hr><h2 id="四、主旨-說明-參數與回傳-範例"><a href="#四、主旨-說明-參數與回傳-範例" class="headerlink" title="四、主旨 + 說明 + 參數與回傳 + 範例"></a>四、主旨 + 說明 + 參數與回傳 + 範例</h2><p>第四層次的重點是<strong>舉例</strong>。</p><p>有了舉例，就算不清楚函式細節，也能迅速理解它的用途與結果。</p><p>這個場景中，資料庫裡面有一個欄位已經儲存了格式化過的 Mac 地址，長這樣：<code>1234567890AB</code>。</p><p>我們要從 API 回傳給前端的時候，需要做一些處理，它讓變成這樣：<code>12 34 56 78 90 AB</code>。</p><p>它真正的邏輯只有這一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; &quot;</span>.join(mac_address[i : i + <span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">12</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>但如果你看程式碼，應該不太可能一眼就看出它處理的結果啦！——除非你是 AI 🤖</p><p>但加上舉例之後就一目了然了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">format_output_mac_address</span>(<span class="params">mac_address: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    對要輸出至 UI 的 MAC address 格式化</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意：僅供「序列化」時提高可讀性使用，不是對進入資料庫的資料做處理</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        mac_address (str): MAC address，來源為資料庫</span></span><br><span class="line"><span class="string">        格式:</span></span><br><span class="line"><span class="string">            1. 12 位數字(含英文)，不含冒號</span></span><br><span class="line"><span class="string">            2. 英文必為大寫</span></span><br><span class="line"><span class="string">        範例: 1234567890AB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        str: 格式化後的 MAC address</span></span><br><span class="line"><span class="string">        範例: 1234567890AB -&gt; 12 34 56 78 90 AB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        ValueError: MAC address 長度不為 12</span></span><br><span class="line"><span class="string">        TypeError: MAC address 不是字串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mac_address) != <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(_(<span class="string">&quot;MAC address must be 12 digits&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(mac_address, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(_(<span class="string">&quot;MAC address must be string&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(mac_address[i : i + <span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">12</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>使用範例能讓讀者一秒理解「怎麼用」與「會拿到什麼結果」。</p><p>這是許多 Docstring 常被忽略的超級關鍵。</p><h3 id="再論舉例的重要性"><a href="#再論舉例的重要性" class="headerlink" title="再論舉例的重要性"></a>再論舉例的重要性</h3><p>上述例子的 output 其實算是很單純的。</p><p>很多時候，函式的 output 可能是一個字典，究竟有哪些 key、value？一言難盡！</p><p>這種情況的舉例就會變得特別重要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_summary</span>(<span class="params">user_id: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    (略)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    範例:</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class="line"><span class="string">            &quot;last_login&quot;: datetime.datetime(2025, 5, 3, 12, 30),</span></span><br><span class="line"><span class="string">            &quot;quota&quot;: (520, 1000)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作為函式的調用方，我常常需要<strong>直接使用</strong>回傳值裡面的元素，所以我希望能一眼就看出這個 output 到底是什麼、<strong>長得什麼樣</strong>——舉例真的很重要。</p><p>在我看來，舉例幾乎是最關鍵的 context 補充方式。</p><hr><h2 id="結語：寫給「下一個開發者」的情書"><a href="#結語：寫給「下一個開發者」的情書" class="headerlink" title="結語：寫給「下一個開發者」的情書"></a>結語：寫給「下一個開發者」的情書</h2><p>Docstring 就像一封情書，寫給未來的自己、同事或其他開發者。</p><p>我打從心底認為，Docstring 有著<strong>十分務實</strong>的一面。</p><p>從本文的例子中，你應該能夠感受到在<strong>有和沒有</strong> Docstring 的情況下，理解這些程式碼所需要的<strong>時間差距與認知負擔</strong>。</p><p>而這正是 Docstring 的價值所在。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.kyomind.tw/code-and-me.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/&quot;&gt;Docstring 的重要性——《Python 功力提升的樂趣》&lt;/a&gt;〉一文中，我提到了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docstring 也不是有寫就行，還需要從「&lt;strong&gt;讀者&lt;/strong&gt;（也就是你的同事）」的角度去思考與表達。不然看起來會很像開發者的自言自語——沒人看得懂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在工作上使用 Python 多年，即便是經驗豐富的 Python 工程師，很多人也未必養成了撰寫 Docstring 的習慣。&lt;/p&gt;
&lt;p&gt;畢竟在日常趕專案的場景下，一段程式碼能否 work，往往比「好讀、好理解」更重要——至少更急迫。&lt;/p&gt;
&lt;p&gt;然而，當專案逐漸擴大、團隊成員增加時，沒有良好的 Docstring，&lt;strong&gt;協作上的痛苦&lt;/strong&gt;就會慢慢浮現。&lt;/p&gt;
&lt;p&gt;Docstring 不是單純寫給自己的備忘，而是寫給「&lt;strong&gt;下一個會看這份程式的人&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;當你開始用這個角度思考，你會發現，寫好 Docstring 並不是加分項，而是基本功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;那要怎樣才能寫好 Python Docstring 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作為 Docstring 信奉者，本文將分享我在過去工作經驗中所累積的 &lt;strong&gt;Python Docstring&lt;/strong&gt; 寫作心得，並整理成&lt;strong&gt;教學指南&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://img.kyomind.tw/code-and-me.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>從 DigitalOcean 到 Hetzner：我為何轉向這家德國 VPS 供應商</title>
    <link href="https://blog.kyomind.tw/hetzner/"/>
    <id>https://blog.kyomind.tw/hetzner/</id>
    <published>2025-04-26T10:21:02.000Z</published>
    <updated>2025-04-27T16:01:24.573Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/GhElIMy.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span>  </p><p>很長一段時間裡，當我需要使用<strong>虛擬機器</strong>（Virtual Machine）來部署自己的個人專案時，來自美國的 <a href="https://www.digitalocean.com/">DigitalOcean</a> 一直是我的首選。</p><p>可能是因為這個「海洋」的意象讓人覺得很舒服吧！價格也還過得去。</p><p>我曾在這篇〈<a href="https://blog.kyomind.tw/update-my-droplet/">計畫更新我的 DigitalOcean VM</a> 〉提過它。</p><p>然而，最近決定在 VM 上部署 Memos 時，我的選擇就不再是 DigitalOcean 了。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/memos/">開源工具 Memos：寫日記的好選擇</a></p></blockquote><p>原因無他，我們有了<strong>更便宜、更強大</strong>的選擇——也就是本文要介紹的 Hetzner。</p><p>在這篇文章中，我將分享我從 DigitalOcean 轉向 Hetzner 的原因，以及這個德國 VPS 供應商的優勢和劣勢。</p><p>我們開始吧！</p><span id="more"></span><hr><h2 id="偶然遇見-Hetzner"><a href="#偶然遇見-Hetzner" class="headerlink" title="偶然遇見 Hetzner"></a>偶然遇見 Hetzner</h2><p>如前所述，我使用 DigitalOcean 的 VM 很長一段時間。</p><p>基本款從最初的每月 5 美元，到後來漲到了 6、7 美元，儘管覺得有些小貴，但因為 DigitalOcean 在新加坡有機房，從台灣連過去延遲較低，大約 100 多毫秒，而且已經習慣，所以也沒想過另尋「新歡」。</p><p>直到有一天，我在 Twitter 上偶然看到有人提到 Hetzner——這才意識到，原來世界上還有這麼這麼「便宜」的 VPS 選擇 ！</p><p>不過在此之前，我們還是先來介紹一下，本文前面說到的 VM 或者是 VPS 究竟是什麼東西呢？ </p><h2 id="VPS-是什麼？為什麼需要-VPS？"><a href="#VPS-是什麼？為什麼需要-VPS？" class="headerlink" title="VPS 是什麼？為什麼需要 VPS？"></a>VPS 是什麼？為什麼需要 VPS？</h2><p>VPS，全名 Virtual Private Server，是<strong>從一台實體伺服器上虛擬出來的獨立空間</strong>。它讓你用租用價格，享受類似獨立主機的自由。</p><p>對於愛搞 side project 的開發者來說，有一台自己的 VPS，意味著能自由部署應用、測試新技術、建立個人服務。不必擔心免費平台的流量限制，也不用和別人搶資源。</p><p>其實我覺得最重要的就是——<strong>你獲得了一個固定 IP</strong>，讓別人可以 24 小時連線。</p><p>VPS 和 VM（Virtual Machine）其實本質很接近。</p><p>簡單來說，VM 是指「虛擬機器」這個技術本身，或指特定的虛擬機器，而 VPS 則是把這種技術<strong>商品化</strong>、打包成一個<strong>可以租用的服務</strong>。</p><p>你可以把 VPS 想成「雲端的 VM，加上管理和網路資源」，對一般開發者來說，兩者在定義區分上幾乎沒什麼區別。</p><h3 id="VPS-供應商"><a href="#VPS-供應商" class="headerlink" title="VPS 供應商"></a>VPS 供應商</h3><p>說到 VPS，市場上的選擇非常多。從大型的雲端服務商（像是 AWS、Azure、Google Cloud），到專門提供 VPS 的公司（像是 Linode、DigitalOcean、Hetzner）都有各自的定位。</p><p>不同的服務商，價格、規格、連線速度也各有差異。</p><p>雲端服務商提供的服務品質通常很高，因為他們有自己的資料中心，但價格也往往最貴，彈性最大。</p><p>除非很有錢，不然我不會直接去這些地方開 VM 來用。</p><p>而本文的主角，則是來自德國的這家公司——Hetzner。</p><hr><h2 id="Hetzner-公司簡介"><a href="#Hetzner-公司簡介" class="headerlink" title="Hetzner 公司簡介"></a>Hetzner 公司簡介</h2><p><a href="https://zh.wikipedia.org/zh-tw/Hetzner">Hetzner</a> 成立於 1997 年，總部位於德國巴伐利亞州的 Gunzenhausen。旗下的服務非常多元，包括但不限於：</p><ul><li>Cloud Hosting（雲端虛擬伺服器）</li><li>Dedicated Hosting（專用伺服器租賃）</li><li>Storage Boxes（線上儲存空間）</li></ul><p>Hetzner 擁有多個資料中心，分別位於德國、芬蘭、美國和新加坡，涵蓋歐洲、美洲與亞洲地區。</p><p>本文用到的服務，就是 Cloud Hosting，也就是 VPS 服務。</p><p>說真的，如果不是看推特，我大概很難知道這家公司的存在。</p><p>畢竟，歐洲公司對我們來說都是相對陌生的。</p><hr><h2 id="Hetzner-vs-DigitalOcean：價差與規格對比"><a href="#Hetzner-vs-DigitalOcean：價差與規格對比" class="headerlink" title="Hetzner vs DigitalOcean：價差與規格對比"></a>Hetzner vs DigitalOcean：價差與規格對比</h2><p>為什麼要換供應商呢？其實很簡單，當然是因為<strong>錢和爽度</strong>囉！</p><p>Hetzner 用你難以想像的價格，提供了遠超預期的硬體資源——德國人就是猛XD</p><h3 id="價格與規格比較"><a href="#價格與規格比較" class="headerlink" title="價格與規格比較"></a>價格與規格比較</h3><p>以下是 DigitalOcean 和 Hetzner 在類似價格區間（7 美元）的方案規格對比：</p><table><thead><tr><th>項目</th><th>DigitalOcean</th><th>Hetzner</th></tr></thead><tbody><tr><td>CPU</td><td>1 核心</td><td>4 核心（ARM）</td></tr><tr><td>RAM</td><td>1 GB</td><td>8 GB</td></tr><tr><td>硬碟空間</td><td>25 GB SSD</td><td>80 GB SSD</td></tr><tr><td>月費價格</td><td>7 美元</td><td>6.49 歐元（約 7 美元）</td></tr><tr><td>可用頻寬</td><td>1 TB 流量</td><td>20 TB 流量</td></tr></tbody></table><p>以幾乎相同的價格，Hetzner 提供了 <strong>4 倍的 CPU</strong>、<strong>8 倍的記憶體</strong>，以及更大的硬碟空間和流量。</p><p>我感覺十分阿妹竟（Amazing）！</p><p>其它不論，光 RAM 的大小其實就<strong>很影響使用體驗</strong>——沒有 2 GB 真的會比較辛苦。</p><p>我請 AI 查了一下，如果 DigitalOcean 要達到右邊 Hetzner 的規格，大概需要一個月 28 美元。</p><p>這個差距，讓人想要不變心都難🥹 </p><hr><p>等等，你先別急著掏出信用卡！</p><p>重點是接下來的部分——<strong>連線速度</strong>與<strong>註冊審核</strong>。</p><p>一言以蔽之：Hetzner 對台灣的延遲不太友好。</p><h2 id="實際測試：Latency-比較"><a href="#實際測試：Latency-比較" class="headerlink" title="實際測試：Latency 比較"></a>實際測試：Latency 比較</h2><p>為了有更直觀的數據，我使用了 <a href="https://www.cloudpingtest.com/">cloudpingtest.com</a> 測試了它所屬 VM 的延遲表現。</p><p>測試環境：中華電信 4G 手機網路。</p><p>以下是測試結果，可以看出，Hetzner 無論你選哪個資料中心，延遲的表現<strong>都不是很好</strong>——尤其是歐洲：</p><p><img src="https://i.imgur.com/G7ETZ7p.png" alt="測試時間為晚上高峰期，網路環境為中華電信 4G，結果僅供參考"><span class="cap">測試時間為晚上高峰期，網路環境為中華電信 4G，結果僅供參考</span>  </p><p>以上是我在晚上高峰時段測試的，白天會稍微好一些，但基本上，歐洲機房的<strong>平均延遲</strong>不會低於 600 ms。</p><p>600 毫秒延遲是什麼概念？可以理解成：<strong>你發出一個請求，伺服器在 0.6 秒後才會收到並開始處理——好久XD</strong></p><p>美國和新加坡的機房會好一點——就一點，但<strong>價格也更貴（尤其是新加坡）</strong>，這需要你自行拿捏。</p><p>我是覺得，如果選到新加坡機房，可能還不如直接選 DigitalOcean。</p><p>DigitalOcean 的新加坡機房延遲基本上只有 100 多毫秒，可以說表現極佳。</p><hr><h2 id="Hetzner-的客戶認證與註冊流程"><a href="#Hetzner-的客戶認證與註冊流程" class="headerlink" title="Hetzner 的客戶認證與註冊流程"></a>Hetzner 的客戶認證與註冊流程</h2><p>除了延遲偏高，Hetzner 另一個讓人討厭的點，就是身分認證流程。</p><p>Hetzner 的註冊流程<strong>相當嚴謹</strong>，堪比虛擬貨幣交易所XD，遠比一般雲端服務供應商麻煩得多。官方說，這主要是為了防範濫用與確保整體服務品質。</p><p>通常在註冊時，你可能需要：</p><ul><li>上傳有效身分證明（例如護照或身分證）</li><li>綁定信用卡或其他付款方式</li><li>等待人工審核通過</li></ul><p>這個過程從幾小時到一兩天都有可能。雖然初期略嫌麻煩，但換來的是更穩定的使用體驗。所以我覺得還可以接受。</p><hr><p>綜上所述，你主要需要考慮的，就是<strong>這個延遲你是否能夠接受</strong>。像我主要就是做我自己的東西而已，不是要提供給別人用的，所以還行。</p><p>但如果是要給別人用的，600 毫秒的延遲，絕對是<strong>有感的慢</strong>😂 </p><hr><h2 id="結語：價格與需求的平衡"><a href="#結語：價格與需求的平衡" class="headerlink" title="結語：價格與需求的平衡"></a>結語：價格與需求的平衡</h2><p>這次轉戰 Hetzner，最大的收穫就是重新認識了「原來 VM 可以這麼便宜！」</p><p>不是每個人都適合 Hetzner。如果你的專案對延遲極度敏感，那麼 DigitalOcean 這類更接近台灣、連線快的服務仍然更合適。（或者選直接在台灣有機房的 GCP）</p><p>但如果你重視的是「<strong>用最低的成本拿到最好的資源</strong>」，那麼 Hetzner 絕對值得列入你的選項清單。</p><p>而且我很認同它對客戶的嚴格審查，哈哈哈！</p><p>總之，有些改變，不是因為原本不好，而是因為找到了更適合自己的地方。</p><p>下一篇將介紹，如何在 Hetzner 上開一台新主機，以及相關的注意事項。敬請期待。</p><hr><h2 id="推廣資訊：使用我的推薦連結，享受免費額度（尚未實現🙏）"><a href="#推廣資訊：使用我的推薦連結，享受免費額度（尚未實現🙏）" class="headerlink" title="推廣資訊：使用我的推薦連結，享受免費額度（尚未實現🙏）"></a>推廣資訊：使用我的推薦連結，享受免費額度（尚未實現🙏）</h2><p>如果你也想試試 Hetzner，可以使用我的推薦連結註冊，新用戶可以直接獲得 <strong>20 歐元的使用額度</strong>，等於可以免費用一台小型 VPS 一段時間。</p><p>小提醒：如果你透過我的推薦連結註冊並付費，未來我也有機會拿到 10 歐元的回饋。不過目前還在努力達標XD</p><blockquote><p><strong>我剛開始用不久，目前還不符合推薦資格，所以連結還不存在XD，你可以先去找別人的連結來用——20 歐不拿白不拿，或等我三個月後符合資格。</strong></p></blockquote><p>當初我已經身分認證完了，才知道有上述 20 歐元額度可以拿，不禁有點扼腕！</p><p>👉 推薦連結（日後補上）</p><p>希望這篇分享能幫助你，在選擇 VPS 的路上，多一個可靠的選擇。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GhElIMy.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;  &lt;/p&gt;
&lt;p&gt;很長一段時間裡，當我需要使用&lt;strong&gt;虛擬機器&lt;/strong&gt;（Virtual Machine）來部署自己的個人專案時，來自美國的 &lt;a href=&quot;https://www.digitalocean.com/&quot;&gt;DigitalOcean&lt;/a&gt; 一直是我的首選。&lt;/p&gt;
&lt;p&gt;可能是因為這個「海洋」的意象讓人覺得很舒服吧！價格也還過得去。&lt;/p&gt;
&lt;p&gt;我曾在這篇〈&lt;a href=&quot;https://blog.kyomind.tw/update-my-droplet/&quot;&gt;計畫更新我的 DigitalOcean VM&lt;/a&gt; 〉提過它。&lt;/p&gt;
&lt;p&gt;然而，最近決定在 VM 上部署 Memos 時，我的選擇就不再是 DigitalOcean 了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/memos/&quot;&gt;開源工具 Memos：寫日記的好選擇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因無他，我們有了&lt;strong&gt;更便宜、更強大&lt;/strong&gt;的選擇——也就是本文要介紹的 Hetzner。&lt;/p&gt;
&lt;p&gt;在這篇文章中，我將分享我從 DigitalOcean 轉向 Hetzner 的原因，以及這個德國 VPS 供應商的優勢和劣勢。&lt;/p&gt;
&lt;p&gt;我們開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/GhElIMy.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
  </entry>
  
  <entry>
    <title>開源工具 Memos 介紹：寫日記的好選擇</title>
    <link href="https://blog.kyomind.tw/memos/"/>
    <id>https://blog.kyomind.tw/memos/</id>
    <published>2025-04-05T05:56:11.000Z</published>
    <updated>2025-05-22T00:08:42.369Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/OCwkXLz.png">  </p><p>你寫日記嗎？</p><p>你想像中的日記是什麼模樣？充滿積極與規劃，還是對內心的失落與探索？</p><p>時間飛逝，從這篇<a href="https://www.facebook.com/share/p/18UV2Yz6ya/">臉書貼文</a>起算，轉眼之間，我已經用 Memos 寫日記超過一年了。</p><p>寫這篇文章，是想跟大家分享我選擇 Memos 的原因、這段期間的心得，以及為什麼我認為它是「寫日記」這件事上，最適合我的工具。</p><p>不過，我們還是先從「<strong>為什麼要寫日記</strong>」開始說起吧！</p><hr><h2 id="為什麼我要寫日記？"><a href="#為什麼我要寫日記？" class="headerlink" title="為什麼我要寫日記？"></a>為什麼我要寫日記？</h2><p>前面提到的臉書貼文，有指出其中的原因，那時的我是這樣說的：</p><blockquote><p>因為想要記錄當下的想法和心情<br>現在回想當時，我只會覺得那時的日子很充實<br>但我已經不記得那時自己都在想些什麼、擔心什麼<br>　<br>美好的一面，很多時候是給別人看的<br>對我而言，我更想知道，那時的自己，是如何的狼狽、焦慮與不安<br>唯有這些，才能讓現在的我產生共鳴，進而更加理解自己<br>　<br>可惜，我已經很難回想起來了<br>雖然肯定有留下一些文字記錄，但說真的，我早已忘記它們在哪<br>真的太可惜了！ </p></blockquote><p>對那時的我來說，寫日記可說是一種「讓自己變得積極」的方法。</p><p>不過，現在的我，不太喜歡用這種「過於積極」的角度來看待這件事情。</p><p>我覺得這樣的心態，對「寫日記」而言是不健康的。</p><p>這個就跟〈<a href="/feel-good-productivity/">《高效原力》書評：做人要 NICE，不要 SMART？</a> 〉中提到的，對「休息是為了走更長遠的路」這類心態的<strong>反感</strong>一樣——不用那麼複雜啦！</p><span id="more"></span><h3 id="寫日記的意義"><a href="#寫日記的意義" class="headerlink" title="寫日記的意義"></a>寫日記的意義</h3><p>我想說，寫日記絕對有它積極的一面，但我更希望這是一個<strong>附帶的結果</strong>，而不是目的。 </p><p>如果你問我「那什麼才是目的？」，現在的我會回答：</p><blockquote><p>寫日記的目的，就是讓自己的內心狀態——尤其是那些負面的情緒、焦慮與不安，有一個可以安置的地方，<strong>讓它們暫時被溫柔地放下來</strong>。</p></blockquote><p>隨著年紀的增長，我對於這類「心靈需求」可謂是愈來愈有感。 </p><p>對我而言，它比任何時間管理或積極向上的方法論，可能都來得重要。 </p><p>一言以蔽之：<strong>我需要一個歸屬</strong>。</p><hr><p>說完寫日記的原因與需求，接下來討論用什麼工具來寫。</p><h2 id="傳統寫日記方式的困擾"><a href="#傳統寫日記方式的困擾" class="headerlink" title="傳統寫日記方式的困擾"></a>傳統寫日記方式的困擾</h2><p>如果你能夠用紙本來寫日記，我認為這是一個<strong>非常理想</strong>的做法，繼續保持即可！</p><p>如果你跟我一樣對於寫字有困擾，或者更依賴數位工具，那麼我可以先分享我的嘗試與經驗 。</p><p>過去我曾嘗試過用 Notion 寫日記：開一個 database。</p><p>它功能強大，彈性高，但在寫「日記」這件事上，就顯得有點殺雞用牛刀了——很多次嘗試，都持續不了多久 。</p><p>像 Bear、UpNote  這些「<strong>類 Evernote</strong>」軟體，相較於 Notion 它們<strong>更輕量</strong>，理論上是更合適的選擇。</p><blockquote><p>相關文章：</p><ul><li><a href="https://blog.kyomind.tw/bear/">Evernote 替代方案——筆記軟體 Bear 2 升級心得</a></li><li><a href="https://blog.kyomind.tw/upnote/">筆記軟體 UpNote 最吸引我的三大亮點</a></li></ul></blockquote><p>因為結構簡單，只要下一個標籤或建立一個筆記本，就可以開始寫了。</p><p>我也試過一陣子啦！但還是覺得不盡理想。</p><h3 id="回顧體驗不佳"><a href="#回顧體驗不佳" class="headerlink" title="回顧體驗不佳"></a>回顧體驗不佳</h3><p>用這些筆記工具來寫日記，最大的困境究竟是什麼？</p><p>我認為是「回顧」。</p><p>換句話說，它們最大問題在於「回顧體驗不佳」。</p><p>以 UpNote 為例，想像一下（圖片中並不是日記，主要是要看 UI），你要回顧上個月或這一週寫的日記，那你一定是<strong>一個一個點擊</strong>。</p><p><img src="https://i.imgur.com/DWLOjEx.png" alt="在這個中間選單中，一個一個點擊"><span class="cap">在這個中間選單中，一個一個點擊</span>  </p><p>這真的很不方便！</p><p>使用 Notion 的 database 也有類似的情況，當然你說 database 可以把內容直接顯示在畫面上。沒錯，我做過，但如此一來，該欄位的排版方便程度也會大幅下降。 </p><p>上述這些我都試過，但我覺得回顧或做記錄時的阻力，都會造成<strong>我很難持續</strong>用它們來寫日記。</p><p>此外，筆記軟體中往往混雜各種資料夾、標籤、專案，這對寫日記也是一種<strong>干擾</strong>！</p><p>就在這個山窮水複疑無路之際，所幸，我發現了 Memos。</p><hr><h2 id="Memos-簡介"><a href="#Memos-簡介" class="headerlink" title="Memos 簡介"></a>Memos 簡介</h2><p><a href="https://github.com/usememos/memos">Memos</a> 是一款開源、輕量級的備忘與記錄工具，主要以「即時、簡潔、<strong>時間序列</strong>」為核心設計理念。</p><p><img src="https://i.imgur.com/GIxpqs5.png" alt="Memos"><span class="cap">Memos</span>  </p><p>它不像 Notion 那樣強調多層次的結構，也不像其它筆記軟體那樣重視分類或標籤——儘管它也支援標籤。</p><p>而是<strong>介於「社群動態」與「個人備忘」之間的形式</strong>。</p><p>每一則 memo 都像是一則私人動態（要公開也是可以公開），簡單、快速地記下當下的心情、想法或待辦事項。</p><p>不只如此，你可以將它部署在自己的電腦或雲端主機上，資料完全掌握在自己手中。這對於在意隱私、希望長期保存紀錄的使用者來說，格外重要。</p><p>Memos 適合的使用情境很多，從寫日記、每日小結、靈感閃現、到工作上的備忘都能涵蓋。</p><p>它的極簡設計也讓人更容易持續使用，不會有「要寫很久、很正式」的壓力。</p><hr><p>請容我再進一步闡述：<strong>為什麼 Memos 很適合寫日記</strong>。</p><h2 id="Memos-的優勢"><a href="#Memos-的優勢" class="headerlink" title="Memos 的優勢"></a>Memos 的優勢</h2><p>Memos 的介面非常簡潔，就像<strong>極簡版的臉書塗鴉牆</strong>。</p><p>打開畫面，就可以直接開始寫下一則「memo」。每一則都是獨立的段落，依照時間排列，上下滑動就能瀏覽，不需額外點擊。</p><p>那太久以前的日記怎麼辦？它有「行事曆」可以選日期，方便你回顧——這是你在臉書開小帳號所做不到的了，哈哈哈。</p><p>這樣的設計，剛好切中我對日記工具的核心需求：</p><table><thead><tr><th>特點</th><th>說明</th></tr></thead><tbody><tr><td>時間軸式介面</td><td>像社群平台一樣滑過紀錄，近期回顧自然流暢</td></tr><tr><td>輕量書寫</td><td>不需標題命名（這很重要）、不用整理，寫下來就好</td></tr><tr><td>支援搜尋與標籤</td><td>想找內容時，仍可精確搜索</td></tr><tr><td>自架、資料自有</td><td>無需擔心平台關閉或資料隱私</td></tr><tr><td>專為記錄而生</td><td>與筆記工具不同，更適合日常心情與思緒的流動式記錄</td></tr></tbody></table><p>綜上所述，Memos 就像是一個「寫給自己的社群平台」，也是我理想中日記工具。</p><hr><h2 id="我的-Memos-書寫經驗"><a href="#我的-Memos-書寫經驗" class="headerlink" title="我的 Memos 書寫經驗"></a>我的 Memos 書寫經驗</h2><p>心動了嗎？別急，不妨再聽聽我的使用感受。</p><p>其實我並不是每天都寫一回，而是想到什麼就會寫下來。雖然不一定是每天，但數量確實不少。在一年多的使用時間裡，大概寫了 600 多則吧：</p><blockquote><p>635 memos in 413 days</p></blockquote><p>參考前面說的，我想再聊聊，我的一些使用細節與心得。</p><h3 id="關於標題"><a href="#關於標題" class="headerlink" title="關於標題"></a>關於標題</h3><p>寫 memo 不需要對日記標題進行命名，就像寫社群發文一樣。這一定程度降低了寫日記的摩擦力。</p><p>筆記軟體大部分時候都需要對標題命名。雖然我們可以用日期當作名稱，但<strong>多一個標題就多一個阻力</strong>。</p><p>當然，也有些人樂於為每天的日記下一個好標題，所以這點見仁見智。 </p><h3 id="要用標籤嗎？"><a href="#要用標籤嗎？" class="headerlink" title="要用標籤嗎？"></a>要用標籤嗎？</h3><p>一開始我會對這些日記用標籤分類，方便回顧。</p><p>這個習慣顯然是我從筆記軟體帶過來的。</p><p>但隨著日記數量越來越多，我覺得標籤也<strong>漸漸成為了一種負擔</strong>：一來是<strong>標籤太多</strong>，二來是很多事情<strong>難以分類</strong>——這成為了另一種寫作上的摩擦力。</p><p>因此，我個人推薦<strong>不要</strong>為你的 memos 加上任何標籤。 </p><p>寫就對了！</p><h3 id="怎麼部署比較好？"><a href="#怎麼部署比較好？" class="headerlink" title="怎麼部署比較好？"></a>怎麼部署比較好？</h3><p>雖然前面說了它這麼多好話，但有一點是我們<strong>不可忽略</strong>的，那就是你要自行「部署」。</p><p>換句話說，<strong>如果你沒有部署這個工具，那你根本就無從使用！</strong></p><p>這對不熟程式的人來說，是一個困擾，甚至是主要的門檻。</p><p>既然推薦了它，這部分我會另寫一篇文章來介紹與討論——甚至是兩篇，請不用擔心。</p><p>順帶一提，我自己是用 Docker 本地部署。</p><hr><h2 id="小結：留下些什麼"><a href="#小結：留下些什麼" class="headerlink" title="小結：留下些什麼"></a>小結：留下些什麼</h2><p>在〈<a href="https://youtu.be/1iujiTGBeaw?si=uiW9ebubimf3KcHQ">小步舞曲</a>〉MV 中（實際取自電影《<a href="https://zh.wikipedia.org/zh-tw/%E8%97%8D%E8%89%B2%E5%A4%A7%E9%96%80">藍色大門</a>》片段），陳柏霖說：</p><blockquote><p>這個夏天，雖然好像什麼都沒做過就過去了，但是總是會留下一些什麼吧！</p></blockquote><blockquote><p>留下什麼，我們就變成什麼樣的大人。</p></blockquote><p>即使忘掉我前面說的那些寫日記的理由，作為一個人，我也想<strong>留下一些什麼</strong>。</p><p>而在 AI 時代，這樣的意念，只會更加強烈而已。</p><p>如果說公開寫作是試圖為別人留下些什麼，那麼寫日記就是為現在的自己留下記錄。</p><p>看看 5 年、10 年之後，我又變成了什麼樣的大人了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OCwkXLz.png&quot;&gt;  &lt;/p&gt;
&lt;p&gt;你寫日記嗎？&lt;/p&gt;
&lt;p&gt;你想像中的日記是什麼模樣？充滿積極與規劃，還是對內心的失落與探索？&lt;/p&gt;
&lt;p&gt;時間飛逝，從這篇&lt;a href=&quot;https://www.facebook.com/share/p/18UV2Yz6ya/&quot;&gt;臉書貼文&lt;/a&gt;起算，轉眼之間，我已經用 Memos 寫日記超過一年了。&lt;/p&gt;
&lt;p&gt;寫這篇文章，是想跟大家分享我選擇 Memos 的原因、這段期間的心得，以及為什麼我認為它是「寫日記」這件事上，最適合我的工具。&lt;/p&gt;
&lt;p&gt;不過，我們還是先從「&lt;strong&gt;為什麼要寫日記&lt;/strong&gt;」開始說起吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;為什麼我要寫日記？&quot;&gt;&lt;a href=&quot;#為什麼我要寫日記？&quot; class=&quot;headerlink&quot; title=&quot;為什麼我要寫日記？&quot;&gt;&lt;/a&gt;為什麼我要寫日記？&lt;/h2&gt;&lt;p&gt;前面提到的臉書貼文，有指出其中的原因，那時的我是這樣說的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因為想要記錄當下的想法和心情&lt;br&gt;現在回想當時，我只會覺得那時的日子很充實&lt;br&gt;但我已經不記得那時自己都在想些什麼、擔心什麼&lt;br&gt;　&lt;br&gt;美好的一面，很多時候是給別人看的&lt;br&gt;對我而言，我更想知道，那時的自己，是如何的狼狽、焦慮與不安&lt;br&gt;唯有這些，才能讓現在的我產生共鳴，進而更加理解自己&lt;br&gt;　&lt;br&gt;可惜，我已經很難回想起來了&lt;br&gt;雖然肯定有留下一些文字記錄，但說真的，我早已忘記它們在哪&lt;br&gt;真的太可惜了！ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;對那時的我來說，寫日記可說是一種「讓自己變得積極」的方法。&lt;/p&gt;
&lt;p&gt;不過，現在的我，不太喜歡用這種「過於積極」的角度來看待這件事情。&lt;/p&gt;
&lt;p&gt;我覺得這樣的心態，對「寫日記」而言是不健康的。&lt;/p&gt;
&lt;p&gt;這個就跟〈&lt;a href=&quot;/feel-good-productivity/&quot;&gt;《高效原力》書評：做人要 NICE，不要 SMART？&lt;/a&gt; 〉中提到的，對「休息是為了走更長遠的路」這類心態的&lt;strong&gt;反感&lt;/strong&gt;一樣——不用那麼複雜啦！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/OCwkXLz.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《高效原力》書評：做人要 NICE，不要 SMART？</title>
    <link href="https://blog.kyomind.tw/feel-good-productivity/"/>
    <id>https://blog.kyomind.tw/feel-good-productivity/</id>
    <published>2025-04-04T01:23:41.000Z</published>
    <updated>2025-04-11T16:43:22.054Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/I4bRpDQ.png" alt="高效原力：用愉悅心態激發生產力，做更多重要的事"><span class="cap">高效原力：用愉悅心態激發生產力，做更多重要的事</span>  </p><p>這是一篇非常「個人」的書評，只講我有興趣的部分。</p><p>老讀者都知道，我對於「生產力」一詞，往往抱持<strong>相對負面</strong>的態度。你也可以說是我的偏見——I think it’s <strong>toxic</strong>。</p><p>尤其是那些對於生產力的<strong>極致追求</strong>，<a href="/less-is-more/">我不喜歡，也不認同</a>。</p><p>就像我在〈<a href="https://kyomind.notion.site/12-Notion-AI-1946a92a98a6804b85afe725fe388031">訂戶限定 12：聊聊寫作 × 我反對生產力最大化 × 再度退訂 Notion AI</a>〉中說的：</p><blockquote><p>在 AI 時代，人不應該（或者說<strong>不值得</strong>）這樣生活、那樣學習。</p></blockquote><p>不過，多虧好友<a href="https://www.facebook.com/dorin.tsai">朵琳小姐</a>的推薦，我還是看了這本書，並且寫下了這篇書評。</p><p>我認為本書確實有可看之處，值得留下幾筆。</p><p>如開頭所言，我只講我有興趣、認同的部分，其餘就直接省略了。</p><hr><h2 id="作者簡介：Ali-Abdaal-是誰？"><a href="#作者簡介：Ali-Abdaal-是誰？" class="headerlink" title="作者簡介：Ali Abdaal 是誰？"></a>作者簡介：Ali Abdaal 是誰？</h2><p><a href="https://www.youtube.com/channel/UCoOae5nYA7VqaXzerajD0lg">Ali Abdaal</a> 是一位從醫學院畢業（也當過實習醫生）的 YouTuber、生產力作家與線上課程創辦人。</p><p>他以分享學習技巧、生產力工具與深度工作法而聞名，經營的 YouTube 頻道累積超過數百萬訂閱者，是當代最具影響力的「生產力 KOL」——或許沒有之一。</p><p>說真的，我對這位作者並不熟悉。我只知道他是個 YouTuber，並且有一個「生產力」的頻道——我想你知道這些也就夠了。</p><span id="more"></span><h2 id="我為什麼想讀這本書？"><a href="#我為什麼想讀這本書？" class="headerlink" title="我為什麼想讀這本書？"></a>我為什麼想讀這本書？</h2><p>除了朋友的推薦，另一方面，我多少還是對這類主題有所興趣。（我只是通常不會照做而已😅）</p><p>或者說，我不認同的生產力是「做很多事」。</p><p>如果重點是<a href="/simple-notion/#%E6%88%91%E4%BB%A5%E7%82%BA%E6%88%91%E6%83%B3%E8%A6%81">把事情做好</a>，仍然值得了解、追求。</p><p>這本書雖然名字叫 Feel-Good Productivity，但它並不是教你怎麼躺平做事，而是引導你用<strong>更溫柔、有效的方式</strong>對待自己的生產力。</p><p>本書強調「<strong>讓你感覺良好</strong>」的生產力，不是用意志力硬撐，而是設計出一種讓你自然想做事的節奏與習慣。</p><h3 id="溫柔而非紀律"><a href="#溫柔而非紀律" class="headerlink" title="溫柔而非紀律"></a>溫柔而非紀律</h3><p>我覺得「<strong>溫柔</strong>」是其中的重點，畢竟生產力一詞往往和「紀律」、「自我要求」掛勾，從而給人一種<strong>沉重的感覺</strong>。</p><p>而本書卻強調要先讓「自我感覺良好」，哈哈哈！這不像一般生產力 KOL 會說的話。</p><p>對自己溫柔，你才會感覺良好嘛！</p><p>我承認，這個切入點確實吸引了我。</p><p>很大程度上，本作可能<a href="/weekly-review-20/#Cal-Newport-%E6%AE%B5%E8%90%BD">比 Cal Newport 的任何一本書更適合一般人</a>XD</p><p>以下是我認為本書的三個重點，從我最有感的開始。</p><hr><h2 id="一、要-NICE，不要-SMART"><a href="#一、要-NICE，不要-SMART" class="headerlink" title="一、要 NICE，不要 SMART"></a>一、要 NICE，不要 SMART</h2><p>你想必聽過「<a href="https://zh.wikipedia.org/zh-tw/SMART%E5%8E%9F%E5%88%99">SMART 原則</a>」，這是職場中常見的目標設定工具。它重視<strong>明確性</strong>與<strong>可衡量</strong>，適合追求<strong>具體成果</strong>的情境（比如升遷、考試、減重等）。</p><p>但我相信沒幾個人真的會用它的設定或執行目標。</p><p>一般而言，SMART 原則主要出現在……你的簡報中。</p><p>原因是，SMART 固然好，但它也太「重」了。</p><p><strong>當你只是想建立一個新習慣、趕快開始行動、或找回對事情的熱情時，SMART 往往太冰冷、太遠、太無趣</strong>。</p><p>它更適合中長期目標。</p><h3 id="NICE-原則"><a href="#NICE-原則" class="headerlink" title="NICE 原則"></a>NICE 原則</h3><p>本書 NICE 原則提供了一個<strong>更貼近生活、更具行動力</strong>的替代方案。</p><p>NICE 四原則是這樣的：</p><ul><li><strong>Near-term（短期）</strong>：設定在近期內能完成的目標。</li><li><strong>Input-based（以輸入為本）</strong>：聚焦在<strong>自己可控制的行為，而非結果</strong>。</li><li><strong>Controllable（可控制）</strong>：減少因外在因素導致失敗的風險。</li><li><strong>Energizing（激發活力）</strong>：目標要<strong>讓你想做</strong>，而不是逼自己完成。</li></ul><p><strong>我們常常設定的目標太大、太遙遠，結果不是拖延，就是陷入無力感</strong>。</p><p>而 NICE 原則的設計，是讓你<strong>今天、此刻就可以做點什麼</strong>，而且做完之後會覺得「我還想繼續做」。</p><h2 id="Input-based——以輸入為本"><a href="#Input-based——以輸入為本" class="headerlink" title="Input-based——以輸入為本"></a>Input-based——以輸入為本</h2><p>這 4 個元素中，其實真正打動我的只有 <strong>Input-based（以輸入為本）。</strong></p><p>它強調：你<strong>不用管</strong>目標為何，只要管「<strong>此時此刻我應該做什麼</strong>」。</p><p>比如「閱讀 30 分鐘」、「散步 10 分鐘」，而不是「為了學習而閱讀」、「為了健康而散步」等等。</p><p><strong>我非常非常喜歡這個看法！</strong></p><p>因為它讓我的壓力大幅下降，確實有兌現書名的承諾——Feel Good！</p><h3 id="以學英文為例"><a href="#以學英文為例" class="headerlink" title="以學英文為例"></a>以學英文為例</h3><p>以我為自己為例吧！</p><p>學英文、考多益，太沉重（主要是太遙遠），想想就累了。</p><p>那<a href="/bbc-6-minute-english/">每天聽半小時的 BBC 6 Minute English</a> 如何？</p><p>我感覺好多了！</p><p>認真思考、計較今天聽的這半小時，對於長遠的英文聽力究竟有多少助益，<strong>實在是一件令人不太愉快的事情</strong>。</p><p>而 NICE 原則（或說其中的 Input-based 原則），則<strong>切斷了這項關聯</strong>！——你只管現在要做啥即可！哈哈哈。</p><h2 id="SMART-vs-NICE"><a href="#SMART-vs-NICE" class="headerlink" title="SMART vs NICE"></a>SMART vs NICE</h2><p>書中還列出了幾個對照範例，幫助我們更清楚兩者的差異：</p><table><thead><tr><th>領域</th><th>SMART 目標</th><th>NICE 目標</th></tr></thead><tbody><tr><td>健康</td><td>三個月內減掉 10 公斤</td><td>每天運動 30 分鐘，實作有趣且可控的運動項目</td></tr><tr><td>事業</td><td>兩年內升為高級經理</td><td>每週花一小時精練一項專業技能，並主動回饋</td></tr><tr><td>教育</td><td>兩年內完成碩士學位</td><td>每天花 30 分鐘複習課程，提升理解力並回顧過去作業</td></tr></tbody></table><p>這些例子讓我們更聚焦「<strong>今天做什麼</strong>」。</p><p>不過我的標題有點取巧啦！作者並沒說不要 SMART，而是建議可以用在長期目標。</p><p>總之，想要 feel good？Let’s be NICE☺️</p><hr><p>接下來這兩點就比較老生常談了。</p><p>我之所以選擇了它們，主要是因為——我一直做不到😂</p><h2 id="二、休息，比你想像得更重要"><a href="#二、休息，比你想像得更重要" class="headerlink" title="二、休息，比你想像得更重要"></a>二、休息，比你想像得更重要</h2><p>我們對「休息」的認知，很多時候都太表面。</p><p>什麼「休息是為了走更長遠的路」啊，豈不是又陷入了 SMART 的沉重感？</p><p>書中最有趣的部分，是強調「<strong>工作中需要的休息，遠比你想像的多</strong>」。</p><p>書中提到，有研究指出最有生產力的人，其實是那些願意<strong>頻繁且深度休息</strong>的人——不是那種工作一小時休息五分鐘的節奏，而是例如「工作 52 分鐘、休息 17 分鐘」這樣的模式。</p><p>你不要太認真——我是指對這段內容別太認真XD。這些可不是什麼嚴謹的研究。</p><p>那些工作中更常休息的人，是不是如書中所言，有著更多「產能」，我持懷疑態度。</p><p>但是，退萬步言，<strong>休息的重要性，確實值得一再強調</strong>。</p><p><strong>因為我們都不擅長休息</strong>。</p><p>我們既不想休息——只想兢兢業業，為目標奮鬥，也不會休息（只會滑手機）。</p><p>很多我們以為的休息，其實根本不是休息！</p><h2 id="三、提防「消耗型行為」"><a href="#三、提防「消耗型行為」" class="headerlink" title="三、提防「消耗型行為」"></a>三、提防「消耗型行為」</h2><p>最後一個重點，是書中提出的「兩張清單法」：</p><ul><li>一張是你在疲憊時會做的「<strong>消耗型行為</strong>」。</li><li>一張是可以真正讓你補充能量的「<strong>充電型行為</strong>」。</li></ul><table><thead><tr><th>精力耗盡時，我們會做的事（消耗能量）</th><th>替我們充電的事情（真正補充能量）</th></tr></thead><tbody><tr><td>看 IG、滑抖音</td><td>散步、練習樂器</td></tr><tr><td>躺著滑手機、看 Netflix 或電影</td><td>聯繫朋友、共進晚餐</td></tr><tr><td>不斷查看 X 平台、對世界憤怒</td><td>前往健身房或做伸展</td></tr><tr><td>吃不健康的外賣</td><td>冥想、瑜伽等身心運動</td></tr></tbody></table><p>如你所知，現代人常見的休息，往往是「消耗型行為」，而不是「充電型行為」。</p><p>當你精力耗盡時，大腦會自動尋找<strong>低門檻快感</strong>來逃避，而這些通常是<strong>消耗性行為，而不是休息</strong>。</p><p>這些資訊，對你而言可能早就不是新聞。</p><p>你知我知——但我們就是做不到，或沒做好。</p><p>「列出兩張清單」的做法，有助於<strong>把下意識的行為轉成有意識的選擇</strong>，幫助我們從疲憊中走出來。</p><p>顯然「身體力行」比「我知道啊！」重要得多。</p><hr><h2 id="結語：對自己溫柔"><a href="#結語：對自己溫柔" class="headerlink" title="結語：對自己溫柔"></a>結語：對自己溫柔</h2><p>整體而言，這三個觀念看似簡單，卻都牽涉到一個更深層的問題：</p><blockquote><p><strong>我們怎麼與自己相處</strong>。</p></blockquote><p><strong>生產力不該是「把自己榨乾」，而是學會「善待那個正在努力的自己」。</strong></p><p><strong>要溫柔且寬容。</strong></p><p>這不容易呀！因為生產力往往給人「你必須勤奮」的禁錮感。</p><p>這也是為何像 Ali Abdaal 這種靠販售「生產力秘技」的 KOL 寫出這樣的一本書時，我會覺得有一種「反差」，進而被吸引了——你贏了！</p><p>平心而論，這本書對我唯一的啟發，就是 <strong>Input-based</strong>，但這很重要。</p><p>光憑這一點，我就願意為它寫一篇書評。</p><p>因為<strong>它讓我在日復一日的 Input-based 活動中，更加自信與堅定。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/I4bRpDQ.png&quot; alt=&quot;高效原力：用愉悅心態激發生產力，做更多重要的事&quot;&gt;  &lt;/p&gt;
&lt;p&gt;這是一篇非常「個人」的書評，只講我有興趣的部分。&lt;/p&gt;
&lt;p&gt;老讀者都知道，我對於「生產力」一詞，往往抱持&lt;strong&gt;相對負面&lt;/strong&gt;的態度。你也可以說是我的偏見——I think it’s &lt;strong&gt;toxic&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;尤其是那些對於生產力的&lt;strong&gt;極致追求&lt;/strong&gt;，&lt;a href=&quot;/less-is-more/&quot;&gt;我不喜歡，也不認同&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;就像我在〈&lt;a href=&quot;https://kyomind.notion.site/12-Notion-AI-1946a92a98a6804b85afe725fe388031&quot;&gt;訂戶限定 12：聊聊寫作 × 我反對生產力最大化 × 再度退訂 Notion AI&lt;/a&gt;〉中說的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 AI 時代，人不應該（或者說&lt;strong&gt;不值得&lt;/strong&gt;）這樣生活、那樣學習。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不過，多虧好友&lt;a href=&quot;https://www.facebook.com/dorin.tsai&quot;&gt;朵琳小姐&lt;/a&gt;的推薦，我還是看了這本書，並且寫下了這篇書評。&lt;/p&gt;
&lt;p&gt;我認為本書確實有可看之處，值得留下幾筆。&lt;/p&gt;
&lt;p&gt;如開頭所言，我只講我有興趣、認同的部分，其餘就直接省略了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;作者簡介：Ali-Abdaal-是誰？&quot;&gt;&lt;a href=&quot;#作者簡介：Ali-Abdaal-是誰？&quot; class=&quot;headerlink&quot; title=&quot;作者簡介：Ali Abdaal 是誰？&quot;&gt;&lt;/a&gt;作者簡介：Ali Abdaal 是誰？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCoOae5nYA7VqaXzerajD0lg&quot;&gt;Ali Abdaal&lt;/a&gt; 是一位從醫學院畢業（也當過實習醫生）的 YouTuber、生產力作家與線上課程創辦人。&lt;/p&gt;
&lt;p&gt;他以分享學習技巧、生產力工具與深度工作法而聞名，經營的 YouTube 頻道累積超過數百萬訂閱者，是當代最具影響力的「生產力 KOL」——或許沒有之一。&lt;/p&gt;
&lt;p&gt;說真的，我對這位作者並不熟悉。我只知道他是個 YouTuber，並且有一個「生產力」的頻道——我想你知道這些也就夠了。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/I4bRpDQ.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="閱讀心得" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>待業 6 個月，我做了哪些事？</title>
    <link href="https://blog.kyomind.tw/weekly-review-42/"/>
    <id>https://blog.kyomind.tw/weekly-review-42/</id>
    <published>2025-04-03T09:01:12.000Z</published>
    <updated>2025-04-11T16:40:15.588Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>這是第 42 期的 Weekly Review，這系列主要記錄我的一些近況、生活與想法。</p><p>在第 38 期〈<a href="/weekly-review-38/">Kyo 待業中！細數我過去的待業時光（上）</a>〉曾提過，我大學畢業後待業的總時間，長達 4 年 8 個月。如果再加上這半年，就超過 5 年了😂</p><p>當然，這些時期，往往也是我人生的重要轉折點：</p><ol><li>第一次待業：書記官考試。</li><li>第二次待業：律師考試 + 轉職軟體工程師。</li></ol><p>而這次，雖然沒有那麼大幅度的轉換，但感覺也是不輕鬆的半年。</p><p>本期就來聊聊，這半年發生了哪些事、我有哪些心得。</p><p>用階段來區分，主要可分為三個部分。</p><span id="more"></span><hr><h2 id="階段一：鐵人賽"><a href="#階段一：鐵人賽" class="headerlink" title="階段一：鐵人賽"></a>階段一：鐵人賽</h2><p>從 Day 1 就開始的鐵人賽準備。</p><p>我在去年 8 月底正式從公司離職，9 月 1 日起進入待業狀態。</p><p>沒有工作的第一天，我做的不是休息，而是直接投入寫作。因為我報名了 iThome 鐵人賽，一場需要連續寫作 30 天的活動。</p><blockquote><p>相關文章：</p><ul><li><a href="/weekly-review-35/">35，開始備戰 2024 iThome 鐵人賽</a></li><li><a href="/2024-ironman-event/">2024 iThome 鐵人賽參賽思路：主題選擇、命名與標題策略</a></li></ul></blockquote><p>我知道，如果等到開賽再寫肯定來不及，容易虎頭蛇尾。因此從 9 月 1 日開始就逐日撰寫內容，為開賽日作「準備」。</p><h3 id="全神貫注"><a href="#全神貫注" class="headerlink" title="全神貫注"></a>全神貫注</h3><p>寫作——哪怕是有壓力的寫作——也可以是一種享受。</p><p>參加鐵人賽這種競賽型的寫作，心理上並不輕鬆。但這段時間是本次待業三個階段中，內心最篤定，行為模式也最為固定的一段時光。</p><p>從完賽的角度，我們不必和別人比較，而是要用力去追逐心中認為「好」的內容。</p><p>這種一心一意的追求，在全職準備的前提下，沒有太多外力的束縛與干擾。</p><p>就是寫！</p><p>辛苦是必然的，但這樣的狀態讓人著迷。</p><p>不過話說回來，我覺得這種經驗一次就可以了🤗</p><hr><h2 id="階段二：軟體工程師求職準備"><a href="#階段二：軟體工程師求職準備" class="headerlink" title="階段二：軟體工程師求職準備"></a>階段二：軟體工程師求職準備</h2><p>過完充實的寫作時光後，接下來就要面對現實了！</p><p>雖然十月中有小休一星期，但內心還是很難放鬆啦！為什麼？當然是因為後續就要開始求職了。</p><p>10 月下旬，我正式啟動求職的前置準備：</p><ul><li>回顧之前工作上的專案，整理<a href="https://www.cake.me/kyomind">履歷</a>、更新 <a href="https://www.linkedin.com/in/kyo-huang/">LinkedIn</a>。</li><li><a href="https://github.com/kyomind/Grind-75">LeetCode 刷題</a>，還發表了「<a href="/series/#%E6%88%91%E7%9A%84-LeetCode-%E5%88%B7%E9%A1%8C%E4%B9%8B%E9%81%93">我的 LeetCode 刷題之道</a>」系列文章。</li><li>學習系統設計。</li></ul><p>其實就是一般軟體工程師求職時會做的事。</p><blockquote><p>相關文章：<a href="/weekly-review-39/">10 月回顧——鐵人賽、演算法與 AI</a></p></blockquote><h3 id="履歷、LinkedIn，也是文字的藝術"><a href="#履歷、LinkedIn，也是文字的藝術" class="headerlink" title="履歷、LinkedIn，也是文字的藝術"></a>履歷、LinkedIn，也是文字的藝術</h3><p>我相信，更新履歷或 LinkedIn 這種事情，應該是很多人下意識在逃避的吧——至少我就一直在逃避XD</p><p>結果開始做之後發現——<strong>事情果然如我想像中的困難</strong>🤣</p><p>要整理自己過去累積的經驗、有效地向別人表達，從來都不是一件容易的事。</p><p>尤其像我這種對文字十分敏感的人，更容易感受到其中讓我不滿意的地方。</p><p>而且我寫履歷比較喜歡有幾分就寫幾分，任何超過我實際能力或經驗的描述甚至推論，都會讓我感受到一絲心虛跟罪惡。</p><p>但我建議你不要這樣，如果你覺得實際上是 7 分，但你寫到 8、9 分，我認為完全可以接受。</p><p>一來是你不一定真的只有 7 分；二來是……你懂的，JD 描述也未必真實。</p><p>更別說，求職是一個自我推廣的舞台與戰場，太過謙虛、含蓄或保守，基本上只會有害無利。</p><h3 id="我真的不喜歡刷題"><a href="#我真的不喜歡刷題" class="headerlink" title="我真的不喜歡刷題"></a>我真的不喜歡刷題</h3><p>接著是 LeetCode 刷題。</p><p>我一開始就知道這不是我喜歡的部分，也知道它是多數工程師面試的「必要之惡」。</p><p>這幾個月我大約刷了七、八十小時，約莫 40 題，但說真的，效果普通。</p><p>進步當然有，但很難說這樣的學習是高效的。</p><p>雖然這個系列還沒有完成，不過我可以確定，實際自己親身刷題過後，<strong>我感受到我對 LeetCode 的厭惡是如此之大，遠超乎我的想像。</strong></p><p>一言以蔽之：<strong>我不認為這是一個成年人該做的事</strong>。我們只是迫不得已。</p><hr><h2 id="階段三：求職與-Burnout"><a href="#階段三：求職與-Burnout" class="headerlink" title="階段三：求職與 Burnout"></a>階段三：求職與 Burnout</h2><p>該來的還是要來，準備是準備不完的。</p><h3 id="早點面試真的很重要"><a href="#早點面試真的很重要" class="headerlink" title="早點面試真的很重要"></a>早點面試真的很重要</h3><p>進入 1 月，我開始投遞履歷。</p><p>第一場面試便讓我意識到一件事：<strong>準備再久，都比不上「實戰一次」有效</strong>。</p><p>面試能讓你知道哪些題目真正重要、哪些表達還需要修正，<strong>效率比自己埋頭苦練要高出不知多少</strong>。（當然，我並不是說毫無準備就可以去面試，會被洗臉！）</p><p>你甚至能夠從面試中，<strong>更加了解自己</strong>。</p><p>如果可以重來，我會在適度準備後，更早開始面試——大概提前一個月吧！</p><h3 id="面試能力明顯進步，但身體接近極限"><a href="#面試能力明顯進步，但身體接近極限" class="headerlink" title="面試能力明顯進步，但身體接近極限"></a>面試能力明顯進步，但身體接近極限</h3><p>2 月時，我能明顯感受到自己的進步。不論是技術表達、問答邏輯，還是面對問題時的沉著度，都提升許多。</p><p>雖然，每次面試官要說出「下一題」的前一秒，我的內心還是超緊張！——這似乎是無法適應的🐥</p><p>與此同時，我的身體也漸漸產生了 burnout 的前兆。</p><p>那種「每天醒來就要戰鬥」的感覺，把我的精神推向了極限。</p><p>這是一個不健康的過程。</p><h3 id="拿到-Offer-後的-Burnout-症狀"><a href="#拿到-Offer-後的-Burnout-症狀" class="headerlink" title="拿到 Offer 後的 Burnout 症狀"></a>拿到 Offer 後的 Burnout 症狀</h3><p>當我終於拿到 offer，情緒才剛放鬆下來，身體就出現了睡不好、短眠等窘況。</p><p>AI 認為，這是求職壓力褪去後，少了抑制 burnout 無力感的正常反應，也就是身體此時的<strong>真實狀態</strong>。</p><p>然後它極力建議我一定要進入「<strong>強制休息</strong>」模式，不然會很危險。</p><blockquote><p>先別想著要為新工作做什麼準備，而是好好休息。</p></blockquote><p>一開始我還不甚情願，還好我一向很信任 AI，於是安排了幾次短暫旅行，和所謂的「<a href="https://kyomind.notion.site/15-Threads-1b36a92a98a680909220dfbd6fce9bbe">資訊斷捨離</a>」，讓身體和心靈從高壓中慢慢解脫出來。</p><hr><h2 id="小結：慢一點、輕鬆一點"><a href="#小結：慢一點、輕鬆一點" class="headerlink" title="小結：慢一點、輕鬆一點"></a>小結：慢一點、輕鬆一點</h2><p>在這個快速變動的時代，休息數個月重新準備與摸索方向，應該會變得更加常見，至少比以前更容易發生。</p><p>其實，<strong>能夠適度休息、好好放鬆，本身就是一種能力</strong>，而這樣的能力也是需要培養的——卻往往被忽視。</p><p>隨時都在汲汲營營，孜孜不倦，最終所能帶來成果，未必如想像中可觀。</p><p>更多是一種自我安慰和徒勞吧！</p><p>所以，即使是待業和求職的階段，也沒必要把自己逼得太緊。</p><p>這樣想，可能會讓人輕鬆些，並帶來更好的結果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是第 42 期的 Weekly Review，這系列主要記錄我的一些近況、生活與想法。&lt;/p&gt;
&lt;p&gt;在第 38 期〈&lt;a href=&quot;/weekly-review-38/&quot;&gt;Kyo 待業中！細數我過去的待業時光（上）&lt;/a&gt;〉曾提過，我大學畢業後待業的總時間，長達 4 年 8 個月。如果再加上這半年，就超過 5 年了😂&lt;/p&gt;
&lt;p&gt;當然，這些時期，往往也是我人生的重要轉折點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次待業：書記官考試。&lt;/li&gt;
&lt;li&gt;第二次待業：律師考試 + 轉職軟體工程師。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而這次，雖然沒有那麼大幅度的轉換，但感覺也是不輕鬆的半年。&lt;/p&gt;
&lt;p&gt;本期就來聊聊，這半年發生了哪些事、我有哪些心得。&lt;/p&gt;
&lt;p&gt;用階段來區分，主要可分為三個部分。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>筆記軟體 UpNote 最吸引我的三大亮點</title>
    <link href="https://blog.kyomind.tw/upnote/"/>
    <id>https://blog.kyomind.tw/upnote/</id>
    <published>2025-03-29T06:13:09.000Z</published>
    <updated>2025-04-11T16:43:54.527Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/uAUlRuc.jpeg" alt="by William Chen on Pexels"><span class="cap">by William Chen on Pexels</span></p><p>如你所知，我是一個「<a href="https://github.com/kyomind#%E7%B0%A1%E4%BB%8B">不做筆記就不會學習</a>」的人🥹</p><p>但就像我在〈<a href="/noteless/">逐漸被我遺忘的卡片筆記</a>〉中提到的那樣，我並不喜歡對特定的筆記軟體過於鑽研、深挖它的大量用法與變化，更不可能建立一個所謂的<a href="/less-is-more/">筆記系統</a>。</p><p><strong>我更愛「簡單粗暴」的方式</strong>😎</p><p>關於我的筆記軟體使用演進史，可以參考過往這幾篇文章：（依時間順序）</p><ul><li><a href="https://medium.com/code-and-me/why-evernote-7cd2abbfbafd">心得 |《曼無止盡》第 40 期：Evernote 的重生之路</a></li><li><a href="/simple-notion/">使用Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a></li><li><a href="/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a></li><li><a href="/bear/">Evernote 替代方案——筆記軟體 Bear 2 升級心得</a></li></ul><p>除了 Evernote 之外，其餘三者都是我現在仍有在使用的。所以它們相互之間<strong>並不是進化式的替代關係</strong>，而是不斷完善的<strong>補充關係</strong>。</p><p>本文要來講講，為何在這三個筆記軟體之外，我還需要第四個筆記軟體——UpNote。</p><span id="more"></span><h2 id="第四個筆記軟體"><a href="#第四個筆記軟體" class="headerlink" title="第四個筆記軟體"></a>第四個筆記軟體</h2><blockquote><p>第四個筆記軟體真的有必要嗎？或者它只是另一種疊床架屋或自我滿足？</p></blockquote><p>我也曾思考過這個問題，所幸，現在已經有了明確的答案，本文就是我對這個答案的闡述。</p><p>如果你對 UpNote 這個軟體有興趣，本文可能是一個很好的切入點。</p><p>我們暫時拋開對細節的教學，直接看看為什麼我都已經有三個筆記軟體了，還認為自己需要它——而你也有可能有相類似的原因。</p><p>不過，開始之前，我們得先對 UpNote 進行簡要的介紹。</p><hr><h2 id="UpNote-簡介"><a href="#UpNote-簡介" class="headerlink" title="UpNote 簡介"></a>UpNote 簡介</h2><p><a href="https://getupnote.com/">UpNote</a> 是一款<strong>跨平台筆記軟體</strong>，支援 iOS、Android、macOS 和 Windows，旨在為用戶提供簡單、優雅且高效的筆記體驗。</p><p>它<strong>以 Markdown 為基礎</strong>，結合直觀的介面設計和強大的功能，吸引了許多尋求 Evernote 替代方案的用戶——包括我。</p><p><img src="https://i.imgur.com/87FzPPL.png" alt="UpNote 使用者介面"><span class="cap">UpNote 使用者介面</span></p><p>UpNote 的核心理念是讓筆記變得輕鬆流暢，並<strong>幫助使用者專注於最重要的內容</strong>。</p><p>免費版限 50 則筆記，只適合作為體驗、測試之用。付費才能解鎖無限筆記數量、附件插入與進階格式化等功能。</p><p>付費方式又分為<strong>月費</strong>或<strong>一次性買斷</strong>：</p><blockquote><p><strong>$1.99&#x2F;month</strong> or <strong>$39.99 Lifetime.</strong></p></blockquote><p>我個人是用了一、兩個月後，覺得 OK 就索性買斷了。</p><hr><h2 id="為什麼還需要第四個筆記軟體？"><a href="#為什麼還需要第四個筆記軟體？" class="headerlink" title="為什麼還需要第四個筆記軟體？"></a>為什麼還需要第四個筆記軟體？</h2><p>曾經，我以為 Notion 足夠萬能，Logseq 足夠自由，Bear 足夠簡單、美型。它們陪我度過了不同階段的筆記需求，同時不斷形塑著我對「好筆記軟體」的定義。</p><p>一般的隨手記事，我不會打開 Notion 或 Logseq——因為它們都很「重」，有著較多的層級或複雜的筆記關聯。</p><p>對於簡單記錄，Bear 無疑是最好的選擇，但它僅限於蘋果生態系（iOS、macOS），而我的手機是安卓啊啊啊！</p><p>這就是我找到 UpNote 並開始使用它的起點。</p><h3 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h3><p>這篇文章沒有詳細的功能介紹，也不是使用教學，而是我的<strong>選擇與考慮</strong>。</p><p>在已經擁有三款筆記軟體的情況下，為什麼我還需要 UpNote？以下是我選擇它的三個關鍵理由。</p><p>最後，我會為讀者——尤其是還在摸索自己喜歡的筆記方式、軟體的人，提出「<strong>基於我個人使用經驗</strong>」的<strong>筆記軟體選擇建議</strong>，作為你下一步的參考。</p><hr><p>因為 Bear 跟 UpNote 兩者的性質很像、介面也大同小異，都屬於 Evernote 的典型替代，所以我會特別比較它跟 Bear 之間的關係。</p><p>好，我們開始吧！</p><h2 id="一、跨平台同步：真正的全裝置筆記自由"><a href="#一、跨平台同步：真正的全裝置筆記自由" class="headerlink" title="一、跨平台同步：真正的全裝置筆記自由"></a>一、跨平台同步：真正的全裝置筆記自由</h2><p>Bear 的一大限制，就是只能在 Apple 生態系內同步。作為 Android 手機用戶，我無法隨時記錄靈感，Bear 成為一個「只能在電腦使用」的工具。（雖然我也有 iPhone、iPad，但很少帶出門😅）</p><p>出門在外的時候，我們常常習慣用手機快速記下一些待辦事項、突然浮現的靈感。這些事如果無法立法被留下來，會讓人<strong>很不安</strong>XD——因為<strong>很可能會忘記</strong>。</p><p>UpNote 的全平台支援，剛好補足了這一塊，讓我在任何裝置（主要是手機）都能隨時記錄。</p><p>雖然和學習關係不大，但記錄雜事、靈感卻也是生活中的「硬需求」。</p><h2 id="二、筆記本：處理「專案」型筆記"><a href="#二、筆記本：處理「專案」型筆記" class="headerlink" title="二、筆記本：處理「專案」型筆記"></a>二、筆記本：處理「專案」型筆記</h2><p>Bear 採用純標籤系統對筆記進行分類，雖然彈性高，但<strong>無法封存</strong>。</p><p>這意味著，當一個標籤底下的筆記現階段已不再重要，它們也<strong>無法從視野中淡出</strong>，除非直接刪除該標籤。但這樣又不利於複習或尋找，因為它們曾經擁有分類。</p><p>我覺得「刪除標籤」是一種<strong>不夠溫柔</strong>的處理方式，儘管它很簡潔。</p><p>UpNote 除了支援標籤，還有「<strong>筆記本</strong>」設計（即圖中的 1️⃣），讓我可以為<strong>專案性質（比如去日本旅遊）、階段性任務</strong>建立專屬的筆記本。</p><p>更重要的是，它們可以<strong>封存</strong>！</p><p>完成的專案不需刪除，只需收進封存區，不佔視野，卻能隨時調出查閱。</p><p>實際使用上，我<strong>幾乎不碰 UpNote 的標籤</strong>（因為這和 Bear 重疊了），而且，我<strong>很克制地只用五到六個筆記本（如上圖）</strong>，讓它成為我處理<strong>專案型筆記</strong>的專屬空間。</p><h2 id="三、空間：清楚區分工作與生活"><a href="#三、空間：清楚區分工作與生活" class="headerlink" title="三、空間：清楚區分工作與生活"></a>三、空間：清楚區分工作與生活</h2><p>UpNote 還有一個低調但強大的功能：<strong>空間（Spaces</strong>，圖中的 2️⃣）每個空間都是獨立的筆記世界，擁有自己的筆記與筆記本。</p><p>我為工作設立了獨立空間，把工作上的學習筆記、工作日誌、任務追蹤分開管理。這些東西我也不想塞到 Bear，因為 Bear 主要作為我個人學習之用。</p><p>比起 Notion 的多層級資料庫系統，UpNote 的<strong>單層架構</strong>讓我不會陷入<strong>過度整理的深淵</strong>——這超重要XD</p><p>這不只是分類上的便利，更是<strong>心理上的切割</strong>——當我切換到「工作」這個空間，就彷彿進入另一個世界，幫助我更快地進入狀態。</p><p>工作與生活的筆記區隔清晰，我的筆記邏輯也變得更簡單，更有彈性。</p><hr><h2 id="結語：足夠好的筆記軟體"><a href="#結語：足夠好的筆記軟體" class="headerlink" title="結語：足夠好的筆記軟體"></a>結語：足夠好的筆記軟體</h2><p><strong>上述這三點，就足以讓我長期使用 UpNote</strong>，而不會覺得它多餘，因為這三點恰恰都是 Bear 所不足備的。</p><p>但我得強調：無論是 UpNote 或 Bear，它們對我來說，都已經「足夠好」了。剩下的是我作為使用者該如何運用與獨立思考的議題。</p><p>UpNote 並非完美，也不是最強大的筆記軟體。但它剛好補足了我現有的缺口——跨平台的行動筆記、可封存的分類機制、獨立清晰的空間設計。</p><p>與其說我「選擇了」 UpNote，不如說<strong>它填補了我筆記需求中的一個空白。更重要的是——這個空白有填補的價值與必要</strong>。</p><p>這正是我持續使用它的原因。</p><hr><h2 id="給筆記新手的軟體選擇攻略"><a href="#給筆記新手的軟體選擇攻略" class="headerlink" title="給筆記新手的軟體選擇攻略"></a>給筆記新手的軟體選擇攻略</h2><p>我覺得<strong>選擇筆記軟體就像選擇信用卡</strong>，除非它能夠<strong>帶來明顯的效益</strong>、<strong>解決具體的痛點</strong>，不然<strong>多一事不如少一事</strong>。</p><p>常用的工具我覺得還是少一點會比較好——雖然我自己好像也沒有做到😅，因為選擇與切換不同軟體的 context 需要時間、心力。</p><p>以下是我的選擇建議，依照你的「筆記軟體使用哲學」進行區分。</p><h3 id="一、簡單派"><a href="#一、簡單派" class="headerlink" title="一、簡單派"></a>一、簡單派</h3><p>希望用「一個」筆記軟體打天下的人：</p><ul><li><strong>純 Apple 生態系用戶</strong>：選擇 Apple Notes 或 Bear。據我所知，Apple Notes 現在基本上已經足夠強大。至於我為何不選它？我已在〈<a href="/bear/">Evernote 替代方案——筆記軟體Bear 2 升級心得</a>〉有所<a href="/bear/#%E4%B8%8D%E7%94%A8-Apple-Notes-%E7%9A%84%E7%90%86%E7%94%B1">說明</a>。</li><li><strong>Windows + 安卓</strong>：選擇 UpNote。</li><li><strong>生態混合型用戶</strong>：選擇 UpNote，或像我一樣，兩者皆有XD</li></ul><p>「簡單粗暴」是我的理想，只是我尚未做到。</p><p>總歸一句：「我還是對筆記太過貪心了。」</p><p>這讓我無法成為最優秀的學習者。</p><h3 id="二、複雜派"><a href="#二、複雜派" class="headerlink" title="二、複雜派"></a>二、複雜派</h3><p>這裡的複雜，不是指筆記軟體數量的多寡，而是<strong>需求的複雜</strong>——你希望它可以做<strong>更多事，超乎單純筆記的事</strong>。</p><p>不用說，Notion 就是你的不二選擇，其實在很多場合我還是蠻推薦 Notion 的。</p><p>原因是因為它可以很複雜，也可以很簡單，而且對免費用戶非常大方。</p><p>唯一要小心的，就是<strong>過度使用：</strong>指用來做它其實並不擅長的事情，或者是把簡單的筆記需求太複雜化。</p><p>這些行為可能會造成<strong>時間黑洞</strong>，而且不容易察覺😬</p><p>奉勸你一句：</p><blockquote><p>不要妄像任何筆記軟體能夠改變你的人生。</p></blockquote><p>它甚至改變不了筆記。</p><hr><p>至於那些擅長<strong>雙向連結</strong>的<strong>卡片筆記軟體</strong>，我個人<strong>並不特別推薦</strong>，<strong>除非你很清楚自己要什麼，否則我認為先不要考慮它們</strong>。</p><p>因為它們從來就不簡單。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/uAUlRuc.jpeg&quot; alt=&quot;by William Chen on Pexels&quot;&gt;&lt;/p&gt;
&lt;p&gt;如你所知，我是一個「&lt;a href=&quot;https://github.com/kyomind#%E7%B0%A1%E4%BB%8B&quot;&gt;不做筆記就不會學習&lt;/a&gt;」的人🥹&lt;/p&gt;
&lt;p&gt;但就像我在〈&lt;a href=&quot;/noteless/&quot;&gt;逐漸被我遺忘的卡片筆記&lt;/a&gt;〉中提到的那樣，我並不喜歡對特定的筆記軟體過於鑽研、深挖它的大量用法與變化，更不可能建立一個所謂的&lt;a href=&quot;/less-is-more/&quot;&gt;筆記系統&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我更愛「簡單粗暴」的方式&lt;/strong&gt;😎&lt;/p&gt;
&lt;p&gt;關於我的筆記軟體使用演進史，可以參考過往這幾篇文章：（依時間順序）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/code-and-me/why-evernote-7cd2abbfbafd&quot;&gt;心得 |《曼無止盡》第 40 期：Evernote 的重生之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/simple-notion/&quot;&gt;使用Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/logseq/&quot;&gt;Logseq 心得：一顆冉冉升起的「卡片筆記」新星&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/bear/&quot;&gt;Evernote 替代方案——筆記軟體 Bear 2 升級心得&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 Evernote 之外，其餘三者都是我現在仍有在使用的。所以它們相互之間&lt;strong&gt;並不是進化式的替代關係&lt;/strong&gt;，而是不斷完善的&lt;strong&gt;補充關係&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文要來講講，為何在這三個筆記軟體之外，我還需要第四個筆記軟體——UpNote。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/uAUlRuc.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
  </entry>
  
  <entry>
    <title>現代斯多葛——哲學能否成為信仰？</title>
    <link href="https://blog.kyomind.tw/stoicism/"/>
    <id>https://blog.kyomind.tw/stoicism/</id>
    <published>2025-03-15T07:43:54.000Z</published>
    <updated>2025-05-24T07:16:06.239Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/zRJZNHB.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>本文講述我開始接觸<strong>斯多葛</strong>哲學（<strong>Stoicism</strong>）的契機，以及我挑選的一些素材，還有<strong>為什麼我認為自己需要一個價值觀之外的「信仰」。</strong></p><p>我得強調，這一切才剛開始，有著強烈的實驗性質。</p><p>只不過，基於對自己的了解，我認為斯多葛很可能就是我正在追求的信仰框架。</p><p>如果你對此也感興趣，且讓我為你娓娓道來。</p><span id="more"></span><hr><h2 id="開端：意外的發現"><a href="#開端：意外的發現" class="headerlink" title="開端：意外的發現"></a>開端：意外的發現</h2><p>一切的起點，是我女朋友讀到的一本心理學相關的書。</p><p>幾個月前，某天聊天時，她突然對我說：「我覺得你很像一個斯多葛主義者。」</p><p>我當下有點訝異，斯多葛主義這個詞雖然不陌生——畢竟中學歷史課本都有！但我從未認真研究過。</p><p>我問她為什麼這麼說，她便分享了書中提到的一些斯多葛主義者的思維方式和行為準則。我聽完之後，驚訝地發現這確實與我的價值觀相似。</p><p>比如常常記錄想法、反省，以便日後遇到類似情況時重新調整行為的選擇。</p><p>儘管如此，當時的我仍只是覺得有趣，並沒有特別放在心上。</p><hr><h2 id="AI-幫我整理斯多葛主義"><a href="#AI-幫我整理斯多葛主義" class="headerlink" title="AI 幫我整理斯多葛主義"></a>AI 幫我整理斯多葛主義</h2><p>過了一段時間，xAI 的 Grok 3 這個 AI 服務推出了，它內建了我個人頗為喜歡的 DeepSearch 功能。我在〈<a href="https://kyomind.notion.site/40b324f98ca94827921a6831b0d7a38f">訂戶限定 13：Deep Research × SuperGrok × 鐵人賽頒獎典禮</a>〉簡單介紹過，還沒訂閱電子報的，趕緊<a href="/subscribe/">訂起來</a>唷！</p><p>我突然想起這件事，於是請它幫我整理「作為一個現代斯多葛主義者，會有怎麼樣的行事與價值觀？」</p><p>其實整理這樣的內容，倒不一定要 DeepSearch 這類的功能，一般的 LLM 都行，只是我希望它的回答，能結合更多網路上「現代素材」。</p><p>它的回答沒讓我失望，詳細內容可點擊<a href="https://grok.com/share/bGVnYWN5_dc0316c1-6d94-4fb0-9efe-fdde34c8393d">這個連結</a>，在此只引用一小部分：</p><ul><li><strong>重視美德</strong>：優先考慮道德卓越和誠實行為，而非物質成功。</li><li><strong>情緒韌性</strong>：通過正念和反思等技術管理情緒，特別是負面情緒。</li><li><strong>接受不確定性</strong>：理解某些事情超出控制範圍，專注於可控制的事物。</li><li><strong>終身學習</strong>：持續追求知識和自我提升，深化對斯多葛原則的理解。</li><li><strong>建立有意義的關係</strong>：重視與他人的深層連結。</li><li><strong>理性導向行動</strong>：基於邏輯和理性做出決策，而非衝動或情緒。</li><li><strong>專注於能掌控的事情，不浪費精力在無法改變的事物上。</strong></li></ul><p>這些原則看起來並不新鮮，甚至部分內容你可能會覺得有些「教條感」。</p><p>可不是嗎？</p><p>但我確實喜歡這些概念，其中一部分已經內化成我的行為模式，而更多則是我仍在努力實踐的方向。</p><p>這讓我不禁開始好奇：如果這些原則是斯多葛主義的一部分，那麼斯多葛主義到底是什麼？</p><p>或許我應該更深入了解。</p><h2 id="斯多葛主義的經典書籍"><a href="#斯多葛主義的經典書籍" class="headerlink" title="斯多葛主義的經典書籍"></a>斯多葛主義的經典書籍</h2><p>於是，我開始請 AI 推薦一些適合入門的書籍——古代、現代各 10 本。</p><p>這裡各選一本介紹即可，因為我目前就只打算讀這 2 本。</p><p>畢竟 Stoicism 是<strong>「用來實踐」的哲學</strong>。我個人是覺得不需要多麼精通其中的「教義」啦！可以慢慢理解、慢慢體會。</p><p>毫無疑問，古羅馬皇帝<a href="https://zh.wikipedia.org/zh-tw/%E9%A6%AC%E7%88%BE%E5%BA%AB%E6%96%AF%C2%B7%E5%A5%A7%E5%88%97%E9%87%8C%E7%83%8F%E6%96%AF">馬可．奧理略</a>的《<a href="https://zh.wikipedia.org/zh-tw/%E6%B2%89%E6%80%9D%E5%BD%95">沉思錄</a>》是必讀經典。</p><p>現代相關書籍中，《The Daily Stoic》則是不錯的入門。台灣翻譯為《<a href="https://www.books.com.tw/products/0010784805">回到自己的內心，每天讀點斯多噶</a>》。</p><p>兩本書風格不同：《沉思錄》是奧理略的私人筆記，內容深刻，卻也帶著強烈的個人色彩；而《The Daily Stoic》則是一本更容易消化的書，每天提供一則斯多葛智慧，並搭配現代詮釋。</p><p>雖然有些評論認為，《The Daily Stoic》對斯多葛主義的理解<strong>過於淺顯</strong>，甚至有點「<strong>過度解讀</strong>」之嫌。</p><p>我從圖書館借了一本，目前讀到五月結束。個人覺得還不錯，我認為現階段不用太糾結於「正確性」——以後可能也不需要。</p><p><img src="https://i.imgur.com/fGlbQze.jpeg"></p><hr><h2 id="為什麼我仍需要信仰？"><a href="#為什麼我仍需要信仰？" class="headerlink" title="為什麼我仍需要信仰？"></a>為什麼我仍需要信仰？</h2><p>在這個過程中，我開始思考一個更深層次的問題：斯多葛主義對我的意義是什麼？</p><p>我不算無神論者（大體而言，我願意相信有神），但我並沒有特定的宗教信仰。或者說，<strong>我並不在乎</strong>。</p><p>然而，和很多人一樣，我始終也在追尋一種「<strong>在我之上</strong>」的東西——Something bigger than yourself。</p><p>這種「更大的東西」，能夠在低潮時期給予人力量，讓人不只是依賴自己的意志力、價值觀，孤軍奮戰。</p><p>這讓我意識到，我所追尋的並非傳統宗教，而是一種能夠在低潮時支持我的力量。這樣的<strong>心靈力量</strong>，我願稱之為<strong>信仰</strong>。</p><h3 id="我需要信仰"><a href="#我需要信仰" class="headerlink" title="我需要信仰"></a>我需要信仰</h3><p>宗教是最常見的支持來源，可惜我無緣擁有。</p><p>我習慣記錄自己的想法、價值觀、對世界的切入角度，這讓我相較於多數人而言，有著更加明確的信念與好惡。</p><p>然而，即便如此，我仍然希望有一個<strong>能夠引導我前進的思維框架</strong>，斯多葛主義或許可以扮演這個角色。</p><p>我們常說「當局者迷」，即使一個人價值觀鮮明，但在低潮的時候，還是很容易會自我懷疑、猶豫不決，甚至迷失方向。</p><p>作為一個有追求的人，我不想只依靠自己，我需要<strong>更堅實的指引</strong>——我需要<strong>信仰</strong>。</p><hr><h2 id="Cal-Newport-與斯多葛主義"><a href="#Cal-Newport-與斯多葛主義" class="headerlink" title="Cal Newport 與斯多葛主義"></a>Cal Newport 與斯多葛主義</h2><p>我還問了 AI：</p><blockquote><p>那 Cal Newport 對斯多葛主義有什麼看法？我感覺他的思想與主張，例如《深度工作》（Deep Work）和《數位極簡主義》（Digital Minimalism），都<strong>很斯多葛</strong>！</p></blockquote><p>沒錯！AI 甚至直接幫我找到了 Cal Newport 在 Daily Stoic 的<a href="https://dailystoic.com/cal-newport-interview/">談訪內容</a>。我們引用一段前言：</p><blockquote><p>Cal is also a fan of the Stoics. In our interview with Cal, he explains his interest and application of Stoicism, why the idea that <em>less can be more</em> has held up since ancient times, the importance of solitude and high-quality leisure, and so much more.</p></blockquote><p>這篇訪談很值得一讀（大部分是 Cal Newport 核心價值觀的重新強調），他提到自己一直廣泛閱讀哲學和宗教歷史，因此斯多葛學說一直在他關注範圍內。</p><p>他還特別提到閱讀 William Irvine 的《A Guide to the Good Life》以及 Tim Ferriss 討論 Seneca 的內容，這些都對他有所啟發。</p><p>說到這裡，我不禁想再回到「<a href="/about/">關於我</a>」中的這一段：<a href="/about/#%E5%B0%88%E6%B3%A8%E8%88%87%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83">專注與深度思考</a>。</p><p>我想，這也是為什麼我喜歡斯多葛的一大理由吧！</p><p>這個議題，我們還要繼續。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/zRJZNHB.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文講述我開始接觸&lt;strong&gt;斯多葛&lt;/strong&gt;哲學（&lt;strong&gt;Stoicism&lt;/strong&gt;）的契機，以及我挑選的一些素材，還有&lt;strong&gt;為什麼我認為自己需要一個價值觀之外的「信仰」。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我得強調，這一切才剛開始，有著強烈的實驗性質。&lt;/p&gt;
&lt;p&gt;只不過，基於對自己的了解，我認為斯多葛很可能就是我正在追求的信仰框架。&lt;/p&gt;
&lt;p&gt;如果你對此也感興趣，且讓我為你娓娓道來。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/zRJZNHB.jpeg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
