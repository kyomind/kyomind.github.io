<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-07-13T08:00:53.355Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Python 工匠》筆記（三）有關「變數」的程式設計建議</title>
    <link href="https://blog.kyomind.tw/python-craftsman-03/"/>
    <id>https://blog.kyomind.tw/python-craftsman-03/</id>
    <published>2024-07-13T06:10:32.000Z</published>
    <updated>2024-07-13T08:00:53.355Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 3 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>如第一篇所言，這是一本關於「Clean Code in Python」的書。</p><p>上一篇我整理書中了第 13 章「<strong>有關單元測試的建議</strong>」的內容（以及我的看法）。這次我們要再回到一開始，繼續學習如何寫好程式碼。</p><p>本文整理自書中的第 1 章第 3 節，為了不過度重複書中內容，下筆點到為止，並加上我自己的理解。</p><span id="more"></span><hr><h2 id="一、保持變數的一致性"><a href="#一、保持變數的一致性" class="headerlink" title="一、保持變數的一致性"></a>一、保持變數的一致性</h2><p>這裡有兩種一致性：</p><ol><li><strong>名字一致性</strong>：在同一專案、模組、函式中，變數名稱應該保持一致。意思是，<strong>對「同一件事物」，不要用不同名稱。</strong></li><li><strong>型態一致性</strong>：變數的型態（型別）應該保持一致。意思是，<strong>不要把同一個變數，重新指向不同型態的資料。</strong></li></ol><p>老實說，這兩件事，就我的經驗，如果團隊沒有特別要求，那就<strong>一定會有人違反。</strong></p><p>乍看這好像也沒什麼，但當你的程式碼規模變得越來越龐大，這些<strong>不一致</strong>就會變成<strong>隱藏的 bug</strong>——魔鬼真的藏在細節裡。</p><p>所幸 Mypy <strong>不允許</strong>你變更變數型態，它的檢查確保了型態一致性。但命名上的一致性，只能靠人來保證。</p><p>關於「<strong>一致性</strong>」的議題，我們還會另篇討論——這真的非常重要。</p><h3 id="重新把變數指向不同型態的資料"><a href="#重新把變數指向不同型態的資料" class="headerlink" title="重新把變數指向不同型態的資料"></a>重新把變數指向不同型態的資料</h3><p>這真的是一個很常見的「巨大壞味道」。當你在程式碼中看到這樣的事情，就應該<strong>立刻警覺</strong>。</p><p>雖然許多時候它可能不會「真的」造成問題（所以才不受重視），但這樣的寫法會讓你的程式碼變得<strong>難以理解</strong>——為什麼前面是 list，後面卻變成了 dict？</p><p>而真正造成問題的時候，又很難 debug。</p><p>以前我也會做這種事，而且從 Python 語法角度，這「完全合法」呀！</p><p>後來自己被「坑」到以後，才理解這樣的寫法是<strong>多麼危險</strong>——難怪 Mypy 會禁止這樣的行為。</p><p>一個簡單避免這類行為的手段，就是<strong>重新命名一個新變數</strong>吧！還有安裝 Mypy，讓工具來幫你檢查。</p><hr><h2 id="二、變數宣告儘量靠近使用處"><a href="#二、變數宣告儘量靠近使用處" class="headerlink" title="二、變數宣告儘量靠近使用處"></a>二、變數宣告儘量靠近使用處</h2><p>這是一個<strong>好習慣</strong>，也是<strong>讓程式碼更易讀</strong>的方法。</p><p>如果我還要跨越好幾百行才能找到一個變數是怎麼宣告的，那會讓人絕望。</p><p>當然幾百行是誇張了，但如果是長函式，然後變數宣告在<strong>函式的開頭</strong>，那至少也是幾十行的事——太累了。</p><p>我們希望變數的宣告與使用能夠<strong>愈近愈好。</strong></p><p>這樣的好處是，你可以<strong>快速理解</strong>這個變數是幹嘛的，而不用一直往上找。</p><hr><h2 id="三、宣告「臨時變數」提升可讀性"><a href="#三、宣告「臨時變數」提升可讀性" class="headerlink" title="三、宣告「臨時變數」提升可讀性"></a>三、宣告「臨時變數」提升可讀性</h2><p>我覺得這是平時開發中，非常容易忽略的一點——因為這很<strong>反人性</strong>！</p><p>當你在寫程式碼時，通常你會<strong>想到什麼就寫什麼</strong>，而不會去想到「這裡可以宣告一個臨時變數，讓程式碼更好讀」。</p><p>這真的很難XD</p><p>我們直接看書中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 為所有性別為女性，或者等級大於 3 的活躍使用者發放 10000 個金幣</span></span><br><span class="line"><span class="keyword">if</span> user.is_active <span class="keyword">and</span> (user.sex == <span class="string">&#x27;female&#x27;</span> <span class="keyword">or</span> user.level &gt; <span class="number">3</span>):</span><br><span class="line">    user.add_coins(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>因為直接照著「業務邏輯」寫，程式碼隨著業務邏輯的複雜度增加，<strong>變得難以閱讀</strong>。</p><p>此時，我們可以宣告一個「<strong>臨時變數</strong>」，讓程式碼更易讀：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 為所有性別為女性，或者等級大於 3 的活躍使用者發放 10000 個金幣</span></span><br><span class="line">user_is_eligible = user.is_active <span class="keyword">and</span> (</span><br><span class="line">    user.sex == <span class="string">&#x27;female&#x27;</span> <span class="keyword">or</span> user.level &gt; <span class="number">3</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> user_is_eligible:</span><br><span class="line">    user.add_coins(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我覺得這真的堪稱神來一筆——這樣的寫法，<strong>讓程式碼更易讀</strong>，也<strong>更易維護</strong>。</p><p>你看完可能覺得，這好像也沒什麼，難嗎？</p><p>我覺得其中的難點在於：<strong>你恰好意識到，臨時變數在這個場景的必要性。</strong></p><p>這需要<strong>很細微的心思</strong>，與<strong>為他人著想的精神</strong>。因為你自己寫、自己讀，其實不需要這麼麻煩。</p><p>我稱這樣的臨時變數為——<strong>良心事業</strong>！</p><hr><h2 id="四、能不宣告變數就別宣告"><a href="#四、能不宣告變數就別宣告" class="headerlink" title="四、能不宣告變數就別宣告"></a>四、能不宣告變數就別宣告</h2><p>當然你看完上一條建議，決心想要好好適時宣告變數，當一個「貼心的人」的時候。</p><p>這條建議就是要<strong>防止你矯枉過正</strong>，濫用上述建議XD</p><p>這正是程式設計可以稱為「藝術」的地方——<strong>平衡</strong>。</p><blockquote><p>定義臨時變數可以提高可讀性。但有時，把不必要的東西賦值成臨時變數反而會讓程式碼<strong>顯得囉嗦</strong>：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_best_trip_by_user_id</span>(<span class="params">user_id</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># OS：『嗯，這個值未來說不定會修改/二次使用』，讓我們先把它定義成變數吧！</span></span><br><span class="line">    user = get_user(user_id)</span><br><span class="line">    trip = get_best_trip(user_id)</span><br><span class="line">    result = &#123;</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: user,</span><br><span class="line">        <span class="string">&#x27;trip&#x27;</span>: trip</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>其實，這段程式碼裡的三個臨時變數完全可以去掉，變成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_best_trip_by_user_id</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: get_user(user_id),</span><br><span class="line">        <span class="string">&#x27;trip&#x27;</span>: get_best_trip(user_id)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>簡言之，變數是「<strong>我現在就需要</strong>」才宣告——包括臨時變數。</p><hr><h2 id="五、空行也是一種「註解」"><a href="#五、空行也是一種「註解」" class="headerlink" title="五、空行也是一種「註解」"></a>五、空行也是一種「註解」</h2><p>說真的，我本來是打算把這段的標題作為文章標題，但這樣顯然有點「文不對題」。</p><p>空行是<strong>程式碼的一部分</strong>，它可以讓程式碼<strong>更易讀</strong>。</p><p>看看書上怎麼說：</p><blockquote><p>程式碼裡的註解不只是那些常規的描述性語句，有時候，沒有一個字元的空行，也算得上一種特殊的「註解」。</p></blockquote><blockquote><p>在寫程式碼時，我們可以適當地在程式碼中插入空行，<strong>把程式碼按不同的邏輯塊分隔開，這樣能有效提升程式碼的可讀性。</strong></p></blockquote><p>這些道理大家都懂，但<strong>真正做到</strong>的人，可能還不算太多。</p><p>部分開發者對於「空行」的態度，還是比較隨心所欲，未必是著眼於<strong>程式碼的可讀</strong>。</p><p>因此讓人感覺<strong>缺乏一致性</strong>：相同的情況，有時候會空行，有時候又不會。</p><p>所以我才會很想把本段作為文章標題，來強調「空行」的重要性XD</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 3 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;如第一篇所言，這是一本關於「Clean Code in Python」的書。&lt;/p&gt;
&lt;p&gt;上一篇我整理書中了第 13 章「&lt;strong&gt;有關單元測試的建議&lt;/strong&gt;」的內容（以及我的看法）。這次我們要再回到一開始，繼續學習如何寫好程式碼。&lt;/p&gt;
&lt;p&gt;本文整理自書中的第 1 章第 3 節，為了不過度重複書中內容，下筆點到為止，並加上我自己的理解。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>《Python 功力提升的樂趣》心得與總結：給 Python 開發者的 Clean Code 入門指南</title>
    <link href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python/"/>
    <id>https://blog.kyomind.tw/beyond-the-basic-stuff-with-python/</id>
    <published>2024-06-30T02:58:44.000Z</published>
    <updated>2024-07-06T10:17:52.386Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tS78Ke0.png" alt="Python 功力提升的樂趣"><span class="cap">Python 功力提升的樂趣</span></p><p>這是「<a href="/series/#Python-%E5%85%A5%E9%96%80%E4%B8%89%E9%83%A8%E6%9B%B2">Python 入門三部曲</a>」的最後一篇！歷時 2 年，終於要為這個系列劃下句點。</p><p>在此之前，我已寫下 3 篇關於《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣</a>》的筆記與心得。本文建立在它們之上，但會從<strong>更高的俯視角度</strong>來介紹與推薦這本書。</p><p>從全書的<strong>輪廓與定位</strong>切入，讓初學者更容易掌握觀念，不至於迷失在細節中。對於已有經驗的 Python 開發者，則可以藉由一篇篇的筆記，直接找到自己感興趣的章節。</p><p>所以，<strong>本文不會在內容上重複前文，或在細節上多加著墨</strong>，而是<strong>更多的回顧與比較</strong>。</p><p>這是為什麼我要<strong>先寫筆記</strong>，最後再完成這篇<strong>閱讀心得</strong>的原因。</p><p>當然，<strong>不是每一本書都值得你如此對待</strong>。畢竟其中要投入時間精力甚多，這是我第一次——可能也是最後一次，這麼詳細地介紹一本書。</p><p>但這本書，我認為值得。</p><h3 id="系列：Python-入門三部曲"><a href="#系列：Python-入門三部曲" class="headerlink" title="系列：Python 入門三部曲"></a>系列：Python 入門三部曲</h3><blockquote><ol><li><a href="/introducing-python/">《精通 Python 第二版》心得：給入門者的 Python 學習藍圖</a></li><li><a href="/the-quick-python-book/">最佳 Python 入門書——《Python 技術者們 - 練功！》心得與導讀</a></li><li><strong>《Python 功力提升的樂趣》心得與總結：給 Python 開發者的 Clean Code 入門指南</strong></li></ol></blockquote><h3 id="系列：Python-功力提升的樂趣"><a href="#系列：Python-功力提升的樂趣" class="headerlink" title="系列：Python 功力提升的樂趣"></a>系列：Python 功力提升的樂趣</h3><blockquote><ol><li><a href="/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a></li><li><a href="/beyond-the-basic-stuff-with-python-02/">《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱</a></li><li><a href="/beyond-the-basic-stuff-with-python-03/">《Python 功力提升的樂趣》筆記（三）函式、註解、docstring</a></li><li><strong>《Python 功力提升的樂趣》心得與總結：給 Python 開發者的 Clean Code 入門指南</strong></li></ol></blockquote><span id="more"></span><hr><p>有鑑於本文是上述兩個系列的<strong>最後一篇</strong>，我打算嘗試一個<strong>與以往截然不同的寫法</strong>。</p><p>改用<strong>回顧與分析</strong>的方式，一步一步地梳理過去各篇文章的<strong>關鍵著眼點</strong>，最後<strong>勾勒</strong>出本書的<strong>核心價值</strong>。為兩個系列同時劃下句點。</p><p>我認為，和其它文章內容的互相比較，更能突顯<strong>本書的整體定位</strong>。</p><p>這或許是我所能想到，最好也<strong>最有趣</strong>的收尾方式。</p><hr><h2 id="「Python-入門書系列」的定位與回顧"><a href="#「Python-入門書系列」的定位與回顧" class="headerlink" title="「Python 入門書系列」的定位與回顧"></a>「Python 入門書系列」的定位與回顧</h2><p>我們先來看看「<strong>Python 入門三部曲</strong>」部分。</p><h3 id="精通-Python-第二版"><a href="#精通-Python-第二版" class="headerlink" title="精通 Python 第二版"></a>精通 Python 第二版</h3><p>第一本我選擇了，可能是全台最暢銷的 Python 書籍——《<a href="https://www.tenlong.com.tw/products/9789865024864">精通 Python 第二版</a>》。</p><p>這是一個「<strong>大而全</strong>」的選擇，儘管它的內容不算深入，而且對於初學者來說，很多部分我覺得也稱不上平易近人。比如介紹 <a href="https://flask.palletsprojects.com/en/3.0.x/">Flask</a> 框架。</p><p>不過它的<strong>基礎語法教學</strong>很值得肯定。</p><p>之所以必須如此，是因為 <strong>Python 使用者實在太多樣化</strong>。彼此的目的不同、需求不同，學習 Python 的方式也必然有所差異。</p><p>所以我們要先準備一張「<strong>藍圖</strong>」，讓我們縱觀 Python 的<strong>全貌</strong>，以及它所能做的到所有事情，再從中做出<strong>屬於自己的取捨</strong>。</p><p>而本書顯然是扮演藍圖角色的絕佳選擇。</p><h3 id="Python-技術者們-練功！"><a href="#Python-技術者們-練功！" class="headerlink" title="Python 技術者們 - 練功！"></a>Python 技術者們 - 練功！</h3><p>有了全局輪廓之後，我們真的要來「<strong>練功</strong>」了。</p><p>對於有特定目標的 Python 使用者，比如使用 Python 進行<strong>資料分析</strong>，可以不必完整地看完這本書，就可以開始動手實作。</p><p>因為很多工作其實<strong>更需要對特定套件的熟悉與了解</strong>，而不是 Python 語言本身。</p><p>可以說，本書的<strong>目標客群</strong>還是更加著眼於「<strong>Python 開發者</strong>」，而不是「Python 使用者」（兩者沒有明確的分界，但仍有些區別）。</p><p>因此，如果你的目標是<strong>成為一名 Python 開發者</strong>，那麼這本書就是你的最佳入門選擇。</p><h3 id="Python-功力提升的樂趣"><a href="#Python-功力提升的樂趣" class="headerlink" title="Python 功力提升的樂趣"></a>Python 功力提升的樂趣</h3><p>最後是我們的主角——《<a href="https://www.tenlong.com.tw/products/9789865027711">Python功力提升的樂趣：寫出乾淨程式碼的最佳實務</a>》。</p><p>為什麼是第三位出場的呢？原因不難理解。</p><p>首先我們要知道 <strong>Python 能做什麼</strong>，然後問自己<strong>想用 Python 做什麼</strong>。</p><p>經過思考，決定成為一個 Python 開發者後，才是如何寫出<strong>乾淨</strong>的 Python 程式碼。</p><p>換句話說，對於主要把 Python 當作<strong>完成工作的工具</strong>的使用者而言，是否能寫出乾淨的 Python 程式碼，恐怕不是特別重要——完成目標才是第一位。</p><p>所以，如果覺得自己不太需要看完上述第二本書，那本書則更加不是必讀。</p><p>這是取捨的<strong>優先順序</strong>，也是<strong>選擇的藝術</strong>。</p><hr><h2 id="誰需要看《Python-功力提升的樂趣》？"><a href="#誰需要看《Python-功力提升的樂趣》？" class="headerlink" title="誰需要看《Python 功力提升的樂趣》？"></a>誰需要看《Python 功力提升的樂趣》？</h2><p>當然是<strong>自認已經或將要成為 Python 開發者</strong>的人。</p><h3 id="Python-開發者"><a href="#Python-開發者" class="headerlink" title="Python 開發者"></a>Python 開發者</h3><p>我們還是試著簡單定義一下，怎麼樣算是一個 Python 開發者：</p><ul><li><strong>熟悉 Python 語法</strong>，使用 Python 開發應用程式、服務或系統。</li><li>你寫的 Python 程式碼<strong>不只要能完成工作</strong>，還會<strong>被讓他人閱讀、維護</strong>。</li><li>對於「<strong>最佳實踐</strong>」有一定追求。不只關心結果，<strong>還關心過程。</strong>因為這將會影響到產出的程式碼<strong>品質</strong>。</li></ul><p>我終究只能列舉一些條件，因為 Python 開發者的定義實在太廣泛了。</p><p>簡而言之，你希望自己的 Python 程式碼<strong>更加乾淨、易讀、易維護</strong>，那麼這本書就是你的好幫手。</p><p>而在我看來，有這樣的心態，就<strong>已經算是</strong>一個 Python 開發者了。</p><hr><h2 id="為什麼要寫乾淨的-Python-程式碼？"><a href="#為什麼要寫乾淨的-Python-程式碼？" class="headerlink" title="為什麼要寫乾淨的 Python 程式碼？"></a>為什麼要寫乾淨的 Python 程式碼？</h2><p><strong>為什麼 Clean Code 很重要？</strong></p><p>乾淨的程式碼有兩個<strong>不可取代</strong>的優點：</p><ol><li><strong>易讀性</strong>：程式碼不僅是給自己，同時也是<strong>給別人看的</strong>。</li><li><strong>易維護性</strong>：當程式碼變得更加複雜時，乾淨的程式碼可以讓你<strong>更容易找到問題</strong>。</li></ol><p>這兩件事，說到底，就是<strong>減少痛苦與省下時間！</strong></p><p>其它都不論，<strong>省下寶貴的時間</strong>就是王道。</p><p>Bug 越少，修 bug 的時間就越少；程式碼越好讀，你就越快找到問題所在。</p><p>誰不想要快樂工作、快樂生活呢？</p><hr><h2 id="「Python-功力提升的樂趣」系列定位與回顧"><a href="#「Python-功力提升的樂趣」系列定位與回顧" class="headerlink" title="「Python 功力提升的樂趣」系列定位與回顧"></a>「Python 功力提升的樂趣」系列定位與回顧</h2><p>好，那我們就來看看，了解了 Python 基本功後，究竟要如何更進一步讓自己的程式碼乾淨、好讀。</p><h3 id="筆記（一）Black、命名、壞味道"><a href="#筆記（一）Black、命名、壞味道" class="headerlink" title="筆記（一）Black、命名、壞味道"></a>筆記（一）Black、命名、壞味道</h3><p>工欲善其事，必先利其器。</p><p>如果專案沒有使用 linter、formatter 來進行開發，那我<strong>幾乎無法想像</strong>，這個專案程式碼會有多麼的雜亂。</p><p>整潔的程式碼有<strong>很多層次</strong>，就像<strong>金字塔</strong>一樣。而機器能夠代勞的，就讓它們代勞吧！</p><p>作者推薦 <a href="https://github.com/psf/black">Black</a>，這是很好的選擇。而現在的我一律推薦 <a href="https://github.com/astral-sh/ruff">Ruff</a>。</p><blockquote><p>相關文章：<a href="/ruff/">Python 開發：Ruff Linter、Formatter 介紹 + 設定教學</a></p></blockquote><p>總之，有這些工具輔助，我們未必能寫出乾淨的程式碼。</p><p>但沒有它們，<strong>一切都只是空談。</strong></p><h3 id="筆記（二）Pythonic、行話、陷阱"><a href="#筆記（二）Pythonic、行話、陷阱" class="headerlink" title="筆記（二）Pythonic、行話、陷阱"></a>筆記（二）Pythonic、行話、陷阱</h3><p>Pythonic 是一個很有趣的概念，它代表了 Python 的<strong>獨特風格</strong>，以及<strong>最佳實務</strong>。</p><p>要達到 Pythonic，就必須要<strong>熟悉 Python 的特性</strong>，並且<strong>適時運用</strong>。</p><p>這需要<strong>長時間的經驗與累積</strong>。</p><p>事實上，只要不是「<strong>有意識地追求</strong>」，無論你寫了再久的 Python，都不一定能夠寫出 Pythonic 的程式碼。</p><p>這不是時間問題，而是「<strong>心態</strong>」問題。</p><p>當然我並不認為每一個 Python 開發者都需要追求 Pythonic，但如果你也想，那本書是一個<strong>很好的開始</strong>。</p><h3 id="筆記（三）函式、註解、docstring"><a href="#筆記（三）函式、註解、docstring" class="headerlink" title="筆記（三）函式、註解、docstring"></a>筆記（三）函式、註解、docstring</h3><p>這篇的重點應該是 <a href="https://en.wikipedia.org/wiki/Docstring">docstring</a>。</p><p>我在許多文章中都強調過 docstring 的重要性。它遠遠不止是單純的註解或文件，應該視為<strong>程式碼的一部分</strong>。</p><p>我很清楚——我非常清楚：一則<strong>用心撰寫</strong>的 docstring，<strong>可以為一個「複雜函式」降低多少「認知負擔」</strong>。可以為函式的閱讀者省下多少理解時間（和腦細胞）。</p><p>然而，<strong>docstring 在實際開發中被輕忽的程度，幾乎與它所帶來的價值一樣巨大。</strong></p><p>在我看來，不寫 docstring、不知道怎麼寫好 docstring，都是<strong>非常非常可惜</strong>的事。</p><p>以後我會專門寫一篇文章，示範如何寫好 Python docstring。我們只需要先知曉：</p><blockquote><p><strong>專案程式碼</strong>不是一堆待執行的指令，做完就好。而是<strong>需要理解與維護的有機體</strong>，docstring 更是其中重要的一環。</p></blockquote><hr><h2 id="結語：Beyond-the-Basic-Stuff-with-Python"><a href="#結語：Beyond-the-Basic-Stuff-with-Python" class="headerlink" title="結語：Beyond the Basic Stuff with Python"></a>結語：Beyond the Basic Stuff with Python</h2><p>沒有人能夠<strong>只因為寫得久</strong>，就自動變成真正的 Python 大師。</p><p>無論是 Pythonic 或 Clean Code，都需要我們在開發這條路上一次又一次捫心自問：</p><blockquote><p>這樣寫，是不是最好的方式？</p></blockquote><p>而本書的最大價值，在於讓這個「起點」<strong>變得清晰且平易近人</strong>。</p><p>因為再往後的 Clean Code 之路，就不再只是表面的程式碼風格，而是需要你了解更多 Python 的<strong>進階特性</strong>，才能夠理解這些設計的<strong>長短得失</strong>與<strong>取捨之道</strong>。</p><p>我們需要一本書，幫助我們打好基礎，培養能力去面對未來更加錯綜複雜的情況。</p><p>而《Python 功力提升的樂趣》無疑是一個<strong>非常稱職的選擇。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tS78Ke0.png&quot; alt=&quot;Python 功力提升的樂趣&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是「&lt;a href=&quot;/series/#Python-%E5%85%A5%E9%96%80%E4%B8%89%E9%83%A8%E6%9B%B2&quot;&gt;Python 入門三部曲&lt;/a&gt;」的最後一篇！歷時 2 年，終於要為這個系列劃下句點。&lt;/p&gt;
&lt;p&gt;在此之前，我已寫下 3 篇關於《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣&lt;/a&gt;》的筆記與心得。本文建立在它們之上，但會從&lt;strong&gt;更高的俯視角度&lt;/strong&gt;來介紹與推薦這本書。&lt;/p&gt;
&lt;p&gt;從全書的&lt;strong&gt;輪廓與定位&lt;/strong&gt;切入，讓初學者更容易掌握觀念，不至於迷失在細節中。對於已有經驗的 Python 開發者，則可以藉由一篇篇的筆記，直接找到自己感興趣的章節。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;本文不會在內容上重複前文，或在細節上多加著墨&lt;/strong&gt;，而是&lt;strong&gt;更多的回顧與比較&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是為什麼我要&lt;strong&gt;先寫筆記&lt;/strong&gt;，最後再完成這篇&lt;strong&gt;閱讀心得&lt;/strong&gt;的原因。&lt;/p&gt;
&lt;p&gt;當然，&lt;strong&gt;不是每一本書都值得你如此對待&lt;/strong&gt;。畢竟其中要投入時間精力甚多，這是我第一次——可能也是最後一次，這麼詳細地介紹一本書。&lt;/p&gt;
&lt;p&gt;但這本書，我認為值得。&lt;/p&gt;
&lt;h3 id=&quot;系列：Python-入門三部曲&quot;&gt;&lt;a href=&quot;#系列：Python-入門三部曲&quot; class=&quot;headerlink&quot; title=&quot;系列：Python 入門三部曲&quot;&gt;&lt;/a&gt;系列：Python 入門三部曲&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/introducing-python/&quot;&gt;《精通 Python 第二版》心得：給入門者的 Python 學習藍圖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/the-quick-python-book/&quot;&gt;最佳 Python 入門書——《Python 技術者們 - 練功！》心得與導讀&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;《Python 功力提升的樂趣》心得與總結：給 Python 開發者的 Clean Code 入門指南&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系列：Python-功力提升的樂趣&quot;&gt;&lt;a href=&quot;#系列：Python-功力提升的樂趣&quot; class=&quot;headerlink&quot; title=&quot;系列：Python 功力提升的樂趣&quot;&gt;&lt;/a&gt;系列：Python 功力提升的樂趣&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/beyond-the-basic-stuff-with-python-01/&quot;&gt;《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/beyond-the-basic-stuff-with-python-02/&quot;&gt;《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/beyond-the-basic-stuff-with-python-03/&quot;&gt;《Python 功力提升的樂趣》筆記（三）函式、註解、docstring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;《Python 功力提升的樂趣》心得與總結：給 Python 開發者的 Clean Code 入門指南&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    <content src="https://i.imgur.com/tS78Ke0.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>33，Tony Huang 與我的坪林之旅</title>
    <link href="https://blog.kyomind.tw/weekly-review-33/"/>
    <id>https://blog.kyomind.tw/weekly-review-33/</id>
    <published>2024-06-29T17:19:22.000Z</published>
    <updated>2024-06-30T02:58:32.547Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>你聽過 <a href="http://www.tonyhuang39.com/">Tony Huang</a> 嗎？</p><p>20 年前他就已經開始寫登山健行 blog，最近 5 年改為拍攝 <a href="https://www.youtube.com/@tonyhuang38">YouTube 影片</a>，成為旅遊 YouTuber。</p><p>他的作品特色是，在旅行中融入人文、歷史、文學等元素，讓觀眾不只是看風景，更能了解台灣這塊土地的過去。</p><p>我無須介紹太多，而是要聊聊，最近看了許多他的影片的一些感想。</p><span id="more"></span><hr><h2 id="一、坪林之旅"><a href="#一、坪林之旅" class="headerlink" title="一、坪林之旅"></a>一、坪林之旅</h2><p>上週日和女友還有她爸一起去了坪林，也是因為看了 Tony 的<a href="https://youtu.be/V45fgw27bD4?si=z9GSE3WCDEUxrzDs">影片</a>，讓我躍躍欲試。</p><p>坪林區位於新北市的東南端，是一個以茶葉聞名的鄉鎮，被稱為「<strong>茶鄉</strong>」。擁有豐富的茶文化以及美麗的自然景觀。</p><p>更重要的是，這裡有好多溪流！依水系可劃分為三區：北勢溪、𩻸魚堀溪、金瓜寮溪。</p><p>大部分溪流旁都建設了自行車道，讓人可以騎著單車，欣賞河濱風光。</p><p>而我是<strong>酷愛走路之人</strong>，所以沒有騎車，只是選擇走路。</p><p>這裡給我的第一印象是，觀光客<strong>相對沒那麼多</strong>，有一種「自己的世界」的感覺。</p><p>尤其大中午（下午 1 點半）走在河濱，哪怕是星期日，也很難遇到人。</p><p><img src="https://i.imgur.com/c6zDvfy.jpeg" alt="𩻸魚堀溪觀魚步道"><span class="cap">𩻸魚堀溪觀魚步道</span></p><p>有趣的是，我的很多想法與感悟，都是發生在河濱。</p><p>如同我在〈<a href="/riverside/#%E6%B2%B3%E6%BF%B1%E4%B9%8B%E6%96%BC%E6%88%91">轉職生活與河濱之於我</a>〉說的：</p><blockquote><p>河濱之於我，就像我們常聽到的「樹洞」比喻，你可以對它說任何秘密與心事，而它會安安靜靜地聆聽並幫你保守這一切。唯一的差別是你並不需要真的說些什麼，只要身在其中，就能感受到一部分的自己得到了解放。</p></blockquote><p>這一次的坪林之旅，我感覺自己又重燃了對河濱的熱情，或說是<strong>對走路的熱情</strong>。</p><hr><h2 id="二、我最喜歡的-Tony-Huang-影片"><a href="#二、我最喜歡的-Tony-Huang-影片" class="headerlink" title="二、我最喜歡的 Tony Huang 影片"></a>二、我最喜歡的 Tony Huang 影片</h2><p>Tony 的影片〈<a href="https://youtu.be/X6rNtltjGfA?si=U-KBdSlaBTGWgFXL">新挑戰：從福隆走到頭城，31公里！追隨吳沙腳步，竟然遇見劉明燈!?</a>〉我看了無數次，沒事就會看。一言以蔽之——它擊中了我的心🥰</p><p>一天走 31 公里，這對大部分人都是不小的挑戰。但 Tony 用他的影片，讓人覺得這是<strong>一種享受</strong>。</p><p>事實上我曾在多年前的 8 月下午，和朋友一起從外澳走到頭城，光這一段就感覺身體要被烤焦了XD</p><p>參考影片的介紹：</p><blockquote><p>這次的徒步旅行，是新的挑戰，我從福隆走到頭城，超過 30 公里。這條路線是清代嘉慶元年（1796）吳沙進入噶瑪蘭所走的路線。不同的是，當年吳沙辛苦翻越隆嶺，而我是要走舊草嶺隧道穿過隆嶺。（下略）</p></blockquote><p>讓人有一種穿越時空的錯覺，彷彿自己也活在那個年代，而<strong>走路就是人生</strong>。</p><p>特別喜歡這支影片，不是因為一天走 31 公里的雄心壯志，甚至也不是影片中所表現的歷史與人文關懷。</p><p>而是我在其中找到了屬於自己的共鳴。<strong>我只是抽取了其中一部分的元素——走路。從而深深地被吸引。</strong></p><hr><h2 id="三、人生可以很簡單"><a href="#三、人生可以很簡單" class="headerlink" title="三、人生可以很簡單"></a>三、人生可以很簡單</h2><p>看完 Tony 這麼多影片，我有一種感覺——<strong>人生真的可以很簡單</strong>。</p><p>他有很多路線，其實都很平淡，如果不是特地解說過去的人文歷史，我們走起來就只是一條普通的步道或馬路。</p><p>我們未必對這些事情感興趣，但我們可以有別的共鳴——屬於自己的共鳴。如魔法般，讓平淡的事物變得有趣。</p><p>對我而言，單純的走路可能並不有趣。</p><p>但在花了很多時間寫作、學習程式之後，大腦已精疲力盡。追逐目標與戰鬥的疲憊感，讓我需要一些<strong>簡單的事物</strong>，好讓自己可以<strong>充分放鬆</strong>。</p><p>此時平淡的走路變成一項<strong>頗具滋味</strong>的活動。頓時令人產生一種<strong>幻覺：人生好像只要這樣就可以滿足了。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;你聽過 &lt;a href=&quot;http://www.tonyhuang39.com/&quot;&gt;Tony Huang&lt;/a&gt; 嗎？&lt;/p&gt;
&lt;p&gt;20 年前他就已經開始寫登山健行 blog，最近 5 年改為拍攝 &lt;a href=&quot;https://www.youtube.com/@tonyhuang38&quot;&gt;YouTube 影片&lt;/a&gt;，成為旅遊 YouTuber。&lt;/p&gt;
&lt;p&gt;他的作品特色是，在旅行中融入人文、歷史、文學等元素，讓觀眾不只是看風景，更能了解台灣這塊土地的過去。&lt;/p&gt;
&lt;p&gt;我無須介紹太多，而是要聊聊，最近看了許多他的影片的一些感想。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
    <category term="河濱" scheme="https://blog.kyomind.tw/tags/%E6%B2%B3%E6%BF%B1/"/>
    
    <category term="人生思考" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Django REST framework 教學（三）View 函式</title>
    <link href="https://blog.kyomind.tw/django-rest-framework-03/"/>
    <id>https://blog.kyomind.tw/django-rest-framework-03/</id>
    <published>2024-06-29T01:01:17.000Z</published>
    <updated>2024-07-06T10:23:04.998Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 的第 9 篇、<a href="/series/#Django-REST-framework-%E6%95%99%E5%AD%B8">DRF 系列</a>的第 3 篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="/django/">Django 文章總覽</a>」。</p><p>本文相關的程式碼改動，都集中在這個 <a href="https://github.com/kyomind/Django-Tutorial/pull/4">PR</a>。</p><hr><p><a href="https://docs.djangoproject.com/en/5.0/topics/http/views/">Views</a> 是 Django 中<strong>處理 HTTP 請求的核心邏輯</strong>。它的作用是接收請求、處理請求，最後返回 response：</p><blockquote><p>A <strong>view function</strong>, or view for short, is a Python function that takes a web request and returns a web response.</p></blockquote><p>在 Django 中，我們可以使用兩種方式來撰寫 views：</p><ol><li>Function-Based Views（FBV），其實就是一個 Python 函式，也是 Django 預設的 view 寫法，所以又稱 <strong>view 函式</strong>。</li><li><a href="https://docs.djangoproject.com/en/5.0/topics/class-based-views/">Class-Based Views</a>（CBV）。CBV 是 Django 1.3 版本引入的，它是基於類別的 view 寫法。</li></ol><h2 id="CBV-與-FBV"><a href="#CBV-與-FBV" class="headerlink" title="CBV 與 FBV"></a>CBV 與 FBV</h2><p>「<a href="https://ithelp.ithome.com.tw/articles/10205779">CBV vs. FBV</a>」是初學 Django 一個常見的議題。如系列的<a href="/django-rest-framework-01/#CBV-vs-FBV">第一篇</a>所言：</p><blockquote><p>CBV 有著<strong>重用程式碼</strong>優勢，適合大型專案。而 FBV 則以<strong>簡單、直接</strong>為賣點，方便快速開發中小型專案。</p></blockquote><p>究竟要選哪個，取決於個人喜好與專案需求。</p><p>Django REST framework（以下簡稱 DRF）同時支援這兩種 views。</p><p>事實上，DRF 顯然<strong>更加鼓勵使用 CBV</strong>，不僅提供了許多現成的 <a href="https://www.django-rest-framework.org/api-guide/generic-views/">generic views</a>，它的很多元件也是基於 CBV 設計的。</p><p>不過，本文只打算介紹 DRF 中的 FBV，並實作一個 DRF view function。</p><span id="more"></span><hr><h2 id="Django-app-中的-views-py"><a href="#Django-app-中的-views-py" class="headerlink" title="Django app 中的 views.py"></a>Django app 中的 views.py</h2><p>回到我們的範例專案——<a href="https://github.com/kyomind/Django-Tutorial">Django Tutorial</a> 中的<code>post</code>app。</p><p>Django Tutorial 是一個簡單的部落格專案，與我的「<a href="/series/#Django-ORM-%E5%A4%96%E9%8D%B5%E6%95%99%E5%AD%B8">系列：Django ORM 外鍵教學</a>」<strong>共用世界觀。</strong></p><p>可以了解一下<a href="/django-models/#%E5%B0%88%E6%A1%88%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%B4%B9">專案模型介紹</a>以及<a href="/reverse-relationships/#%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%A8%A1%E5%9E%8B%E8%AA%BF%E6%95%B4">範例程式碼模型調整</a>。</p><p>不過因為它們的<strong>設計非常簡單</strong>，直接看程式碼應該也無妨。</p><h3 id="views-py"><a href="#views-py" class="headerlink" title="views.py"></a>views.py</h3><p><code>views.py</code>是 Django app 中<strong>處理 HTTP 請求的地方</strong>，我們在這裡定義各種 views。</p><p>上一回我們已經在 <a href="https://github.com/kyomind/Django-Tutorial/blob/django-rest-framework-02/post/views.py">views.py</a> 中用 view 函式實作了一個簡單的 API：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello, world!&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>這次我們要再進一步，實作一個更複雜的 API，且更多使用 DRF 的功能。</p><hr><h2 id="DRF-View-Function"><a href="#DRF-View-Function" class="headerlink" title="DRF View Function"></a>DRF View Function</h2><p>首先，我們需要引入<code>api_view</code>裝飾器與<code>Response</code>類別：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br></pre></td></tr></table></figure><p>還有最後的<code>status</code>模組，用於設定 HTTP 狀態碼。</p><p>接著，我們將這些 DRF 元件套用在我們的 view function 上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(<span class="params">[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_posts</span>(<span class="params">request</span>):</span><br><span class="line">    posts = Post.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer = PostSerializer(posts, many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure><p>這樣我們就實作了一個簡單的 DRF <code>GET</code> API，用於取得所有的文章。</p><p>這裡的<code>PostSerializer</code>是一個<a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器</a>，我們會在下一篇文章中介紹。</p><p>此刻，我們先專注於<code>api_view</code>裝飾器與<code>Response</code>類別上。</p><hr><p>如前所述，Django 的 view 本質上是一個 Python 函式，它接收一個 HTTP request，返回一個 HTTP response。</p><p><strong>那 DRF 的 view function 又有什麼不同呢？</strong>——其實就是<strong>整合了 DRF 提供的功能。</strong></p><p>我們來看看 DRF 究竟幫我們做了什麼，讓開發 API 變得更簡單。</p><h2 id="一、api-view-裝飾器"><a href="#一、api-view-裝飾器" class="headerlink" title="一、api_view 裝飾器"></a>一、<code>api_view</code> 裝飾器</h2><p><code>api_view</code>裝飾器，它的<strong>主要目的</strong>是將普通的 Django view <strong>轉換為</strong> DRF 的 <strong>API view</strong>。為此，它做了以下幾件事：</p><ol><li><strong>方法限制</strong>：<code>@api_view([&#39;GET&#39;])</code>指定了這個 view 允許的 HTTP 方法。當請求方法不在允許列表中時，DRF 會自動回應<code>405 Method Not Allowed</code>。</li><li><strong>request</strong>：DRF 將 Django 的<code>HttpRequest</code>物件轉換為<code>Request</code>物件。它更加方便操作，比如可以通過<code>request.data</code>取得 POST 請求的資料，而不需要自己去處理<code>request.POST</code>或<code>request.body</code>。</li><li><strong>例外處理</strong>：<code>api_view</code>重新封裝了 view，提供了內建的錯誤處理機制。</li></ol><p>其中<strong>第二點</strong>是最重要的，因為 DRF 的<code>Request</code>物件提供了更多的功能，包括實務中大量使用的<code>request.data</code>。</p><p>Django 原生的<code>HttpRequest</code>物件，只提供了<code>request.POST</code>和<code>request.body</code>，兩者在使用上都有<a href="/django-request/#%E4%B8%89%E3%80%81HttpRequest-POST">一定限制</a>。</p><blockquote><p>相關文章：<a href="/django-request/">Django HttpRequest 常用屬性介紹</a></p></blockquote><p>而 DRF 對其進行了<strong>簡化</strong>，讓我們可以更加專注在 API 的邏輯上，這確實是一大加分。</p><h2 id="二、Response-類別"><a href="#二、Response-類別" class="headerlink" title="二、Response 類別"></a>二、<code>Response</code> 類別</h2><p><code>Response</code>是 DRF 提供的<strong>自定義 response</strong>，它繼承自 Django 的<code>HttpResponse</code>，並提供了更多的功能。</p><p>不過在我看來，<code>Response</code>的重要性沒有<code>api_view</code>裝飾器那麼高，使用 Django 的<code>JsonResponse</code>也能達到類似的效果：</p><ol><li><strong>資料轉換</strong>：<code>Response</code> 能夠接受 Python 字典、list 或其他可序列化的資料結構，並自動將它們轉換為 JSON 回應。你不用手動調用 <code>json.dumps</code>。</li><li><strong>狀態碼</strong>：你可以通過 <code>Response(data, status=status.HTTP_200_OK)</code> 設置回應的 HTTP 狀態碼。</li></ol><p>通常，我們<strong>主要的需求</strong>就是返回一個 JSON response。</p><p>所以這裡就不多討論<code>Response</code>，很多時候我都是直接使用<code>JsonResponse</code>。</p><h2 id="三、status-模組"><a href="#三、status-模組" class="headerlink" title="三、status 模組"></a>三、<code>status</code> 模組</h2><p>DRF 的<code>status</code>模組提供了一系列的 HTTP 狀態碼，將它們封裝成了<strong>常數</strong>。比如：</p><ul><li><code>status.HTTP_200_OK</code>：200 OK</li><li><code>status.HTTP_201_CREATED</code>：201 Created</li><li><code>status.HTTP_400_BAD_REQUEST</code>：400 Bad Request</li><li><code>status.HTTP_404_NOT_FOUND</code>：404 Not Found</li><li><code>status.HTTP_405_METHOD_NOT_ALLOWED</code>：405 Method Not Allowed</li></ul><p>這對於提高程式碼的可讀性與一致性很有幫助，這樣我們就不用牢牢記住每個狀態碼的數字與背後的意義——尤其是那些比較少用到的狀態碼。</p><hr><p>目前為止，新的 API view function 的<strong>框架</strong>已經完成了，可惜它還<strong>無法運作</strong>——因為我們還沒有定義<code>PostSerializer</code>。</p><p>這部分我們下回再來處理。文章結束前，我們還要對「路由」進行一些調整。</p><h2 id="路由設定"><a href="#路由設定" class="headerlink" title="路由設定"></a>路由設定</h2><p>在<code>post/urls.py</code>新增一個路由，並調整<code>import</code>方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> post <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;hello/&#x27;</span>, views.hello_world),</span><br><span class="line">    path(<span class="string">&#x27;posts/&#x27;</span>, views.get_posts),  <span class="comment"># 新增這一行</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果要透過 API 取得所有文章，就要訪問<code>/post/posts/</code>這個 path。</p><p>path 的前半部是專案的一級路由，它們是由<code>DjangoTutorial/urls.py</code>設定的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;post/&#x27;</span>, include(<span class="string">&#x27;post.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>後半部是 Django app 的路由。這樣的設計有助於管理與維護。</p><p>不過<code>/post/posts/</code>這 path 的設計看起來有點怪——<strong>語意上有所重複</strong>。這主要是<strong>目前的情境太過簡單</strong>造成的。所以我們<strong>先取消一級路由的前綴</strong>，改為：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;post.urls&#x27;</span>)),  <span class="comment"># 將前綴去掉</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>讓取得所有文章的 path 變成<code>/posts/</code>，看起來更加自然。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 的第 9 篇、&lt;a href=&quot;/series/#Django-REST-framework-%E6%95%99%E5%AD%B8&quot;&gt;DRF 系列&lt;/a&gt;的第 3 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;本文相關的程式碼改動，都集中在這個 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial/pull/4&quot;&gt;PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/5.0/topics/http/views/&quot;&gt;Views&lt;/a&gt; 是 Django 中&lt;strong&gt;處理 HTTP 請求的核心邏輯&lt;/strong&gt;。它的作用是接收請求、處理請求，最後返回 response：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;view function&lt;/strong&gt;, or view for short, is a Python function that takes a web request and returns a web response.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Django 中，我們可以使用兩種方式來撰寫 views：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Function-Based Views（FBV），其實就是一個 Python 函式，也是 Django 預設的 view 寫法，所以又稱 &lt;strong&gt;view 函式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/5.0/topics/class-based-views/&quot;&gt;Class-Based Views&lt;/a&gt;（CBV）。CBV 是 Django 1.3 版本引入的，它是基於類別的 view 寫法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;CBV-與-FBV&quot;&gt;&lt;a href=&quot;#CBV-與-FBV&quot; class=&quot;headerlink&quot; title=&quot;CBV 與 FBV&quot;&gt;&lt;/a&gt;CBV 與 FBV&lt;/h2&gt;&lt;p&gt;「&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10205779&quot;&gt;CBV vs. FBV&lt;/a&gt;」是初學 Django 一個常見的議題。如系列的&lt;a href=&quot;/django-rest-framework-01/#CBV-vs-FBV&quot;&gt;第一篇&lt;/a&gt;所言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CBV 有著&lt;strong&gt;重用程式碼&lt;/strong&gt;優勢，適合大型專案。而 FBV 則以&lt;strong&gt;簡單、直接&lt;/strong&gt;為賣點，方便快速開發中小型專案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;究竟要選哪個，取決於個人喜好與專案需求。&lt;/p&gt;
&lt;p&gt;Django REST framework（以下簡稱 DRF）同時支援這兩種 views。&lt;/p&gt;
&lt;p&gt;事實上，DRF 顯然&lt;strong&gt;更加鼓勵使用 CBV&lt;/strong&gt;，不僅提供了許多現成的 &lt;a href=&quot;https://www.django-rest-framework.org/api-guide/generic-views/&quot;&gt;generic views&lt;/a&gt;，它的很多元件也是基於 CBV 設計的。&lt;/p&gt;
&lt;p&gt;不過，本文只打算介紹 DRF 中的 FBV，並實作一個 DRF view function。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="Django REST framework" scheme="https://blog.kyomind.tw/tags/Django-REST-framework/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>Python type checker：Mypy 介紹</title>
    <link href="https://blog.kyomind.tw/mypy/"/>
    <id>https://blog.kyomind.tw/mypy/</id>
    <published>2024-06-28T03:02:23.000Z</published>
    <updated>2024-06-30T13:43:52.087Z</updated>
    
    <content type="html"><![CDATA[<!-- ![picture 0](https://i.imgur.com/Eps34hb.jpeg) --><!-- ![](https://i.imgur.com/VXSLiC6.png) --><!-- ![by Koma Zhang](https://i.imgur.com/rnvlF18.jpg) --><p><img src="https://i.imgur.com/VhSp2Jb.png"></p><p>在〈<a href="/robust-python-01/">《強健的 Python》筆記（一）Type Hints 的成本與挑戰</a>〉一文中，我們闡述了為 Python 專案程式碼加上 type hints 的<strong>長期價值</strong>與<strong>需要付出的成本</strong>。</p><p>文中多次提到了 <a href="https://github.com/python/mypy">Mypy</a> 這個<strong>靜態類型檢查器</strong>。</p><p>本文從<strong>歷史發展</strong>、工作原理與工具的<strong>整體輪廓</strong>上介紹 Mypy 的特色，</p><p>雖然沒有詳細的 Mypy 使用教學，但<strong>更了解 Mypy，可能讓你對 Python 的型別檢查產生不同的看法。</strong></p><p>老實說，我覺得 Mypy 不太需要學習，只要引入一些設定就好。這部分我們會在下一篇文章中介紹。</p><p>最後，我會分享一些使用 Mypy 時的心得與經驗。</p><p>如果看過開頭那篇文章，你可能會認同：<strong>我們終將要成為 Python type hints 的信徒</strong>。而 Mypy 就是最佳的布道者。</p><hr><h2 id="為什麼需要-Mypy"><a href="#為什麼需要-Mypy" class="headerlink" title="為什麼需要 Mypy"></a>為什麼需要 Mypy</h2><p>Python 是一門廣受歡迎的「<a href="https://www.ithome.com.tw/voice/87841">動態定型</a>」程式語言，以其簡潔的語法和靈活性著稱。</p><p>然而，這種<strong>靈活性</strong>有時也會成為<strong>問題</strong>，特別是在大型專案中，型別錯誤可能會導致難以追蹤的 bug，從而降低程式碼的可靠性和可維護性。</p><p>在這樣的背景下，Mypy 應運而生。</p><span id="more"></span><h2 id="Mypy-介紹"><a href="#Mypy-介紹" class="headerlink" title="Mypy 介紹"></a>Mypy 介紹</h2><p>Mypy 是由 <a href="https://github.com/JukkaL">Jukka Lehtosalo</a> 開發的一個開源專案，它是一個<strong>靜態類型檢查工具</strong>，旨在通過閱讀 Python 程式碼中的<strong>型別註解（type hints、type annotations）</strong>來提供完善的型別檢查。及早發現類型錯誤，從而提高程式碼品質。</p><h3 id="Mypy-的歷史發展"><a href="#Mypy-的歷史發展" class="headerlink" title="Mypy 的歷史發展"></a>Mypy 的歷史發展</h3><p>Mypy 的開發歷史可以追溯到 2012 年，當時 Jukka Lehtosalo 在他的博士論文中首次提出了這個想法。</p><p>隨著專案的發展，Python 之父 Guido van Rossum 也對此<strong>表示支援</strong>——可參考良葛格的〈<a href="https://www.ithome.com.tw/voice/116983">Type Hints的野心</a>〉一文。並在 2014 年共同提出了 <a href="https://peps.python.org/pep-0484/">PEP 484</a>，該 PEP 正式將型別註解引入了 Python 語言標準，並在 Python 3.5 中實現。</p><p>沒錯，Mypy 的存在甚至比 Python 3.5 <strong>更早</strong>。由此可知，Mypy 才是 Python type hints 的<strong>催生人</strong>😎</p><h2 id="Mypy-的工作原理"><a href="#Mypy-的工作原理" class="headerlink" title="Mypy 的工作原理"></a>Mypy 的工作原理</h2><p>Mypy 的工作原理非常簡單：在開發者新增型別註解後，Mypy 會在檢查過程中<strong>閱讀這些註解</strong>，並根據註解所描述的類型來判斷程式碼是否正確。</p><p>這樣一來，很多在運行時才會暴露的錯誤，可以在開發階段就被捕捉到。</p><p>使用 Mypy 的主要好處包括：</p><ul><li><strong>提高程式碼的穩定性和可靠性</strong>：通過及早發現類型錯誤，可以避免很多運行時才會出現的 bug。</li><li><strong>增強程式碼的可讀性</strong>：型別註解可以<strong>作為文件的一部分</strong>，使程式碼的用途和預期行為更加清晰。</li><li><strong>提升團隊合作效率</strong>：當多個開發者協作時，型別註解可以幫助大家保持一致的理解和程式碼風格。</li></ul><hr><h2 id="其他類型檢查器"><a href="#其他類型檢查器" class="headerlink" title="其他類型檢查器"></a>其他類型檢查器</h2><p>對我而言，Mypy 是型別檢查時的<strong>首選</strong>，因為它最親民，意思是它檢查時最「寬容」，所以<strong>最容易上手。</strong></p><p>但也有其他類型檢查器可供選擇，這裡只介紹最常見的幾個：</p><table><thead><tr><th>工具</th><th>描述</th><th>優點</th><th>缺點</th></tr></thead><tbody><tr><td><a href="https://github.com/microsoft/pyright">Pyright</a></td><td>由 Microsoft 開發的一個高效能、功能強大的靜態類型檢查工具，<strong>特別適合大型專案。</strong></td><td><strong>直接整合 VSCode</strong>、支援 TypeScript 類型系統</td><td>社區支持相對較少</td></tr><tr><td><a href="https://github.com/facebook/pyre-check">Pyre</a></td><td>由 Facebook 開發的靜態類型檢查工具，強調高效能和高準確性的類型檢查。</td><td>檢查速度快、精確度高</td><td>設定較為複雜，學習曲線較陡</td></tr><tr><td><a href="https://github.com/google/pytype">Pytype</a></td><td>由 Google 開發的靜態類型檢查工具，支持<strong>自動類型推斷</strong>和錯誤檢查。</td><td>自動推斷類型</td><td>設定和使用相對複雜</td></tr></tbody></table><p>它們剛好都是由各個巨頭公司開發的XD</p><p>其中值得一提的是 VS Code 中 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance">Pylance</a> 套件，它採用的正是 Pyright，你可以在編輯器中<strong>直接開啟</strong>它的型別檢查功能。</p><p>不過它的嚴格程度比 Mypy 還要高，要完全遵守真的很累（難怪說它適合大型專案），所以我還是比較喜歡 Mypy。</p><hr><h2 id="我的-Mypy-經驗與心得"><a href="#我的-Mypy-經驗與心得" class="headerlink" title="我的 Mypy 經驗與心得"></a>我的 Mypy 經驗與心得</h2><p>從今年 3 月開始寫 Django Ninja 而認真導入 Mypy 至今，我覺得它對於<strong>發現潛在錯誤</strong>非常有幫助。</p><p>這無疑是<strong>靜態類型檢查</strong>的魅力所在：幫助你在開發過程中<strong>提前發現問題</strong>。</p><p>它甚至會<strong>強迫</strong>你寫出<strong>更好、意圖更清晰的程式碼</strong>，因為你<strong>不得不思考變數的型別</strong>，無法再像以前那樣隨心所欲。</p><p>當然，為專案程式碼加上 type hints，會增加一定的工作量。但從獲得的收益，兩相權衡，我認為<strong>很值得</strong>。</p><p>尤其要<strong>特別強調一點</strong>：預設的 Mypy 其實<strong>非常寬容</strong>，你可以<strong>慢慢地</strong>導入它，不用一下子就把大部分程式碼都加上 type hints。</p><p>我想這也正是 Python type hints 的<strong>核心精神：取你所需，不必非黑即白。</strong></p>]]></content>
    
    
    <summary type="html">&lt;!-- ![picture 0](https://i.imgur.com/Eps34hb.jpeg) --&gt;
&lt;!-- ![](https://i.imgur.com/VXSLiC6.png) --&gt;
&lt;!-- ![by Koma Zhang](https://i.imgur.com/rnvlF18.jpg) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VhSp2Jb.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;/robust-python-01/&quot;&gt;《強健的 Python》筆記（一）Type Hints 的成本與挑戰&lt;/a&gt;〉一文中，我們闡述了為 Python 專案程式碼加上 type hints 的&lt;strong&gt;長期價值&lt;/strong&gt;與&lt;strong&gt;需要付出的成本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;文中多次提到了 &lt;a href=&quot;https://github.com/python/mypy&quot;&gt;Mypy&lt;/a&gt; 這個&lt;strong&gt;靜態類型檢查器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文從&lt;strong&gt;歷史發展&lt;/strong&gt;、工作原理與工具的&lt;strong&gt;整體輪廓&lt;/strong&gt;上介紹 Mypy 的特色，&lt;/p&gt;
&lt;p&gt;雖然沒有詳細的 Mypy 使用教學，但&lt;strong&gt;更了解 Mypy，可能讓你對 Python 的型別檢查產生不同的看法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老實說，我覺得 Mypy 不太需要學習，只要引入一些設定就好。這部分我們會在下一篇文章中介紹。&lt;/p&gt;
&lt;p&gt;最後，我會分享一些使用 Mypy 時的心得與經驗。&lt;/p&gt;
&lt;p&gt;如果看過開頭那篇文章，你可能會認同：&lt;strong&gt;我們終將要成為 Python type hints 的信徒&lt;/strong&gt;。而 Mypy 就是最佳的布道者。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;為什麼需要-Mypy&quot;&gt;&lt;a href=&quot;#為什麼需要-Mypy&quot; class=&quot;headerlink&quot; title=&quot;為什麼需要 Mypy&quot;&gt;&lt;/a&gt;為什麼需要 Mypy&lt;/h2&gt;&lt;p&gt;Python 是一門廣受歡迎的「&lt;a href=&quot;https://www.ithome.com.tw/voice/87841&quot;&gt;動態定型&lt;/a&gt;」程式語言，以其簡潔的語法和靈活性著稱。&lt;/p&gt;
&lt;p&gt;然而，這種&lt;strong&gt;靈活性&lt;/strong&gt;有時也會成為&lt;strong&gt;問題&lt;/strong&gt;，特別是在大型專案中，型別錯誤可能會導致難以追蹤的 bug，從而降低程式碼的可靠性和可維護性。&lt;/p&gt;
&lt;p&gt;在這樣的背景下，Mypy 應運而生。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/rnvlF18.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Type Hints" scheme="https://blog.kyomind.tw/tags/Type-Hints/"/>
    
    <category term="Mypy" scheme="https://blog.kyomind.tw/tags/Mypy/"/>
    
  </entry>
  
  <entry>
    <title>32，下半年寫作目標</title>
    <link href="https://blog.kyomind.tw/weekly-review-32/"/>
    <id>https://blog.kyomind.tw/weekly-review-32/</id>
    <published>2024-06-21T14:50:45.000Z</published>
    <updated>2024-07-06T10:24:07.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>在〈<a href="/keyboard-shortcuts/">現代軟體的「鍵盤快捷鍵」記憶爭奪戰</a>〉一文的留言中，有讀者提到我最近似乎變多產了。</p><p>確實如此。</p><p>有人注意到這件事，讓我非常高興XD，甚至可以說感動。</p><p>而本文斗膽預告：下半年將會比上半年，更加多產🔥</p><hr><p>我通常不太想為自己立 flag，預告也屬於此類。尤其有〈<a href="/weekly-review-24/">24，收回「發文計畫」</a>〉的前車之鑑，心裡難免會暗暗擔憂：「是不是說出來就會更容易失敗？」</p><p>當然，我知道實際並非如此——很多事做不做，成不成，終究還是操之在己。</p><p>至少寫作是這樣的。</p><h3 id="三個寫作方向"><a href="#三個寫作方向" class="headerlink" title="三個寫作方向"></a>三個寫作方向</h3><p>這篇來聊聊我今年下半年的<strong>寫作目標</strong>，主要有<strong>三大方向</strong>。</p><p>看完這三個方向，想必你就能理解，為何說一定會比上半年更多產。</p><p>換言之，如果真的都能達成，多產只是必然的結果。</p><span id="more"></span><h2 id="一、Django-Tutorial"><a href="#一、Django-Tutorial" class="headerlink" title="一、Django Tutorial"></a>一、Django Tutorial</h2><p><a href="/tags/Django-Tutorial/">Django Tutorial</a> 目前出到第 8 篇了。</p><p>看一下上面的文章清單，其中一半都是這兩個月寫的！而第 1 篇，已經是近 1 年前的事了！</p><p>最近 2 個月我開始認真創作本系列。</p><p>因為想用 <a href="https://github.com/kyomind/Django-Tutorial">Django-Tutorial</a> 作為範例程式碼專案，所以有些和 Django 沒有直接關係，但可以用同一個 repo 來示範的文章，寫作上都被這個系列卡住了XD。</p><p>比如「專案容器化」或「Poetry 多階段建構 image」，都需要這個專案有一定的雛形才會更有感！</p><p>而且我現在文章和 <a href="https://github.com/kyomind/Django-Tutorial/pull/2">PR</a>（範例程式碼改動）都是同時發，不太想用「先寫文章以後再補 code」的方式創作。</p><p>所以要加把勁寫 Django Tutorial（主要是 <a href="/series/#Django-REST-framework-%E6%95%99%E5%AD%B8">Django REST framework 系列</a>）。</p><h2 id="二、參加-iThome-鐵人賽"><a href="#二、參加-iThome-鐵人賽" class="headerlink" title="二、參加 iThome 鐵人賽"></a>二、參加 iThome 鐵人賽</h2><p>很多開發者都想過要參加<a href="https://ithelp.ithome.com.tw/2023ironman/event">鐵人賽</a>，我當然也不例外。想了好幾年了，但真正付諸行動並不容易。</p><p>首先要有合適的主題，我覺得「<strong>不大不小</strong>」的主題是最適合的。主題太大，不好下筆不說，可能已經有很多人寫過了，比如 Python 相關，需要自己再細分範疇。</p><p>其次，投入的心力更是不言而喻。</p><p>鐵人賽對我的額外挑戰之處在於——我太喜歡「修改」文章了。寫作時，很多心力都花在了「不算刀口的刀口」上。</p><p>而參加這種<strong>和時間賽跑</strong>的比賽（雖然可以提前備稿），<strong>我必須控制自己的改稿欲。</strong></p><h3 id="完賽優先"><a href="#完賽優先" class="headerlink" title="完賽優先"></a>完賽優先</h3><p>因此，我說服自己，以「<strong>完賽</strong>」為最高準則XD</p><p>嚴格控制每一篇的字數、篇幅，先壓抑想修改文章的欲望——我可以等比賽結束後，在我自己的 blog 上，想怎麼改就怎麼改。</p><p>對我而言，這算是一個小型專案了，且讓我們拭目以待。</p><p>當然，提前備稿一定是要的😎</p><h2 id="三、「告別法律，我的程式轉職之路」系列"><a href="#三、「告別法律，我的程式轉職之路」系列" class="headerlink" title="三、「告別法律，我的程式轉職之路」系列"></a>三、「告別法律，我的程式轉職之路」系列</h2><p>多年前，剛轉職不久，我在 Medium 寫過一篇〈<a href="https://medium.com/code-and-me/%E6%B3%95%E5%BE%8B%E4%BA%BA%E5%88%B0%E5%B7%A5%E7%A8%8B%E5%B8%AB-%E6%88%91%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%BD%89%E8%81%B7%E4%B9%8B%E8%B7%AF-%E4%B8%80-%E5%89%8D%E8%A8%80%E7%AF%87-441a11089913">法律人到工程師，我的程式轉職之路（一）：前言篇</a>〉。然後，就沒有然後了😂</p><p>沒寫下去的原因很多，不過追根究柢，還是「創作方向」讓我<strong>缺乏動力。</strong></p><p>本來打算寫成「教你怎麼成功轉職軟體工程師」這類的文章。</p><p>而無心繼續，一方面是覺得自己成為軟體工程師後的起步實在稱不上順遂，嚴重影響「相信自己可以給後進者建議」的信心XD。</p><p>二是此後幾年，成功轉職軟體工程師的人數大增，所以也不值一提了。</p><h3 id="新的創作方向"><a href="#新的創作方向" class="headerlink" title="新的創作方向"></a>新的創作方向</h3><p>所以，這次我要換一個方向寫——以「<strong>記錄自己某一段人生經歷及當時的內心狀態</strong>」為目的。</p><p>因為現在的我，仍不時會想起，準備轉職的那段時光。如果能在此時此刻，趁著記憶還不算太久遠，寫下更多關於當時的心情。</p><p>相信 10 年後的我，會覺得欣慰與感激。</p><p>預計分成 4 篇：</p><ol><li>公務員篇。</li><li>律師國考篇。</li><li>資策會篇。</li><li>自學篇。</li></ol><p>可以看出，前兩篇講的都是我<strong>接觸程式之前</strong>的事。那時的我，自然不可能料到，後面將發生的一切。這也是人生的有趣之處。</p><p>這個系列需要等 11 月，鐵人賽結束後，才能正式開始創作，預計花費 2、3 個月寫完這 4 篇。</p><hr><h2 id="非技術類文章？"><a href="#非技術類文章？" class="headerlink" title="非技術類文章？"></a>非技術類文章？</h2><p>前兩部分是和「程式、技術」相關的主題，而第三部分則要等到鐵人賽後。</p><p>那非技術類文章還發嗎？</p><p><a href="/weekly-review-30/#%E4%BA%8C%E3%80%81%E5%B0%88%E6%A5%AD%E5%85%A7%E5%AE%B9%E8%88%87%E5%80%8B%E4%BA%BA%E5%BF%83%E5%BE%97%E4%BA%A4%E9%8C%AF">之前提過</a>，我很難一直寫程式類內容，因為心理上容易疲勞。所以當然會繼續寫非技術文章——主要發表在 <a href="https://blog.kyomind.tw/categories/Weekly-Review/">Weekly Review</a>。</p><p>創作 Weekly Review 的感受，和其它文章很不一樣，是我<strong>心靈上的避風港</strong>。</p><p>寫累了，就回到這裡，休息一日，整裝待發。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;/keyboard-shortcuts/&quot;&gt;現代軟體的「鍵盤快捷鍵」記憶爭奪戰&lt;/a&gt;〉一文的留言中，有讀者提到我最近似乎變多產了。&lt;/p&gt;
&lt;p&gt;確實如此。&lt;/p&gt;
&lt;p&gt;有人注意到這件事，讓我非常高興XD，甚至可以說感動。&lt;/p&gt;
&lt;p&gt;而本文斗膽預告：下半年將會比上半年，更加多產🔥&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我通常不太想為自己立 flag，預告也屬於此類。尤其有〈&lt;a href=&quot;/weekly-review-24/&quot;&gt;24，收回「發文計畫」&lt;/a&gt;〉的前車之鑑，心裡難免會暗暗擔憂：「是不是說出來就會更容易失敗？」&lt;/p&gt;
&lt;p&gt;當然，我知道實際並非如此——很多事做不做，成不成，終究還是操之在己。&lt;/p&gt;
&lt;p&gt;至少寫作是這樣的。&lt;/p&gt;
&lt;h3 id=&quot;三個寫作方向&quot;&gt;&lt;a href=&quot;#三個寫作方向&quot; class=&quot;headerlink&quot; title=&quot;三個寫作方向&quot;&gt;&lt;/a&gt;三個寫作方向&lt;/h3&gt;&lt;p&gt;這篇來聊聊我今年下半年的&lt;strong&gt;寫作目標&lt;/strong&gt;，主要有&lt;strong&gt;三大方向&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看完這三個方向，想必你就能理解，為何說一定會比上半年更多產。&lt;/p&gt;
&lt;p&gt;換言之，如果真的都能達成，多產只是必然的結果。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（下）關聯查詢</title>
    <link href="https://blog.kyomind.tw/django-orm-query-relations/"/>
    <id>https://blog.kyomind.tw/django-orm-query-relations/</id>
    <published>2024-06-15T09:51:00.000Z</published>
    <updated>2024-06-23T16:38:37.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 的第 8 篇、<a href="/series/#Django-ORM-%E5%A4%96%E9%8D%B5%E6%95%99%E5%AD%B8">Django ORM 外鍵教學</a>的第 3 篇——完結篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="/django/">Django 文章總覽</a>」。</p><h3 id="系列：Django-ORM-外鍵教學"><a href="#系列：Django-ORM-外鍵教學" class="headerlink" title="系列：Django ORM 外鍵教學"></a>系列：Django ORM 外鍵教學</h3><blockquote><ol><li><a href="/django-models/">Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</a></li><li><a href="/reverse-relationships/">Django ORM：一對一、一對多外鍵教學（中）反向關聯</a></li><li><strong>Django ORM：一對一、一對多外鍵教學（下）關聯查詢</strong></li></ol></blockquote><hr><p>經過前 2 篇的鋪墊，我們可以真正開始感受，使用 ORM 來<strong>查詢 db 關聯物件</strong>的方便與直觀之美。</p><p>開始前，我們要先匯入範例資料，方式請參考〈<a href="/django-fixtures/">用 Django Fixture 匯入與導出資料</a>〉介紹的 Django fixture 與資料內容。</p><p>打開<a href="https://github.com/kyomind/Django-Tutorial">範例專案</a>，cd 至專案根目錄，並使用指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py loaddata post_data.json</span><br></pre></td></tr></table></figure><p>好，現在我們的 db 已經有資料了。</p><p>如果你已經不記得具體有哪些 table、它們代表什麼，可參考第一篇的<a href="/django-models/#%E5%B0%88%E6%A1%88%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%B4%B9">模型介紹</a>，以及第二篇<a href="/reverse-relationships/#%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%A8%A1%E5%9E%8B%E8%AA%BF%E6%95%B4">對模型架構的調整</a>，或直接觀看 <a href="https://github.com/kyomind/Django-Tutorial/blob/main/post/models.py">models.py</a> 原始碼。</p><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文只專注介紹 Django ORM 中的<strong>外鍵關聯查詢</strong>。</p><p>畢竟 Django ORM 的查詢語法實在太多了，很多時候都要回去看文件。</p><p>而其中關聯查詢特別常用，值得我們專門學習，熟練掌握。</p><span id="more"></span><h2 id="範例資料簡介"><a href="#範例資料簡介" class="headerlink" title="範例資料簡介"></a>範例資料簡介</h2><p>目前 db 中有 3 個 table，範例資料是由這段程式碼所建立：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> post.models <span class="keyword">import</span> Post, Subtitle, Comment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Post</span></span><br><span class="line">post1 = Post.objects.create(title=<span class="string">&quot;Django Fixtures&quot;</span>, content=<span class="string">&quot;Content of Django Fixtures&quot;</span>)</span><br><span class="line">post2 = Post.objects.create(title=<span class="string">&quot;ORM Basics&quot;</span>, content=<span class="string">&quot;Content of ORM Basics&quot;</span>)</span><br><span class="line">post3 = Post.objects.create(title=<span class="string">&quot;Advanced Queries&quot;</span>, content=<span class="string">&quot;Content of Advanced Queries&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Subtitle</span></span><br><span class="line">subtitle1 = Subtitle.objects.create(content=<span class="string">&quot;An Overview&quot;</span>, post=post1)</span><br><span class="line">subtitle2 = Subtitle.objects.create(content=<span class="string">&quot;Introduction to ORM&quot;</span>, post=post2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Comment</span></span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Great article!&quot;</span>, post=post1)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Very informative.&quot;</span>, post=post2)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Helped a lot!&quot;</span>, post=post3)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Need more examples.&quot;</span>, post=post3)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Thanks for the tips!&quot;</span>, post=post3)</span><br></pre></td></tr></table></figure><h3 id="範例設計"><a href="#範例設計" class="headerlink" title="範例設計"></a>範例設計</h3><p>如你所見，總共有 3 篇文章，其中 2 篇有副標題。這些文章共計有 5 篇留言，分屬於不同的文章。</p><p>為了確保教學內容聚焦在「外鍵關聯查詢」本身，我設計的範例資料<strong>相對單純，且筆數很少</strong>。以免你光要看懂範例資料就花掉好些時間。</p><p>不過它們依舊很有代表性！</p><p>這些 db 實例覆蓋了以下幾個重要的場景：</p><ol><li><strong>多個文章（Post）實例</strong>，每個文章有不同的標題和內容。</li><li><strong>文章和副標題（Subtitle）的一對一關聯</strong>，其中有文章有副標題，有的沒有，這可以用來展示一對一關聯的查詢。以及「關聯不存在」的情況。</li><li><strong>文章和留言（Comment）的一對多關聯</strong>，每個文章有不同數量的留言，這可以用來展示外鍵關聯的查詢。</li></ol><hr><h2 id="使用-進行-Django-ORM-查詢"><a href="#使用-進行-Django-ORM-查詢" class="headerlink" title="使用__進行 Django ORM 查詢"></a>使用<code>__</code>進行 Django ORM 查詢</h2><p>開始學習前，還有另一件重要的事要提醒。</p><p>Django ORM 會大量使用雙底線（<code>__</code>）進行查詢。因此，你的 Django 模型欄位名稱<strong>不可以有雙底線</strong>。</p><p>而這些查詢主要分為<strong>兩大類。</strong></p><h3 id="一、以特定條件查詢欄位"><a href="#一、以特定條件查詢欄位" class="headerlink" title="一、以特定條件查詢欄位"></a>一、以特定條件查詢欄位</h3><p>利用雙底線來指定欄位的<strong>查詢條件</strong>，例如等於、不等於、大於、小於等。</p><p>常見的查詢條件有：<code>__exact</code>、<code>__iexact</code>、<code>__contains</code>、<code>__icontains</code>、<code>__gt</code>（大於）、<code>__gte</code>（大於等於）、<code>__lt</code>（小於）、<code>__lte</code>（小於等於）、<code>__in</code>、<code>__isnull</code> 等。</p><p>實例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢標題包含 &#x27;Python&#x27; 的文章，不區分大小寫</span></span><br><span class="line">Post.objects.<span class="built_in">filter</span>(title__icontains=<span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="二、外鍵關聯查詢"><a href="#二、外鍵關聯查詢" class="headerlink" title="二、外鍵關聯查詢"></a>二、外鍵關聯查詢</h3><p>外鍵關聯查詢，就是「跨 table」的查詢。只用一次查詢，就能同時對兩個 table 進行條件過濾並獲得結果。</p><p>此時的雙底線，代表的是外鍵欄位的<strong>屬性</strong>。比如<code>post</code>是<code>Comment</code>的外鍵欄位，而<code>post__title</code>指的是<code>Post</code>的<code>title</code>欄位。</p><p>接來就用這些資料，示範常見的外鍵關聯查詢。</p><p>附帶一提，第二篇使用<strong>反向關聯欄位</strong>的方式，也可以算是外鍵關聯查詢的一種。</p><hr><p>了解雙底線的兩大用途後，<strong>才不會混淆查詢條件和關聯查詢。</strong></p><p>以下例子不算複雜，<strong>但也未必很簡單</strong>。畢竟我們要展示的是「關聯查詢」，而不是單純的查詢。</p><p>第二篇介紹的「<strong>反向關聯</strong>」，是必須熟悉的內容。因為前兩個例子都與反向關聯有關。</p><p>讓我們開始吧！</p><h2 id="一、查詢「有副標題」的文章"><a href="#一、查詢「有副標題」的文章" class="headerlink" title="一、查詢「有副標題」的文章"></a>一、查詢「有副標題」的文章</h2><p>文章有副標題，代表文章和副標題之間「存在」一對一關聯。</p><p>這裡的重點：我們可以用<code>isnull</code>作為查詢條件，判斷「<strong>關聯是否存在</strong>」。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> post.models <span class="keyword">import</span> Post</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢所有「有副標題」的文章</span></span><br><span class="line">posts_with_subtitle = Post.objects.<span class="built_in">filter</span>(</span><br><span class="line">    subtitle__isnull=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>subtitle</code>是<code>Post</code>的一對一<strong>反向關聯欄位</strong>，查詢方式是<code>subtitle__isnull</code>。</p><p>值得注意的是，如果<code>subtitle</code>是<strong>普通欄位</strong>或<strong>正向關聯欄位</strong>，那相同寫法的查詢效果，將<strong>截然不同</strong>——會變成限制欄位值是否為<code>None</code>。</p><p>當然，正向關聯欄位的值若為<code>None</code>，也是代表（正向）關聯不存在。不過這與<strong>反向關聯不存在</strong>，本質上仍有所區別。</p><p>查詢結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>posts_with_subtitles</span><br><span class="line">&lt;QuerySet [<span class="string">&#x27;Django Fixtures&#x27;</span>, <span class="string">&#x27;ORM Basics&#x27;</span>]&gt;</span><br></pre></td></tr></table></figure><p>簡言之，<code>isnull</code><strong>很常用來查詢「關聯是否存在」</strong>，這在外鍵關聯查詢中非常實用。</p><h2 id="二、查詢留言中有「Thanks」一詞的文章"><a href="#二、查詢留言中有「Thanks」一詞的文章" class="headerlink" title="二、查詢留言中有「Thanks」一詞的文章"></a>二、查詢留言中有「Thanks」一詞的文章</h2><p>以「反向關聯欄位」進行查詢，我們來看<strong>第二種情況</strong>。</p><p>查詢留言中包括特定字詞，比如「Thanks」的文章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">posts_with_thankful_comments = Post.objects.<span class="built_in">filter</span>(</span><br><span class="line">    comments__content__icontains=<span class="string">&#x27;Thanks&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>comments</code>是<code>Post</code>的反向關聯屬性，和前面的<code>subtitle</code>類似。只不過這裡是<strong>一對多</strong>關聯。</p><p>這裡的重點是，<code>related_name</code> 不僅可以用來訪問 <code>post.comments</code>，也可以直接用在查詢中，就像上面寫的那樣。</p><p>因為它也是一個外鍵關聯屬性——<strong>反向關聯屬性</strong>。</p><p>查詢結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>posts_with_thankful_comments</span><br><span class="line">&lt;QuerySet [&lt;Post: &lt;<span class="number">3</span>&gt;: Advanced Queries&gt;]&gt;</span><br></pre></td></tr></table></figure><h2 id="三、查詢-id-為-1-的文章留言數"><a href="#三、查詢-id-為-1-的文章留言數" class="headerlink" title="三、查詢 id 為 1 的文章留言數"></a>三、查詢 id 為 1 的文章留言數</h2><p>無論是一對一或一對多，當查詢對象是外鍵關聯欄位時，可以直接以<code>__</code>查詢並過濾該<strong>外鍵欄位「值」</strong>（即<strong>另一個 db 實例</strong>）<strong>所擁有</strong>的欄位名稱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> post.models <span class="keyword">import</span> Comment</span><br><span class="line"></span><br><span class="line">comment_count = Comment.objects.<span class="built_in">filter</span>(post__id=<span class="number">1</span>).count()</span><br></pre></td></tr></table></figure><p><code>Comment</code>有一個<strong>外鍵欄位</strong>為<code>post</code>，指向一個<code>Post</code>實例。我們可以直接使用<code>__</code>，以 <code>Post</code>自己的屬性——本例中為<code>id</code>，作為查詢條件。</p><p>查詢結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment_count</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>這種以「<strong>正向關聯</strong>欄位」的屬性（比如<code>post</code>的屬性<code>id</code>）作為條件的查詢，佔了關聯查詢需求的<strong>很大一部分</strong>。</p><h2 id="查詢外鍵-Primary-Key-的不同變體"><a href="#查詢外鍵-Primary-Key-的不同變體" class="headerlink" title="查詢外鍵 Primary Key 的不同變體"></a>查詢外鍵 Primary Key 的不同變體</h2><p>上述的<code>id</code>是外鍵<code>post</code>的主鍵（Primary Key），用<code>id</code>查詢的情況很常見。</p><p>因此，用外鍵的主鍵（Primary Key）欄位查詢時，Django 幫你準備了<strong>多種寫法</strong>。以下寫法效果皆相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 post__id 原來的寫法</span></span><br><span class="line">comments_count = Comment.objects.<span class="built_in">filter</span>(post__id=<span class="number">1</span>).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 post_id</span></span><br><span class="line">comments_count = Comment.objects.<span class="built_in">filter</span>(post_id=<span class="number">1</span>).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 post__pk</span></span><br><span class="line">comments_count = Comment.objects.<span class="built_in">filter</span>(post__pk=<span class="number">1</span>).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用直接使用物件查詢</span></span><br><span class="line">post = Post.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">comments_count = Comment.objects.<span class="built_in">filter</span>(post=post).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你甚至可以這樣寫！</span></span><br><span class="line">comments_count = Comment.objects.<span class="built_in">filter</span>(post=<span class="number">1</span>).count()</span><br></pre></td></tr></table></figure><p>Django 會自動為外鍵加上<code>_id</code>，代表<strong>該外鍵的主鍵</strong>，命名模式為<code>&lt;外鍵名稱&gt;_id</code>。且<strong>無論該外鍵欄位主鍵名稱是什麼</strong>，都可以使用這種寫法。</p><p>同理，<code>post__pk</code>也是類似效果，它們都算是一種<strong>欄位別名</strong>。</p><p>雖然用別名的寫法讓人感覺更加「道地」、更像內行人。但如果想保守起見，還是使用<code>post__id</code>比較好。因為這種寫法<strong>最直觀</strong>，而且<strong>適用於所有欄位。</strong></p><p>我個人認為，不用別名也沒關係，<strong>explicit 至上。</strong></p><h3 id="何時使用哪種寫法？"><a href="#何時使用哪種寫法？" class="headerlink" title="何時使用哪種寫法？"></a>何時使用哪種寫法？</h3><p>Django 入門者最常使用的是第 4 種，它很好懂，因為欄位值正是一個 db 物件！</p><p>然而，它需要程式碼上下文中，先有一個<code>post</code>物件。如果沒有，就要像上面寫的，先透過查詢取得<code>post</code>物件——<strong>這會增加一次 db 查詢。</strong></p><p>如果當前上下文只有<code>post</code>的 id，強烈建議使用前 3 種寫法（個人推薦第 1 種），以減少不必要的查詢負擔。</p><p>第 5 種寫法雖然也「很 Django」，但很多人不熟悉，所以我不敢輕易採用。</p><h2 id="四、查詢標題有「Django」的所有留言"><a href="#四、查詢標題有「Django」的所有留言" class="headerlink" title="四、查詢標題有「Django」的所有留言"></a>四、查詢標題有「Django」的所有留言</h2><p>上面「三」是用 id 查詢，這裡改用<strong>特定字詞</strong>查詢。</p><p>而且，不是直接查詢標題中包含「Django」的文章（這和外鍵查詢無關），而是文章標題中包括 Django 的<strong>所有留言</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comments_for_django_posts = Comment.objects.<span class="built_in">filter</span>(</span><br><span class="line">    post__title__icontains=<span class="string">&#x27;Django&#x27;</span>)</span><br></pre></td></tr></table></figure><p>「<a href="/django-orm-query-relations/#%E4%BA%8C%E3%80%81%E6%9F%A5%E8%A9%A2%E7%95%99%E8%A8%80%E4%B8%AD%E6%9C%89%E3%80%8CThanks%E3%80%8D%E4%B8%80%E8%A9%9E%E7%9A%84%E6%96%87%E7%AB%A0">二</a>」的<code>comments__content__icontains</code>，和這裡的<code>post__title__icontains</code>，有一個<strong>區別</strong>——前者是<strong>反向關聯欄位</strong>，後者是<strong>正向關聯欄位</strong>。</p><p>兩者都用了經典的「<strong>兩次雙底線</strong>」查詢，即<code>post__title__icontains</code>。</p><p>這樣的語句看起來有點「<strong>抽象</strong>」，這也是為什麼我們要把雙底線查詢分成兩大類，因為它們可能會<strong>同時出現！</strong></p><p>弄清楚兩者之間的區別，才更容易明白，兩次雙底線各代表什麼查詢條件：</p><ol><li><code>post__title</code>：查詢<code>Post</code>的<code>title</code>欄位。</li><li><code>title__icontains</code>：查詢<code>title</code>欄位中包含特定字詞（不分大小寫）的文章。</li></ol><p>查詢結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>comments_for_django_posts</span><br><span class="line">&lt;QuerySet [&lt;Comment: &lt;<span class="number">1</span>&gt;: Great article!&gt;]&gt;</span><br></pre></td></tr></table></figure><h2 id="查詢結果的變數命名"><a href="#查詢結果的變數命名" class="headerlink" title="查詢結果的變數命名"></a>查詢結果的變數命名</h2><p>所有的 ORM 查詢結果的變數，只要結果是 0 到多個——也就是 QuerySet，請務必使用「複數」命名，比如<code>comments</code>、<code>posts</code>。</p><p>只有在確定「最多只會拿到一個」db 實例時，才用單數。這通常只發生在，你使用了<code>get</code>或<code>first</code>、<code>last</code>等直接回傳實例的 QuerySet 方法。</p><p>本文中的查詢結果變數命名都較為冗長，主要是為了教學上的表達。</p><p>實務中我通常不會把查詢條件一一映射到變數命名，除非該條件、特性非常重要。</p><hr><h2 id="結語：Djangonic"><a href="#結語：Djangonic" class="headerlink" title="結語：Djangonic"></a>結語：Djangonic</h2><p>本文僅涵蓋了 Django ORM 外鍵查詢的一部分，但都是經典且常用的場景，有一定的代表性。</p><p>善用這些關聯查詢的重點在於使程式碼<strong>更加直觀和優雅。</strong></p><p>如第二篇文章所述，其實這些查詢也可以「不透過」外鍵關聯查詢來實現，但可能會讓程式碼變得冗長，甚至難以理解。</p><p>熟練的 Python 開發者可以達到 Pythonic 的境界，在 Django 中也有類似 Pythonic 的術語，稱為「Djangonic」或「Djangonic way」。</p><p>這種風格強調利用 Django 的內建功能和最佳實踐，以簡化程式碼和提高可維護性。</p><p>這也是我們作為 Django 開發者的日常追求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 的第 8 篇、&lt;a href=&quot;/series/#Django-ORM-%E5%A4%96%E9%8D%B5%E6%95%99%E5%AD%B8&quot;&gt;Django ORM 外鍵教學&lt;/a&gt;的第 3 篇——完結篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;h3 id=&quot;系列：Django-ORM-外鍵教學&quot;&gt;&lt;a href=&quot;#系列：Django-ORM-外鍵教學&quot; class=&quot;headerlink&quot; title=&quot;系列：Django ORM 外鍵教學&quot;&gt;&lt;/a&gt;系列：Django ORM 外鍵教學&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/django-models/&quot;&gt;Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/reverse-relationships/&quot;&gt;Django ORM：一對一、一對多外鍵教學（中）反向關聯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django ORM：一對一、一對多外鍵教學（下）關聯查詢&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;經過前 2 篇的鋪墊，我們可以真正開始感受，使用 ORM 來&lt;strong&gt;查詢 db 關聯物件&lt;/strong&gt;的方便與直觀之美。&lt;/p&gt;
&lt;p&gt;開始前，我們要先匯入範例資料，方式請參考〈&lt;a href=&quot;/django-fixtures/&quot;&gt;用 Django Fixture 匯入與導出資料&lt;/a&gt;〉介紹的 Django fixture 與資料內容。&lt;/p&gt;
&lt;p&gt;打開&lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;範例專案&lt;/a&gt;，cd 至專案根目錄，並使用指令：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python manage.py loaddata post_data.json&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;好，現在我們的 db 已經有資料了。&lt;/p&gt;
&lt;p&gt;如果你已經不記得具體有哪些 table、它們代表什麼，可參考第一篇的&lt;a href=&quot;/django-models/#%E5%B0%88%E6%A1%88%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%B4%B9&quot;&gt;模型介紹&lt;/a&gt;，以及第二篇&lt;a href=&quot;/reverse-relationships/#%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%A8%A1%E5%9E%8B%E8%AA%BF%E6%95%B4&quot;&gt;對模型架構的調整&lt;/a&gt;，或直接觀看 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial/blob/main/post/models.py&quot;&gt;models.py&lt;/a&gt; 原始碼。&lt;/p&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;本文只專注介紹 Django ORM 中的&lt;strong&gt;外鍵關聯查詢&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;畢竟 Django ORM 的查詢語法實在太多了，很多時候都要回去看文件。&lt;/p&gt;
&lt;p&gt;而其中關聯查詢特別常用，值得我們專門學習，熟練掌握。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
    <category term="Django ORM" scheme="https://blog.kyomind.tw/tags/Django-ORM/"/>
    
  </entry>
  
  <entry>
    <title>現代軟體的「鍵盤快捷鍵」記憶爭奪戰</title>
    <link href="https://blog.kyomind.tw/keyboard-shortcuts/"/>
    <id>https://blog.kyomind.tw/keyboard-shortcuts/</id>
    <published>2024-06-09T07:51:43.000Z</published>
    <updated>2024-06-12T07:27:39.432Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>現代人每天都會用一堆軟體、app、線上服務。</p><p>其中比較複雜的工具（包括瀏覽器與作業系統），往往都有搭配「鍵盤快捷鍵」來加速你的操作。</p><p>然而，軟體很多，快捷鍵更多！<strong>究竟哪些要記、哪些可以放棄，才能降低大腦的負擔？</strong></p><p>本文簡要分享我的看法。</p><h2 id="本文所謂的快捷鍵"><a href="#本文所謂的快捷鍵" class="headerlink" title="本文所謂的快捷鍵"></a>本文所謂的快捷鍵</h2><p>首先說明，像<code>ctrl+C</code>、<code>ctrl+V</code>、<code>ctrl+B</code>、<code>ctrl+S</code>這些，已成為大家心中公認的快捷鍵設定，各大軟體廠商也幾乎不可能在設計上違背的，就不再討論範圍。</p><p>這裡講的是那些不同軟體之間<strong>特有</strong>的快捷鍵。而且也不是要討論這些快捷鍵的設計是否合理、好記。</p><p>而是要說，我<strong>如何選擇（取捨）</strong>要記得哪些、放棄哪些的思路，以及我對「記憶快捷鍵來增加效率（生產力）」的整體看法。</p><p>只是簡單的個人心得，供參。</p><span id="more"></span><hr><h2 id="鍵盤快捷鍵的優點"><a href="#鍵盤快捷鍵的優點" class="headerlink" title="鍵盤快捷鍵的優點"></a>鍵盤快捷鍵的優點</h2><p>鍵盤快捷鍵的優點在於<strong>提高工作效率</strong>，自不待言。</p><p>想像一下，你需要頻繁地複製和貼上文字，如果每次都要用滑鼠點擊右鍵、選擇複製、移動滑鼠、再點擊右鍵……，想想就累人。</p><p>通過鍵盤快捷鍵，我們可以快速完成這些操作，節省大量時間。</p><p>而且，我覺得比起身體的勞累，能有效降低「重覆機械性行為」帶來的<strong>心理疲勞與排斥感</strong>，才是快捷鍵的最大價值。</p><h2 id="快捷鍵的兩難問題"><a href="#快捷鍵的兩難問題" class="headerlink" title="快捷鍵的兩難問題"></a>快捷鍵的兩難問題</h2><p>然而，記憶這些快捷鍵並不容易。不同軟體有不同的快捷鍵，有時還<strong>相互衝突</strong>。</p><p>上古時期（20 年前），我們只有微軟 Office，所以問題不大。甚至很多人像我一樣，除了複製、貼上外，都是使用軟體 UI 上的文字編輯器，而不是快捷鍵。</p><p>但時代不同了，現在的軟體太多了！每天常用的恐怕就超過 10 個，每個都有自己的快鍵設定——而且不一定都能自定義。</p><p>記住這些快捷鍵對於大腦來說是一個<del>不小</del>巨大的負擔，特別是那些包含多個按鍵組合的快捷鍵。</p><h3 id="目前有記快捷鍵的軟體"><a href="#目前有記快捷鍵的軟體" class="headerlink" title="目前有記快捷鍵的軟體"></a>目前有記快捷鍵的軟體</h3><p>以我自己為例，常用且<strong>至少記憶一組以上</strong>快鍵捷的軟體有（<code>*</code>代表只記一、兩組）：</p><ol><li>VS Code</li><li>Notion（筆記軟體）</li><li><a href="https://logseq.com/">Logseq</a>（筆記軟體）</li><li><a href="https://bear.app/">Bear</a>（筆記軟體）</li><li><a href="https://getupnote.com/">UpNote</a>（筆記軟體，為了 Android 的同步）</li><li>Zsh（終端機 Shell）</li><li><a href="https://www.raycast.com/">Raycast</a>（主要使用 Snippets）</li><li><a href="https://rectangleapp.com/">Rectangle</a>（調整視窗大小）</li><li><a href="https://cleanshot.com/">CleanShot X</a>（截圖）</li><li><a href="https://pasteapp.io/">Paste*</a>（剪貼簿管理）</li><li><a href="https://textsniper.app/">TextSniper*</a>（OCR 文字辨識）</li><li>Google Chrome*</li><li>macOS*</li></ol><p>列出來一看，數量上確實不容小覷。</p><p>所幸和部分人相比，我還不需要使用<strong>影像處理軟體</strong>修圖、剪片等，不然真的要瘋了。</p><p>但還是讓人有點喘不過氣來。</p><hr><p>以下是我對「記憶快捷鍵」的基本思路。</p><h2 id="一、VS-Code-為王"><a href="#一、VS-Code-為王" class="headerlink" title="一、VS Code 為王"></a>一、VS Code 為王</h2><p>VS Code 是我願意投入最大心力去記憶快捷鍵的軟體工具。</p><p>原因無它——我要寫程式！而 VS Code 幾乎是我唯一的 IDE（整合開發編輯器）。</p><p>當然，VS Code 功能極多，快捷鍵是怎樣也記不完，光我常用的就超過 20 個了。但我願意，而且值得。</p><p>不僅如此，接下來我還打算寫 2 到 3 篇我常用的 VS Code 快捷鍵整理文章，因為一段時間沒用就會忘記XD</p><p>但還是那句話，我願意。記憶 VS Code 快鍵能幫我省下的時間，與增加的開發樂趣，遠遠超過其它軟體。</p><p>它是<strong>唯一</strong>的。</p><h2 id="二、筆記軟體：以-Notion、Logseq-為主"><a href="#二、筆記軟體：以-Notion、Logseq-為主" class="headerlink" title="二、筆記軟體：以 Notion、Logseq 為主"></a>二、筆記軟體：以 Notion、Logseq 為主</h2><p>Notion 作為我最早開始記憶快鍵的筆記軟體，對它的快鍵的記憶無疑是最深刻的。</p><p>後來用了 Logseq、Bear，記的快鍵就相對少了。</p><p>但我主要也只記 Notion「<code>alt+cmd+0-9</code>」 這系列的快捷鍵，因為同時要按 3 個鍵，和其它筆記軟體衝突的情況較少，所以不會覺得太費力。</p><p>而 Logseq 只有這三組我最常用（以下都是 Mac）：</p><ul><li><code>cmd+shift+H</code>，highlight 文字。</li><li><code>ctrl+L</code>，清空該行。（相當於 zsh 的<code>ctrl+u</code>，這個我也很常用！）</li><li><code>cmd+K</code>，搜尋。</li></ul><p>筆記軟體是<strong>最容易發生快鍵衝突的生態系</strong>！這完全可以理解，畢竟編輯操作實在太多了，而且快捷鍵的設計也不是那麼一致。</p><p>比如我用 Bear 時，就常常想不起來<strong>清單和 TODO</strong> 的快捷鍵：</p><ul><li><code>cmd+L</code>：無序清單。（用<code>-+space</code>會更快）</li><li><code>shift+cmd+L</code>：有序清單。</li><li><code>cmd+T</code>：TODO。</li></ul><p>這些快捷鍵和 Notion <strong>完全不同！</strong></p><p>對於筆記軟體，我的看法是，選一個常用 app 的記多一些。如果還有第二、三個筆記軟體，記一、兩個常用操作就好了，剩下就交給 UI 編輯器吧！</p><p>不需要把一切都「最佳化」——記憶是有限的，而且註定會不斷遺忘。</p><h2 id="三、60-分就是滿分"><a href="#三、60-分就是滿分" class="headerlink" title="三、60 分就是滿分"></a>三、60 分就是滿分</h2><p>我覺得記憶快捷鍵這件事，肯定不是多多益善。</p><p>因為記得多就忘得多，「取捨」在這個議題上顯得特別重要。</p><p>羨慕「高手寫程式都不用碰滑鼠」嗎？<strong>我也羨慕，但我不會去追求。</strong></p><p>全用滑鼠操作固然低效，不過只要能減少滑鼠使用率達 50%，也已經很厲害了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;現代人每天都會用一堆軟體、app、線上服務。&lt;/p&gt;
&lt;p&gt;其中比較複雜的工具（包括瀏覽器與作業系統），往往都有搭配「鍵盤快捷鍵」來加速你的操作。&lt;/p&gt;
&lt;p&gt;然而，軟體很多，快捷鍵更多！&lt;strong&gt;究竟哪些要記、哪些可以放棄，才能降低大腦的負擔？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文簡要分享我的看法。&lt;/p&gt;
&lt;h2 id=&quot;本文所謂的快捷鍵&quot;&gt;&lt;a href=&quot;#本文所謂的快捷鍵&quot; class=&quot;headerlink&quot; title=&quot;本文所謂的快捷鍵&quot;&gt;&lt;/a&gt;本文所謂的快捷鍵&lt;/h2&gt;&lt;p&gt;首先說明，像&lt;code&gt;ctrl+C&lt;/code&gt;、&lt;code&gt;ctrl+V&lt;/code&gt;、&lt;code&gt;ctrl+B&lt;/code&gt;、&lt;code&gt;ctrl+S&lt;/code&gt;這些，已成為大家心中公認的快捷鍵設定，各大軟體廠商也幾乎不可能在設計上違背的，就不再討論範圍。&lt;/p&gt;
&lt;p&gt;這裡講的是那些不同軟體之間&lt;strong&gt;特有&lt;/strong&gt;的快捷鍵。而且也不是要討論這些快捷鍵的設計是否合理、好記。&lt;/p&gt;
&lt;p&gt;而是要說，我&lt;strong&gt;如何選擇（取捨）&lt;/strong&gt;要記得哪些、放棄哪些的思路，以及我對「記憶快捷鍵來增加效率（生產力）」的整體看法。&lt;/p&gt;
&lt;p&gt;只是簡單的個人心得，供參。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="VS Code" scheme="https://blog.kyomind.tw/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>用 Django Fixture 匯入與導出資料</title>
    <link href="https://blog.kyomind.tw/django-fixtures/"/>
    <id>https://blog.kyomind.tw/django-fixtures/</id>
    <published>2024-06-08T10:12:44.000Z</published>
    <updated>2024-06-21T14:18:49.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 的第 7 篇。</p><p>範例程式碼可參考我的 <a href="/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="/django/">Django 文章總覽</a>」。</p><p>本文相關的程式碼改動，都集中在這個 <a href="https://github.com/kyomind/Django-Tutorial/pull/2">PR</a>。</p><hr><p>本文可視為 <a href="/series/#Django-ORM-%E5%A4%96%E9%8D%B5%E6%95%99%E5%AD%B8">Django ORM 外鍵教學</a>第三部分——查詢篇——的<strong>前置教學</strong>，因為我們需要一些範例資料作為<strong>查詢的標的。</strong></p><p>為了快速且輕鬆地建立這些範例，我們要善用 Django fixture。</p><p>本文介紹 Django fixture 的基本用法，並以 Django-Tutorial 的範例資料為例，示範如何導出與匯入 fixture。</p><h2 id="什麼是-Django-Fixture"><a href="#什麼是-Django-Fixture" class="headerlink" title="什麼是 Django Fixture"></a>什麼是 Django Fixture</h2><p>Django fixture 是一種用來管理資料庫數據的工具。</p><p>它允許你以 JSON 或 XML 等格式將資料庫中的數據<strong>導出（序列化）到特定文件中</strong>，並在需要時將這些數據<strong>匯入到資料庫。</strong></p><p>你可以輕鬆地透過 Django fixture 初始化資料庫內容，設置測試數據，或者在不同環境間傳輸數據。</p><p>顯然的，它也很適合用來「快速建立」（或說匯入）我文章教學所需要的資料。</p><p>更多細節與介紹，可參考 <a href="https://docs.djangoproject.com/en/5.0/topics/db/fixtures/">Django 文件</a>。</p><span id="more"></span><hr><h2 id="Django-Fixture-的三大用途"><a href="#Django-Fixture-的三大用途" class="headerlink" title="Django Fixture 的三大用途"></a>Django Fixture 的三大用途</h2><p>Django fixture 主要有三種用途。我覺得<strong>第一種情況</strong>是最有實務價值的。</p><h3 id="一、初始化資料庫"><a href="#一、初始化資料庫" class="headerlink" title="一、初始化資料庫"></a>一、初始化資料庫</h3><ul><li>在開發或首次部署，用於建立資料庫中的初始數據。</li><li>常用於設定預設的用戶、權限或其他需要的<strong>基礎選項</strong>數據。</li></ul><p>資料庫中總有一些，<strong>在專案部署階段就必須存在的資料</strong>。</p><p>比如「服務類型」為了<strong>未來的擴充彈性</strong>，選擇不寫成簡單的 enum（Django <a href="https://docs.djangoproject.com/en/5.0/ref/models/fields/#choices">choices</a>）欄位，而是直接獨立一個 db table，table 中的每一筆資料都是現有的服務類型。</p><p>而我們需要在<strong>首次部署</strong>時，把<strong>當前所有服務類型</strong>預先寫入 db，即<strong>資料初始化</strong>。</p><p>這個需求很常見，也很適合用 Django fixture 來處理。</p><h3 id="二、測試"><a href="#二、測試" class="headerlink" title="二、測試"></a><strong>二、測</strong>試</h3><ul><li>測試時用來準備一致的測試數據，確保測試的可靠性和可重現性。</li><li>測試資料可以被重複使用，不需要每次手動建立。</li></ul><p>如果有用 pytest，基本上會被 <a href="https://docs.pytest.org/en/latest/explanation/fixtures.html">pytest fixture</a> 取代，我幾乎沒這麼用過。</p><h3 id="三、資料的備份與還原"><a href="#三、資料的備份與還原" class="headerlink" title="三、資料的備份與還原"></a>三、資料的備份與還原</h3><ul><li>可以用來導出資料庫的部分或全部數據，方便做數據備份。</li><li>在需要時可以通過 fixture 還原資料庫的狀態。</li></ul><p>備份大量資料顯然有更好、更標準的方式，所以這比較適合備份簡單的資料。</p><p>比如我們後續教學用的範例資料，恰好適合！</p><hr><p>進入正題。</p><p>我們要為 Django Tutorial 的 <a href="https://github.com/kyomind/Django-Tutorial/blob/main/post/models.py">models</a> 建立一些簡單的範例資料。</p><h2 id="建立範例資料並導出為-Fixture"><a href="#建立範例資料並導出為-Fixture" class="headerlink" title="建立範例資料並導出為 Fixture"></a>建立範例資料並導出為 Fixture</h2><p>這是建立資料的 Python script：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> post.models <span class="keyword">import</span> Post, Subtitle, Comment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Post</span></span><br><span class="line">post1 = Post.objects.create(title=<span class="string">&quot;Django Fixtures&quot;</span>, content=<span class="string">&quot;Content of Django Fixtures&quot;</span>)</span><br><span class="line">post2 = Post.objects.create(title=<span class="string">&quot;ORM Basics&quot;</span>, content=<span class="string">&quot;Content of ORM Basics&quot;</span>)</span><br><span class="line">post3 = Post.objects.create(title=<span class="string">&quot;Advanced Queries&quot;</span>, content=<span class="string">&quot;Content of Advanced Queries&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Subtitle</span></span><br><span class="line">subtitle1 = Subtitle.objects.create(content=<span class="string">&quot;An Overview&quot;</span>, post=post1)</span><br><span class="line">subtitle2 = Subtitle.objects.create(content=<span class="string">&quot;Introduction to ORM&quot;</span>, post=post2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Comment</span></span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Great article!&quot;</span>, post=post1)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Very informative.&quot;</span>, post=post2)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Helped a lot!&quot;</span>, post=post3)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Need more examples.&quot;</span>, post=post3)</span><br><span class="line">Comment.objects.create(content=<span class="string">&quot;Thanks for the tips!&quot;</span>, post=post3)</span><br></pre></td></tr></table></figure><p>要使用這段程式碼來建立 db 實例，需要進入 Django shell 並執行程式碼。</p><p>我本來想用這種方式，讓讀者也可以自行建立資料並重現教學環境，但這樣的方式顯然不夠友好。</p><p>更好的方式是使用 Django fixture。</p><h3 id="導出為-Fixture"><a href="#導出為-Fixture" class="headerlink" title="導出為 Fixture"></a>導出為 Fixture</h3><p>一旦導出為 Django fixture，讀者只需要透過 Django 指令匯入，就可以重現整個 db 的資料環境，無疑是更好的選擇！</p><p>如何導出，使用<code>dumpdata</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py dumpdata post --output=post_data.json</span><br></pre></td></tr></table></figure><p>可以用<code>post</code>（Django app 名稱）來<strong>限定</strong>要輸出的 model 資料範圍。</p><p>如果不指定 app，<code>dumpdata</code> 指令會嘗試匯出整個專案的所有資料，包括 Django 本身的內建 db 資料。這通常包括大量不必要的內容，並且讓輸出文件變得過於複雜。</p><h2 id="匯入-Fixture"><a href="#匯入-Fixture" class="headerlink" title="匯入 Fixture"></a>匯入 Fixture</h2><p>輸出之後就是匯入，匯入也非常簡單，使用<code>loaddata</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py loaddata post_data.json</span><br></pre></td></tr></table></figure><p>實際執行結果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ python manage.py loaddata post_data.json</span><br><span class="line">Installed 10 object(s) from 1 fixture(s)</span><br></pre></td></tr></table></figure><p>會顯示總共匯入了幾筆資料，以及來源總共是幾筆 Django fixture(s)。</p><p>附帶一提，匯入之前，記得先確保已完成所有的 db 遷移！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 的第 7 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;本文相關的程式碼改動，都集中在這個 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial/pull/2&quot;&gt;PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文可視為 &lt;a href=&quot;/series/#Django-ORM-%E5%A4%96%E9%8D%B5%E6%95%99%E5%AD%B8&quot;&gt;Django ORM 外鍵教學&lt;/a&gt;第三部分——查詢篇——的&lt;strong&gt;前置教學&lt;/strong&gt;，因為我們需要一些範例資料作為&lt;strong&gt;查詢的標的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;為了快速且輕鬆地建立這些範例，我們要善用 Django fixture。&lt;/p&gt;
&lt;p&gt;本文介紹 Django fixture 的基本用法，並以 Django-Tutorial 的範例資料為例，示範如何導出與匯入 fixture。&lt;/p&gt;
&lt;h2 id=&quot;什麼是-Django-Fixture&quot;&gt;&lt;a href=&quot;#什麼是-Django-Fixture&quot; class=&quot;headerlink&quot; title=&quot;什麼是 Django Fixture&quot;&gt;&lt;/a&gt;什麼是 Django Fixture&lt;/h2&gt;&lt;p&gt;Django fixture 是一種用來管理資料庫數據的工具。&lt;/p&gt;
&lt;p&gt;它允許你以 JSON 或 XML 等格式將資料庫中的數據&lt;strong&gt;導出（序列化）到特定文件中&lt;/strong&gt;，並在需要時將這些數據&lt;strong&gt;匯入到資料庫。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以輕鬆地透過 Django fixture 初始化資料庫內容，設置測試數據，或者在不同環境間傳輸數據。&lt;/p&gt;
&lt;p&gt;顯然的，它也很適合用來「快速建立」（或說匯入）我文章教學所需要的資料。&lt;/p&gt;
&lt;p&gt;更多細節與介紹，可參考 &lt;a href=&quot;https://docs.djangoproject.com/en/5.0/topics/db/fixtures/&quot;&gt;Django 文件&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Python》筆記（一）以拆分代替索引</title>
    <link href="https://blog.kyomind.tw/effective-python-01/"/>
    <id>https://blog.kyomind.tw/effective-python-01/</id>
    <published>2024-06-03T03:06:40.000Z</published>
    <updated>2024-06-10T07:36:00.514Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/8lztFoJ.png" alt="Effective Python 中文版"><span class="cap">Effective Python 中文版</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9789865026325">Effective Python 中文版｜寫出良好 Python 程式的 90 個具體做法</a>》筆記的第 1 篇，你可以當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>毫無疑問，這又是一本關於「Clean Code in Python」的書——而且很可能是<strong>評價最高</strong>的一本。</p><p>本書由 <strong>90 個具體做法</strong>所組成，搭配大量實例，助你寫出更 Pythonic 的程式碼。</p><p>內容有初階也有進階（比如 metaclass），我會挑選書中我認為「<strong>重要且實用</strong>」的部分作為分享準則。簡言之，<strong>不會太深</strong>——但很可能是<strong>常常被忽略或低估</strong>的部分。</p><p>本文整理自書中的<strong>「做法 6：優先選用多重指定的拆分而非索引」。</strong></p><p>附帶一提，作者已經把書中的程式碼範例都放在 <a href="https://github.com/bslatkin/effectivepython">effectivepython</a> 這個 repo，這對於我這種要寫筆記、心得文章的人，真是再方便不過。</p><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文的主旨只有一個：試圖說服你，<strong>不要</strong>在程式碼中使用<strong>索引取值</strong>——盡可能改用拆分（unpacking）來代替索引。</p><p>這裡的索引取值，指的是像<code>items[2]</code>這樣，以序列（<a href="https://realpython.com/python-sequences/">sequence</a>）的<strong>數字索引</strong>來取值的情況。</p><p>如果程式碼只有你一個人撰寫與維護，且日後也是如此，或許未必要堅持這個原則。</p><p>但如果涉及<strong>多人協作</strong>，未來還有<strong>交接與維護需求</strong>，那麼<strong>避免索引取值</strong>，肯定能提升程式的可讀性，同時更容易維護。</p><span id="more"></span><h2 id="索引取值的問題"><a href="#索引取值的問題" class="headerlink" title="索引取值的問題"></a>索引取值的問題</h2><p>索引取值的<strong>根本問題</strong>，正是基於上述考量：</p><ol><li><strong>可讀性差</strong>：光憑<code>items[2]</code>，我們不知道 2 代表什麼。</li><li><strong>容易出錯</strong>：索引值的<strong>表意性弱</strong>，容易<strong>誤取</strong>，這可能導致程式崩潰。</li><li><strong>維護困難</strong>：今天你還記得 2 是什麼意思，半年後就不一定了。</li></ol><p>就我的經驗，索引取值<strong>很常和 for 迴圈一起使用</strong>，因為它們都是<strong>爬取資料</strong>的常見手段，而且是很「<strong>手刻</strong>」的那種——即<strong>完全不通用。</strong></p><p>一般而言，爬取資料的程式碼，對於非實際開發者，往往已經<strong>很不容易閱讀。</strong></p><p>如果再加上索引取值，容易讓人倍感<strong>困惑</strong>。</p><p>為索引值寫註解，是一個折衷辦法，但依舊不是最好的那個。</p><hr><h2 id="拆分（unpacking）"><a href="#拆分（unpacking）" class="headerlink" title="拆分（unpacking）"></a>拆分（unpacking）</h2><p>使用<strong>拆分</strong>（unpacking）才是更好的做法。</p><p>拆分是指<strong>將 sequence、iterable 中的多個元素，一次性賦值給多個變數的操作</strong>。</p><p>這個方式能提高可讀性，避免使用<strong>神秘的數字索引</strong>，讓你的程式碼更加清晰明瞭。</p><p>拆分的基本用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># sequence unpacking</span></span><br><span class="line">x, y, z = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;  <span class="comment"># iterable unpacking</span></span><br></pre></td></tr></table></figure><h3 id="索引-vs-拆分"><a href="#索引-vs-拆分" class="headerlink" title="索引 vs 拆分"></a>索引 vs 拆分</h3><p>拆分相對於索引取值，對可讀性有著明顯的進步。</p><p>我們看書中的例子，這是索引取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example 2</span></span><br><span class="line">item = (<span class="string">&#x27;Peanut butter&#x27;</span>, <span class="string">&#x27;Jelly&#x27;</span>)</span><br><span class="line">first = item[<span class="number">0</span>]</span><br><span class="line">second = item[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(first, <span class="string">&#x27;and&#x27;</span>, second)</span><br></pre></td></tr></table></figure><p>這是拆分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example 4</span></span><br><span class="line">item = (<span class="string">&#x27;Peanut butter&#x27;</span>, <span class="string">&#x27;Jelly&#x27;</span>)</span><br><span class="line">first, second = item  <span class="comment"># Unpacking</span></span><br><span class="line"><span class="built_in">print</span>(first, <span class="string">&#x27;and&#x27;</span>, second)</span><br></pre></td></tr></table></figure><p>拆分顯然更簡潔、更直接。</p><p>雖然最後都是賦值給了變數<code>first</code>和<code>second</code>，但少了中間的索引取值，程式碼中的「<strong>視覺雜訊</strong>」也減少了——這很重要。</p><hr><h2 id="拆分在協作中的價值"><a href="#拆分在協作中的價值" class="headerlink" title="拆分在協作中的價值"></a>拆分在協作中的價值</h2><p>平心而論，索引取值對於撰寫程式的人而言，往往是<strong>比較輕鬆</strong>的做法，所以我們更偏愛用索引。</p><p>但對於閱讀程式碼的人，就有點<strong>辛苦</strong>了。</p><p>推薦使用拆分的目的很簡單——<strong>避免透過索引取值再賦值給變數</strong>，而是<strong>直接賦值</strong>給多個變數，<strong>減少中間流程，也減少視覺雜訊。</strong></p><p>更別說，有些索引取值<strong>「並不會」再重新賦值</strong>給新變數，這類情況<strong>更應該</strong>使用拆分。（詳見最後「<a href="#%E6%88%91%E7%9A%84%E5%AF%A6%E4%BD%9C">我的實作</a>」）</p><h3 id="明確的意圖"><a href="#明確的意圖" class="headerlink" title="明確的意圖"></a>明確的意圖</h3><p>除此之外，<strong>拆分還可以讓你的「程式意圖」更加明確！</strong>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member_names = [member[<span class="number">1</span>] <span class="keyword">for</span> member <span class="keyword">in</span> members]</span><br></pre></td></tr></table></figure><p>這樣的寫法容易讓我有<strong>兩個疑問</strong>（這是我自己寫過的程式碼）：</p><ol><li>索引 0 是什麼？完全不需要嗎？我可以忽略嗎？</li><li>索引有 2 或 3 嗎？（即<code>member</code>有更多元素嗎？——我們無法確定）</li></ol><p>這些<strong>不確定因素</strong>，讓你的程式意圖變得<strong>模糊</strong>。雖然自己清楚，但對於程式碼的閱讀者，則是一種不必要的「<strong>認知負擔</strong>」。</p><p>這些認知負擔不斷累積，將導致人們<strong>需要花更多時間</strong>，才能讀懂你的程式碼。</p><p>而拆分的寫法，可以讓情況<strong>明確許多：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member_names = [name <span class="keyword">for</span> _, name <span class="keyword">in</span> members]</span><br></pre></td></tr></table></figure><p>我們<strong>透過拆分與變數</strong>大聲宣布：<strong>member 總共只有兩個元素，而且我只要第二個！</strong></p><hr><h2 id="進階拆分"><a href="#進階拆分" class="headerlink" title="進階拆分"></a>進階拆分</h2><blockquote><p>但我就是<strong>只需要其中一個變數</strong>，怎麼辦？就像前述的<code>items[2]</code></p></blockquote><p>以拆分取代索引，我們需要一些「<strong>配套措拖</strong>」，才能夠用得方便、滑順。</p><p>其中最常用的，就是<code>_</code>和<code>*</code>。</p><h3 id="善用-來進行拆分"><a href="#善用-來進行拆分" class="headerlink" title="善用_來進行拆分"></a>善用<code>_</code>來進行拆分</h3><p>很簡單，把<strong>不要的內容</strong>丟給<code>_</code>變數。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, _, last = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br></pre></td></tr></table></figure><p>這樣寫最大的好處，是<strong>明確告訴讀者</strong>：我不需要前兩個元素，所以直接丟給<code>_</code>。</p><h3 id="善用-進行拆分"><a href="#善用-進行拆分" class="headerlink" title="善用*進行拆分"></a>善用<code>*</code>進行拆分</h3><p>如果你想要的元素在<strong>第一個</strong>或<strong>最後一個</strong>，而且<strong>拆分的元素較多</strong>，那用<code>*</code>會更加方便。</p><p>使用星號（<code>*</code>）<strong>收集其餘的值：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first, *middle, last = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(middle)  <span class="comment"># [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>其中<code>middle</code>的變數內容，會是一個<strong>擁有 0 到多個元素</strong>的<code>list</code>。</p><h3 id="結合-和"><a href="#結合-和" class="headerlink" title="結合_和*"></a>結合<code>_</code>和<code>*</code></h3><p>第一個例子只有 3 個元素，而第二個例子有 5 個元素。</p><p>如果有更多，比如 10 個，而我們依舊<strong>只需要最後一個</strong>，難道要寫一堆<code>_</code>？</p><p>當然不！這時可以結合兩者，<strong>重構第一個例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*_, last = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br></pre></td></tr></table></figure><p>是不是非常簡潔？</p><h3 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h3><p><code>_</code>很常用，而<code>*</code>拆分我比較少用（拆分 3 個以上的情況對我相對少見）。</p><p>無論如何，只要有數字索引出現，我們<strong>第一時間就要想到「能否用拆分來取代？」</strong>——通常可以！</p><p>這是一個很好的習慣，相信你的同事會感謝你。</p><hr><h2 id="書中範例欣賞"><a href="#書中範例欣賞" class="headerlink" title="書中範例欣賞"></a>書中範例欣賞</h2><p>我們看一段書中的程式碼，比較索引取值和拆分（其實還用了<code>enumerate</code>），兩者的差別<strong>究竟能有多大</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">snacks = [(<span class="string">&#x27;bacon&#x27;</span>, <span class="number">350</span>), (<span class="string">&#x27;donut&#x27;</span>, <span class="number">240</span>), (<span class="string">&#x27;muffin&#x27;</span>, <span class="number">190</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example 8 使用索引取值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(snacks)):</span><br><span class="line">    item = snacks[i]</span><br><span class="line">    name = item[<span class="number">0</span>]</span><br><span class="line">    calories = item[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;#<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;name&#125;</span> has <span class="subst">&#123;calories&#125;</span> calories&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example 9 使用拆分（加上 enumerate）</span></span><br><span class="line"><span class="keyword">for</span> rank, (name, calories) <span class="keyword">in</span> <span class="built_in">enumerate</span>(snacks, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;#<span class="subst">&#123;rank&#125;</span>: <span class="subst">&#123;name&#125;</span> has <span class="subst">&#123;calories&#125;</span> calories&#x27;</span>)</span><br></pre></td></tr></table></figure><p>不過，不可否認，上面的拆分寫法需要你認真閱讀才能讀懂，因為它有點複雜。</p><p>但即使不了解其中的細節，也能輕易看出，後者更加優雅。</p><p>而且<strong>大部分需要你拆分的情境，都比這個例子單純。</strong>例如以下的實作。</p><h2 id="我的實作"><a href="#我的實作" class="headerlink" title="我的實作"></a>我的實作</h2><p>在剛發表的〈<a href="/weekly-review-31/">31，打造新版「熱門文章排名」</a>〉一文的<a href="https://github.com/kyomind/blog-post-ranking/">專案實作</a>中，我用拆分<strong>重構</strong>了原有的<a href="https://github.com/kyomind/blog-post-ranking/blob/main/src/functions.py#L105">程式碼</a>（內容已略有不同，以下為早前版本）。</p><p>這段程式把從 GA4 整理出的網站流量資料，以一定格式寫入 Markdown 文件中。</p><p>舊版，使用索引取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rank = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> page_views:</span><br><span class="line">   <span class="keyword">if</span> row[<span class="number">0</span>] <span class="keyword">in</span> ignored_paths:</span><br><span class="line">       <span class="keyword">continue</span></span><br><span class="line">   f.write(<span class="string">f&#x27;<span class="subst">&#123;rank&#125;</span>. [<span class="subst">&#123;row[<span class="number">1</span>]&#125;</span>](<span class="subst">&#123;row[<span class="number">0</span>]&#125;</span>)\n&#x27;</span>)</span><br><span class="line">   rank += <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> rank &gt; <span class="number">10</span>:</span><br><span class="line">       <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>如前所述，索引取值對於程式撰寫者來說，可能是<strong>最直覺</strong>的做法，也相對輕鬆。所以我一開始也是這樣寫的，<strong>但真的不太好讀XD</strong></p><p><code>row[0]</code>、<code>row[1]</code><strong>到底是什麼？</strong>不清楚——有認知負擔。</p><h3 id="以拆分重構"><a href="#以拆分重構" class="headerlink" title="以拆分重構"></a>以拆分重構</h3><p>改用拆分重構，並以<code>_</code><strong>省略不需要的變數</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rank = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> path, title, _ <span class="keyword">in</span> page_views:</span><br><span class="line">    <span class="keyword">if</span> path <span class="keyword">in</span> ignored_paths:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    f.write(<span class="string">f&#x27;<span class="subst">&#123;rank&#125;</span>. [<span class="subst">&#123;title&#125;</span>](<span class="subst">&#123;path&#125;</span>)\n&#x27;</span>)</span><br><span class="line">    rank += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> rank &gt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>這個例子，比上述所有例子都<strong>更能凸顯</strong>拆分的價值。</p><p>因為<code>row[0]</code>、<code>row[1]</code><strong>最終都沒有再被重新賦值</strong>給另一個變數，而是<strong>直接寫入文件。</strong></p><p>使用索引，你<strong>幾乎看不出</strong><code>row[0]</code>、<code>row[1]</code>究竟代表什麼——只能靠猜。</p><p>改用拆分，我們能知曉被寫入的是<code>title</code>和<code>path</code>，而不是<strong>神秘的索引取值</strong>。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>總的來說，我覺得拆分是一個<strong>大大被低估</strong>卻<strong>異常實用</strong>的技巧。</p><p>善用拆分能讓你的程式碼更加 Pythonic。</p><p>從今天開始，在 for 迴圈中，就別再索引取值了吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/8lztFoJ.png&quot; alt=&quot;Effective Python 中文版&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865026325&quot;&gt;Effective Python 中文版｜寫出良好 Python 程式的 90 個具體做法&lt;/a&gt;》筆記的第 1 篇，你可以當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;毫無疑問，這又是一本關於「Clean Code in Python」的書——而且很可能是&lt;strong&gt;評價最高&lt;/strong&gt;的一本。&lt;/p&gt;
&lt;p&gt;本書由 &lt;strong&gt;90 個具體做法&lt;/strong&gt;所組成，搭配大量實例，助你寫出更 Pythonic 的程式碼。&lt;/p&gt;
&lt;p&gt;內容有初階也有進階（比如 metaclass），我會挑選書中我認為「&lt;strong&gt;重要且實用&lt;/strong&gt;」的部分作為分享準則。簡言之，&lt;strong&gt;不會太深&lt;/strong&gt;——但很可能是&lt;strong&gt;常常被忽略或低估&lt;/strong&gt;的部分。&lt;/p&gt;
&lt;p&gt;本文整理自書中的&lt;strong&gt;「做法 6：優先選用多重指定的拆分而非索引」。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;附帶一提，作者已經把書中的程式碼範例都放在 &lt;a href=&quot;https://github.com/bslatkin/effectivepython&quot;&gt;effectivepython&lt;/a&gt; 這個 repo，這對於我這種要寫筆記、心得文章的人，真是再方便不過。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;本文的主旨只有一個：試圖說服你，&lt;strong&gt;不要&lt;/strong&gt;在程式碼中使用&lt;strong&gt;索引取值&lt;/strong&gt;——盡可能改用拆分（unpacking）來代替索引。&lt;/p&gt;
&lt;p&gt;這裡的索引取值，指的是像&lt;code&gt;items[2]&lt;/code&gt;這樣，以序列（&lt;a href=&quot;https://realpython.com/python-sequences/&quot;&gt;sequence&lt;/a&gt;）的&lt;strong&gt;數字索引&lt;/strong&gt;來取值的情況。&lt;/p&gt;
&lt;p&gt;如果程式碼只有你一個人撰寫與維護，且日後也是如此，或許未必要堅持這個原則。&lt;/p&gt;
&lt;p&gt;但如果涉及&lt;strong&gt;多人協作&lt;/strong&gt;，未來還有&lt;strong&gt;交接與維護需求&lt;/strong&gt;，那麼&lt;strong&gt;避免索引取值&lt;/strong&gt;，肯定能提升程式的可讀性，同時更容易維護。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/QpRyvxH.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
  </entry>
  
</feed>
